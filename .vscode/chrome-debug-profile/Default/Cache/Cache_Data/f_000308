import {
  __esm,
  __export
} from "/@fs/D:/twenty-table-o/node_modules/.vite/packages/twenty-front/deps/chunk-XPZLJQLW.js?v=226f7286";
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}
var init_isObjectLike = __esm({
  "node_modules/graphql/jsutils/isObjectLike.mjs"() {
  }
});
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}
var init_invariant = __esm({
  "node_modules/graphql/jsutils/invariant.mjs"() {
  }
});
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
var LineRegExp;
var init_location = __esm({
  "node_modules/graphql/language/location.mjs"() {
    init_invariant();
    LineRegExp = /\r\n|[\n\r]/g;
  }
});
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}
var init_printLocation = __esm({
  "node_modules/graphql/language/printLocation.mjs"() {
    init_location();
  }
});
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}
function printError(error) {
  return error.toString();
}
function formatError(error) {
  return error.toJSON();
}
var GraphQLError;
var init_GraphQLError = __esm({
  "node_modules/graphql/error/GraphQLError.mjs"() {
    init_isObjectLike();
    init_location();
    init_printLocation();
    GraphQLError = class _GraphQLError extends Error {
      /**
       * An array of `{ line, column }` locations within the source GraphQL document
       * which correspond to this error.
       *
       * Errors during validation often contain multiple locations, for example to
       * point out two things with the same name. Errors during execution include a
       * single location, the field which produced the error.
       *
       * Enumerable, and appears in the result of JSON.stringify().
       */
      /**
       * An array describing the JSON-path into the execution response which
       * corresponds to this error. Only included for errors during execution.
       *
       * Enumerable, and appears in the result of JSON.stringify().
       */
      /**
       * An array of GraphQL AST Nodes corresponding to this error.
       */
      /**
       * The source GraphQL document for the first location of this error.
       *
       * Note that if this Error represents more than one node, the source may not
       * represent nodes after the first node.
       */
      /**
       * An array of character offsets within the source GraphQL document
       * which correspond to this error.
       */
      /**
       * The original error thrown from a field resolver during execution.
       */
      /**
       * Extension fields to add to the formatted error.
       */
      /**
       * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
       */
      constructor(message, ...rawArgs) {
        var _this$nodes, _nodeLocations$, _ref;
        const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
        super(message);
        this.name = "GraphQLError";
        this.path = path !== null && path !== void 0 ? path : void 0;
        this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
        this.nodes = undefinedIfEmpty(
          Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
        );
        const nodeLocations = undefinedIfEmpty(
          (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
        );
        this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
        this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
        this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
        const originalExtensions = isObjectLike(
          originalError === null || originalError === void 0 ? void 0 : originalError.extensions
        ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
        this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
        Object.defineProperties(this, {
          message: {
            writable: true,
            enumerable: true
          },
          name: {
            enumerable: false
          },
          nodes: {
            enumerable: false
          },
          source: {
            enumerable: false
          },
          positions: {
            enumerable: false
          },
          originalError: {
            enumerable: false
          }
        });
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
          Object.defineProperty(this, "stack", {
            value: originalError.stack,
            writable: true,
            configurable: true
          });
        } else if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _GraphQLError);
        } else {
          Object.defineProperty(this, "stack", {
            value: Error().stack,
            writable: true,
            configurable: true
          });
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLError";
      }
      toString() {
        let output = this.message;
        if (this.nodes) {
          for (const node of this.nodes) {
            if (node.loc) {
              output += "\n\n" + printLocation(node.loc);
            }
          }
        } else if (this.source && this.locations) {
          for (const location of this.locations) {
            output += "\n\n" + printSourceLocation(this.source, location);
          }
        }
        return output;
      }
      toJSON() {
        const formattedError = {
          message: this.message
        };
        if (this.locations != null) {
          formattedError.locations = this.locations;
        }
        if (this.path != null) {
          formattedError.path = this.path;
        }
        if (this.extensions != null && Object.keys(this.extensions).length > 0) {
          formattedError.extensions = this.extensions;
        }
        return formattedError;
      }
    };
  }
});
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}
var init_syntaxError = __esm({
  "node_modules/graphql/error/syntaxError.mjs"() {
    init_GraphQLError();
  }
});
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var Location, Token, QueryDocumentKeys, kindValues, OperationTypeNode;
var init_ast = __esm({
  "node_modules/graphql/language/ast.mjs"() {
    Location = class {
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The Token at which this Node begins.
       */
      /**
       * The Token at which this Node ends.
       */
      /**
       * The Source document the AST represents.
       */
      constructor(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      get [Symbol.toStringTag]() {
        return "Location";
      }
      toJSON() {
        return {
          start: this.start,
          end: this.end
        };
      }
    };
    Token = class {
      /**
       * The kind of Token.
       */
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The 1-indexed line number on which this Token appears.
       */
      /**
       * The 1-indexed column number at which this Token begins.
       */
      /**
       * For non-punctuation tokens, represents the interpreted value of the token.
       *
       * Note: is undefined for punctuation tokens, but typed as string for
       * convenience in the parser.
       */
      /**
       * Tokens exist as nodes in a double-linked-list amongst all tokens
       * including ignored tokens. <SOF> is always the first node and <EOF>
       * the last.
       */
      constructor(kind, start, end, line, column, value) {
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = null;
        this.next = null;
      }
      get [Symbol.toStringTag]() {
        return "Token";
      }
      toJSON() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      }
    };
    QueryDocumentKeys = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: [
        "name",
        "variableDefinitions",
        "directives",
        "selectionSet"
      ],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: [
        "name",
        // Note: fragment variable definitions are deprecated and will removed in v17.0.0
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
      ],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: [
        "description",
        "name",
        "type",
        "defaultValue",
        "directives"
      ],
      InterfaceTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    };
    kindValues = new Set(Object.keys(QueryDocumentKeys));
    (function(OperationTypeNode2) {
      OperationTypeNode2["QUERY"] = "query";
      OperationTypeNode2["MUTATION"] = "mutation";
      OperationTypeNode2["SUBSCRIPTION"] = "subscription";
    })(OperationTypeNode || (OperationTypeNode = {}));
  }
});
var DirectiveLocation;
var init_directiveLocation = __esm({
  "node_modules/graphql/language/directiveLocation.mjs"() {
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation || (DirectiveLocation = {}));
  }
});
var Kind;
var init_kinds = __esm({
  "node_modules/graphql/language/kinds.mjs"() {
    (function(Kind2) {
      Kind2["NAME"] = "Name";
      Kind2["DOCUMENT"] = "Document";
      Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
      Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
      Kind2["SELECTION_SET"] = "SelectionSet";
      Kind2["FIELD"] = "Field";
      Kind2["ARGUMENT"] = "Argument";
      Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
      Kind2["INLINE_FRAGMENT"] = "InlineFragment";
      Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
      Kind2["VARIABLE"] = "Variable";
      Kind2["INT"] = "IntValue";
      Kind2["FLOAT"] = "FloatValue";
      Kind2["STRING"] = "StringValue";
      Kind2["BOOLEAN"] = "BooleanValue";
      Kind2["NULL"] = "NullValue";
      Kind2["ENUM"] = "EnumValue";
      Kind2["LIST"] = "ListValue";
      Kind2["OBJECT"] = "ObjectValue";
      Kind2["OBJECT_FIELD"] = "ObjectField";
      Kind2["DIRECTIVE"] = "Directive";
      Kind2["NAMED_TYPE"] = "NamedType";
      Kind2["LIST_TYPE"] = "ListType";
      Kind2["NON_NULL_TYPE"] = "NonNullType";
      Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
      Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
      Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
      Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
      Kind2["FIELD_DEFINITION"] = "FieldDefinition";
      Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
      Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
      Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
      Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
      Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
      Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
      Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
      Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
      Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
      Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
      Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
      Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
      Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
      Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
    })(Kind || (Kind = {}));
  }
});
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}
var init_characterClasses = __esm({
  "node_modules/graphql/language/characterClasses.mjs"() {
  }
});
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0; i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
}
function isPrintableAsBlockString(value) {
  if (value === "") {
    return true;
  }
  let isEmptyLine = true;
  let hasIndent = false;
  let hasCommonIndent = true;
  let seenNonEmptyLine = false;
  for (let i = 0; i < value.length; ++i) {
    switch (value.codePointAt(i)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return false;
      case 13:
        return false;
      case 10:
        if (isEmptyLine && !seenNonEmptyLine) {
          return false;
        }
        seenNonEmptyLine = true;
        isEmptyLine = true;
        hasIndent = false;
        break;
      case 9:
      case 32:
        hasIndent || (hasIndent = isEmptyLine);
        break;
      default:
        hasCommonIndent && (hasCommonIndent = hasIndent);
        isEmptyLine = false;
    }
  }
  if (isEmptyLine) {
    return false;
  }
  if (hasCommonIndent && seenNonEmptyLine) {
    return false;
  }
  return true;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}
var init_blockString = __esm({
  "node_modules/graphql/language/blockString.mjs"() {
    init_characterClasses();
  }
});
var TokenKind;
var init_tokenKind = __esm({
  "node_modules/graphql/language/tokenKind.mjs"() {
    (function(TokenKind2) {
      TokenKind2["SOF"] = "<SOF>";
      TokenKind2["EOF"] = "<EOF>";
      TokenKind2["BANG"] = "!";
      TokenKind2["DOLLAR"] = "$";
      TokenKind2["AMP"] = "&";
      TokenKind2["PAREN_L"] = "(";
      TokenKind2["PAREN_R"] = ")";
      TokenKind2["SPREAD"] = "...";
      TokenKind2["COLON"] = ":";
      TokenKind2["EQUALS"] = "=";
      TokenKind2["AT"] = "@";
      TokenKind2["BRACKET_L"] = "[";
      TokenKind2["BRACKET_R"] = "]";
      TokenKind2["BRACE_L"] = "{";
      TokenKind2["PIPE"] = "|";
      TokenKind2["BRACE_R"] = "}";
      TokenKind2["NAME"] = "Name";
      TokenKind2["INT"] = "Int";
      TokenKind2["FLOAT"] = "Float";
      TokenKind2["STRING"] = "String";
      TokenKind2["BLOCK_STRING"] = "BlockString";
      TokenKind2["COMMENT"] = "Comment";
    })(TokenKind || (TokenKind = {}));
  }
});
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location) {
  const code = lexer.source.body.codePointAt(location);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(
      lexer.source,
      position,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position,
    body.slice(start + 1, position)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(
      lexer.source,
      position,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position,
    body.slice(start, position)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape.value;
      position += escape.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(
      position,
      position + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
  );
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid character escape sequence: "${body.slice(
      position,
      position + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position,
    body.slice(start, position)
  );
}
var Lexer;
var init_lexer = __esm({
  "node_modules/graphql/language/lexer.mjs"() {
    init_syntaxError();
    init_ast();
    init_blockString();
    init_characterClasses();
    init_tokenKind();
    Lexer = class {
      /**
       * The previously focused non-ignored token.
       */
      /**
       * The currently focused non-ignored token.
       */
      /**
       * The (1-indexed) line containing the current token.
       */
      /**
       * The character offset at which the current line begins.
       */
      constructor(source) {
        const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
      }
      get [Symbol.toStringTag]() {
        return "Lexer";
      }
      /**
       * Advances the token stream to the next non-ignored token.
       */
      advance() {
        this.lastToken = this.token;
        const token = this.token = this.lookahead();
        return token;
      }
      /**
       * Looks ahead and returns the next non-ignored token, but does not change
       * the state of Lexer.
       */
      lookahead() {
        let token = this.token;
        if (token.kind !== TokenKind.EOF) {
          do {
            if (token.next) {
              token = token.next;
            } else {
              const nextToken = readNextToken(this, token.end);
              token.next = nextToken;
              nextToken.prev = token;
              token = nextToken;
            }
          } while (token.kind === TokenKind.COMMENT);
        }
        return token;
      }
    };
  }
});
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
var init_devAssert = __esm({
  "node_modules/graphql/jsutils/devAssert.mjs"() {
  }
});
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
var MAX_ARRAY_LENGTH, MAX_RECURSIVE_DEPTH;
var init_inspect = __esm({
  "node_modules/graphql/jsutils/inspect.mjs"() {
    MAX_ARRAY_LENGTH = 10;
    MAX_RECURSIVE_DEPTH = 2;
  }
});
var instanceOf;
var init_instanceOf = __esm({
  "node_modules/graphql/jsutils/instanceOf.mjs"() {
    init_inspect();
    instanceOf = /* c8 ignore next 6 */
    // FIXME: https://github.com/graphql/graphql-js/issues/2317
    globalThis.process && false ? function instanceOf2(value, constructor) {
      return value instanceof constructor;
    } : function instanceOf3(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        var _value$constructor;
        const className = constructor.prototype[Symbol.toStringTag];
        const valueClassName = (
          // We still need to support constructor's name to detect conflicts with older versions of this library.
          Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
        );
        if (className === valueClassName) {
          const stringifiedValue = inspect(value);
          throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return false;
    };
  }
});
function isSource(source) {
  return instanceOf(source, Source);
}
var Source;
var init_source = __esm({
  "node_modules/graphql/language/source.mjs"() {
    init_devAssert();
    init_inspect();
    init_instanceOf();
    Source = class {
      constructor(body, name = "GraphQL request", locationOffset = {
        line: 1,
        column: 1
      }) {
        typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
        this.body = body;
        this.name = name;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || devAssert(
          false,
          "line in locationOffset is 1-indexed and must be positive."
        );
        this.locationOffset.column > 0 || devAssert(
          false,
          "column in locationOffset is 1-indexed and must be positive."
        );
      }
      get [Symbol.toStringTag]() {
        return "Source";
      }
    };
  }
});
function parse(source, options) {
  const parser = new Parser(source, options);
  return parser.parseDocument();
}
function parseValue(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const value = parser.parseValueLiteral(false);
  parser.expectToken(TokenKind.EOF);
  return value;
}
function parseConstValue(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const value = parser.parseConstValueLiteral();
  parser.expectToken(TokenKind.EOF);
  return value;
}
function parseType(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const type = parser.parseTypeReference();
  parser.expectToken(TokenKind.EOF);
  return type;
}
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}
var Parser;
var init_parser = __esm({
  "node_modules/graphql/language/parser.mjs"() {
    init_syntaxError();
    init_ast();
    init_directiveLocation();
    init_kinds();
    init_lexer();
    init_source();
    init_tokenKind();
    Parser = class {
      constructor(source, options = {}) {
        const sourceObj = isSource(source) ? source : new Source(source);
        this._lexer = new Lexer(sourceObj);
        this._options = options;
        this._tokenCounter = 0;
      }
      /**
       * Converts a name lex token into a name parse node.
       */
      parseName() {
        const token = this.expectToken(TokenKind.NAME);
        return this.node(token, {
          kind: Kind.NAME,
          value: token.value
        });
      }
      // Implements the parsing rules in the Document section.
      /**
       * Document : Definition+
       */
      parseDocument() {
        return this.node(this._lexer.token, {
          kind: Kind.DOCUMENT,
          definitions: this.many(
            TokenKind.SOF,
            this.parseDefinition,
            TokenKind.EOF
          )
        });
      }
      /**
       * Definition :
       *   - ExecutableDefinition
       *   - TypeSystemDefinition
       *   - TypeSystemExtension
       *
       * ExecutableDefinition :
       *   - OperationDefinition
       *   - FragmentDefinition
       *
       * TypeSystemDefinition :
       *   - SchemaDefinition
       *   - TypeDefinition
       *   - DirectiveDefinition
       *
       * TypeDefinition :
       *   - ScalarTypeDefinition
       *   - ObjectTypeDefinition
       *   - InterfaceTypeDefinition
       *   - UnionTypeDefinition
       *   - EnumTypeDefinition
       *   - InputObjectTypeDefinition
       */
      parseDefinition() {
        if (this.peek(TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        }
        const hasDescription = this.peekDescription();
        const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
          if (hasDescription) {
            throw syntaxError(
              this._lexer.source,
              this._lexer.token.start,
              "Unexpected description, descriptions are supported only on type definitions."
            );
          }
          switch (keywordToken.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      // Implements the parsing rules in the Operations section.
      /**
       * OperationDefinition :
       *  - SelectionSet
       *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
       */
      parseOperationDefinition() {
        const start = this._lexer.token;
        if (this.peek(TokenKind.BRACE_L)) {
          return this.node(start, {
            kind: Kind.OPERATION_DEFINITION,
            operation: OperationTypeNode.QUERY,
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet()
          });
        }
        const operation = this.parseOperationType();
        let name;
        if (this.peek(TokenKind.NAME)) {
          name = this.parseName();
        }
        return this.node(start, {
          kind: Kind.OPERATION_DEFINITION,
          operation,
          name,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * OperationType : one of query mutation subscription
       */
      parseOperationType() {
        const operationToken = this.expectToken(TokenKind.NAME);
        switch (operationToken.value) {
          case "query":
            return OperationTypeNode.QUERY;
          case "mutation":
            return OperationTypeNode.MUTATION;
          case "subscription":
            return OperationTypeNode.SUBSCRIPTION;
        }
        throw this.unexpected(operationToken);
      }
      /**
       * VariableDefinitions : ( VariableDefinition+ )
       */
      parseVariableDefinitions() {
        return this.optionalMany(
          TokenKind.PAREN_L,
          this.parseVariableDefinition,
          TokenKind.PAREN_R
        );
      }
      /**
       * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
       */
      parseVariableDefinition() {
        return this.node(this._lexer.token, {
          kind: Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
          directives: this.parseConstDirectives()
        });
      }
      /**
       * Variable : $ Name
       */
      parseVariable() {
        const start = this._lexer.token;
        this.expectToken(TokenKind.DOLLAR);
        return this.node(start, {
          kind: Kind.VARIABLE,
          name: this.parseName()
        });
      }
      /**
       * ```
       * SelectionSet : { Selection+ }
       * ```
       */
      parseSelectionSet() {
        return this.node(this._lexer.token, {
          kind: Kind.SELECTION_SET,
          selections: this.many(
            TokenKind.BRACE_L,
            this.parseSelection,
            TokenKind.BRACE_R
          )
        });
      }
      /**
       * Selection :
       *   - Field
       *   - FragmentSpread
       *   - InlineFragment
       */
      parseSelection() {
        return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      }
      /**
       * Field : Alias? Name Arguments? Directives? SelectionSet?
       *
       * Alias : Name :
       */
      parseField() {
        const start = this._lexer.token;
        const nameOrAlias = this.parseName();
        let alias;
        let name;
        if (this.expectOptionalToken(TokenKind.COLON)) {
          alias = nameOrAlias;
          name = this.parseName();
        } else {
          name = nameOrAlias;
        }
        return this.node(start, {
          kind: Kind.FIELD,
          alias,
          name,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
        });
      }
      /**
       * Arguments[Const] : ( Argument[?Const]+ )
       */
      parseArguments(isConst) {
        const item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
      }
      /**
       * Argument[Const] : Name : Value[?Const]
       */
      parseArgument(isConst = false) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        return this.node(start, {
          kind: Kind.ARGUMENT,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      parseConstArgument() {
        return this.parseArgument(true);
      }
      // Implements the parsing rules in the Fragments section.
      /**
       * Corresponds to both FragmentSpread and InlineFragment in the spec.
       *
       * FragmentSpread : ... FragmentName Directives?
       *
       * InlineFragment : ... TypeCondition? Directives? SelectionSet
       */
      parseFragment() {
        const start = this._lexer.token;
        this.expectToken(TokenKind.SPREAD);
        const hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
          return this.node(start, {
            kind: Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false)
          });
        }
        return this.node(start, {
          kind: Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * FragmentDefinition :
       *   - fragment FragmentName on TypeCondition Directives? SelectionSet
       *
       * TypeCondition : NamedType
       */
      parseFragmentDefinition() {
        const start = this._lexer.token;
        this.expectKeyword("fragment");
        if (this._options.allowLegacyFragmentVariables === true) {
          return this.node(start, {
            kind: Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        return this.node(start, {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * FragmentName : Name but not `on`
       */
      parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      }
      // Implements the parsing rules in the Values section.
      /**
       * Value[Const] :
       *   - [~Const] Variable
       *   - IntValue
       *   - FloatValue
       *   - StringValue
       *   - BooleanValue
       *   - NullValue
       *   - EnumValue
       *   - ListValue[?Const]
       *   - ObjectValue[?Const]
       *
       * BooleanValue : one of `true` `false`
       *
       * NullValue : `null`
       *
       * EnumValue : Name but not `true`, `false` or `null`
       */
      parseValueLiteral(isConst) {
        const token = this._lexer.token;
        switch (token.kind) {
          case TokenKind.BRACKET_L:
            return this.parseList(isConst);
          case TokenKind.BRACE_L:
            return this.parseObject(isConst);
          case TokenKind.INT:
            this.advanceLexer();
            return this.node(token, {
              kind: Kind.INT,
              value: token.value
            });
          case TokenKind.FLOAT:
            this.advanceLexer();
            return this.node(token, {
              kind: Kind.FLOAT,
              value: token.value
            });
          case TokenKind.STRING:
          case TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case TokenKind.NAME:
            this.advanceLexer();
            switch (token.value) {
              case "true":
                return this.node(token, {
                  kind: Kind.BOOLEAN,
                  value: true
                });
              case "false":
                return this.node(token, {
                  kind: Kind.BOOLEAN,
                  value: false
                });
              case "null":
                return this.node(token, {
                  kind: Kind.NULL
                });
              default:
                return this.node(token, {
                  kind: Kind.ENUM,
                  value: token.value
                });
            }
          case TokenKind.DOLLAR:
            if (isConst) {
              this.expectToken(TokenKind.DOLLAR);
              if (this._lexer.token.kind === TokenKind.NAME) {
                const varName = this._lexer.token.value;
                throw syntaxError(
                  this._lexer.source,
                  token.start,
                  `Unexpected variable "$${varName}" in constant value.`
                );
              } else {
                throw this.unexpected(token);
              }
            }
            return this.parseVariable();
          default:
            throw this.unexpected();
        }
      }
      parseConstValueLiteral() {
        return this.parseValueLiteral(true);
      }
      parseStringLiteral() {
        const token = this._lexer.token;
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.STRING,
          value: token.value,
          block: token.kind === TokenKind.BLOCK_STRING
        });
      }
      /**
       * ListValue[Const] :
       *   - [ ]
       *   - [ Value[?Const]+ ]
       */
      parseList(isConst) {
        const item = () => this.parseValueLiteral(isConst);
        return this.node(this._lexer.token, {
          kind: Kind.LIST,
          values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
        });
      }
      /**
       * ```
       * ObjectValue[Const] :
       *   - { }
       *   - { ObjectField[?Const]+ }
       * ```
       */
      parseObject(isConst) {
        const item = () => this.parseObjectField(isConst);
        return this.node(this._lexer.token, {
          kind: Kind.OBJECT,
          fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
        });
      }
      /**
       * ObjectField[Const] : Name : Value[?Const]
       */
      parseObjectField(isConst) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        return this.node(start, {
          kind: Kind.OBJECT_FIELD,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      // Implements the parsing rules in the Directives section.
      /**
       * Directives[Const] : Directive[?Const]+
       */
      parseDirectives(isConst) {
        const directives = [];
        while (this.peek(TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }
        return directives;
      }
      parseConstDirectives() {
        return this.parseDirectives(true);
      }
      /**
       * ```
       * Directive[Const] : @ Name Arguments[?Const]?
       * ```
       */
      parseDirective(isConst) {
        const start = this._lexer.token;
        this.expectToken(TokenKind.AT);
        return this.node(start, {
          kind: Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst)
        });
      }
      // Implements the parsing rules in the Types section.
      /**
       * Type :
       *   - NamedType
       *   - ListType
       *   - NonNullType
       */
      parseTypeReference() {
        const start = this._lexer.token;
        let type;
        if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
          const innerType = this.parseTypeReference();
          this.expectToken(TokenKind.BRACKET_R);
          type = this.node(start, {
            kind: Kind.LIST_TYPE,
            type: innerType
          });
        } else {
          type = this.parseNamedType();
        }
        if (this.expectOptionalToken(TokenKind.BANG)) {
          return this.node(start, {
            kind: Kind.NON_NULL_TYPE,
            type
          });
        }
        return type;
      }
      /**
       * NamedType : Name
       */
      parseNamedType() {
        return this.node(this._lexer.token, {
          kind: Kind.NAMED_TYPE,
          name: this.parseName()
        });
      }
      // Implements the parsing rules in the Type Definition section.
      peekDescription() {
        return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
      }
      /**
       * Description : StringValue
       */
      parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      }
      /**
       * ```
       * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
       * ```
       */
      parseSchemaDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.many(
          TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          TokenKind.BRACE_R
        );
        return this.node(start, {
          kind: Kind.SCHEMA_DEFINITION,
          description,
          directives,
          operationTypes
        });
      }
      /**
       * OperationTypeDefinition : OperationType : NamedType
       */
      parseOperationTypeDefinition() {
        const start = this._lexer.token;
        const operation = this.parseOperationType();
        this.expectToken(TokenKind.COLON);
        const type = this.parseNamedType();
        return this.node(start, {
          kind: Kind.OPERATION_TYPE_DEFINITION,
          operation,
          type
        });
      }
      /**
       * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
       */
      parseScalarTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.SCALAR_TYPE_DEFINITION,
          description,
          name,
          directives
        });
      }
      /**
       * ObjectTypeDefinition :
       *   Description?
       *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
       */
      parseObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: Kind.OBJECT_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * ImplementsInterfaces :
       *   - implements `&`? NamedType
       *   - ImplementsInterfaces & NamedType
       */
      parseImplementsInterfaces() {
        return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
      }
      /**
       * ```
       * FieldsDefinition : { FieldDefinition+ }
       * ```
       */
      parseFieldsDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseFieldDefinition,
          TokenKind.BRACE_R
        );
      }
      /**
       * FieldDefinition :
       *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
       */
      parseFieldDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        this.expectToken(TokenKind.COLON);
        const type = this.parseTypeReference();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.FIELD_DEFINITION,
          description,
          name,
          arguments: args,
          type,
          directives
        });
      }
      /**
       * ArgumentsDefinition : ( InputValueDefinition+ )
       */
      parseArgumentDefs() {
        return this.optionalMany(
          TokenKind.PAREN_L,
          this.parseInputValueDef,
          TokenKind.PAREN_R
        );
      }
      /**
       * InputValueDefinition :
       *   - Description? Name : Type DefaultValue? Directives[Const]?
       */
      parseInputValueDef() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        const type = this.parseTypeReference();
        let defaultValue;
        if (this.expectOptionalToken(TokenKind.EQUALS)) {
          defaultValue = this.parseConstValueLiteral();
        }
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.INPUT_VALUE_DEFINITION,
          description,
          name,
          type,
          defaultValue,
          directives
        });
      }
      /**
       * InterfaceTypeDefinition :
       *   - Description? interface Name Directives[Const]? FieldsDefinition?
       */
      parseInterfaceTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: Kind.INTERFACE_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * UnionTypeDefinition :
       *   - Description? union Name Directives[Const]? UnionMemberTypes?
       */
      parseUnionTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        return this.node(start, {
          kind: Kind.UNION_TYPE_DEFINITION,
          description,
          name,
          directives,
          types
        });
      }
      /**
       * UnionMemberTypes :
       *   - = `|`? NamedType
       *   - UnionMemberTypes | NamedType
       */
      parseUnionMemberTypes() {
        return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
      }
      /**
       * EnumTypeDefinition :
       *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
       */
      parseEnumTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        return this.node(start, {
          kind: Kind.ENUM_TYPE_DEFINITION,
          description,
          name,
          directives,
          values
        });
      }
      /**
       * ```
       * EnumValuesDefinition : { EnumValueDefinition+ }
       * ```
       */
      parseEnumValuesDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseEnumValueDefinition,
          TokenKind.BRACE_R
        );
      }
      /**
       * EnumValueDefinition : Description? EnumValue Directives[Const]?
       */
      parseEnumValueDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseEnumValueName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.ENUM_VALUE_DEFINITION,
          description,
          name,
          directives
        });
      }
      /**
       * EnumValue : Name but not `true`, `false` or `null`
       */
      parseEnumValueName() {
        if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
          throw syntaxError(
            this._lexer.source,
            this._lexer.token.start,
            `${getTokenDesc(
              this._lexer.token
            )} is reserved and cannot be used for an enum value.`
          );
        }
        return this.parseName();
      }
      /**
       * InputObjectTypeDefinition :
       *   - Description? input Name Directives[Const]? InputFieldsDefinition?
       */
      parseInputObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        return this.node(start, {
          kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description,
          name,
          directives,
          fields
        });
      }
      /**
       * ```
       * InputFieldsDefinition : { InputValueDefinition+ }
       * ```
       */
      parseInputFieldsDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseInputValueDef,
          TokenKind.BRACE_R
        );
      }
      /**
       * TypeSystemExtension :
       *   - SchemaExtension
       *   - TypeExtension
       *
       * TypeExtension :
       *   - ScalarTypeExtension
       *   - ObjectTypeExtension
       *   - InterfaceTypeExtension
       *   - UnionTypeExtension
       *   - EnumTypeExtension
       *   - InputObjectTypeDefinition
       */
      parseTypeSystemExtension() {
        const keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      /**
       * ```
       * SchemaExtension :
       *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
       *  - extend schema Directives[Const]
       * ```
       */
      parseSchemaExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.optionalMany(
          TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          TokenKind.BRACE_R
        );
        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.SCHEMA_EXTENSION,
          directives,
          operationTypes
        });
      }
      /**
       * ScalarTypeExtension :
       *   - extend scalar Name Directives[Const]
       */
      parseScalarTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        if (directives.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.SCALAR_TYPE_EXTENSION,
          name,
          directives
        });
      }
      /**
       * ObjectTypeExtension :
       *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend type Name ImplementsInterfaces? Directives[Const]
       *  - extend type Name ImplementsInterfaces
       */
      parseObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.OBJECT_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * InterfaceTypeExtension :
       *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend interface Name ImplementsInterfaces? Directives[Const]
       *  - extend interface Name ImplementsInterfaces
       */
      parseInterfaceTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.INTERFACE_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * UnionTypeExtension :
       *   - extend union Name Directives[Const]? UnionMemberTypes
       *   - extend union Name Directives[Const]
       */
      parseUnionTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        if (directives.length === 0 && types.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.UNION_TYPE_EXTENSION,
          name,
          directives,
          types
        });
      }
      /**
       * EnumTypeExtension :
       *   - extend enum Name Directives[Const]? EnumValuesDefinition
       *   - extend enum Name Directives[Const]
       */
      parseEnumTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.ENUM_TYPE_EXTENSION,
          name,
          directives,
          values
        });
      }
      /**
       * InputObjectTypeExtension :
       *   - extend input Name Directives[Const]? InputFieldsDefinition
       *   - extend input Name Directives[Const]
       */
      parseInputObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name,
          directives,
          fields
        });
      }
      /**
       * ```
       * DirectiveDefinition :
       *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
       * ```
       */
      parseDirectiveDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(TokenKind.AT);
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        const repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        const locations = this.parseDirectiveLocations();
        return this.node(start, {
          kind: Kind.DIRECTIVE_DEFINITION,
          description,
          name,
          arguments: args,
          repeatable,
          locations
        });
      }
      /**
       * DirectiveLocations :
       *   - `|`? DirectiveLocation
       *   - DirectiveLocations | DirectiveLocation
       */
      parseDirectiveLocations() {
        return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
      }
      /*
       * DirectiveLocation :
       *   - ExecutableDirectiveLocation
       *   - TypeSystemDirectiveLocation
       *
       * ExecutableDirectiveLocation : one of
       *   `QUERY`
       *   `MUTATION`
       *   `SUBSCRIPTION`
       *   `FIELD`
       *   `FRAGMENT_DEFINITION`
       *   `FRAGMENT_SPREAD`
       *   `INLINE_FRAGMENT`
       *
       * TypeSystemDirectiveLocation : one of
       *   `SCHEMA`
       *   `SCALAR`
       *   `OBJECT`
       *   `FIELD_DEFINITION`
       *   `ARGUMENT_DEFINITION`
       *   `INTERFACE`
       *   `UNION`
       *   `ENUM`
       *   `ENUM_VALUE`
       *   `INPUT_OBJECT`
       *   `INPUT_FIELD_DEFINITION`
       */
      parseDirectiveLocation() {
        const start = this._lexer.token;
        const name = this.parseName();
        if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
          return name;
        }
        throw this.unexpected(start);
      }
      // Core parsing utility functions
      /**
       * Returns a node that, if configured to do so, sets a "loc" field as a
       * location object, used to identify the place in the source that created a
       * given parsed object.
       */
      node(startToken, node) {
        if (this._options.noLocation !== true) {
          node.loc = new Location(
            startToken,
            this._lexer.lastToken,
            this._lexer.source
          );
        }
        return node;
      }
      /**
       * Determines if the next token is of a given kind
       */
      peek(kind) {
        return this._lexer.token.kind === kind;
      }
      /**
       * If the next token is of the given kind, return that token after advancing the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      expectToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return token;
        }
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
        );
      }
      /**
       * If the next token is of the given kind, return "true" after advancing the lexer.
       * Otherwise, do not change the parser state and return "false".
       */
      expectOptionalToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      /**
       * If the next token is a given keyword, advance the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      expectKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === TokenKind.NAME && token.value === value) {
          this.advanceLexer();
        } else {
          throw syntaxError(
            this._lexer.source,
            token.start,
            `Expected "${value}", found ${getTokenDesc(token)}.`
          );
        }
      }
      /**
       * If the next token is a given keyword, return "true" after advancing the lexer.
       * Otherwise, do not change the parser state and return "false".
       */
      expectOptionalKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === TokenKind.NAME && token.value === value) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      /**
       * Helper function for creating an error when an unexpected lexed token is encountered.
       */
      unexpected(atToken) {
        const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return syntaxError(
          this._lexer.source,
          token.start,
          `Unexpected ${getTokenDesc(token)}.`
        );
      }
      /**
       * Returns a possibly empty list of parse nodes, determined by the parseFn.
       * This list begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }
        return nodes;
      }
      /**
       * Returns a list of parse nodes, determined by the parseFn.
       * It can be empty only if open token is missing otherwise it will always return non-empty list
       * that begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        return [];
      }
      /**
       * Returns a non-empty list of parse nodes, determined by the parseFn.
       * This list begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      /**
       * Returns a non-empty list of parse nodes, determined by the parseFn.
       * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
       * Advances the parser to the next lex token after last item in the list.
       */
      delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (this.expectOptionalToken(delimiterKind));
        return nodes;
      }
      advanceLexer() {
        const { maxTokens } = this._options;
        const token = this._lexer.advance();
        if (maxTokens !== void 0 && token.kind !== TokenKind.EOF) {
          ++this._tokenCounter;
          if (this._tokenCounter > maxTokens) {
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Document contains more that ${maxTokens} tokens. Parsing aborted.`
            );
          }
        }
      }
    };
  }
});
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
var MAX_SUGGESTIONS;
var init_didYouMean = __esm({
  "node_modules/graphql/jsutils/didYouMean.mjs"() {
    MAX_SUGGESTIONS = 5;
  }
});
function identityFunc(x) {
  return x;
}
var init_identityFunc = __esm({
  "node_modules/graphql/jsutils/identityFunc.mjs"() {
  }
});
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}
var init_keyMap = __esm({
  "node_modules/graphql/jsutils/keyMap.mjs"() {
  }
});
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}
var init_keyValMap = __esm({
  "node_modules/graphql/jsutils/keyValMap.mjs"() {
  }
});
function mapValue(map, fn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn(map[key], key);
  }
  return result;
}
var init_mapValue = __esm({
  "node_modules/graphql/jsutils/mapValue.mjs"() {
  }
});
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
function isDigit2(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}
var DIGIT_0, DIGIT_9;
var init_naturalCompare = __esm({
  "node_modules/graphql/jsutils/naturalCompare.mjs"() {
    DIGIT_0 = 48;
    DIGIT_9 = 57;
  }
});
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a, b) => {
    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);
  });
}
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i = 0; i < strLength; ++i) {
    array[i] = str.charCodeAt(i);
  }
  return array;
}
var LexicalDistance;
var init_suggestionList = __esm({
  "node_modules/graphql/jsutils/suggestionList.mjs"() {
    init_naturalCompare();
    LexicalDistance = class {
      constructor(input) {
        this._input = input;
        this._inputLowerCase = input.toLowerCase();
        this._inputArray = stringToArray(this._inputLowerCase);
        this._rows = [
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0)
        ];
      }
      measure(option, threshold) {
        if (this._input === option) {
          return 0;
        }
        const optionLowerCase = option.toLowerCase();
        if (this._inputLowerCase === optionLowerCase) {
          return 1;
        }
        let a = stringToArray(optionLowerCase);
        let b = this._inputArray;
        if (a.length < b.length) {
          const tmp = a;
          a = b;
          b = tmp;
        }
        const aLength = a.length;
        const bLength = b.length;
        if (aLength - bLength > threshold) {
          return void 0;
        }
        const rows = this._rows;
        for (let j = 0; j <= bLength; j++) {
          rows[0][j] = j;
        }
        for (let i = 1; i <= aLength; i++) {
          const upRow = rows[(i - 1) % 3];
          const currentRow = rows[i % 3];
          let smallestCell = currentRow[0] = i;
          for (let j = 1; j <= bLength; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            let currentCell = Math.min(
              upRow[j] + 1,
              // delete
              currentRow[j - 1] + 1,
              // insert
              upRow[j - 1] + cost
              // substitute
            );
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
              const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
              currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
            }
            if (currentCell < smallestCell) {
              smallestCell = currentCell;
            }
            currentRow[j] = currentCell;
          }
          if (smallestCell > threshold) {
            return void 0;
          }
        }
        const distance = rows[aLength % 3][bLength];
        return distance <= threshold ? distance : void 0;
      }
    };
  }
});
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}
var init_toObjMap = __esm({
  "node_modules/graphql/jsutils/toObjMap.mjs"() {
  }
});
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapedRegExp, escapeSequences;
var init_printString = __esm({
  "node_modules/graphql/language/printString.mjs"() {
    escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    escapeSequences = [
      "\\u0000",
      "\\u0001",
      "\\u0002",
      "\\u0003",
      "\\u0004",
      "\\u0005",
      "\\u0006",
      "\\u0007",
      "\\b",
      "\\t",
      "\\n",
      "\\u000B",
      "\\f",
      "\\r",
      "\\u000E",
      "\\u000F",
      "\\u0010",
      "\\u0011",
      "\\u0012",
      "\\u0013",
      "\\u0014",
      "\\u0015",
      "\\u0016",
      "\\u0017",
      "\\u0018",
      "\\u0019",
      "\\u001A",
      "\\u001B",
      "\\u001C",
      "\\u001D",
      "\\u001E",
      "\\u001F",
      "",
      "",
      '\\"',
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 2F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 3F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 4F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\",
      "",
      "",
      "",
      // 5F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 6F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\u007F",
      "\\u0080",
      "\\u0081",
      "\\u0082",
      "\\u0083",
      "\\u0084",
      "\\u0085",
      "\\u0086",
      "\\u0087",
      "\\u0088",
      "\\u0089",
      "\\u008A",
      "\\u008B",
      "\\u008C",
      "\\u008D",
      "\\u008E",
      "\\u008F",
      "\\u0090",
      "\\u0091",
      "\\u0092",
      "\\u0093",
      "\\u0094",
      "\\u0095",
      "\\u0096",
      "\\u0097",
      "\\u0098",
      "\\u0099",
      "\\u009A",
      "\\u009B",
      "\\u009C",
      "\\u009D",
      "\\u009E",
      "\\u009F"
    ];
  }
});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function visitInParallel(visitors) {
  const skipping = new Array(visitors.length).fill(null);
  const mergedVisitor = /* @__PURE__ */ Object.create(null);
  for (const kind of Object.values(Kind)) {
    let hasVisitor = false;
    const enterList = new Array(visitors.length).fill(void 0);
    const leaveList = new Array(visitors.length).fill(void 0);
    for (let i = 0; i < visitors.length; ++i) {
      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
      hasVisitor || (hasVisitor = enter != null || leave != null);
      enterList[i] = enter;
      leaveList[i] = leave;
    }
    if (!hasVisitor) {
      continue;
    }
    const mergedEnterLeave = {
      enter(...args) {
        const node = args[0];
        for (let i = 0; i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _enterList$i;
            const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== void 0) {
              return result;
            }
          }
        }
      },
      leave(...args) {
        const node = args[0];
        for (let i = 0; i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _leaveList$i;
            const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== void 0 && result !== false) {
              return result;
            }
          } else if (skipping[i] === node) {
            skipping[i] = null;
          }
        }
      }
    };
    mergedVisitor[kind] = mergedEnterLeave;
  }
  return mergedVisitor;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
function getVisitFn(visitor, kind, isLeaving) {
  const { enter, leave } = getEnterLeaveForKind(visitor, kind);
  return isLeaving ? leave : enter;
}
var BREAK;
var init_visitor = __esm({
  "node_modules/graphql/language/visitor.mjs"() {
    init_devAssert();
    init_inspect();
    init_ast();
    init_kinds();
    BREAK = Object.freeze({});
  }
});
function print(ast) {
  return visit(ast, printDocASTReducer);
}
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
var MAX_LINE_LENGTH, printDocASTReducer;
var init_printer = __esm({
  "node_modules/graphql/language/printer.mjs"() {
    init_blockString();
    init_printString();
    init_visitor();
    MAX_LINE_LENGTH = 80;
    printDocASTReducer = {
      Name: {
        leave: (node) => node.value
      },
      Variable: {
        leave: (node) => "$" + node.name
      },
      // Document
      Document: {
        leave: (node) => join(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave(node) {
          const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
          const prefix = join(
            [
              node.operation,
              join([node.name, varDefs]),
              join(node.directives, " ")
            ],
            " "
          );
          return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
      },
      SelectionSet: {
        leave: ({ selections }) => block(selections)
      },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap("", alias, ": ") + name;
          let argsLine = prefix + wrap("(", join(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
          }
          return join([argsLine, join(directives, " "), selectionSet], " ");
        }
      },
      Argument: {
        leave: ({ name, value }) => name + ": " + value
      },
      // Fragments
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join(
          [
            "...",
            wrap("on ", typeCondition),
            join(directives, " "),
            selectionSet
          ],
          " "
        )
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // or removed in the future.
          `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
        )
      },
      // Value
      IntValue: {
        leave: ({ value }) => value
      },
      FloatValue: {
        leave: ({ value }) => value
      },
      StringValue: {
        leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
      },
      BooleanValue: {
        leave: ({ value }) => value ? "true" : "false"
      },
      NullValue: {
        leave: () => "null"
      },
      EnumValue: {
        leave: ({ value }) => value
      },
      ListValue: {
        leave: ({ values }) => "[" + join(values, ", ") + "]"
      },
      ObjectValue: {
        leave: ({ fields }) => "{" + join(fields, ", ") + "}"
      },
      ObjectField: {
        leave: ({ name, value }) => name + ": " + value
      },
      // Directive
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
      },
      // Type
      NamedType: {
        leave: ({ name }) => name
      },
      ListType: {
        leave: ({ type }) => "[" + type + "]"
      },
      NonNullType: {
        leave: ({ type }) => type + "!"
      },
      // Type System Definitions
      SchemaDefinition: {
        leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
          [
            "type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      FieldDefinition: {
        leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
          [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
          " "
        )
      },
      InterfaceTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
          [
            "interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      UnionTypeDefinition: {
        leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
          ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
          " "
        )
      },
      EnumTypeDefinition: {
        leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join(
          ["extend schema", join(directives, " "), block(operationTypes)],
          " "
        )
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(
          [
            "extend type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(
          [
            "extend interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join(
          [
            "extend union",
            name,
            join(directives, " "),
            wrap("= ", join(types, " | "))
          ],
          " "
        )
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
      }
    };
  }
});
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}
var init_valueFromASTUntyped = __esm({
  "node_modules/graphql/utilities/valueFromASTUntyped.mjs"() {
    init_keyValMap();
    init_kinds();
  }
});
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i = 1; i < name.length; ++i) {
    if (!isNameContinue(name.charCodeAt(i))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
      );
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name}" does not.`
    );
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}
var init_assertName = __esm({
  "node_modules/graphql/type/assertName.mjs"() {
    init_devAssert();
    init_GraphQLError();
    init_characterClasses();
  }
});
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function assertType(type) {
  if (!isType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL type.`);
  }
  return type;
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function assertScalarType(type) {
  if (!isScalarType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Scalar type.`);
  }
  return type;
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function assertObjectType(type) {
  if (!isObjectType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Object type.`);
  }
  return type;
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function assertInterfaceType(type) {
  if (!isInterfaceType(type)) {
    throw new Error(
      `Expected ${inspect(type)} to be a GraphQL Interface type.`
    );
  }
  return type;
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function assertUnionType(type) {
  if (!isUnionType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Union type.`);
  }
  return type;
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function assertEnumType(type) {
  if (!isEnumType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Enum type.`);
  }
  return type;
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function assertInputObjectType(type) {
  if (!isInputObjectType(type)) {
    throw new Error(
      `Expected ${inspect(type)} to be a GraphQL Input Object type.`
    );
  }
  return type;
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function assertListType(type) {
  if (!isListType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL List type.`);
  }
  return type;
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function assertNonNullType(type) {
  if (!isNonNullType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Non-Null type.`);
  }
  return type;
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function assertInputType(type) {
  if (!isInputType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL input type.`);
  }
  return type;
}
function isOutputType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
}
function assertOutputType(type) {
  if (!isOutputType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL output type.`);
  }
  return type;
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function assertLeafType(type) {
  if (!isLeafType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL leaf type.`);
  }
  return type;
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function assertCompositeType(type) {
  if (!isCompositeType(type)) {
    throw new Error(
      `Expected ${inspect(type)} to be a GraphQL composite type.`
    );
  }
  return type;
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
function assertAbstractType(type) {
  if (!isAbstractType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL abstract type.`);
  }
  return type;
}
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function assertWrappingType(type) {
  if (!isWrappingType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL wrapping type.`);
  }
  return type;
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function assertNullableType(type) {
  if (!isNullableType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL nullable type.`);
  }
  return type;
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function isNamedType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
}
function assertNamedType(type) {
  if (!isNamedType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL named type.`);
  }
  return type;
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
function defineTypes(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types;
}
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}
var GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType;
var init_definition = __esm({
  "node_modules/graphql/type/definition.mjs"() {
    init_devAssert();
    init_didYouMean();
    init_identityFunc();
    init_inspect();
    init_instanceOf();
    init_isObjectLike();
    init_keyMap();
    init_keyValMap();
    init_mapValue();
    init_suggestionList();
    init_toObjMap();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_valueFromASTUntyped();
    init_assertName();
    GraphQLList = class {
      constructor(ofType) {
        isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLList";
      }
      toString() {
        return "[" + String(this.ofType) + "]";
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLNonNull = class {
      constructor(ofType) {
        isNullableType(ofType) || devAssert(
          false,
          `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
        );
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLNonNull";
      }
      toString() {
        return String(this.ofType) + "!";
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLScalarType = class {
      constructor(config) {
        var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
        const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
        this.name = assertName(config.name);
        this.description = config.description;
        this.specifiedByURL = config.specifiedByURL;
        this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
        this.parseValue = parseValue2;
        this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
          false,
          `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
        );
        config.serialize == null || typeof config.serialize === "function" || devAssert(
          false,
          `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
        );
        if (config.parseLiteral) {
          typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
            false,
            `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
          );
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLScalarType";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          specifiedByURL: this.specifiedByURL,
          serialize: this.serialize,
          parseValue: this.parseValue,
          parseLiteral: this.parseLiteral,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLObjectType = class {
      constructor(config) {
        var _config$extensionASTN2;
        this.name = assertName(config.name);
        this.description = config.description;
        this.isTypeOf = config.isTypeOf;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
        this._fields = () => defineFieldMap(config);
        this._interfaces = () => defineInterfaces(config);
        config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
          false,
          `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          isTypeOf: this.isTypeOf,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLInterfaceType = class {
      constructor(config) {
        var _config$extensionASTN3;
        this.name = assertName(config.name);
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
        this._fields = defineFieldMap.bind(void 0, config);
        this._interfaces = defineInterfaces.bind(void 0, config);
        config.resolveType == null || typeof config.resolveType === "function" || devAssert(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInterfaceType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLUnionType = class {
      constructor(config) {
        var _config$extensionASTN4;
        this.name = assertName(config.name);
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
        this._types = defineTypes.bind(void 0, config);
        config.resolveType == null || typeof config.resolveType === "function" || devAssert(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLUnionType";
      }
      getTypes() {
        if (typeof this._types === "function") {
          this._types = this._types();
        }
        return this._types;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          types: this.getTypes(),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLEnumType = class {
      /* <T> */
      constructor(config) {
        var _config$extensionASTN5;
        this.name = assertName(config.name);
        this.description = config.description;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
        this._values = defineEnumValues(this.name, config.values);
        this._valueLookup = new Map(
          this._values.map((enumValue) => [enumValue.value, enumValue])
        );
        this._nameLookup = keyMap(this._values, (value) => value.name);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLEnumType";
      }
      getValues() {
        return this._values;
      }
      getValue(name) {
        return this._nameLookup[name];
      }
      serialize(outputValue) {
        const enumValue = this._valueLookup.get(outputValue);
        if (enumValue === void 0) {
          throw new GraphQLError(
            `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
          );
        }
        return enumValue.name;
      }
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          const valueStr = inspect(inputValue);
          throw new GraphQLError(
            `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
          );
        }
        const enumValue = this.getValue(inputValue);
        if (enumValue == null) {
          throw new GraphQLError(
            `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
          );
        }
        return enumValue.value;
      }
      parseLiteral(valueNode, _variables) {
        if (valueNode.kind !== Kind.ENUM) {
          const valueStr = print(valueNode);
          throw new GraphQLError(
            `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        const enumValue = this.getValue(valueNode.value);
        if (enumValue == null) {
          const valueStr = print(valueNode);
          throw new GraphQLError(
            `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        return enumValue.value;
      }
      toConfig() {
        const values = keyValMap(
          this.getValues(),
          (value) => value.name,
          (value) => ({
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode
          })
        );
        return {
          name: this.name,
          description: this.description,
          values,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLInputObjectType = class {
      constructor(config) {
        var _config$extensionASTN6;
        this.name = assertName(config.name);
        this.description = config.description;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
        this._fields = defineInputFieldMap.bind(void 0, config);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInputObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      toConfig() {
        const fields = mapValue(this.getFields(), (field) => ({
          description: field.description,
          type: field.type,
          defaultValue: field.defaultValue,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        }));
        return {
          name: this.name,
          description: this.description,
          fields,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
  }
});
function isSpecifiedScalarType(type) {
  return specifiedScalarTypes.some(({ name }) => type.name === name);
}
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}
var GRAPHQL_MAX_INT, GRAPHQL_MIN_INT, GraphQLInt, GraphQLFloat, GraphQLString, GraphQLBoolean, GraphQLID, specifiedScalarTypes;
var init_scalars = __esm({
  "node_modules/graphql/type/scalars.mjs"() {
    init_inspect();
    init_isObjectLike();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    GRAPHQL_MAX_INT = 2147483647;
    GRAPHQL_MIN_INT = -2147483648;
    GraphQLInt = new GraphQLScalarType({
      name: "Int",
      description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isInteger(num)) {
          throw new GraphQLError(
            `Int cannot represent non-integer value: ${inspect(coercedValue)}`
          );
        }
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new GraphQLError(
            "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
          throw new GraphQLError(
            `Int cannot represent non-integer value: ${inspect(inputValue)}`
          );
        }
        if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
          throw new GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${inputValue}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.INT) {
          throw new GraphQLError(
            `Int cannot represent non-integer value: ${print(valueNode)}`,
            {
              nodes: valueNode
            }
          );
        }
        const num = parseInt(valueNode.value, 10);
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
            {
              nodes: valueNode
            }
          );
        }
        return num;
      }
    });
    GraphQLFloat = new GraphQLScalarType({
      name: "Float",
      description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isFinite(num)) {
          throw new GraphQLError(
            `Float cannot represent non numeric value: ${inspect(coercedValue)}`
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
          throw new GraphQLError(
            `Float cannot represent non numeric value: ${inspect(inputValue)}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
          throw new GraphQLError(
            `Float cannot represent non numeric value: ${print(valueNode)}`,
            valueNode
          );
        }
        return parseFloat(valueNode.value);
      }
    });
    GraphQLString = new GraphQLScalarType({
      name: "String",
      description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (typeof coercedValue === "boolean") {
          return coercedValue ? "true" : "false";
        }
        if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
          return coercedValue.toString();
        }
        throw new GraphQLError(
          `String cannot represent value: ${inspect(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          throw new GraphQLError(
            `String cannot represent a non string value: ${inspect(inputValue)}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.STRING) {
          throw new GraphQLError(
            `String cannot represent a non string value: ${print(valueNode)}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    GraphQLBoolean = new GraphQLScalarType({
      name: "Boolean",
      description: "The `Boolean` scalar type represents `true` or `false`.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue;
        }
        if (Number.isFinite(coercedValue)) {
          return coercedValue !== 0;
        }
        throw new GraphQLError(
          `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "boolean") {
          throw new GraphQLError(
            `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.BOOLEAN) {
          throw new GraphQLError(
            `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    GraphQLID = new GraphQLScalarType({
      name: "ID",
      description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (Number.isInteger(coercedValue)) {
          return String(coercedValue);
        }
        throw new GraphQLError(
          `ID cannot represent value: ${inspect(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue === "string") {
          return inputValue;
        }
        if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
          return inputValue.toString();
        }
        throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
          throw new GraphQLError(
            "ID cannot represent a non-string and non-integer value: " + print(valueNode),
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    specifiedScalarTypes = Object.freeze([
      GraphQLString,
      GraphQLInt,
      GraphQLFloat,
      GraphQLBoolean,
      GraphQLID
    ]);
  }
});
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
function assertDirective(directive) {
  if (!isDirective(directive)) {
    throw new Error(
      `Expected ${inspect(directive)} to be a GraphQL directive.`
    );
  }
  return directive;
}
function isSpecifiedDirective(directive) {
  return specifiedDirectives.some(({ name }) => name === directive.name);
}
var GraphQLDirective, GraphQLIncludeDirective, GraphQLSkipDirective, DEFAULT_DEPRECATION_REASON, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective, specifiedDirectives;
var init_directives = __esm({
  "node_modules/graphql/type/directives.mjs"() {
    init_devAssert();
    init_inspect();
    init_instanceOf();
    init_isObjectLike();
    init_toObjMap();
    init_directiveLocation();
    init_assertName();
    init_definition();
    init_scalars();
    GraphQLDirective = class {
      constructor(config) {
        var _config$isRepeatable, _config$args;
        this.name = assertName(config.name);
        this.description = config.description;
        this.locations = config.locations;
        this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
        const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
        isObjectLike(args) && !Array.isArray(args) || devAssert(
          false,
          `@${config.name} args must be an object with argument names as keys.`
        );
        this.args = defineArguments(args);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLDirective";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          locations: this.locations,
          args: argsToArgsConfig(this.args),
          isRepeatable: this.isRepeatable,
          extensions: this.extensions,
          astNode: this.astNode
        };
      }
      toString() {
        return "@" + this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLIncludeDirective = new GraphQLDirective({
      name: "include",
      description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
      locations: [
        DirectiveLocation.FIELD,
        DirectiveLocation.FRAGMENT_SPREAD,
        DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new GraphQLNonNull(GraphQLBoolean),
          description: "Included when true."
        }
      }
    });
    GraphQLSkipDirective = new GraphQLDirective({
      name: "skip",
      description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
      locations: [
        DirectiveLocation.FIELD,
        DirectiveLocation.FRAGMENT_SPREAD,
        DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new GraphQLNonNull(GraphQLBoolean),
          description: "Skipped when true."
        }
      }
    });
    DEFAULT_DEPRECATION_REASON = "No longer supported";
    GraphQLDeprecatedDirective = new GraphQLDirective({
      name: "deprecated",
      description: "Marks an element of a GraphQL schema as no longer supported.",
      locations: [
        DirectiveLocation.FIELD_DEFINITION,
        DirectiveLocation.ARGUMENT_DEFINITION,
        DirectiveLocation.INPUT_FIELD_DEFINITION,
        DirectiveLocation.ENUM_VALUE
      ],
      args: {
        reason: {
          type: GraphQLString,
          description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
          defaultValue: DEFAULT_DEPRECATION_REASON
        }
      }
    });
    GraphQLSpecifiedByDirective = new GraphQLDirective({
      name: "specifiedBy",
      description: "Exposes a URL that specifies the behavior of this scalar.",
      locations: [DirectiveLocation.SCALAR],
      args: {
        url: {
          type: new GraphQLNonNull(GraphQLString),
          description: "The URL that specifies the behavior of this scalar."
        }
      }
    });
    specifiedDirectives = Object.freeze([
      GraphQLIncludeDirective,
      GraphQLSkipDirective,
      GraphQLDeprecatedDirective,
      GraphQLSpecifiedByDirective
    ]);
  }
});
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}
var init_isIterableObject = __esm({
  "node_modules/graphql/jsutils/isIterableObject.mjs"() {
  }
});
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp;
var init_astFromValue = __esm({
  "node_modules/graphql/utilities/astFromValue.mjs"() {
    init_inspect();
    init_invariant();
    init_isIterableObject();
    init_isObjectLike();
    init_kinds();
    init_definition();
    init_scalars();
    integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});
function isIntrospectionType(type) {
  return introspectionTypes.some(({ name }) => type.name === name);
}
var __Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, TypeKind, __TypeKind, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, introspectionTypes;
var init_introspection = __esm({
  "node_modules/graphql/type/introspection.mjs"() {
    init_inspect();
    init_invariant();
    init_directiveLocation();
    init_printer();
    init_astFromValue();
    init_definition();
    init_scalars();
    __Schema = new GraphQLObjectType({
      name: "__Schema",
      description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
      fields: () => ({
        description: {
          type: GraphQLString,
          resolve: (schema) => schema.description
        },
        types: {
          description: "A list of all types supported by this server.",
          type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
          resolve(schema) {
            return Object.values(schema.getTypeMap());
          }
        },
        queryType: {
          description: "The type that query operations will be rooted at.",
          type: new GraphQLNonNull(__Type),
          resolve: (schema) => schema.getQueryType()
        },
        mutationType: {
          description: "If this server supports mutation, the type that mutation operations will be rooted at.",
          type: __Type,
          resolve: (schema) => schema.getMutationType()
        },
        subscriptionType: {
          description: "If this server support subscription, the type that subscription operations will be rooted at.",
          type: __Type,
          resolve: (schema) => schema.getSubscriptionType()
        },
        directives: {
          description: "A list of all directives supported by this server.",
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__Directive))
          ),
          resolve: (schema) => schema.getDirectives()
        }
      })
    });
    __Directive = new GraphQLObjectType({
      name: "__Directive",
      description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (directive) => directive.name
        },
        description: {
          type: GraphQLString,
          resolve: (directive) => directive.description
        },
        isRepeatable: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (directive) => directive.isRepeatable
        },
        locations: {
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
          ),
          resolve: (directive) => directive.locations
        },
        args: {
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__InputValue))
          ),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        }
      })
    });
    __DirectiveLocation = new GraphQLEnumType({
      name: "__DirectiveLocation",
      description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
      values: {
        QUERY: {
          value: DirectiveLocation.QUERY,
          description: "Location adjacent to a query operation."
        },
        MUTATION: {
          value: DirectiveLocation.MUTATION,
          description: "Location adjacent to a mutation operation."
        },
        SUBSCRIPTION: {
          value: DirectiveLocation.SUBSCRIPTION,
          description: "Location adjacent to a subscription operation."
        },
        FIELD: {
          value: DirectiveLocation.FIELD,
          description: "Location adjacent to a field."
        },
        FRAGMENT_DEFINITION: {
          value: DirectiveLocation.FRAGMENT_DEFINITION,
          description: "Location adjacent to a fragment definition."
        },
        FRAGMENT_SPREAD: {
          value: DirectiveLocation.FRAGMENT_SPREAD,
          description: "Location adjacent to a fragment spread."
        },
        INLINE_FRAGMENT: {
          value: DirectiveLocation.INLINE_FRAGMENT,
          description: "Location adjacent to an inline fragment."
        },
        VARIABLE_DEFINITION: {
          value: DirectiveLocation.VARIABLE_DEFINITION,
          description: "Location adjacent to a variable definition."
        },
        SCHEMA: {
          value: DirectiveLocation.SCHEMA,
          description: "Location adjacent to a schema definition."
        },
        SCALAR: {
          value: DirectiveLocation.SCALAR,
          description: "Location adjacent to a scalar definition."
        },
        OBJECT: {
          value: DirectiveLocation.OBJECT,
          description: "Location adjacent to an object type definition."
        },
        FIELD_DEFINITION: {
          value: DirectiveLocation.FIELD_DEFINITION,
          description: "Location adjacent to a field definition."
        },
        ARGUMENT_DEFINITION: {
          value: DirectiveLocation.ARGUMENT_DEFINITION,
          description: "Location adjacent to an argument definition."
        },
        INTERFACE: {
          value: DirectiveLocation.INTERFACE,
          description: "Location adjacent to an interface definition."
        },
        UNION: {
          value: DirectiveLocation.UNION,
          description: "Location adjacent to a union definition."
        },
        ENUM: {
          value: DirectiveLocation.ENUM,
          description: "Location adjacent to an enum definition."
        },
        ENUM_VALUE: {
          value: DirectiveLocation.ENUM_VALUE,
          description: "Location adjacent to an enum value definition."
        },
        INPUT_OBJECT: {
          value: DirectiveLocation.INPUT_OBJECT,
          description: "Location adjacent to an input object type definition."
        },
        INPUT_FIELD_DEFINITION: {
          value: DirectiveLocation.INPUT_FIELD_DEFINITION,
          description: "Location adjacent to an input object field definition."
        }
      }
    });
    __Type = new GraphQLObjectType({
      name: "__Type",
      description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
      fields: () => ({
        kind: {
          type: new GraphQLNonNull(__TypeKind),
          resolve(type) {
            if (isScalarType(type)) {
              return TypeKind.SCALAR;
            }
            if (isObjectType(type)) {
              return TypeKind.OBJECT;
            }
            if (isInterfaceType(type)) {
              return TypeKind.INTERFACE;
            }
            if (isUnionType(type)) {
              return TypeKind.UNION;
            }
            if (isEnumType(type)) {
              return TypeKind.ENUM;
            }
            if (isInputObjectType(type)) {
              return TypeKind.INPUT_OBJECT;
            }
            if (isListType(type)) {
              return TypeKind.LIST;
            }
            if (isNonNullType(type)) {
              return TypeKind.NON_NULL;
            }
            invariant(false, `Unexpected type: "${inspect(type)}".`);
          }
        },
        name: {
          type: GraphQLString,
          resolve: (type) => "name" in type ? type.name : void 0
        },
        description: {
          type: GraphQLString,
          resolve: (type) => (
            /* c8 ignore next */
            "description" in type ? type.description : void 0
          )
        },
        specifiedByURL: {
          type: GraphQLString,
          resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
        },
        fields: {
          type: new GraphQLList(new GraphQLNonNull(__Field)),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if (isObjectType(type) || isInterfaceType(type)) {
              const fields = Object.values(type.getFields());
              return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
            }
          }
        },
        interfaces: {
          type: new GraphQLList(new GraphQLNonNull(__Type)),
          resolve(type) {
            if (isObjectType(type) || isInterfaceType(type)) {
              return type.getInterfaces();
            }
          }
        },
        possibleTypes: {
          type: new GraphQLList(new GraphQLNonNull(__Type)),
          resolve(type, _args, _context, { schema }) {
            if (isAbstractType(type)) {
              return schema.getPossibleTypes(type);
            }
          }
        },
        enumValues: {
          type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if (isEnumType(type)) {
              const values = type.getValues();
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        inputFields: {
          type: new GraphQLList(new GraphQLNonNull(__InputValue)),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if (isInputObjectType(type)) {
              const values = Object.values(type.getFields());
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        ofType: {
          type: __Type,
          resolve: (type) => "ofType" in type ? type.ofType : void 0
        }
      })
    });
    __Field = new GraphQLObjectType({
      name: "__Field",
      description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (field) => field.name
        },
        description: {
          type: GraphQLString,
          resolve: (field) => field.description
        },
        args: {
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__InputValue))
          ),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        },
        type: {
          type: new GraphQLNonNull(__Type),
          resolve: (field) => field.type
        },
        isDeprecated: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (field) => field.deprecationReason != null
        },
        deprecationReason: {
          type: GraphQLString,
          resolve: (field) => field.deprecationReason
        }
      })
    });
    __InputValue = new GraphQLObjectType({
      name: "__InputValue",
      description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (inputValue) => inputValue.name
        },
        description: {
          type: GraphQLString,
          resolve: (inputValue) => inputValue.description
        },
        type: {
          type: new GraphQLNonNull(__Type),
          resolve: (inputValue) => inputValue.type
        },
        defaultValue: {
          type: GraphQLString,
          description: "A GraphQL-formatted string representing the default value for this input value.",
          resolve(inputValue) {
            const { type, defaultValue } = inputValue;
            const valueAST = astFromValue(defaultValue, type);
            return valueAST ? print(valueAST) : null;
          }
        },
        isDeprecated: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (field) => field.deprecationReason != null
        },
        deprecationReason: {
          type: GraphQLString,
          resolve: (obj) => obj.deprecationReason
        }
      })
    });
    __EnumValue = new GraphQLObjectType({
      name: "__EnumValue",
      description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (enumValue) => enumValue.name
        },
        description: {
          type: GraphQLString,
          resolve: (enumValue) => enumValue.description
        },
        isDeprecated: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (enumValue) => enumValue.deprecationReason != null
        },
        deprecationReason: {
          type: GraphQLString,
          resolve: (enumValue) => enumValue.deprecationReason
        }
      })
    });
    (function(TypeKind2) {
      TypeKind2["SCALAR"] = "SCALAR";
      TypeKind2["OBJECT"] = "OBJECT";
      TypeKind2["INTERFACE"] = "INTERFACE";
      TypeKind2["UNION"] = "UNION";
      TypeKind2["ENUM"] = "ENUM";
      TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
      TypeKind2["LIST"] = "LIST";
      TypeKind2["NON_NULL"] = "NON_NULL";
    })(TypeKind || (TypeKind = {}));
    __TypeKind = new GraphQLEnumType({
      name: "__TypeKind",
      description: "An enum describing what kind of type a given `__Type` is.",
      values: {
        SCALAR: {
          value: TypeKind.SCALAR,
          description: "Indicates this type is a scalar."
        },
        OBJECT: {
          value: TypeKind.OBJECT,
          description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
        },
        INTERFACE: {
          value: TypeKind.INTERFACE,
          description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
        },
        UNION: {
          value: TypeKind.UNION,
          description: "Indicates this type is a union. `possibleTypes` is a valid field."
        },
        ENUM: {
          value: TypeKind.ENUM,
          description: "Indicates this type is an enum. `enumValues` is a valid field."
        },
        INPUT_OBJECT: {
          value: TypeKind.INPUT_OBJECT,
          description: "Indicates this type is an input object. `inputFields` is a valid field."
        },
        LIST: {
          value: TypeKind.LIST,
          description: "Indicates this type is a list. `ofType` is a valid field."
        },
        NON_NULL: {
          value: TypeKind.NON_NULL,
          description: "Indicates this type is a non-null. `ofType` is a valid field."
        }
      }
    });
    SchemaMetaFieldDef = {
      name: "__schema",
      type: new GraphQLNonNull(__Schema),
      description: "Access the current type schema of this server.",
      args: [],
      resolve: (_source, _args, _context, { schema }) => schema,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    TypeMetaFieldDef = {
      name: "__type",
      type: __Type,
      description: "Request the type information of a single type.",
      args: [
        {
          name: "name",
          description: void 0,
          type: new GraphQLNonNull(GraphQLString),
          defaultValue: void 0,
          deprecationReason: void 0,
          extensions: /* @__PURE__ */ Object.create(null),
          astNode: void 0
        }
      ],
      resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    TypeNameMetaFieldDef = {
      name: "__typename",
      type: new GraphQLNonNull(GraphQLString),
      description: "The name of the current Object type at runtime.",
      args: [],
      resolve: (_source, _args, _context, { parentType }) => parentType.name,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    introspectionTypes = Object.freeze([
      __Schema,
      __Directive,
      __DirectiveLocation,
      __Type,
      __Field,
      __InputValue,
      __EnumValue,
      __TypeKind
    ]);
  }
});
function isSchema(schema) {
  return instanceOf(schema, GraphQLSchema);
}
function assertSchema(schema) {
  if (!isSchema(schema)) {
    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);
  }
  return schema;
}
function collectReferencedTypes(type, typeSet) {
  const namedType = getNamedType(type);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
        for (const arg of field.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
      }
    }
  }
  return typeSet;
}
var GraphQLSchema;
var init_schema = __esm({
  "node_modules/graphql/type/schema.mjs"() {
    init_devAssert();
    init_inspect();
    init_instanceOf();
    init_isObjectLike();
    init_toObjMap();
    init_ast();
    init_definition();
    init_directives();
    init_introspection();
    GraphQLSchema = class {
      // Used as a cache for validateSchema().
      constructor(config) {
        var _config$extensionASTN, _config$directives;
        this.__validationErrors = config.assumeValid === true ? [] : void 0;
        isObjectLike(config) || devAssert(false, "Must provide configuration object.");
        !config.types || Array.isArray(config.types) || devAssert(
          false,
          `"types" must be Array if provided but got: ${inspect(config.types)}.`
        );
        !config.directives || Array.isArray(config.directives) || devAssert(
          false,
          `"directives" must be Array if provided but got: ${inspect(config.directives)}.`
        );
        this.description = config.description;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        this._queryType = config.query;
        this._mutationType = config.mutation;
        this._subscriptionType = config.subscription;
        this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
        const allReferencedTypes = new Set(config.types);
        if (config.types != null) {
          for (const type of config.types) {
            allReferencedTypes.delete(type);
            collectReferencedTypes(type, allReferencedTypes);
          }
        }
        if (this._queryType != null) {
          collectReferencedTypes(this._queryType, allReferencedTypes);
        }
        if (this._mutationType != null) {
          collectReferencedTypes(this._mutationType, allReferencedTypes);
        }
        if (this._subscriptionType != null) {
          collectReferencedTypes(this._subscriptionType, allReferencedTypes);
        }
        for (const directive of this._directives) {
          if (isDirective(directive)) {
            for (const arg of directive.args) {
              collectReferencedTypes(arg.type, allReferencedTypes);
            }
          }
        }
        collectReferencedTypes(__Schema, allReferencedTypes);
        this._typeMap = /* @__PURE__ */ Object.create(null);
        this._subTypeMap = /* @__PURE__ */ Object.create(null);
        this._implementationsMap = /* @__PURE__ */ Object.create(null);
        for (const namedType of allReferencedTypes) {
          if (namedType == null) {
            continue;
          }
          const typeName = namedType.name;
          typeName || devAssert(
            false,
            "One of the provided types for building the Schema is missing a name."
          );
          if (this._typeMap[typeName] !== void 0) {
            throw new Error(
              `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
            );
          }
          this._typeMap[typeName] = namedType;
          if (isInterfaceType(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if (isInterfaceType(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.interfaces.push(namedType);
              }
            }
          } else if (isObjectType(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if (isInterfaceType(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.objects.push(namedType);
              }
            }
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLSchema";
      }
      getQueryType() {
        return this._queryType;
      }
      getMutationType() {
        return this._mutationType;
      }
      getSubscriptionType() {
        return this._subscriptionType;
      }
      getRootType(operation) {
        switch (operation) {
          case OperationTypeNode.QUERY:
            return this.getQueryType();
          case OperationTypeNode.MUTATION:
            return this.getMutationType();
          case OperationTypeNode.SUBSCRIPTION:
            return this.getSubscriptionType();
        }
      }
      getTypeMap() {
        return this._typeMap;
      }
      getType(name) {
        return this.getTypeMap()[name];
      }
      getPossibleTypes(abstractType) {
        return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
      }
      getImplementations(interfaceType) {
        const implementations = this._implementationsMap[interfaceType.name];
        return implementations !== null && implementations !== void 0 ? implementations : {
          objects: [],
          interfaces: []
        };
      }
      isSubType(abstractType, maybeSubType) {
        let map = this._subTypeMap[abstractType.name];
        if (map === void 0) {
          map = /* @__PURE__ */ Object.create(null);
          if (isUnionType(abstractType)) {
            for (const type of abstractType.getTypes()) {
              map[type.name] = true;
            }
          } else {
            const implementations = this.getImplementations(abstractType);
            for (const type of implementations.objects) {
              map[type.name] = true;
            }
            for (const type of implementations.interfaces) {
              map[type.name] = true;
            }
          }
          this._subTypeMap[abstractType.name] = map;
        }
        return map[maybeSubType.name] !== void 0;
      }
      getDirectives() {
        return this._directives;
      }
      getDirective(name) {
        return this.getDirectives().find((directive) => directive.name === name);
      }
      toConfig() {
        return {
          description: this.description,
          query: this.getQueryType(),
          mutation: this.getMutationType(),
          subscription: this.getSubscriptionType(),
          types: Object.values(this.getTypeMap()),
          directives: this.getDirectives(),
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
          assumeValid: this.__validationErrors !== void 0
        };
      }
    };
  }
});
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}
var init_typeComparators = __esm({
  "node_modules/graphql/utilities/typeComparators.mjs"() {
    init_definition();
  }
});
function validateSchema(schema) {
  assertSchema(schema);
  if (schema.__validationErrors) {
    return schema.__validationErrors;
  }
  const context = new SchemaValidationContext(schema);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context);
  const errors = context.getErrors();
  schema.__validationErrors = errors;
  return errors;
}
function assertValidSchema(schema) {
  const errors = validateSchema(schema);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
function validateRootTypes(context) {
  const schema = context.schema;
  const queryType = schema.getQueryType();
  if (!queryType) {
    context.reportError("Query root type must be provided.", schema.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context.reportError(
      `Query root type must be Object type, it cannot be ${inspect(
        queryType
      )}.`,
      (_getOperationTypeNode = getOperationTypeNode(
        schema,
        OperationTypeNode.QUERY
      )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
    );
  }
  const mutationType = schema.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context.reportError(
      `Mutation root type must be Object type if provided, it cannot be ${inspect(mutationType)}.`,
      (_getOperationTypeNode2 = getOperationTypeNode(
        schema,
        OperationTypeNode.MUTATION
      )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
    );
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context.reportError(
      `Subscription root type must be Object type if provided, it cannot be ${inspect(subscriptionType)}.`,
      (_getOperationTypeNode3 = getOperationTypeNode(
        schema,
        OperationTypeNode.SUBSCRIPTION
      )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
    );
  }
}
function getOperationTypeNode(schema, operation) {
  var _flatMap$find;
  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(
    // FIXME: https://github.com/graphql/graphql-js/issues/2203
    (schemaNode) => {
      var _schemaNode$operation;
      return (
        /* c8 ignore next */
        (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []
      );
    }
  ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
}
function validateDirectives(context) {
  for (const directive of context.schema.getDirectives()) {
    if (!isDirective(directive)) {
      context.reportError(
        `Expected directive but got: ${inspect(directive)}.`,
        directive === null || directive === void 0 ? void 0 : directive.astNode
      );
      continue;
    }
    validateName(context, directive);
    for (const arg of directive.args) {
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        context.reportError(
          `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${inspect(arg.type)}.`,
          arg.astNode
        );
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context.reportError(
          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
          ]
        );
      }
    }
  }
}
function validateName(context, node) {
  if (node.name.startsWith("__")) {
    context.reportError(
      `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
      node.astNode
    );
  }
}
function validateTypes(context) {
  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  const typeMap = context.schema.getTypeMap();
  for (const type of Object.values(typeMap)) {
    if (!isNamedType(type)) {
      context.reportError(
        `Expected GraphQL named type but got: ${inspect(type)}.`,
        type.astNode
      );
      continue;
    }
    if (!isIntrospectionType(type)) {
      validateName(context, type);
    }
    if (isObjectType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isInterfaceType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isUnionType(type)) {
      validateUnionMembers(context, type);
    } else if (isEnumType(type)) {
      validateEnumValues(context, type);
    } else if (isInputObjectType(type)) {
      validateInputFields(context, type);
      validateInputObjectCircularRefs(type);
    }
  }
}
function validateFields(context, type) {
  const fields = Object.values(type.getFields());
  if (fields.length === 0) {
    context.reportError(`Type ${type.name} must define one or more fields.`, [
      type.astNode,
      ...type.extensionASTNodes
    ]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context.reportError(
        `The type of ${type.name}.${field.name} must be Output Type but got: ${inspect(field.type)}.`,
        (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
      );
    }
    for (const arg of field.args) {
      const argName = arg.name;
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context.reportError(
          `The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${inspect(arg.type)}.`,
          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
        );
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context.reportError(
          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
          ]
        );
      }
    }
  }
}
function validateInterfaces(context, type) {
  const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
  for (const iface of type.getInterfaces()) {
    if (!isInterfaceType(iface)) {
      context.reportError(
        `Type ${inspect(type)} must only implement Interface types, it cannot implement ${inspect(iface)}.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    if (type === iface) {
      context.reportError(
        `Type ${type.name} cannot implement itself because it would create a circular reference.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context.reportError(
        `Type ${type.name} can only implement ${iface.name} once.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context, type, iface);
    validateTypeImplementsInterface(context, type, iface);
  }
}
function validateTypeImplementsInterface(context, type, iface) {
  const typeFieldMap = type.getFields();
  for (const ifaceField of Object.values(iface.getFields())) {
    const fieldName = ifaceField.name;
    const typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context.reportError(
        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,
        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]
      );
      continue;
    }
    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context.reportError(
        `Interface field ${iface.name}.${fieldName} expects type ${inspect(ifaceField.type)} but ${type.name}.${fieldName} is type ${inspect(typeField.type)}.`,
        [
          (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
          (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
        ]
      );
    }
    for (const ifaceArg of ifaceField.args) {
      const argName = ifaceArg.name;
      const typeArg = typeField.args.find((arg) => arg.name === argName);
      if (!typeArg) {
        context.reportError(
          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,
          [ifaceArg.astNode, typeField.astNode]
        );
        continue;
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context.reportError(
          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${inspect(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${inspect(typeArg.type)}.`,
          [
            (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
            (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
          ]
        );
      }
    }
    for (const typeArg of typeField.args) {
      const argName = typeArg.name;
      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
      if (!ifaceArg && isRequiredArgument(typeArg)) {
        context.reportError(
          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
          [typeArg.astNode, ifaceField.astNode]
        );
      }
    }
  }
}
function validateTypeImplementsAncestors(context, type, iface) {
  const ifaceInterfaces = type.getInterfaces();
  for (const transitive of iface.getInterfaces()) {
    if (!ifaceInterfaces.includes(transitive)) {
      context.reportError(
        transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
        [
          ...getAllImplementsInterfaceNodes(iface, transitive),
          ...getAllImplementsInterfaceNodes(type, iface)
        ]
      );
    }
  }
}
function validateUnionMembers(context, union) {
  const memberTypes = union.getTypes();
  if (memberTypes.length === 0) {
    context.reportError(
      `Union type ${union.name} must define one or more member types.`,
      [union.astNode, ...union.extensionASTNodes]
    );
  }
  const includedTypeNames = /* @__PURE__ */ Object.create(null);
  for (const memberType of memberTypes) {
    if (includedTypeNames[memberType.name]) {
      context.reportError(
        `Union type ${union.name} can only include type ${memberType.name} once.`,
        getUnionMemberTypeNodes(union, memberType.name)
      );
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context.reportError(
        `Union type ${union.name} can only include Object types, it cannot include ${inspect(memberType)}.`,
        getUnionMemberTypeNodes(union, String(memberType))
      );
    }
  }
}
function validateEnumValues(context, enumType) {
  const enumValues = enumType.getValues();
  if (enumValues.length === 0) {
    context.reportError(
      `Enum type ${enumType.name} must define one or more values.`,
      [enumType.astNode, ...enumType.extensionASTNodes]
    );
  }
  for (const enumValue of enumValues) {
    validateName(context, enumValue);
  }
}
function validateInputFields(context, inputObj) {
  const fields = Object.values(inputObj.getFields());
  if (fields.length === 0) {
    context.reportError(
      `Input Object type ${inputObj.name} must define one or more fields.`,
      [inputObj.astNode, ...inputObj.extensionASTNodes]
    );
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context.reportError(
        `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${inspect(field.type)}.`,
        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
      );
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context.reportError(
        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
        [
          getDeprecatedDirectiveNode(field.astNode),
          (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
        ]
      );
    }
  }
}
function createInputObjectCircularRefsValidator(context) {
  const visitedTypes = /* @__PURE__ */ Object.create(null);
  const fieldPath = [];
  const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    const fields = Object.values(inputObj.getFields());
    for (const field of fields) {
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        const fieldType = field.type.ofType;
        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === void 0) {
          detectCycleRecursive(fieldType);
        } else {
          const cyclePath = fieldPath.slice(cycleIndex);
          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
          context.reportError(
            `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
            cyclePath.map((fieldObj) => fieldObj.astNode)
          );
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = void 0;
  }
}
function getAllImplementsInterfaceNodes(type, iface) {
  const { astNode, extensionASTNodes } = type;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((typeNode) => {
    var _typeNode$interfaces;
    return (
      /* c8 ignore next */
      (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []
    );
  }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
}
function getUnionMemberTypeNodes(union, typeName) {
  const { astNode, extensionASTNodes } = union;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((unionNode) => {
    var _unionNode$types;
    return (
      /* c8 ignore next */
      (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []
    );
  }).filter((typeNode) => typeNode.name.value === typeName);
}
function getDeprecatedDirectiveNode(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
    (node) => node.name.value === GraphQLDeprecatedDirective.name
  );
}
var SchemaValidationContext;
var init_validate = __esm({
  "node_modules/graphql/type/validate.mjs"() {
    init_inspect();
    init_GraphQLError();
    init_ast();
    init_typeComparators();
    init_definition();
    init_directives();
    init_introspection();
    init_schema();
    SchemaValidationContext = class {
      constructor(schema) {
        this._errors = [];
        this.schema = schema;
      }
      reportError(message, nodes) {
        const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
        this._errors.push(
          new GraphQLError(message, {
            nodes: _nodes
          })
        );
      }
      getErrors() {
        return this._errors;
      }
    };
  }
});
var init_type = __esm({
  "node_modules/graphql/type/index.mjs"() {
    init_schema();
    init_definition();
    init_directives();
    init_scalars();
    init_introspection();
    init_validate();
    init_assertName();
  }
});
function isDefinitionNode(node) {
  return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
}
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isSelectionNode(node) {
  return node.kind === Kind.FIELD || node.kind === Kind.FRAGMENT_SPREAD || node.kind === Kind.INLINE_FRAGMENT;
}
function isValueNode(node) {
  return node.kind === Kind.VARIABLE || node.kind === Kind.INT || node.kind === Kind.FLOAT || node.kind === Kind.STRING || node.kind === Kind.BOOLEAN || node.kind === Kind.NULL || node.kind === Kind.ENUM || node.kind === Kind.LIST || node.kind === Kind.OBJECT;
}
function isConstValueNode(node) {
  return isValueNode(node) && (node.kind === Kind.LIST ? node.values.some(isConstValueNode) : node.kind === Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== Kind.VARIABLE);
}
function isTypeNode(node) {
  return node.kind === Kind.NAMED_TYPE || node.kind === Kind.LIST_TYPE || node.kind === Kind.NON_NULL_TYPE;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}
var init_predicates = __esm({
  "node_modules/graphql/language/predicates.mjs"() {
    init_kinds();
  }
});
var init_language = __esm({
  "node_modules/graphql/language/index.mjs"() {
    init_source();
    init_location();
    init_printLocation();
    init_kinds();
    init_tokenKind();
    init_lexer();
    init_parser();
    init_printer();
    init_visitor();
    init_ast();
    init_predicates();
    init_directiveLocation();
  }
});
var version, versionInfo;
var init_version = __esm({
  "node_modules/graphql/version.mjs"() {
    version = "16.8.0";
    versionInfo = Object.freeze({
      major: 16,
      minor: 8,
      patch: 0,
      preReleaseTag: null
    });
  }
});
function isPromise(value) {
  return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
}
var init_isPromise = __esm({
  "node_modules/graphql/jsutils/isPromise.mjs"() {
  }
});
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}
var init_typeFromAST = __esm({
  "node_modules/graphql/utilities/typeFromAST.mjs"() {
    init_kinds();
    init_definition();
  }
});
function getFieldDef(schema, parentType, fieldNode) {
  const name = fieldNode.name.value;
  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name];
  }
}
function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter(...args) {
      const node = args[0];
      typeInfo.enter(node);
      const fn = getEnterLeaveForKind(visitor, node.kind).enter;
      if (fn) {
        const result = fn.apply(visitor, args);
        if (result !== void 0) {
          typeInfo.leave(node);
          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }
        return result;
      }
    },
    leave(...args) {
      const node = args[0];
      const fn = getEnterLeaveForKind(visitor, node.kind).leave;
      let result;
      if (fn) {
        result = fn.apply(visitor, args);
      }
      typeInfo.leave(node);
      return result;
    }
  };
}
var TypeInfo;
var init_TypeInfo = __esm({
  "node_modules/graphql/utilities/TypeInfo.mjs"() {
    init_ast();
    init_kinds();
    init_visitor();
    init_definition();
    init_introspection();
    init_typeFromAST();
    TypeInfo = class {
      constructor(schema, initialType, getFieldDefFn) {
        this._schema = schema;
        this._typeStack = [];
        this._parentTypeStack = [];
        this._inputTypeStack = [];
        this._fieldDefStack = [];
        this._defaultValueStack = [];
        this._directive = null;
        this._argument = null;
        this._enumValue = null;
        this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
        if (initialType) {
          if (isInputType(initialType)) {
            this._inputTypeStack.push(initialType);
          }
          if (isCompositeType(initialType)) {
            this._parentTypeStack.push(initialType);
          }
          if (isOutputType(initialType)) {
            this._typeStack.push(initialType);
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "TypeInfo";
      }
      getType() {
        if (this._typeStack.length > 0) {
          return this._typeStack[this._typeStack.length - 1];
        }
      }
      getParentType() {
        if (this._parentTypeStack.length > 0) {
          return this._parentTypeStack[this._parentTypeStack.length - 1];
        }
      }
      getInputType() {
        if (this._inputTypeStack.length > 0) {
          return this._inputTypeStack[this._inputTypeStack.length - 1];
        }
      }
      getParentInputType() {
        if (this._inputTypeStack.length > 1) {
          return this._inputTypeStack[this._inputTypeStack.length - 2];
        }
      }
      getFieldDef() {
        if (this._fieldDefStack.length > 0) {
          return this._fieldDefStack[this._fieldDefStack.length - 1];
        }
      }
      getDefaultValue() {
        if (this._defaultValueStack.length > 0) {
          return this._defaultValueStack[this._defaultValueStack.length - 1];
        }
      }
      getDirective() {
        return this._directive;
      }
      getArgument() {
        return this._argument;
      }
      getEnumValue() {
        return this._enumValue;
      }
      enter(node) {
        const schema = this._schema;
        switch (node.kind) {
          case Kind.SELECTION_SET: {
            const namedType = getNamedType(this.getType());
            this._parentTypeStack.push(
              isCompositeType(namedType) ? namedType : void 0
            );
            break;
          }
          case Kind.FIELD: {
            const parentType = this.getParentType();
            let fieldDef;
            let fieldType;
            if (parentType) {
              fieldDef = this._getFieldDef(schema, parentType, node);
              if (fieldDef) {
                fieldType = fieldDef.type;
              }
            }
            this._fieldDefStack.push(fieldDef);
            this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);
            break;
          }
          case Kind.DIRECTIVE:
            this._directive = schema.getDirective(node.name.value);
            break;
          case Kind.OPERATION_DEFINITION: {
            const rootType = schema.getRootType(node.operation);
            this._typeStack.push(isObjectType(rootType) ? rootType : void 0);
            break;
          }
          case Kind.INLINE_FRAGMENT:
          case Kind.FRAGMENT_DEFINITION: {
            const typeConditionAST = node.typeCondition;
            const outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());
            this._typeStack.push(isOutputType(outputType) ? outputType : void 0);
            break;
          }
          case Kind.VARIABLE_DEFINITION: {
            const inputType = typeFromAST(schema, node.type);
            this._inputTypeStack.push(
              isInputType(inputType) ? inputType : void 0
            );
            break;
          }
          case Kind.ARGUMENT: {
            var _this$getDirective;
            let argDef;
            let argType;
            const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
            if (fieldOrDirective) {
              argDef = fieldOrDirective.args.find(
                (arg) => arg.name === node.name.value
              );
              if (argDef) {
                argType = argDef.type;
              }
            }
            this._argument = argDef;
            this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
            this._inputTypeStack.push(isInputType(argType) ? argType : void 0);
            break;
          }
          case Kind.LIST: {
            const listType = getNullableType(this.getInputType());
            const itemType = isListType(listType) ? listType.ofType : listType;
            this._defaultValueStack.push(void 0);
            this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);
            break;
          }
          case Kind.OBJECT_FIELD: {
            const objectType = getNamedType(this.getInputType());
            let inputFieldType;
            let inputField;
            if (isInputObjectType(objectType)) {
              inputField = objectType.getFields()[node.name.value];
              if (inputField) {
                inputFieldType = inputField.type;
              }
            }
            this._defaultValueStack.push(
              inputField ? inputField.defaultValue : void 0
            );
            this._inputTypeStack.push(
              isInputType(inputFieldType) ? inputFieldType : void 0
            );
            break;
          }
          case Kind.ENUM: {
            const enumType = getNamedType(this.getInputType());
            let enumValue;
            if (isEnumType(enumType)) {
              enumValue = enumType.getValue(node.value);
            }
            this._enumValue = enumValue;
            break;
          }
          default:
        }
      }
      leave(node) {
        switch (node.kind) {
          case Kind.SELECTION_SET:
            this._parentTypeStack.pop();
            break;
          case Kind.FIELD:
            this._fieldDefStack.pop();
            this._typeStack.pop();
            break;
          case Kind.DIRECTIVE:
            this._directive = null;
            break;
          case Kind.OPERATION_DEFINITION:
          case Kind.INLINE_FRAGMENT:
          case Kind.FRAGMENT_DEFINITION:
            this._typeStack.pop();
            break;
          case Kind.VARIABLE_DEFINITION:
            this._inputTypeStack.pop();
            break;
          case Kind.ARGUMENT:
            this._argument = null;
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case Kind.LIST:
          case Kind.OBJECT_FIELD:
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case Kind.ENUM:
            this._enumValue = null;
            break;
          default:
        }
      }
    };
  }
});
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}
var init_ExecutableDefinitionsRule = __esm({
  "node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs"() {
    init_GraphQLError();
    init_kinds();
    init_predicates();
  }
});
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type = context.getParentType();
      if (type) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
}
function getSuggestedFieldNames(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}
var init_FieldsOnCorrectTypeRule = __esm({
  "node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs"() {
    init_didYouMean();
    init_naturalCompare();
    init_suggestionList();
    init_GraphQLError();
    init_definition();
  }
});
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print(node.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}
var init_FragmentsOnCompositeTypesRule = __esm({
  "node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs"() {
    init_GraphQLError();
    init_printer();
    init_definition();
    init_typeFromAST();
  }
});
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}
var init_KnownArgumentNamesRule = __esm({
  "node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs"() {
    init_didYouMean();
    init_suggestionList();
    init_GraphQLError();
    init_kinds();
    init_directives();
  }
});
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}
var init_KnownDirectivesRule = __esm({
  "node_modules/graphql/validation/rules/KnownDirectivesRule.mjs"() {
    init_inspect();
    init_invariant();
    init_GraphQLError();
    init_ast();
    init_directiveLocation();
    init_kinds();
    init_directives();
  }
});
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}
var init_KnownFragmentNamesRule = __esm({
  "node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs"() {
    init_GraphQLError();
  }
});
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function isSDLNode(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
}
var standardTypeNames;
var init_KnownTypeNamesRule = __esm({
  "node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs"() {
    init_didYouMean();
    init_suggestionList();
    init_GraphQLError();
    init_predicates();
    init_introspection();
    init_scalars();
    standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
      (type) => type.name
    );
  }
});
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var init_LoneAnonymousOperationRule = __esm({
  "node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs"() {
    init_GraphQLError();
    init_kinds();
  }
});
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}
var init_LoneSchemaDefinitionRule = __esm({
  "node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs"() {
    init_GraphQLError();
  }
});
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}
var init_NoFragmentCyclesRule = __esm({
  "node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs"() {
    init_GraphQLError();
  }
});
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}
var init_NoUndefinedVariablesRule = __esm({
  "node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs"() {
    init_GraphQLError();
  }
});
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}
var init_NoUnusedFragmentsRule = __esm({
  "node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs"() {
    init_GraphQLError();
  }
});
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}
var init_NoUnusedVariablesRule = __esm({
  "node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs"() {
    init_GraphQLError();
  }
});
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}
var init_sortValueNode = __esm({
  "node_modules/graphql/utilities/sortValueNode.mjs"() {
    init_naturalCompare();
    init_kinds();
  }
});
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i = 0; i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i]
      );
      for (let j = i + 1; j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          false,
          fragmentNames[i],
          fragmentNames[j]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    )) {
      continue;
    }
    comparedFragmentPairs.add(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    );
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i = 0; i < fields.length; i++) {
        for (let j = i + 1; j < fields.length; j++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i],
            fields[j]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (stringifyArguments(node1) !== stringifyArguments(node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function stringifyArguments(fieldNode) {
  var _fieldNode$arguments;
  const args = (
    /* c8 ignore next */
    (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : []
  );
  const inputObjectWithArgs = {
    kind: Kind.OBJECT,
    fields: args.map((argNode) => ({
      kind: Kind.OBJECT_FIELD,
      name: argNode.name,
      value: argNode.value
    }))
  };
  return print(sortValueNode(inputObjectWithArgs));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var PairSet;
var init_OverlappingFieldsCanBeMergedRule = __esm({
  "node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"() {
    init_inspect();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    init_sortValueNode();
    init_typeFromAST();
    PairSet = class {
      constructor() {
        this._data = /* @__PURE__ */ new Map();
      }
      has(a, b, areMutuallyExclusive) {
        var _this$_data$get;
        const [key1, key2] = a < b ? [a, b] : [b, a];
        const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
        if (result === void 0) {
          return false;
        }
        return areMutuallyExclusive ? true : areMutuallyExclusive === result;
      }
      add(a, b, areMutuallyExclusive) {
        const [key1, key2] = a < b ? [a, b] : [b, a];
        const map = this._data.get(key1);
        if (map === void 0) {
          this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
        } else {
          map.set(key2, areMutuallyExclusive);
        }
      }
    };
  }
});
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
}
var init_PossibleFragmentSpreadsRule = __esm({
  "node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs"() {
    init_inspect();
    init_GraphQLError();
    init_definition();
    init_typeComparators();
    init_typeFromAST();
  }
});
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
function typeToExtKind(type) {
  if (isScalarType(type)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}
var defKindToExtKind;
var init_PossibleTypeExtensionsRule = __esm({
  "node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs"() {
    init_didYouMean();
    init_inspect();
    init_invariant();
    init_suggestionList();
    init_GraphQLError();
    init_kinds();
    init_predicates();
    init_definition();
    defKindToExtKind = {
      [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
      [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
      [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
      [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
      [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
      [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
    };
  }
});
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}
var init_ProvidedRequiredArgumentsRule = __esm({
  "node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs"() {
    init_inspect();
    init_keyMap();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    init_directives();
  }
});
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type = context.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet
                }
              )
            );
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
var init_ScalarLeafsRule = __esm({
  "node_modules/graphql/validation/rules/ScalarLeafsRule.mjs"() {
    init_inspect();
    init_GraphQLError();
    init_definition();
  }
});
function printPathArray(path) {
  return path.map(
    (key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key
  ).join("");
}
var init_printPathArray = __esm({
  "node_modules/graphql/jsutils/printPathArray.mjs"() {
  }
});
function addPath(prev, key, typename) {
  return {
    prev,
    key,
    typename
  };
}
function pathToArray(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
var init_Path = __esm({
  "node_modules/graphql/jsutils/Path.mjs"() {
  }
});
function coerceInputValue(inputValue, type, onError = defaultOnError) {
  return coerceInputValueImpl(inputValue, type, onError, void 0);
}
function defaultOnError(path, invalidValue, error) {
  let errorPrefix = "Invalid value " + inspect(invalidValue);
  if (path.length > 0) {
    errorPrefix += ` at "value${printPathArray(path)}"`;
  }
  error.message = errorPrefix + ": " + error.message;
  throw error;
}
function coerceInputValueImpl(inputValue, type, onError, path) {
  if (isNonNullType(type)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type.ofType, onError, path);
    }
    onError(
      pathToArray(path),
      inputValue,
      new GraphQLError(
        `Expected non-nullable type "${inspect(type)}" not to be null.`
      )
    );
    return;
  }
  if (inputValue == null) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(inputValue)) {
      return Array.from(inputValue, (itemValue, index) => {
        const itemPath = addPath(path, index, void 0);
        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
      });
    }
    return [coerceInputValueImpl(inputValue, itemType, onError, path)];
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(inputValue)) {
      onError(
        pathToArray(path),
        inputValue,
        new GraphQLError(`Expected type "${type.name}" to be an object.`)
      );
      return;
    }
    const coercedValue = {};
    const fieldDefs = type.getFields();
    for (const field of Object.values(fieldDefs)) {
      const fieldValue = inputValue[field.name];
      if (fieldValue === void 0) {
        if (field.defaultValue !== void 0) {
          coercedValue[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          const typeStr = inspect(field.type);
          onError(
            pathToArray(path),
            inputValue,
            new GraphQLError(
              `Field "${field.name}" of required type "${typeStr}" was not provided.`
            )
          );
        }
        continue;
      }
      coercedValue[field.name] = coerceInputValueImpl(
        fieldValue,
        field.type,
        onError,
        addPath(path, field.name, type.name)
      );
    }
    for (const fieldName of Object.keys(inputValue)) {
      if (!fieldDefs[fieldName]) {
        const suggestions = suggestionList(
          fieldName,
          Object.keys(type.getFields())
        );
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(
            `Field "${fieldName}" is not defined by type "${type.name}".` + didYouMean(suggestions)
          )
        );
      }
    }
    return coercedValue;
  }
  if (isLeafType(type)) {
    let parseResult;
    try {
      parseResult = type.parseValue(inputValue);
    } catch (error) {
      if (error instanceof GraphQLError) {
        onError(pathToArray(path), inputValue, error);
      } else {
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(`Expected type "${type.name}". ` + error.message, {
            originalError: error
          })
        );
      }
      return;
    }
    if (parseResult === void 0) {
      onError(
        pathToArray(path),
        inputValue,
        new GraphQLError(`Expected type "${type.name}".`)
      );
    }
    return parseResult;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var init_coerceInputValue = __esm({
  "node_modules/graphql/utilities/coerceInputValue.mjs"() {
    init_didYouMean();
    init_inspect();
    init_invariant();
    init_isIterableObject();
    init_isObjectLike();
    init_Path();
    init_printPathArray();
    init_suggestionList();
    init_GraphQLError();
    init_definition();
  }
});
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result;
    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}
var init_valueFromAST = __esm({
  "node_modules/graphql/utilities/valueFromAST.mjs"() {
    init_inspect();
    init_invariant();
    init_keyMap();
    init_kinds();
    init_definition();
  }
});
function getVariableValues(schema, varDefNodes, inputs, options) {
  const errors = [];
  const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
  try {
    const coerced = coerceVariableValues(
      schema,
      varDefNodes,
      inputs,
      (error) => {
        if (maxErrors != null && errors.length >= maxErrors) {
          throw new GraphQLError(
            "Too many errors processing variables, error limit reached. Execution aborted."
          );
        }
        errors.push(error);
      }
    );
    if (errors.length === 0) {
      return {
        coerced
      };
    }
  } catch (error) {
    errors.push(error);
  }
  return {
    errors
  };
}
function coerceVariableValues(schema, varDefNodes, inputs, onError) {
  const coercedValues = {};
  for (const varDefNode of varDefNodes) {
    const varName = varDefNode.variable.name.value;
    const varType = typeFromAST(schema, varDefNode.type);
    if (!isInputType(varType)) {
      const varTypeStr = print(varDefNode.type);
      onError(
        new GraphQLError(
          `Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`,
          {
            nodes: varDefNode.type
          }
        )
      );
      continue;
    }
    if (!hasOwnProperty(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
      } else if (isNonNullType(varType)) {
        const varTypeStr = inspect(varType);
        onError(
          new GraphQLError(
            `Variable "$${varName}" of required type "${varTypeStr}" was not provided.`,
            {
              nodes: varDefNode
            }
          )
        );
      }
      continue;
    }
    const value = inputs[varName];
    if (value === null && isNonNullType(varType)) {
      const varTypeStr = inspect(varType);
      onError(
        new GraphQLError(
          `Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`,
          {
            nodes: varDefNode
          }
        )
      );
      continue;
    }
    coercedValues[varName] = coerceInputValue(
      value,
      varType,
      (path, invalidValue, error) => {
        let prefix = `Variable "$${varName}" got invalid value ` + inspect(invalidValue);
        if (path.length > 0) {
          prefix += ` at "${varName}${printPathArray(path)}"`;
        }
        onError(
          new GraphQLError(prefix + "; " + error.message, {
            nodes: varDefNode,
            originalError: error
          })
        );
      }
    );
  }
  return coercedValues;
}
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var init_values = __esm({
  "node_modules/graphql/execution/values.mjs"() {
    init_inspect();
    init_keyMap();
    init_printPathArray();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    init_coerceInputValue();
    init_typeFromAST();
    init_valueFromAST();
  }
});
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}
var init_collectFields = __esm({
  "node_modules/graphql/execution/collectFields.mjs"() {
    init_kinds();
    init_definition();
    init_directives();
    init_typeFromAST();
    init_values();
  }
});
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
var init_SingleFieldSubscriptionsRule = __esm({
  "node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs"() {
    init_GraphQLError();
    init_kinds();
    init_collectFields();
  }
});
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}
var init_groupBy = __esm({
  "node_modules/graphql/jsutils/groupBy.mjs"() {
  }
});
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}
var init_UniqueArgumentDefinitionNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs"() {
    init_groupBy();
    init_GraphQLError();
  }
});
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}
var init_UniqueArgumentNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs"() {
    init_groupBy();
    init_GraphQLError();
  }
});
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}
var init_UniqueDirectiveNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs"() {
    init_GraphQLError();
  }
});
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}
var init_UniqueDirectivesPerLocationRule = __esm({
  "node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs"() {
    init_GraphQLError();
    init_kinds();
    init_predicates();
    init_directives();
  }
});
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}
var init_UniqueEnumValueNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs"() {
    init_GraphQLError();
    init_definition();
  }
});
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
}
var init_UniqueFieldDefinitionNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs"() {
    init_GraphQLError();
    init_definition();
  }
});
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}
var init_UniqueFragmentNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs"() {
    init_GraphQLError();
  }
});
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}
var init_UniqueInputFieldNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs"() {
    init_invariant();
    init_GraphQLError();
  }
});
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}
var init_UniqueOperationNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs"() {
    init_GraphQLError();
  }
});
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}
var init_UniqueOperationTypesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs"() {
    init_GraphQLError();
  }
});
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}
var init_UniqueTypeNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs"() {
    init_GraphQLError();
  }
});
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}
var init_UniqueVariableNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs"() {
    init_groupBy();
    init_GraphQLError();
  }
});
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue(node) {
      const type = getNullableType(context.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type = context.getInputType();
      if (isNonNullType(type)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type)}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type.parseLiteral(
      node,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}; ` + error.message,
          {
            nodes: node,
            originalError: error
          }
        )
      );
    }
  }
}
var init_ValuesOfCorrectTypeRule = __esm({
  "node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs"() {
    init_didYouMean();
    init_inspect();
    init_keyMap();
    init_suggestionList();
    init_GraphQLError();
    init_printer();
    init_definition();
  }
});
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.type);
      if (type !== void 0 && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}
var init_VariablesAreInputTypesRule = __esm({
  "node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs"() {
    init_GraphQLError();
    init_printer();
    init_definition();
    init_typeFromAST();
  }
});
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}
var init_VariablesInAllowedPositionRule = __esm({
  "node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs"() {
    init_inspect();
    init_GraphQLError();
    init_kinds();
    init_definition();
    init_typeComparators();
    init_typeFromAST();
  }
});
var specifiedRules, specifiedSDLRules;
var init_specifiedRules = __esm({
  "node_modules/graphql/validation/specifiedRules.mjs"() {
    init_ExecutableDefinitionsRule();
    init_FieldsOnCorrectTypeRule();
    init_FragmentsOnCompositeTypesRule();
    init_KnownArgumentNamesRule();
    init_KnownDirectivesRule();
    init_KnownFragmentNamesRule();
    init_KnownTypeNamesRule();
    init_LoneAnonymousOperationRule();
    init_LoneSchemaDefinitionRule();
    init_NoFragmentCyclesRule();
    init_NoUndefinedVariablesRule();
    init_NoUnusedFragmentsRule();
    init_NoUnusedVariablesRule();
    init_OverlappingFieldsCanBeMergedRule();
    init_PossibleFragmentSpreadsRule();
    init_PossibleTypeExtensionsRule();
    init_ProvidedRequiredArgumentsRule();
    init_ScalarLeafsRule();
    init_SingleFieldSubscriptionsRule();
    init_UniqueArgumentDefinitionNamesRule();
    init_UniqueArgumentNamesRule();
    init_UniqueDirectiveNamesRule();
    init_UniqueDirectivesPerLocationRule();
    init_UniqueEnumValueNamesRule();
    init_UniqueFieldDefinitionNamesRule();
    init_UniqueFragmentNamesRule();
    init_UniqueInputFieldNamesRule();
    init_UniqueOperationNamesRule();
    init_UniqueOperationTypesRule();
    init_UniqueTypeNamesRule();
    init_UniqueVariableNamesRule();
    init_ValuesOfCorrectTypeRule();
    init_VariablesAreInputTypesRule();
    init_VariablesInAllowedPositionRule();
    specifiedRules = Object.freeze([
      ExecutableDefinitionsRule,
      UniqueOperationNamesRule,
      LoneAnonymousOperationRule,
      SingleFieldSubscriptionsRule,
      KnownTypeNamesRule,
      FragmentsOnCompositeTypesRule,
      VariablesAreInputTypesRule,
      ScalarLeafsRule,
      FieldsOnCorrectTypeRule,
      UniqueFragmentNamesRule,
      KnownFragmentNamesRule,
      NoUnusedFragmentsRule,
      PossibleFragmentSpreadsRule,
      NoFragmentCyclesRule,
      UniqueVariableNamesRule,
      NoUndefinedVariablesRule,
      NoUnusedVariablesRule,
      KnownDirectivesRule,
      UniqueDirectivesPerLocationRule,
      KnownArgumentNamesRule,
      UniqueArgumentNamesRule,
      ValuesOfCorrectTypeRule,
      ProvidedRequiredArgumentsRule,
      VariablesInAllowedPositionRule,
      OverlappingFieldsCanBeMergedRule,
      UniqueInputFieldNamesRule
    ]);
    specifiedSDLRules = Object.freeze([
      LoneSchemaDefinitionRule,
      UniqueOperationTypesRule,
      UniqueTypeNamesRule,
      UniqueEnumValueNamesRule,
      UniqueFieldDefinitionNamesRule,
      UniqueArgumentDefinitionNamesRule,
      UniqueDirectiveNamesRule,
      KnownTypeNamesRule,
      KnownDirectivesRule,
      UniqueDirectivesPerLocationRule,
      PossibleTypeExtensionsRule,
      KnownArgumentNamesOnDirectivesRule,
      UniqueArgumentNamesRule,
      UniqueInputFieldNamesRule,
      ProvidedRequiredArgumentsOnDirectivesRule
    ]);
  }
});
var ASTValidationContext, SDLValidationContext, ValidationContext;
var init_ValidationContext = __esm({
  "node_modules/graphql/validation/ValidationContext.mjs"() {
    init_kinds();
    init_visitor();
    init_TypeInfo();
    ASTValidationContext = class {
      constructor(ast, onError) {
        this._ast = ast;
        this._fragments = void 0;
        this._fragmentSpreads = /* @__PURE__ */ new Map();
        this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
        this._onError = onError;
      }
      get [Symbol.toStringTag]() {
        return "ASTValidationContext";
      }
      reportError(error) {
        this._onError(error);
      }
      getDocument() {
        return this._ast;
      }
      getFragment(name) {
        let fragments;
        if (this._fragments) {
          fragments = this._fragments;
        } else {
          fragments = /* @__PURE__ */ Object.create(null);
          for (const defNode of this.getDocument().definitions) {
            if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[defNode.name.value] = defNode;
            }
          }
          this._fragments = fragments;
        }
        return fragments[name];
      }
      getFragmentSpreads(node) {
        let spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
          spreads = [];
          const setsToVisit = [node];
          let set;
          while (set = setsToVisit.pop()) {
            for (const selection of set.selections) {
              if (selection.kind === Kind.FRAGMENT_SPREAD) {
                spreads.push(selection);
              } else if (selection.selectionSet) {
                setsToVisit.push(selection.selectionSet);
              }
            }
          }
          this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
      }
      getRecursivelyReferencedFragments(operation) {
        let fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
          fragments = [];
          const collectedNames = /* @__PURE__ */ Object.create(null);
          const nodesToVisit = [operation.selectionSet];
          let node;
          while (node = nodesToVisit.pop()) {
            for (const spread of this.getFragmentSpreads(node)) {
              const fragName = spread.name.value;
              if (collectedNames[fragName] !== true) {
                collectedNames[fragName] = true;
                const fragment = this.getFragment(fragName);
                if (fragment) {
                  fragments.push(fragment);
                  nodesToVisit.push(fragment.selectionSet);
                }
              }
            }
          }
          this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
      }
    };
    SDLValidationContext = class extends ASTValidationContext {
      constructor(ast, schema, onError) {
        super(ast, onError);
        this._schema = schema;
      }
      get [Symbol.toStringTag]() {
        return "SDLValidationContext";
      }
      getSchema() {
        return this._schema;
      }
    };
    ValidationContext = class extends ASTValidationContext {
      constructor(schema, ast, typeInfo, onError) {
        super(ast, onError);
        this._schema = schema;
        this._typeInfo = typeInfo;
        this._variableUsages = /* @__PURE__ */ new Map();
        this._recursiveVariableUsages = /* @__PURE__ */ new Map();
      }
      get [Symbol.toStringTag]() {
        return "ValidationContext";
      }
      getSchema() {
        return this._schema;
      }
      getVariableUsages(node) {
        let usages = this._variableUsages.get(node);
        if (!usages) {
          const newUsages = [];
          const typeInfo = new TypeInfo(this._schema);
          visit(
            node,
            visitWithTypeInfo(typeInfo, {
              VariableDefinition: () => false,
              Variable(variable) {
                newUsages.push({
                  node: variable,
                  type: typeInfo.getInputType(),
                  defaultValue: typeInfo.getDefaultValue()
                });
              }
            })
          );
          usages = newUsages;
          this._variableUsages.set(node, usages);
        }
        return usages;
      }
      getRecursiveVariableUsages(operation) {
        let usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
          usages = this.getVariableUsages(operation);
          for (const frag of this.getRecursivelyReferencedFragments(operation)) {
            usages = usages.concat(this.getVariableUsages(frag));
          }
          this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
      }
      getType() {
        return this._typeInfo.getType();
      }
      getParentType() {
        return this._typeInfo.getParentType();
      }
      getInputType() {
        return this._typeInfo.getInputType();
      }
      getParentInputType() {
        return this._typeInfo.getParentInputType();
      }
      getFieldDef() {
        return this._typeInfo.getFieldDef();
      }
      getDirective() {
        return this._typeInfo.getDirective();
      }
      getArgument() {
        return this._typeInfo.getArgument();
      }
      getEnumValue() {
        return this._typeInfo.getEnumValue();
      }
    };
  }
});
function validate(schema, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema)) {
  var _options$maxErrors;
  const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
  documentAST || devAssert(false, "Must provide document.");
  assertValidSchema(schema);
  const abortObj = Object.freeze({});
  const errors = [];
  const context = new ValidationContext(
    schema,
    documentAST,
    typeInfo,
    (error) => {
      if (errors.length >= maxErrors) {
        errors.push(
          new GraphQLError(
            "Too many validation errors, error limit reached. Validation aborted."
          )
        );
        throw abortObj;
      }
      errors.push(error);
    }
  );
  const visitor = visitInParallel(rules.map((rule) => rule(context)));
  try {
    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));
  } catch (e) {
    if (e !== abortObj) {
      throw e;
    }
  }
  return errors;
}
function validateSDL(documentAST, schemaToExtend, rules = specifiedSDLRules) {
  const errors = [];
  const context = new SDLValidationContext(
    documentAST,
    schemaToExtend,
    (error) => {
      errors.push(error);
    }
  );
  const visitors = rules.map((rule) => rule(context));
  visit(documentAST, visitInParallel(visitors));
  return errors;
}
function assertValidSDL(documentAST) {
  const errors = validateSDL(documentAST);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
function assertValidSDLExtension(documentAST, schema) {
  const errors = validateSDL(documentAST, schema);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
var init_validate2 = __esm({
  "node_modules/graphql/validation/validate.mjs"() {
    init_devAssert();
    init_GraphQLError();
    init_visitor();
    init_validate();
    init_TypeInfo();
    init_specifiedRules();
    init_ValidationContext();
  }
});
function memoize3(fn) {
  let cache0;
  return function memoized(a1, a2, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a2);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a2, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === void 0) {
      fnResult = fn(a1, a2, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}
var init_memoize3 = __esm({
  "node_modules/graphql/jsutils/memoize3.mjs"() {
  }
});
function promiseForObject(object) {
  return Promise.all(Object.values(object)).then((resolvedValues) => {
    const resolvedObject = /* @__PURE__ */ Object.create(null);
    for (const [i, key] of Object.keys(object).entries()) {
      resolvedObject[key] = resolvedValues[i];
    }
    return resolvedObject;
  });
}
var init_promiseForObject = __esm({
  "node_modules/graphql/jsutils/promiseForObject.mjs"() {
  }
});
function promiseReduce(values, callbackFn, initialValue) {
  let accumulator = initialValue;
  for (const value of values) {
    accumulator = isPromise(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
  }
  return accumulator;
}
var init_promiseReduce = __esm({
  "node_modules/graphql/jsutils/promiseReduce.mjs"() {
    init_isPromise();
  }
});
function toError(thrownValue) {
  return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
}
var NonErrorThrown;
var init_toError = __esm({
  "node_modules/graphql/jsutils/toError.mjs"() {
    init_inspect();
    NonErrorThrown = class extends Error {
      constructor(thrownValue) {
        super("Unexpected error value: " + inspect(thrownValue));
        this.name = "NonErrorThrown";
        this.thrownValue = thrownValue;
      }
    };
  }
});
function locatedError(rawOriginalError, nodes, path) {
  var _nodes;
  const originalError = toError(rawOriginalError);
  if (isLocatedGraphQLError(originalError)) {
    return originalError;
  }
  return new GraphQLError(originalError.message, {
    nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
    source: originalError.source,
    positions: originalError.positions,
    path,
    originalError
  });
}
function isLocatedGraphQLError(error) {
  return Array.isArray(error.path);
}
var init_locatedError = __esm({
  "node_modules/graphql/error/locatedError.mjs"() {
    init_toError();
    init_GraphQLError();
  }
});
function execute(args) {
  arguments.length < 2 || devAssert(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const { schema, document, variableValues, rootValue } = args;
  assertValidExecutionArguments(schema, document, variableValues);
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext
    };
  }
  try {
    const { operation } = exeContext;
    const result = executeOperation(exeContext, operation, rootValue);
    if (isPromise(result)) {
      return result.then(
        (data) => buildResponse(data, exeContext.errors),
        (error) => {
          exeContext.errors.push(error);
          return buildResponse(null, exeContext.errors);
        }
      );
    }
    return buildResponse(result, exeContext.errors);
  } catch (error) {
    exeContext.errors.push(error);
    return buildResponse(null, exeContext.errors);
  }
}
function executeSync(args) {
  const result = execute(args);
  if (isPromise(result)) {
    throw new Error("GraphQL execution failed to complete synchronously.");
  }
  return result;
}
function buildResponse(data, errors) {
  return errors.length === 0 ? {
    data
  } : {
    errors,
    data
  };
}
function assertValidExecutionArguments(schema, document, rawVariableValues) {
  document || devAssert(false, "Must provide document.");
  assertValidSchema(schema);
  rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert(
    false,
    "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
  );
}
function buildExecutionContext(args) {
  var _definition$name, _operation$variableDe;
  const {
    schema,
    document,
    rootValue,
    contextValue,
    variableValues: rawVariableValues,
    operationName,
    fieldResolver,
    typeResolver,
    subscribeFieldResolver
  } = args;
  let operation;
  const fragments = /* @__PURE__ */ Object.create(null);
  for (const definition of document.definitions) {
    switch (definition.kind) {
      case Kind.OPERATION_DEFINITION:
        if (operationName == null) {
          if (operation !== void 0) {
            return [
              new GraphQLError(
                "Must provide operation name if query contains multiple operations."
              )
            ];
          }
          operation = definition;
        } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
          operation = definition;
        }
        break;
      case Kind.FRAGMENT_DEFINITION:
        fragments[definition.name.value] = definition;
        break;
      default:
    }
  }
  if (!operation) {
    if (operationName != null) {
      return [new GraphQLError(`Unknown operation named "${operationName}".`)];
    }
    return [new GraphQLError("Must provide an operation.")];
  }
  const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
  const coercedVariableValues = getVariableValues(
    schema,
    variableDefinitions,
    rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {},
    {
      maxErrors: 50
    }
  );
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
    typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
    subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
    errors: []
  };
}
function executeOperation(exeContext, operation, rootValue) {
  const rootType = exeContext.schema.getRootType(operation.operation);
  if (rootType == null) {
    throw new GraphQLError(
      `Schema is not configured to execute ${operation.operation} operation.`,
      {
        nodes: operation
      }
    );
  }
  const rootFields = collectFields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    rootType,
    operation.selectionSet
  );
  const path = void 0;
  switch (operation.operation) {
    case OperationTypeNode.QUERY:
      return executeFields(exeContext, rootType, rootValue, path, rootFields);
    case OperationTypeNode.MUTATION:
      return executeFieldsSerially(
        exeContext,
        rootType,
        rootValue,
        path,
        rootFields
      );
    case OperationTypeNode.SUBSCRIPTION:
      return executeFields(exeContext, rootType, rootValue, path, rootFields);
  }
}
function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
  return promiseReduce(
    fields.entries(),
    (results, [responseName, fieldNodes]) => {
      const fieldPath = addPath(path, responseName, parentType.name);
      const result = executeField(
        exeContext,
        parentType,
        sourceValue,
        fieldNodes,
        fieldPath
      );
      if (result === void 0) {
        return results;
      }
      if (isPromise(result)) {
        return result.then((resolvedResult) => {
          results[responseName] = resolvedResult;
          return results;
        });
      }
      results[responseName] = result;
      return results;
    },
    /* @__PURE__ */ Object.create(null)
  );
}
function executeFields(exeContext, parentType, sourceValue, path, fields) {
  const results = /* @__PURE__ */ Object.create(null);
  let containsPromise = false;
  try {
    for (const [responseName, fieldNodes] of fields.entries()) {
      const fieldPath = addPath(path, responseName, parentType.name);
      const result = executeField(
        exeContext,
        parentType,
        sourceValue,
        fieldNodes,
        fieldPath
      );
      if (result !== void 0) {
        results[responseName] = result;
        if (isPromise(result)) {
          containsPromise = true;
        }
      }
    }
  } catch (error) {
    if (containsPromise) {
      return promiseForObject(results).finally(() => {
        throw error;
      });
    }
    throw error;
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results);
}
function executeField(exeContext, parentType, source, fieldNodes, path) {
  var _fieldDef$resolve;
  const fieldDef = getFieldDef2(exeContext.schema, parentType, fieldNodes[0]);
  if (!fieldDef) {
    return;
  }
  const returnType = fieldDef.type;
  const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
  const info = buildResolveInfo(
    exeContext,
    fieldDef,
    fieldNodes,
    parentType,
    path
  );
  try {
    const args = getArgumentValues(
      fieldDef,
      fieldNodes[0],
      exeContext.variableValues
    );
    const contextValue = exeContext.contextValue;
    const result = resolveFn(source, args, contextValue, info);
    let completed;
    if (isPromise(result)) {
      completed = result.then(
        (resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved)
      );
    } else {
      completed = completeValue(
        exeContext,
        returnType,
        fieldNodes,
        info,
        path,
        result
      );
    }
    if (isPromise(completed)) {
      return completed.then(void 0, (rawError) => {
        const error = locatedError(rawError, fieldNodes, pathToArray(path));
        return handleFieldError(error, returnType, exeContext);
      });
    }
    return completed;
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray(path));
    return handleFieldError(error, returnType, exeContext);
  }
}
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
function handleFieldError(error, returnType, exeContext) {
  if (isNonNullType(returnType)) {
    throw error;
  }
  exeContext.errors.push(error);
  return null;
}
function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
  if (result instanceof Error) {
    throw result;
  }
  if (isNonNullType(returnType)) {
    const completed = completeValue(
      exeContext,
      returnType.ofType,
      fieldNodes,
      info,
      path,
      result
    );
    if (completed === null) {
      throw new Error(
        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`
      );
    }
    return completed;
  }
  if (result == null) {
    return null;
  }
  if (isListType(returnType)) {
    return completeListValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result
    );
  }
  if (isLeafType(returnType)) {
    return completeLeafValue(returnType, result);
  }
  if (isAbstractType(returnType)) {
    return completeAbstractValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result
    );
  }
  if (isObjectType(returnType)) {
    return completeObjectValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result
    );
  }
  invariant(
    false,
    "Cannot complete value of unexpected output type: " + inspect(returnType)
  );
}
function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
  if (!isIterableObject(result)) {
    throw new GraphQLError(
      `Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`
    );
  }
  const itemType = returnType.ofType;
  let containsPromise = false;
  const completedResults = Array.from(result, (item, index) => {
    const itemPath = addPath(path, index, void 0);
    try {
      let completedItem;
      if (isPromise(item)) {
        completedItem = item.then(
          (resolved) => completeValue(
            exeContext,
            itemType,
            fieldNodes,
            info,
            itemPath,
            resolved
          )
        );
      } else {
        completedItem = completeValue(
          exeContext,
          itemType,
          fieldNodes,
          info,
          itemPath,
          item
        );
      }
      if (isPromise(completedItem)) {
        containsPromise = true;
        return completedItem.then(void 0, (rawError) => {
          const error = locatedError(
            rawError,
            fieldNodes,
            pathToArray(itemPath)
          );
          return handleFieldError(error, itemType, exeContext);
        });
      }
      return completedItem;
    } catch (rawError) {
      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));
      return handleFieldError(error, itemType, exeContext);
    }
  });
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
function completeLeafValue(returnType, result) {
  const serializedResult = returnType.serialize(result);
  if (serializedResult == null) {
    throw new Error(
      `Expected \`${inspect(returnType)}.serialize(${inspect(result)})\` to return non-nullable value, returned: ${inspect(serializedResult)}`
    );
  }
  return serializedResult;
}
function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
  var _returnType$resolveTy;
  const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
  const contextValue = exeContext.contextValue;
  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
  if (isPromise(runtimeType)) {
    return runtimeType.then(
      (resolvedRuntimeType) => completeObjectValue(
        exeContext,
        ensureValidRuntimeType(
          resolvedRuntimeType,
          exeContext,
          returnType,
          fieldNodes,
          info,
          result
        ),
        fieldNodes,
        info,
        path,
        result
      )
    );
  }
  return completeObjectValue(
    exeContext,
    ensureValidRuntimeType(
      runtimeType,
      exeContext,
      returnType,
      fieldNodes,
      info,
      result
    ),
    fieldNodes,
    info,
    path,
    result
  );
}
function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
  if (runtimeTypeName == null) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
      fieldNodes
    );
  }
  if (isObjectType(runtimeTypeName)) {
    throw new GraphQLError(
      "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
    );
  }
  if (typeof runtimeTypeName !== "string") {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${inspect(result)}, received "${inspect(runtimeTypeName)}".`
    );
  }
  const runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`,
      {
        nodes: fieldNodes
      }
    );
  }
  if (!isObjectType(runtimeType)) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`,
      {
        nodes: fieldNodes
      }
    );
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw new GraphQLError(
      `Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`,
      {
        nodes: fieldNodes
      }
    );
  }
  return runtimeType;
}
function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
  const subFieldNodes = collectSubfields2(exeContext, returnType, fieldNodes);
  if (returnType.isTypeOf) {
    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
    if (isPromise(isTypeOf)) {
      return isTypeOf.then((resolvedIsTypeOf) => {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
        return executeFields(
          exeContext,
          returnType,
          result,
          path,
          subFieldNodes
        );
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result, fieldNodes);
    }
  }
  return executeFields(exeContext, returnType, result, path, subFieldNodes);
}
function invalidReturnTypeError(returnType, result, fieldNodes) {
  return new GraphQLError(
    `Expected value of type "${returnType.name}" but got: ${inspect(result)}.`,
    {
      nodes: fieldNodes
    }
  );
}
function getFieldDef2(schema, parentType, fieldNode) {
  const fieldName = fieldNode.name.value;
  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  } else if (fieldName === TypeNameMetaFieldDef.name) {
    return TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}
var collectSubfields2, defaultTypeResolver, defaultFieldResolver;
var init_execute = __esm({
  "node_modules/graphql/execution/execute.mjs"() {
    init_devAssert();
    init_inspect();
    init_invariant();
    init_isIterableObject();
    init_isObjectLike();
    init_isPromise();
    init_memoize3();
    init_Path();
    init_promiseForObject();
    init_promiseReduce();
    init_GraphQLError();
    init_locatedError();
    init_ast();
    init_kinds();
    init_definition();
    init_introspection();
    init_validate();
    init_collectFields();
    init_values();
    collectSubfields2 = memoize3(
      (exeContext, returnType, fieldNodes) => collectSubfields(
        exeContext.schema,
        exeContext.fragments,
        exeContext.variableValues,
        returnType,
        fieldNodes
      )
    );
    defaultTypeResolver = function(value, contextValue, info, abstractType) {
      if (isObjectLike(value) && typeof value.__typename === "string") {
        return value.__typename;
      }
      const possibleTypes = info.schema.getPossibleTypes(abstractType);
      const promisedIsTypeOfResults = [];
      for (let i = 0; i < possibleTypes.length; i++) {
        const type = possibleTypes[i];
        if (type.isTypeOf) {
          const isTypeOfResult = type.isTypeOf(value, contextValue, info);
          if (isPromise(isTypeOfResult)) {
            promisedIsTypeOfResults[i] = isTypeOfResult;
          } else if (isTypeOfResult) {
            return type.name;
          }
        }
      }
      if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
          for (let i = 0; i < isTypeOfResults.length; i++) {
            if (isTypeOfResults[i]) {
              return possibleTypes[i].name;
            }
          }
        });
      }
    };
    defaultFieldResolver = function(source, args, contextValue, info) {
      if (isObjectLike(source) || typeof source === "function") {
        const property = source[info.fieldName];
        if (typeof property === "function") {
          return source[info.fieldName](args, contextValue, info);
        }
        return property;
      }
    };
  }
});
function graphql(args) {
  return new Promise((resolve) => resolve(graphqlImpl(args)));
}
function graphqlSync(args) {
  const result = graphqlImpl(args);
  if (isPromise(result)) {
    throw new Error("GraphQL execution failed to complete synchronously.");
  }
  return result;
}
function graphqlImpl(args) {
  arguments.length < 2 || devAssert(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const {
    schema,
    source,
    rootValue,
    contextValue,
    variableValues,
    operationName,
    fieldResolver,
    typeResolver
  } = args;
  const schemaValidationErrors = validateSchema(schema);
  if (schemaValidationErrors.length > 0) {
    return {
      errors: schemaValidationErrors
    };
  }
  let document;
  try {
    document = parse(source);
  } catch (syntaxError2) {
    return {
      errors: [syntaxError2]
    };
  }
  const validationErrors = validate(schema, document);
  if (validationErrors.length > 0) {
    return {
      errors: validationErrors
    };
  }
  return execute({
    schema,
    document,
    rootValue,
    contextValue,
    variableValues,
    operationName,
    fieldResolver,
    typeResolver
  });
}
var init_graphql = __esm({
  "node_modules/graphql/graphql.mjs"() {
    init_devAssert();
    init_isPromise();
    init_parser();
    init_validate();
    init_validate2();
    init_execute();
  }
});
function isAsyncIterable(maybeAsyncIterable) {
  return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
}
var init_isAsyncIterable = __esm({
  "node_modules/graphql/jsutils/isAsyncIterable.mjs"() {
  }
});
function mapAsyncIterator(iterable, callback) {
  const iterator = iterable[Symbol.asyncIterator]();
  async function mapResult(result) {
    if (result.done) {
      return result;
    }
    try {
      return {
        value: await callback(result.value),
        done: false
      };
    } catch (error) {
      if (typeof iterator.return === "function") {
        try {
          await iterator.return();
        } catch (_e) {
        }
      }
      throw error;
    }
  }
  return {
    async next() {
      return mapResult(await iterator.next());
    },
    async return() {
      return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
        value: void 0,
        done: true
      };
    },
    async throw(error) {
      if (typeof iterator.throw === "function") {
        return mapResult(await iterator.throw(error));
      }
      throw error;
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
var init_mapAsyncIterator = __esm({
  "node_modules/graphql/execution/mapAsyncIterator.mjs"() {
  }
});
async function subscribe(args) {
  arguments.length < 2 || devAssert(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const resultOrStream = await createSourceEventStream(args);
  if (!isAsyncIterable(resultOrStream)) {
    return resultOrStream;
  }
  const mapSourceToResponse = (payload) => execute({ ...args, rootValue: payload });
  return mapAsyncIterator(resultOrStream, mapSourceToResponse);
}
function toNormalizedArgs(args) {
  const firstArg = args[0];
  if (firstArg && "document" in firstArg) {
    return firstArg;
  }
  return {
    schema: firstArg,
    // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    subscribeFieldResolver: args[6]
  };
}
async function createSourceEventStream(...rawArgs) {
  const args = toNormalizedArgs(rawArgs);
  const { schema, document, variableValues } = args;
  assertValidExecutionArguments(schema, document, variableValues);
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext
    };
  }
  try {
    const eventStream = await executeSubscription(exeContext);
    if (!isAsyncIterable(eventStream)) {
      throw new Error(
        `Subscription field must return Async Iterable. Received: ${inspect(eventStream)}.`
      );
    }
    return eventStream;
  } catch (error) {
    if (error instanceof GraphQLError) {
      return {
        errors: [error]
      };
    }
    throw error;
  }
}
async function executeSubscription(exeContext) {
  const { schema, fragments, operation, variableValues, rootValue } = exeContext;
  const rootType = schema.getSubscriptionType();
  if (rootType == null) {
    throw new GraphQLError(
      "Schema is not configured to execute subscription operation.",
      {
        nodes: operation
      }
    );
  }
  const rootFields = collectFields(
    schema,
    fragments,
    variableValues,
    rootType,
    operation.selectionSet
  );
  const [responseName, fieldNodes] = [...rootFields.entries()][0];
  const fieldDef = getFieldDef2(schema, rootType, fieldNodes[0]);
  if (!fieldDef) {
    const fieldName = fieldNodes[0].name.value;
    throw new GraphQLError(
      `The subscription field "${fieldName}" is not defined.`,
      {
        nodes: fieldNodes
      }
    );
  }
  const path = addPath(void 0, responseName, rootType.name);
  const info = buildResolveInfo(
    exeContext,
    fieldDef,
    fieldNodes,
    rootType,
    path
  );
  try {
    var _fieldDef$subscribe;
    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues);
    const contextValue = exeContext.contextValue;
    const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
    const eventStream = await resolveFn(rootValue, args, contextValue, info);
    if (eventStream instanceof Error) {
      throw eventStream;
    }
    return eventStream;
  } catch (error) {
    throw locatedError(error, fieldNodes, pathToArray(path));
  }
}
var init_subscribe = __esm({
  "node_modules/graphql/execution/subscribe.mjs"() {
    init_devAssert();
    init_inspect();
    init_isAsyncIterable();
    init_Path();
    init_GraphQLError();
    init_locatedError();
    init_collectFields();
    init_execute();
    init_mapAsyncIterator();
    init_values();
  }
});
var init_execution = __esm({
  "node_modules/graphql/execution/index.mjs"() {
    init_Path();
    init_execute();
    init_subscribe();
    init_values();
  }
});
function NoDeprecatedCustomRule(context) {
  return {
    Field(node) {
      const fieldDef = context.getFieldDef();
      const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
      if (fieldDef && deprecationReason != null) {
        const parentType = context.getParentType();
        parentType != null || invariant(false);
        context.reportError(
          new GraphQLError(
            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,
            {
              nodes: node
            }
          )
        );
      }
    },
    Argument(node) {
      const argDef = context.getArgument();
      const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
      if (argDef && deprecationReason != null) {
        const directiveDef = context.getDirective();
        if (directiveDef != null) {
          context.reportError(
            new GraphQLError(
              `Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        } else {
          const parentType = context.getParentType();
          const fieldDef = context.getFieldDef();
          parentType != null && fieldDef != null || invariant(false);
          context.reportError(
            new GraphQLError(
              `Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    ObjectField(node) {
      const inputObjectDef = getNamedType(context.getParentInputType());
      if (isInputObjectType(inputObjectDef)) {
        const inputFieldDef = inputObjectDef.getFields()[node.name.value];
        const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
        if (deprecationReason != null) {
          context.reportError(
            new GraphQLError(
              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    EnumValue(node) {
      const enumValueDef = context.getEnumValue();
      const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
      if (enumValueDef && deprecationReason != null) {
        const enumTypeDef = getNamedType(context.getInputType());
        enumTypeDef != null || invariant(false);
        context.reportError(
          new GraphQLError(
            `The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var init_NoDeprecatedCustomRule = __esm({
  "node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs"() {
    init_invariant();
    init_GraphQLError();
    init_definition();
  }
});
function NoSchemaIntrospectionCustomRule(context) {
  return {
    Field(node) {
      const type = getNamedType(context.getType());
      if (type && isIntrospectionType(type)) {
        context.reportError(
          new GraphQLError(
            `GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var init_NoSchemaIntrospectionCustomRule = __esm({
  "node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs"() {
    init_GraphQLError();
    init_definition();
    init_introspection();
  }
});
var init_validation = __esm({
  "node_modules/graphql/validation/index.mjs"() {
    init_validate2();
    init_ValidationContext();
    init_specifiedRules();
    init_ExecutableDefinitionsRule();
    init_FieldsOnCorrectTypeRule();
    init_FragmentsOnCompositeTypesRule();
    init_KnownArgumentNamesRule();
    init_KnownDirectivesRule();
    init_KnownFragmentNamesRule();
    init_KnownTypeNamesRule();
    init_LoneAnonymousOperationRule();
    init_NoFragmentCyclesRule();
    init_NoUndefinedVariablesRule();
    init_NoUnusedFragmentsRule();
    init_NoUnusedVariablesRule();
    init_OverlappingFieldsCanBeMergedRule();
    init_PossibleFragmentSpreadsRule();
    init_ProvidedRequiredArgumentsRule();
    init_ScalarLeafsRule();
    init_SingleFieldSubscriptionsRule();
    init_UniqueArgumentNamesRule();
    init_UniqueDirectivesPerLocationRule();
    init_UniqueFragmentNamesRule();
    init_UniqueInputFieldNamesRule();
    init_UniqueOperationNamesRule();
    init_UniqueVariableNamesRule();
    init_ValuesOfCorrectTypeRule();
    init_VariablesAreInputTypesRule();
    init_VariablesInAllowedPositionRule();
    init_LoneSchemaDefinitionRule();
    init_UniqueOperationTypesRule();
    init_UniqueTypeNamesRule();
    init_UniqueEnumValueNamesRule();
    init_UniqueFieldDefinitionNamesRule();
    init_UniqueArgumentDefinitionNamesRule();
    init_UniqueDirectiveNamesRule();
    init_PossibleTypeExtensionsRule();
    init_NoDeprecatedCustomRule();
    init_NoSchemaIntrospectionCustomRule();
  }
});
var init_error = __esm({
  "node_modules/graphql/error/index.mjs"() {
    init_GraphQLError();
    init_syntaxError();
    init_locatedError();
  }
});
function getIntrospectionQuery(options) {
  const optionsWithDefault = {
    descriptions: true,
    specifiedByUrl: false,
    directiveIsRepeatable: false,
    schemaDescription: false,
    inputValueDeprecation: false,
    ...options
  };
  const descriptions = optionsWithDefault.descriptions ? "description" : "";
  const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
  const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
  const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
  function inputDeprecation(str) {
    return optionsWithDefault.inputValueDeprecation ? str : "";
  }
  return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
}
var init_getIntrospectionQuery = __esm({
  "node_modules/graphql/utilities/getIntrospectionQuery.mjs"() {
  }
});
function getOperationAST(documentAST, operationName) {
  let operation = null;
  for (const definition of documentAST.definitions) {
    if (definition.kind === Kind.OPERATION_DEFINITION) {
      var _definition$name;
      if (operationName == null) {
        if (operation) {
          return null;
        }
        operation = definition;
      } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
        return definition;
      }
    }
  }
  return operation;
}
var init_getOperationAST = __esm({
  "node_modules/graphql/utilities/getOperationAST.mjs"() {
    init_kinds();
  }
});
function getOperationRootType(schema, operation) {
  if (operation.operation === "query") {
    const queryType = schema.getQueryType();
    if (!queryType) {
      throw new GraphQLError(
        "Schema does not define the required query root type.",
        {
          nodes: operation
        }
      );
    }
    return queryType;
  }
  if (operation.operation === "mutation") {
    const mutationType = schema.getMutationType();
    if (!mutationType) {
      throw new GraphQLError("Schema is not configured for mutations.", {
        nodes: operation
      });
    }
    return mutationType;
  }
  if (operation.operation === "subscription") {
    const subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
      throw new GraphQLError("Schema is not configured for subscriptions.", {
        nodes: operation
      });
    }
    return subscriptionType;
  }
  throw new GraphQLError(
    "Can only have query, mutation and subscription operations.",
    {
      nodes: operation
    }
  );
}
var init_getOperationRootType = __esm({
  "node_modules/graphql/utilities/getOperationRootType.mjs"() {
    init_GraphQLError();
  }
});
function introspectionFromSchema(schema, options) {
  const optionsWithDefaults = {
    specifiedByUrl: true,
    directiveIsRepeatable: true,
    schemaDescription: true,
    inputValueDeprecation: true,
    ...options
  };
  const document = parse(getIntrospectionQuery(optionsWithDefaults));
  const result = executeSync({
    schema,
    document
  });
  !result.errors && result.data || invariant(false);
  return result.data;
}
var init_introspectionFromSchema = __esm({
  "node_modules/graphql/utilities/introspectionFromSchema.mjs"() {
    init_invariant();
    init_parser();
    init_execute();
    init_getIntrospectionQuery();
  }
});
function buildClientSchema(introspection, options) {
  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(
    false,
    `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${inspect(
      introspection
    )}.`
  );
  const schemaIntrospection = introspection.__schema;
  const typeMap = keyValMap(
    schemaIntrospection.types,
    (typeIntrospection) => typeIntrospection.name,
    (typeIntrospection) => buildType(typeIntrospection)
  );
  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {
    if (typeMap[stdType.name]) {
      typeMap[stdType.name] = stdType;
    }
  }
  const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
  const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
  const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
  const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
  return new GraphQLSchema({
    description: schemaIntrospection.description,
    query: queryType,
    mutation: mutationType,
    subscription: subscriptionType,
    types: Object.values(typeMap),
    directives,
    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
  });
  function getType(typeRef) {
    if (typeRef.kind === TypeKind.LIST) {
      const itemRef = typeRef.ofType;
      if (!itemRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      return new GraphQLList(getType(itemRef));
    }
    if (typeRef.kind === TypeKind.NON_NULL) {
      const nullableRef = typeRef.ofType;
      if (!nullableRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      const nullableType = getType(nullableRef);
      return new GraphQLNonNull(assertNullableType(nullableType));
    }
    return getNamedType2(typeRef);
  }
  function getNamedType2(typeRef) {
    const typeName = typeRef.name;
    if (!typeName) {
      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);
    }
    const type = typeMap[typeName];
    if (!type) {
      throw new Error(
        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`
      );
    }
    return type;
  }
  function getObjectType(typeRef) {
    return assertObjectType(getNamedType2(typeRef));
  }
  function getInterfaceType(typeRef) {
    return assertInterfaceType(getNamedType2(typeRef));
  }
  function buildType(type) {
    if (type != null && type.name != null && type.kind != null) {
      switch (type.kind) {
        case TypeKind.SCALAR:
          return buildScalarDef(type);
        case TypeKind.OBJECT:
          return buildObjectDef(type);
        case TypeKind.INTERFACE:
          return buildInterfaceDef(type);
        case TypeKind.UNION:
          return buildUnionDef(type);
        case TypeKind.ENUM:
          return buildEnumDef(type);
        case TypeKind.INPUT_OBJECT:
          return buildInputObjectDef(type);
      }
    }
    const typeStr = inspect(type);
    throw new Error(
      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`
    );
  }
  function buildScalarDef(scalarIntrospection) {
    return new GraphQLScalarType({
      name: scalarIntrospection.name,
      description: scalarIntrospection.description,
      specifiedByURL: scalarIntrospection.specifiedByURL
    });
  }
  function buildImplementationsList(implementingIntrospection) {
    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {
      return [];
    }
    if (!implementingIntrospection.interfaces) {
      const implementingIntrospectionStr = inspect(implementingIntrospection);
      throw new Error(
        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`
      );
    }
    return implementingIntrospection.interfaces.map(getInterfaceType);
  }
  function buildObjectDef(objectIntrospection) {
    return new GraphQLObjectType({
      name: objectIntrospection.name,
      description: objectIntrospection.description,
      interfaces: () => buildImplementationsList(objectIntrospection),
      fields: () => buildFieldDefMap(objectIntrospection)
    });
  }
  function buildInterfaceDef(interfaceIntrospection) {
    return new GraphQLInterfaceType({
      name: interfaceIntrospection.name,
      description: interfaceIntrospection.description,
      interfaces: () => buildImplementationsList(interfaceIntrospection),
      fields: () => buildFieldDefMap(interfaceIntrospection)
    });
  }
  function buildUnionDef(unionIntrospection) {
    if (!unionIntrospection.possibleTypes) {
      const unionIntrospectionStr = inspect(unionIntrospection);
      throw new Error(
        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`
      );
    }
    return new GraphQLUnionType({
      name: unionIntrospection.name,
      description: unionIntrospection.description,
      types: () => unionIntrospection.possibleTypes.map(getObjectType)
    });
  }
  function buildEnumDef(enumIntrospection) {
    if (!enumIntrospection.enumValues) {
      const enumIntrospectionStr = inspect(enumIntrospection);
      throw new Error(
        `Introspection result missing enumValues: ${enumIntrospectionStr}.`
      );
    }
    return new GraphQLEnumType({
      name: enumIntrospection.name,
      description: enumIntrospection.description,
      values: keyValMap(
        enumIntrospection.enumValues,
        (valueIntrospection) => valueIntrospection.name,
        (valueIntrospection) => ({
          description: valueIntrospection.description,
          deprecationReason: valueIntrospection.deprecationReason
        })
      )
    });
  }
  function buildInputObjectDef(inputObjectIntrospection) {
    if (!inputObjectIntrospection.inputFields) {
      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);
      throw new Error(
        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`
      );
    }
    return new GraphQLInputObjectType({
      name: inputObjectIntrospection.name,
      description: inputObjectIntrospection.description,
      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)
    });
  }
  function buildFieldDefMap(typeIntrospection) {
    if (!typeIntrospection.fields) {
      throw new Error(
        `Introspection result missing fields: ${inspect(typeIntrospection)}.`
      );
    }
    return keyValMap(
      typeIntrospection.fields,
      (fieldIntrospection) => fieldIntrospection.name,
      buildField
    );
  }
  function buildField(fieldIntrospection) {
    const type = getType(fieldIntrospection.type);
    if (!isOutputType(type)) {
      const typeStr = inspect(type);
      throw new Error(
        `Introspection must provide output type for fields, but received: ${typeStr}.`
      );
    }
    if (!fieldIntrospection.args) {
      const fieldIntrospectionStr = inspect(fieldIntrospection);
      throw new Error(
        `Introspection result missing field args: ${fieldIntrospectionStr}.`
      );
    }
    return {
      description: fieldIntrospection.description,
      deprecationReason: fieldIntrospection.deprecationReason,
      type,
      args: buildInputValueDefMap(fieldIntrospection.args)
    };
  }
  function buildInputValueDefMap(inputValueIntrospections) {
    return keyValMap(
      inputValueIntrospections,
      (inputValue) => inputValue.name,
      buildInputValue
    );
  }
  function buildInputValue(inputValueIntrospection) {
    const type = getType(inputValueIntrospection.type);
    if (!isInputType(type)) {
      const typeStr = inspect(type);
      throw new Error(
        `Introspection must provide input type for arguments, but received: ${typeStr}.`
      );
    }
    const defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : void 0;
    return {
      description: inputValueIntrospection.description,
      type,
      defaultValue,
      deprecationReason: inputValueIntrospection.deprecationReason
    };
  }
  function buildDirective(directiveIntrospection) {
    if (!directiveIntrospection.args) {
      const directiveIntrospectionStr = inspect(directiveIntrospection);
      throw new Error(
        `Introspection result missing directive args: ${directiveIntrospectionStr}.`
      );
    }
    if (!directiveIntrospection.locations) {
      const directiveIntrospectionStr = inspect(directiveIntrospection);
      throw new Error(
        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`
      );
    }
    return new GraphQLDirective({
      name: directiveIntrospection.name,
      description: directiveIntrospection.description,
      isRepeatable: directiveIntrospection.isRepeatable,
      locations: directiveIntrospection.locations.slice(),
      args: buildInputValueDefMap(directiveIntrospection.args)
    });
  }
}
var init_buildClientSchema = __esm({
  "node_modules/graphql/utilities/buildClientSchema.mjs"() {
    init_devAssert();
    init_inspect();
    init_isObjectLike();
    init_keyValMap();
    init_parser();
    init_definition();
    init_directives();
    init_introspection();
    init_scalars();
    init_schema();
    init_valueFromAST();
  }
});
function extendSchema(schema, documentAST, options) {
  assertSchema(schema);
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
    assertValidSDLExtension(documentAST, schema);
  }
  const schemaConfig = schema.toConfig();
  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);
}
function extendSchemaImpl(schemaConfig, documentAST, options) {
  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
  const typeDefs = [];
  const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
  const directiveDefs = [];
  let schemaDef;
  const schemaExtensions = [];
  for (const def of documentAST.definitions) {
    if (def.kind === Kind.SCHEMA_DEFINITION) {
      schemaDef = def;
    } else if (def.kind === Kind.SCHEMA_EXTENSION) {
      schemaExtensions.push(def);
    } else if (isTypeDefinitionNode(def)) {
      typeDefs.push(def);
    } else if (isTypeExtensionNode(def)) {
      const extendedTypeName = def.name.value;
      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      directiveDefs.push(def);
    }
  }
  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
    return schemaConfig;
  }
  const typeMap = /* @__PURE__ */ Object.create(null);
  for (const existingType of schemaConfig.types) {
    typeMap[existingType.name] = extendNamedType(existingType);
  }
  for (const typeNode of typeDefs) {
    var _stdTypeMap$name;
    const name = typeNode.name.value;
    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
  }
  const operationTypes = {
    // Get the extended root operation types.
    query: schemaConfig.query && replaceNamedType(schemaConfig.query),
    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
    // Then, incorporate schema definition and all schema extensions.
    ...schemaDef && getOperationTypes([schemaDef]),
    ...getOperationTypes(schemaExtensions)
  };
  return {
    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
    ...operationTypes,
    types: Object.values(typeMap),
    directives: [
      ...schemaConfig.directives.map(replaceDirective),
      ...directiveDefs.map(buildDirective)
    ],
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
  };
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    }
    if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      args: mapValue(config.args, extendArg)
    });
  }
  function extendNamedType(type) {
    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {
      return type;
    }
    if (isScalarType(type)) {
      return extendScalarType(type);
    }
    if (isObjectType(type)) {
      return extendObjectType(type);
    }
    if (isInterfaceType(type)) {
      return extendInterfaceType(type);
    }
    if (isUnionType(type)) {
      return extendUnionType(type);
    }
    if (isEnumType(type)) {
      return extendEnumType(type);
    }
    if (isInputObjectType(type)) {
      return extendInputObjectType(type);
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
  function extendInputObjectType(type) {
    var _typeExtensionsMap$co;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
    return new GraphQLInputObjectType({
      ...config,
      fields: () => ({
        ...mapValue(config.fields, (field) => ({
          ...field,
          type: replaceType(field.type)
        })),
        ...buildInputFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendEnumType(type) {
    var _typeExtensionsMap$ty;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
    return new GraphQLEnumType({
      ...config,
      values: { ...config.values, ...buildEnumValueMap(extensions) },
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendScalarType(type) {
    var _typeExtensionsMap$co2;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
    let specifiedByURL = config.specifiedByURL;
    for (const extensionNode of extensions) {
      var _getSpecifiedByURL;
      specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
    }
    return new GraphQLScalarType({
      ...config,
      specifiedByURL,
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendObjectType(type) {
    var _typeExtensionsMap$co3;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
    return new GraphQLObjectType({
      ...config,
      interfaces: () => [
        ...type.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => ({
        ...mapValue(config.fields, extendField),
        ...buildFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendInterfaceType(type) {
    var _typeExtensionsMap$co4;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
    return new GraphQLInterfaceType({
      ...config,
      interfaces: () => [
        ...type.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => ({
        ...mapValue(config.fields, extendField),
        ...buildFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendUnionType(type) {
    var _typeExtensionsMap$co5;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
    return new GraphQLUnionType({
      ...config,
      types: () => [
        ...type.getTypes().map(replaceNamedType),
        ...buildUnionTypes(extensions)
      ],
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendField(field) {
    return {
      ...field,
      type: replaceType(field.type),
      args: field.args && mapValue(field.args, extendArg)
    };
  }
  function extendArg(arg) {
    return { ...arg, type: replaceType(arg.type) };
  }
  function getOperationTypes(nodes) {
    const opTypes = {};
    for (const node of nodes) {
      var _node$operationTypes;
      const operationTypesNodes = (
        /* c8 ignore next */
        (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : []
      );
      for (const operationType of operationTypesNodes) {
        opTypes[operationType.operation] = getNamedType2(operationType.type);
      }
    }
    return opTypes;
  }
  function getNamedType2(node) {
    var _stdTypeMap$name2;
    const name = node.name.value;
    const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
    if (type === void 0) {
      throw new Error(`Unknown type: "${name}".`);
    }
    return type;
  }
  function getWrappedType(node) {
    if (node.kind === Kind.LIST_TYPE) {
      return new GraphQLList(getWrappedType(node.type));
    }
    if (node.kind === Kind.NON_NULL_TYPE) {
      return new GraphQLNonNull(getWrappedType(node.type));
    }
    return getNamedType2(node);
  }
  function buildDirective(node) {
    var _node$description;
    return new GraphQLDirective({
      name: node.name.value,
      description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
      // @ts-expect-error
      locations: node.locations.map(({ value }) => value),
      isRepeatable: node.repeatable,
      args: buildArgumentMap(node.arguments),
      astNode: node
    });
  }
  function buildFieldMap(nodes) {
    const fieldConfigMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$fields;
      const nodeFields = (
        /* c8 ignore next */
        (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : []
      );
      for (const field of nodeFields) {
        var _field$description;
        fieldConfigMap[field.name.value] = {
          // Note: While this could make assertions to get the correctly typed
          // value, that would throw immediately while type system validation
          // with validateSchema() will produce more actionable results.
          type: getWrappedType(field.type),
          description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
          args: buildArgumentMap(field.arguments),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return fieldConfigMap;
  }
  function buildArgumentMap(args) {
    const argsNodes = (
      /* c8 ignore next */
      args !== null && args !== void 0 ? args : []
    );
    const argConfigMap = /* @__PURE__ */ Object.create(null);
    for (const arg of argsNodes) {
      var _arg$description;
      const type = getWrappedType(arg.type);
      argConfigMap[arg.name.value] = {
        type,
        description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
        defaultValue: valueFromAST(arg.defaultValue, type),
        deprecationReason: getDeprecationReason(arg),
        astNode: arg
      };
    }
    return argConfigMap;
  }
  function buildInputFieldMap(nodes) {
    const inputFieldMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$fields2;
      const fieldsNodes = (
        /* c8 ignore next */
        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : []
      );
      for (const field of fieldsNodes) {
        var _field$description2;
        const type = getWrappedType(field.type);
        inputFieldMap[field.name.value] = {
          type,
          description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
          defaultValue: valueFromAST(field.defaultValue, type),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return inputFieldMap;
  }
  function buildEnumValueMap(nodes) {
    const enumValueMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$values;
      const valuesNodes = (
        /* c8 ignore next */
        (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : []
      );
      for (const value of valuesNodes) {
        var _value$description;
        enumValueMap[value.name.value] = {
          description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
          deprecationReason: getDeprecationReason(value),
          astNode: value
        };
      }
    }
    return enumValueMap;
  }
  function buildInterfaces(nodes) {
    return nodes.flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (node) => {
        var _node$interfaces$map, _node$interfaces;
        return (
          /* c8 ignore next */
          (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType2)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []
        );
      }
    );
  }
  function buildUnionTypes(nodes) {
    return nodes.flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (node) => {
        var _node$types$map, _node$types;
        return (
          /* c8 ignore next */
          (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType2)) !== null && _node$types$map !== void 0 ? _node$types$map : []
        );
      }
    );
  }
  function buildType(astNode) {
    var _typeExtensionsMap$na;
    const name = astNode.name.value;
    const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
    switch (astNode.kind) {
      case Kind.OBJECT_TYPE_DEFINITION: {
        var _astNode$description;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLObjectType({
          name,
          description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INTERFACE_TYPE_DEFINITION: {
        var _astNode$description2;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInterfaceType({
          name,
          description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.ENUM_TYPE_DEFINITION: {
        var _astNode$description3;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLEnumType({
          name,
          description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
          values: buildEnumValueMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.UNION_TYPE_DEFINITION: {
        var _astNode$description4;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLUnionType({
          name,
          description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
          types: () => buildUnionTypes(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.SCALAR_TYPE_DEFINITION: {
        var _astNode$description5;
        return new GraphQLScalarType({
          name,
          description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
          specifiedByURL: getSpecifiedByURL(astNode),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {
        var _astNode$description6;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInputObjectType({
          name,
          description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
          fields: () => buildInputFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
    }
  }
}
function getDeprecationReason(node) {
  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);
  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
}
function getSpecifiedByURL(node) {
  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);
  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
}
var stdTypeMap;
var init_extendSchema = __esm({
  "node_modules/graphql/utilities/extendSchema.mjs"() {
    init_devAssert();
    init_inspect();
    init_invariant();
    init_keyMap();
    init_mapValue();
    init_kinds();
    init_predicates();
    init_definition();
    init_directives();
    init_introspection();
    init_scalars();
    init_schema();
    init_validate2();
    init_values();
    init_valueFromAST();
    stdTypeMap = keyMap(
      [...specifiedScalarTypes, ...introspectionTypes],
      (type) => type.name
    );
  }
});
function buildASTSchema(documentAST, options) {
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
    assertValidSDL(documentAST);
  }
  const emptySchemaConfig = {
    description: void 0,
    types: [],
    directives: [],
    extensions: /* @__PURE__ */ Object.create(null),
    extensionASTNodes: [],
    assumeValid: false
  };
  const config = extendSchemaImpl(emptySchemaConfig, documentAST, options);
  if (config.astNode == null) {
    for (const type of config.types) {
      switch (type.name) {
        case "Query":
          config.query = type;
          break;
        case "Mutation":
          config.mutation = type;
          break;
        case "Subscription":
          config.subscription = type;
          break;
      }
    }
  }
  const directives = [
    ...config.directives,
    // If specified directives were not explicitly declared, add them.
    ...specifiedDirectives.filter(
      (stdDirective) => config.directives.every(
        (directive) => directive.name !== stdDirective.name
      )
    )
  ];
  return new GraphQLSchema({ ...config, directives });
}
function buildSchema(source, options) {
  const document = parse(source, {
    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
    allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
  });
  return buildASTSchema(document, {
    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
  });
}
var init_buildASTSchema = __esm({
  "node_modules/graphql/utilities/buildASTSchema.mjs"() {
    init_devAssert();
    init_kinds();
    init_parser();
    init_directives();
    init_schema();
    init_validate2();
    init_extendSchema();
  }
});
function lexicographicSortSchema(schema) {
  const schemaConfig = schema.toConfig();
  const typeMap = keyValMap(
    sortByName(schemaConfig.types),
    (type) => type.name,
    sortNamedType
  );
  return new GraphQLSchema({
    ...schemaConfig,
    types: Object.values(typeMap),
    directives: sortByName(schemaConfig.directives).map(sortDirective),
    query: replaceMaybeType(schemaConfig.query),
    mutation: replaceMaybeType(schemaConfig.mutation),
    subscription: replaceMaybeType(schemaConfig.subscription)
  });
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    } else if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceMaybeType(maybeType) {
    return maybeType && replaceNamedType(maybeType);
  }
  function sortDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      locations: sortBy(config.locations, (x) => x),
      args: sortArgs(config.args)
    });
  }
  function sortArgs(args) {
    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
  }
  function sortFields2(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type),
      args: field.args && sortArgs(field.args)
    }));
  }
  function sortInputFields(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type)
    }));
  }
  function sortTypes(array) {
    return sortByName(array).map(replaceNamedType);
  }
  function sortNamedType(type) {
    if (isScalarType(type) || isIntrospectionType(type)) {
      return type;
    }
    if (isObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLObjectType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isInterfaceType(type)) {
      const config = type.toConfig();
      return new GraphQLInterfaceType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isUnionType(type)) {
      const config = type.toConfig();
      return new GraphQLUnionType({
        ...config,
        types: () => sortTypes(config.types)
      });
    }
    if (isEnumType(type)) {
      const config = type.toConfig();
      return new GraphQLEnumType({
        ...config,
        values: sortObjMap(config.values, (value) => value)
      });
    }
    if (isInputObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLInputObjectType({
        ...config,
        fields: () => sortInputFields(config.fields)
      });
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
}
function sortObjMap(map, sortValueFn) {
  const sortedMap = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map).sort(naturalCompare)) {
    sortedMap[key] = sortValueFn(map[key]);
  }
  return sortedMap;
}
function sortByName(array) {
  return sortBy(array, (obj) => obj.name);
}
function sortBy(array, mapToKey) {
  return array.slice().sort((obj1, obj2) => {
    const key1 = mapToKey(obj1);
    const key2 = mapToKey(obj2);
    return naturalCompare(key1, key2);
  });
}
var init_lexicographicSortSchema = __esm({
  "node_modules/graphql/utilities/lexicographicSortSchema.mjs"() {
    init_inspect();
    init_invariant();
    init_keyValMap();
    init_naturalCompare();
    init_definition();
    init_directives();
    init_introspection();
    init_schema();
  }
});
function printSchema(schema) {
  return printFilteredSchema(
    schema,
    (n) => !isSpecifiedDirective(n),
    isDefinedType
  );
}
function printIntrospectionSchema(schema) {
  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);
}
function isDefinedType(type) {
  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);
}
function printFilteredSchema(schema, directiveFilter, typeFilter) {
  const directives = schema.getDirectives().filter(directiveFilter);
  const types = Object.values(schema.getTypeMap()).filter(typeFilter);
  return [
    printSchemaDefinition(schema),
    ...directives.map((directive) => printDirective(directive)),
    ...types.map((type) => printType(type))
  ].filter(Boolean).join("\n\n");
}
function printSchemaDefinition(schema) {
  if (schema.description == null && isSchemaOfCommonNames(schema)) {
    return;
  }
  const operationTypes = [];
  const queryType = schema.getQueryType();
  if (queryType) {
    operationTypes.push(`  query: ${queryType.name}`);
  }
  const mutationType = schema.getMutationType();
  if (mutationType) {
    operationTypes.push(`  mutation: ${mutationType.name}`);
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType) {
    operationTypes.push(`  subscription: ${subscriptionType.name}`);
  }
  return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
}
function isSchemaOfCommonNames(schema) {
  const queryType = schema.getQueryType();
  if (queryType && queryType.name !== "Query") {
    return false;
  }
  const mutationType = schema.getMutationType();
  if (mutationType && mutationType.name !== "Mutation") {
    return false;
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && subscriptionType.name !== "Subscription") {
    return false;
  }
  return true;
}
function printType(type) {
  if (isScalarType(type)) {
    return printScalar(type);
  }
  if (isObjectType(type)) {
    return printObject(type);
  }
  if (isInterfaceType(type)) {
    return printInterface(type);
  }
  if (isUnionType(type)) {
    return printUnion(type);
  }
  if (isEnumType(type)) {
    return printEnum(type);
  }
  if (isInputObjectType(type)) {
    return printInputObject(type);
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function printScalar(type) {
  return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
}
function printImplementedInterfaces(type) {
  const interfaces = type.getInterfaces();
  return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
}
function printObject(type) {
  return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
}
function printInterface(type) {
  return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
}
function printUnion(type) {
  const types = type.getTypes();
  const possibleTypes = types.length ? " = " + types.join(" | ") : "";
  return printDescription(type) + "union " + type.name + possibleTypes;
}
function printEnum(type) {
  const values = type.getValues().map(
    (value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason)
  );
  return printDescription(type) + `enum ${type.name}` + printBlock(values);
}
function printInputObject(type) {
  const fields = Object.values(type.getFields()).map(
    (f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f)
  );
  return printDescription(type) + `input ${type.name}` + printBlock(fields);
}
function printFields(type) {
  const fields = Object.values(type.getFields()).map(
    (f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason)
  );
  return printBlock(fields);
}
function printBlock(items) {
  return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
}
function printArgs(args, indentation = "") {
  if (args.length === 0) {
    return "";
  }
  if (args.every((arg) => !arg.description)) {
    return "(" + args.map(printInputValue).join(", ") + ")";
  }
  return "(\n" + args.map(
    (arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)
  ).join("\n") + "\n" + indentation + ")";
}
function printInputValue(arg) {
  const defaultAST = astFromValue(arg.defaultValue, arg.type);
  let argDecl = arg.name + ": " + String(arg.type);
  if (defaultAST) {
    argDecl += ` = ${print(defaultAST)}`;
  }
  return argDecl + printDeprecated(arg.deprecationReason);
}
function printDirective(directive) {
  return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
}
function printDeprecated(reason) {
  if (reason == null) {
    return "";
  }
  if (reason !== DEFAULT_DEPRECATION_REASON) {
    const astValue = print({
      kind: Kind.STRING,
      value: reason
    });
    return ` @deprecated(reason: ${astValue})`;
  }
  return " @deprecated";
}
function printSpecifiedByURL(scalar) {
  if (scalar.specifiedByURL == null) {
    return "";
  }
  const astValue = print({
    kind: Kind.STRING,
    value: scalar.specifiedByURL
  });
  return ` @specifiedBy(url: ${astValue})`;
}
function printDescription(def, indentation = "", firstInBlock = true) {
  const { description } = def;
  if (description == null) {
    return "";
  }
  const blockString = print({
    kind: Kind.STRING,
    value: description,
    block: isPrintableAsBlockString(description)
  });
  const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
  return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
}
var init_printSchema = __esm({
  "node_modules/graphql/utilities/printSchema.mjs"() {
    init_inspect();
    init_invariant();
    init_blockString();
    init_kinds();
    init_printer();
    init_definition();
    init_directives();
    init_introspection();
    init_scalars();
    init_astFromValue();
  }
});
function concatAST(documents) {
  const definitions = [];
  for (const doc of documents) {
    definitions.push(...doc.definitions);
  }
  return {
    kind: Kind.DOCUMENT,
    definitions
  };
}
var init_concatAST = __esm({
  "node_modules/graphql/utilities/concatAST.mjs"() {
    init_kinds();
  }
});
function separateOperations(documentAST) {
  const operations = [];
  const depGraph = /* @__PURE__ */ Object.create(null);
  for (const definitionNode of documentAST.definitions) {
    switch (definitionNode.kind) {
      case Kind.OPERATION_DEFINITION:
        operations.push(definitionNode);
        break;
      case Kind.FRAGMENT_DEFINITION:
        depGraph[definitionNode.name.value] = collectDependencies(
          definitionNode.selectionSet
        );
        break;
      default:
    }
  }
  const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
  for (const operation of operations) {
    const dependencies = /* @__PURE__ */ new Set();
    for (const fragmentName of collectDependencies(operation.selectionSet)) {
      collectTransitiveDependencies(dependencies, depGraph, fragmentName);
    }
    const operationName = operation.name ? operation.name.value : "";
    separatedDocumentASTs[operationName] = {
      kind: Kind.DOCUMENT,
      definitions: documentAST.definitions.filter(
        (node) => node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value)
      )
    };
  }
  return separatedDocumentASTs;
}
function collectTransitiveDependencies(collected, depGraph, fromName) {
  if (!collected.has(fromName)) {
    collected.add(fromName);
    const immediateDeps = depGraph[fromName];
    if (immediateDeps !== void 0) {
      for (const toName of immediateDeps) {
        collectTransitiveDependencies(collected, depGraph, toName);
      }
    }
  }
}
function collectDependencies(selectionSet) {
  const dependencies = [];
  visit(selectionSet, {
    FragmentSpread(node) {
      dependencies.push(node.name.value);
    }
  });
  return dependencies;
}
var init_separateOperations = __esm({
  "node_modules/graphql/utilities/separateOperations.mjs"() {
    init_kinds();
    init_visitor();
  }
});
function stripIgnoredCharacters(source) {
  const sourceObj = isSource(source) ? source : new Source(source);
  const body = sourceObj.body;
  const lexer = new Lexer(sourceObj);
  let strippedBody = "";
  let wasLastAddedTokenNonPunctuator = false;
  while (lexer.advance().kind !== TokenKind.EOF) {
    const currentToken = lexer.token;
    const tokenKind = currentToken.kind;
    const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);
    if (wasLastAddedTokenNonPunctuator) {
      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {
        strippedBody += " ";
      }
    }
    const tokenBody = body.slice(currentToken.start, currentToken.end);
    if (tokenKind === TokenKind.BLOCK_STRING) {
      strippedBody += printBlockString(currentToken.value, {
        minimize: true
      });
    } else {
      strippedBody += tokenBody;
    }
    wasLastAddedTokenNonPunctuator = isNonPunctuator;
  }
  return strippedBody;
}
var init_stripIgnoredCharacters = __esm({
  "node_modules/graphql/utilities/stripIgnoredCharacters.mjs"() {
    init_blockString();
    init_lexer();
    init_source();
    init_tokenKind();
  }
});
function assertValidName(name) {
  const error = isValidNameError(name);
  if (error) {
    throw error;
  }
  return name;
}
function isValidNameError(name) {
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.startsWith("__")) {
    return new GraphQLError(
      `Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`
    );
  }
  try {
    assertName(name);
  } catch (error) {
    return error;
  }
}
var init_assertValidName = __esm({
  "node_modules/graphql/utilities/assertValidName.mjs"() {
    init_devAssert();
    init_GraphQLError();
    init_assertName();
  }
});
function findBreakingChanges(oldSchema, newSchema) {
  return findSchemaChanges(oldSchema, newSchema).filter(
    (change) => change.type in BreakingChangeType
  );
}
function findDangerousChanges(oldSchema, newSchema) {
  return findSchemaChanges(oldSchema, newSchema).filter(
    (change) => change.type in DangerousChangeType
  );
}
function findSchemaChanges(oldSchema, newSchema) {
  return [
    ...findTypeChanges(oldSchema, newSchema),
    ...findDirectiveChanges(oldSchema, newSchema)
  ];
}
function findDirectiveChanges(oldSchema, newSchema) {
  const schemaChanges = [];
  const directivesDiff = diff(
    oldSchema.getDirectives(),
    newSchema.getDirectives()
  );
  for (const oldDirective of directivesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.DIRECTIVE_REMOVED,
      description: `${oldDirective.name} was removed.`
    });
  }
  for (const [oldDirective, newDirective] of directivesDiff.persisted) {
    const argsDiff = diff(oldDirective.args, newDirective.args);
    for (const newArg of argsDiff.added) {
      if (isRequiredArgument(newArg)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
        });
      }
    }
    for (const oldArg of argsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
        description: `${oldArg.name} was removed from ${oldDirective.name}.`
      });
    }
    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
        description: `Repeatable flag was removed from ${oldDirective.name}.`
      });
    }
    for (const location of oldDirective.locations) {
      if (!newDirective.locations.includes(location)) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
          description: `${location} was removed from ${oldDirective.name}.`
        });
      }
    }
  }
  return schemaChanges;
}
function findTypeChanges(oldSchema, newSchema) {
  const schemaChanges = [];
  const typesDiff = diff(
    Object.values(oldSchema.getTypeMap()),
    Object.values(newSchema.getTypeMap())
  );
  for (const oldType of typesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED,
      description: isSpecifiedScalarType(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
    });
  }
  for (const [oldType, newType] of typesDiff.persisted) {
    if (isEnumType(oldType) && isEnumType(newType)) {
      schemaChanges.push(...findEnumTypeChanges(oldType, newType));
    } else if (isUnionType(oldType) && isUnionType(newType)) {
      schemaChanges.push(...findUnionTypeChanges(oldType, newType));
    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {
      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
    } else if (isObjectType(oldType) && isObjectType(newType)) {
      schemaChanges.push(
        ...findFieldChanges(oldType, newType),
        ...findImplementedInterfacesChanges(oldType, newType)
      );
    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {
      schemaChanges.push(
        ...findFieldChanges(oldType, newType),
        ...findImplementedInterfacesChanges(oldType, newType)
      );
    } else if (oldType.constructor !== newType.constructor) {
      schemaChanges.push({
        type: BreakingChangeType.TYPE_CHANGED_KIND,
        description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
      });
    }
  }
  return schemaChanges;
}
function findInputObjectTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const fieldsDiff = diff(
    Object.values(oldType.getFields()),
    Object.values(newType.getFields())
  );
  for (const newField of fieldsDiff.added) {
    if (isRequiredInputField(newField)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
        description: `A required field ${newField.name} on input type ${oldType.name} was added.`
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
      });
    }
  }
  for (const oldField of fieldsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: `${oldType.name}.${oldField.name} was removed.`
    });
  }
  for (const [oldField, newField] of fieldsDiff.persisted) {
    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
      oldField.type,
      newField.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
      });
    }
  }
  return schemaChanges;
}
function findUnionTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
  for (const newPossibleType of possibleTypesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.TYPE_ADDED_TO_UNION,
      description: `${newPossibleType.name} was added to union type ${oldType.name}.`
    });
  }
  for (const oldPossibleType of possibleTypesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
    });
  }
  return schemaChanges;
}
function findEnumTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const valuesDiff = diff(oldType.getValues(), newType.getValues());
  for (const newValue of valuesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
      description: `${newValue.name} was added to enum type ${oldType.name}.`
    });
  }
  for (const oldValue of valuesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
      description: `${oldValue.name} was removed from enum type ${oldType.name}.`
    });
  }
  return schemaChanges;
}
function findImplementedInterfacesChanges(oldType, newType) {
  const schemaChanges = [];
  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
  for (const newInterface of interfacesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
    });
  }
  for (const oldInterface of interfacesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
    });
  }
  return schemaChanges;
}
function findFieldChanges(oldType, newType) {
  const schemaChanges = [];
  const fieldsDiff = diff(
    Object.values(oldType.getFields()),
    Object.values(newType.getFields())
  );
  for (const oldField of fieldsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: `${oldType.name}.${oldField.name} was removed.`
    });
  }
  for (const [oldField, newField] of fieldsDiff.persisted) {
    schemaChanges.push(...findArgChanges(oldType, oldField, newField));
    const isSafe = isChangeSafeForObjectOrInterfaceField(
      oldField.type,
      newField.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
      });
    }
  }
  return schemaChanges;
}
function findArgChanges(oldType, oldField, newField) {
  const schemaChanges = [];
  const argsDiff = diff(oldField.args, newField.args);
  for (const oldArg of argsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.ARG_REMOVED,
      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
    });
  }
  for (const [oldArg, newArg] of argsDiff.persisted) {
    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
      oldArg.type,
      newArg.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.ARG_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
      });
    } else if (oldArg.defaultValue !== void 0) {
      if (newArg.defaultValue === void 0) {
        schemaChanges.push({
          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
        });
      } else {
        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
        if (oldValueStr !== newValueStr) {
          schemaChanges.push({
            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
          });
        }
      }
    }
  }
  for (const newArg of argsDiff.added) {
    if (isRequiredArgument(newArg)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_ARG_ADDED,
        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_ARG_ADDED,
        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
      });
    }
  }
  return schemaChanges;
}
function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
  if (isListType(oldType)) {
    return (
      // if they're both lists, make sure the underlying types are compatible
      isListType(newType) && isChangeSafeForObjectOrInterfaceField(
        oldType.ofType,
        newType.ofType
      ) || // moving from nullable to non-null of the same underlying type is safe
      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
    );
  }
  if (isNonNullType(oldType)) {
    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
  }
  return (
    // if they're both named types, see if their names are equivalent
    isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe
    isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
  );
}
function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
  if (isListType(oldType)) {
    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
  }
  if (isNonNullType(oldType)) {
    return (
      // if they're both non-null, make sure the underlying types are
      // compatible
      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(
        oldType.ofType,
        newType.ofType
      ) || // moving from non-null to nullable of the same underlying type is safe
      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)
    );
  }
  return isNamedType(newType) && oldType.name === newType.name;
}
function typeKindName(type) {
  if (isScalarType(type)) {
    return "a Scalar type";
  }
  if (isObjectType(type)) {
    return "an Object type";
  }
  if (isInterfaceType(type)) {
    return "an Interface type";
  }
  if (isUnionType(type)) {
    return "a Union type";
  }
  if (isEnumType(type)) {
    return "an Enum type";
  }
  if (isInputObjectType(type)) {
    return "an Input type";
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function stringifyValue(value, type) {
  const ast = astFromValue(value, type);
  ast != null || invariant(false);
  return print(sortValueNode(ast));
}
function diff(oldArray, newArray) {
  const added = [];
  const removed = [];
  const persisted = [];
  const oldMap = keyMap(oldArray, ({ name }) => name);
  const newMap = keyMap(newArray, ({ name }) => name);
  for (const oldItem of oldArray) {
    const newItem = newMap[oldItem.name];
    if (newItem === void 0) {
      removed.push(oldItem);
    } else {
      persisted.push([oldItem, newItem]);
    }
  }
  for (const newItem of newArray) {
    if (oldMap[newItem.name] === void 0) {
      added.push(newItem);
    }
  }
  return {
    added,
    persisted,
    removed
  };
}
var BreakingChangeType, DangerousChangeType;
var init_findBreakingChanges = __esm({
  "node_modules/graphql/utilities/findBreakingChanges.mjs"() {
    init_inspect();
    init_invariant();
    init_keyMap();
    init_printer();
    init_definition();
    init_scalars();
    init_astFromValue();
    init_sortValueNode();
    (function(BreakingChangeType2) {
      BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
      BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
      BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
      BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
      BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
      BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
      BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
      BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
      BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
      BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
      BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
      BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
      BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
      BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
      BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
      BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
    })(BreakingChangeType || (BreakingChangeType = {}));
    (function(DangerousChangeType2) {
      DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
      DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
      DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
      DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
      DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
      DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
    })(DangerousChangeType || (DangerousChangeType = {}));
  }
});
var init_utilities = __esm({
  "node_modules/graphql/utilities/index.mjs"() {
    init_getIntrospectionQuery();
    init_getOperationAST();
    init_getOperationRootType();
    init_introspectionFromSchema();
    init_buildClientSchema();
    init_buildASTSchema();
    init_extendSchema();
    init_lexicographicSortSchema();
    init_printSchema();
    init_typeFromAST();
    init_valueFromAST();
    init_valueFromASTUntyped();
    init_astFromValue();
    init_TypeInfo();
    init_coerceInputValue();
    init_concatAST();
    init_separateOperations();
    init_stripIgnoredCharacters();
    init_typeComparators();
    init_assertValidName();
    init_findBreakingChanges();
  }
});
var graphql_exports = {};
__export(graphql_exports, {
  BREAK: () => BREAK,
  BreakingChangeType: () => BreakingChangeType,
  DEFAULT_DEPRECATION_REASON: () => DEFAULT_DEPRECATION_REASON,
  DangerousChangeType: () => DangerousChangeType,
  DirectiveLocation: () => DirectiveLocation,
  ExecutableDefinitionsRule: () => ExecutableDefinitionsRule,
  FieldsOnCorrectTypeRule: () => FieldsOnCorrectTypeRule,
  FragmentsOnCompositeTypesRule: () => FragmentsOnCompositeTypesRule,
  GRAPHQL_MAX_INT: () => GRAPHQL_MAX_INT,
  GRAPHQL_MIN_INT: () => GRAPHQL_MIN_INT,
  GraphQLBoolean: () => GraphQLBoolean,
  GraphQLDeprecatedDirective: () => GraphQLDeprecatedDirective,
  GraphQLDirective: () => GraphQLDirective,
  GraphQLEnumType: () => GraphQLEnumType,
  GraphQLError: () => GraphQLError,
  GraphQLFloat: () => GraphQLFloat,
  GraphQLID: () => GraphQLID,
  GraphQLIncludeDirective: () => GraphQLIncludeDirective,
  GraphQLInputObjectType: () => GraphQLInputObjectType,
  GraphQLInt: () => GraphQLInt,
  GraphQLInterfaceType: () => GraphQLInterfaceType,
  GraphQLList: () => GraphQLList,
  GraphQLNonNull: () => GraphQLNonNull,
  GraphQLObjectType: () => GraphQLObjectType,
  GraphQLScalarType: () => GraphQLScalarType,
  GraphQLSchema: () => GraphQLSchema,
  GraphQLSkipDirective: () => GraphQLSkipDirective,
  GraphQLSpecifiedByDirective: () => GraphQLSpecifiedByDirective,
  GraphQLString: () => GraphQLString,
  GraphQLUnionType: () => GraphQLUnionType,
  Kind: () => Kind,
  KnownArgumentNamesRule: () => KnownArgumentNamesRule,
  KnownDirectivesRule: () => KnownDirectivesRule,
  KnownFragmentNamesRule: () => KnownFragmentNamesRule,
  KnownTypeNamesRule: () => KnownTypeNamesRule,
  Lexer: () => Lexer,
  Location: () => Location,
  LoneAnonymousOperationRule: () => LoneAnonymousOperationRule,
  LoneSchemaDefinitionRule: () => LoneSchemaDefinitionRule,
  NoDeprecatedCustomRule: () => NoDeprecatedCustomRule,
  NoFragmentCyclesRule: () => NoFragmentCyclesRule,
  NoSchemaIntrospectionCustomRule: () => NoSchemaIntrospectionCustomRule,
  NoUndefinedVariablesRule: () => NoUndefinedVariablesRule,
  NoUnusedFragmentsRule: () => NoUnusedFragmentsRule,
  NoUnusedVariablesRule: () => NoUnusedVariablesRule,
  OperationTypeNode: () => OperationTypeNode,
  OverlappingFieldsCanBeMergedRule: () => OverlappingFieldsCanBeMergedRule,
  PossibleFragmentSpreadsRule: () => PossibleFragmentSpreadsRule,
  PossibleTypeExtensionsRule: () => PossibleTypeExtensionsRule,
  ProvidedRequiredArgumentsRule: () => ProvidedRequiredArgumentsRule,
  ScalarLeafsRule: () => ScalarLeafsRule,
  SchemaMetaFieldDef: () => SchemaMetaFieldDef,
  SingleFieldSubscriptionsRule: () => SingleFieldSubscriptionsRule,
  Source: () => Source,
  Token: () => Token,
  TokenKind: () => TokenKind,
  TypeInfo: () => TypeInfo,
  TypeKind: () => TypeKind,
  TypeMetaFieldDef: () => TypeMetaFieldDef,
  TypeNameMetaFieldDef: () => TypeNameMetaFieldDef,
  UniqueArgumentDefinitionNamesRule: () => UniqueArgumentDefinitionNamesRule,
  UniqueArgumentNamesRule: () => UniqueArgumentNamesRule,
  UniqueDirectiveNamesRule: () => UniqueDirectiveNamesRule,
  UniqueDirectivesPerLocationRule: () => UniqueDirectivesPerLocationRule,
  UniqueEnumValueNamesRule: () => UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule: () => UniqueFieldDefinitionNamesRule,
  UniqueFragmentNamesRule: () => UniqueFragmentNamesRule,
  UniqueInputFieldNamesRule: () => UniqueInputFieldNamesRule,
  UniqueOperationNamesRule: () => UniqueOperationNamesRule,
  UniqueOperationTypesRule: () => UniqueOperationTypesRule,
  UniqueTypeNamesRule: () => UniqueTypeNamesRule,
  UniqueVariableNamesRule: () => UniqueVariableNamesRule,
  ValidationContext: () => ValidationContext,
  ValuesOfCorrectTypeRule: () => ValuesOfCorrectTypeRule,
  VariablesAreInputTypesRule: () => VariablesAreInputTypesRule,
  VariablesInAllowedPositionRule: () => VariablesInAllowedPositionRule,
  __Directive: () => __Directive,
  __DirectiveLocation: () => __DirectiveLocation,
  __EnumValue: () => __EnumValue,
  __Field: () => __Field,
  __InputValue: () => __InputValue,
  __Schema: () => __Schema,
  __Type: () => __Type,
  __TypeKind: () => __TypeKind,
  assertAbstractType: () => assertAbstractType,
  assertCompositeType: () => assertCompositeType,
  assertDirective: () => assertDirective,
  assertEnumType: () => assertEnumType,
  assertEnumValueName: () => assertEnumValueName,
  assertInputObjectType: () => assertInputObjectType,
  assertInputType: () => assertInputType,
  assertInterfaceType: () => assertInterfaceType,
  assertLeafType: () => assertLeafType,
  assertListType: () => assertListType,
  assertName: () => assertName,
  assertNamedType: () => assertNamedType,
  assertNonNullType: () => assertNonNullType,
  assertNullableType: () => assertNullableType,
  assertObjectType: () => assertObjectType,
  assertOutputType: () => assertOutputType,
  assertScalarType: () => assertScalarType,
  assertSchema: () => assertSchema,
  assertType: () => assertType,
  assertUnionType: () => assertUnionType,
  assertValidName: () => assertValidName,
  assertValidSchema: () => assertValidSchema,
  assertWrappingType: () => assertWrappingType,
  astFromValue: () => astFromValue,
  buildASTSchema: () => buildASTSchema,
  buildClientSchema: () => buildClientSchema,
  buildSchema: () => buildSchema,
  coerceInputValue: () => coerceInputValue,
  concatAST: () => concatAST,
  createSourceEventStream: () => createSourceEventStream,
  defaultFieldResolver: () => defaultFieldResolver,
  defaultTypeResolver: () => defaultTypeResolver,
  doTypesOverlap: () => doTypesOverlap,
  execute: () => execute,
  executeSync: () => executeSync,
  extendSchema: () => extendSchema,
  findBreakingChanges: () => findBreakingChanges,
  findDangerousChanges: () => findDangerousChanges,
  formatError: () => formatError,
  getArgumentValues: () => getArgumentValues,
  getDirectiveValues: () => getDirectiveValues,
  getEnterLeaveForKind: () => getEnterLeaveForKind,
  getIntrospectionQuery: () => getIntrospectionQuery,
  getLocation: () => getLocation,
  getNamedType: () => getNamedType,
  getNullableType: () => getNullableType,
  getOperationAST: () => getOperationAST,
  getOperationRootType: () => getOperationRootType,
  getVariableValues: () => getVariableValues,
  getVisitFn: () => getVisitFn,
  graphql: () => graphql,
  graphqlSync: () => graphqlSync,
  introspectionFromSchema: () => introspectionFromSchema,
  introspectionTypes: () => introspectionTypes,
  isAbstractType: () => isAbstractType,
  isCompositeType: () => isCompositeType,
  isConstValueNode: () => isConstValueNode,
  isDefinitionNode: () => isDefinitionNode,
  isDirective: () => isDirective,
  isEnumType: () => isEnumType,
  isEqualType: () => isEqualType,
  isExecutableDefinitionNode: () => isExecutableDefinitionNode,
  isInputObjectType: () => isInputObjectType,
  isInputType: () => isInputType,
  isInterfaceType: () => isInterfaceType,
  isIntrospectionType: () => isIntrospectionType,
  isLeafType: () => isLeafType,
  isListType: () => isListType,
  isNamedType: () => isNamedType,
  isNonNullType: () => isNonNullType,
  isNullableType: () => isNullableType,
  isObjectType: () => isObjectType,
  isOutputType: () => isOutputType,
  isRequiredArgument: () => isRequiredArgument,
  isRequiredInputField: () => isRequiredInputField,
  isScalarType: () => isScalarType,
  isSchema: () => isSchema,
  isSelectionNode: () => isSelectionNode,
  isSpecifiedDirective: () => isSpecifiedDirective,
  isSpecifiedScalarType: () => isSpecifiedScalarType,
  isType: () => isType,
  isTypeDefinitionNode: () => isTypeDefinitionNode,
  isTypeExtensionNode: () => isTypeExtensionNode,
  isTypeNode: () => isTypeNode,
  isTypeSubTypeOf: () => isTypeSubTypeOf,
  isTypeSystemDefinitionNode: () => isTypeSystemDefinitionNode,
  isTypeSystemExtensionNode: () => isTypeSystemExtensionNode,
  isUnionType: () => isUnionType,
  isValidNameError: () => isValidNameError,
  isValueNode: () => isValueNode,
  isWrappingType: () => isWrappingType,
  lexicographicSortSchema: () => lexicographicSortSchema,
  locatedError: () => locatedError,
  parse: () => parse,
  parseConstValue: () => parseConstValue,
  parseType: () => parseType,
  parseValue: () => parseValue,
  print: () => print,
  printError: () => printError,
  printIntrospectionSchema: () => printIntrospectionSchema,
  printLocation: () => printLocation,
  printSchema: () => printSchema,
  printSourceLocation: () => printSourceLocation,
  printType: () => printType,
  resolveObjMapThunk: () => resolveObjMapThunk,
  resolveReadonlyArrayThunk: () => resolveReadonlyArrayThunk,
  responsePathAsArray: () => pathToArray,
  separateOperations: () => separateOperations,
  specifiedDirectives: () => specifiedDirectives,
  specifiedRules: () => specifiedRules,
  specifiedScalarTypes: () => specifiedScalarTypes,
  stripIgnoredCharacters: () => stripIgnoredCharacters,
  subscribe: () => subscribe,
  syntaxError: () => syntaxError,
  typeFromAST: () => typeFromAST,
  validate: () => validate,
  validateSchema: () => validateSchema,
  valueFromAST: () => valueFromAST,
  valueFromASTUntyped: () => valueFromASTUntyped,
  version: () => version,
  versionInfo: () => versionInfo,
  visit: () => visit,
  visitInParallel: () => visitInParallel,
  visitWithTypeInfo: () => visitWithTypeInfo
});
var init_graphql2 = __esm({
  "node_modules/graphql/index.mjs"() {
    init_version();
    init_graphql();
    init_type();
    init_language();
    init_execution();
    init_validation();
    init_error();
    init_utilities();
  }
});
export {
  GraphQLError,
  DirectiveLocation,
  Kind,
  parse,
  BREAK,
  visit,
  print,
  isType,
  isScalarType,
  isObjectType,
  isInterfaceType,
  isUnionType,
  isEnumType,
  isInputObjectType,
  isListType,
  isNonNullType,
  isInputType,
  isOutputType,
  isLeafType,
  isCompositeType,
  isAbstractType,
  assertAbstractType,
  GraphQLList,
  GraphQLNonNull,
  getNullableType,
  isNamedType,
  getNamedType,
  GraphQLScalarType,
  GraphQLObjectType,
  GraphQLInterfaceType,
  GraphQLEnumType,
  GraphQLInputObjectType,
  doTypesOverlap,
  GraphQLFloat,
  GraphQLBoolean,
  astFromValue,
  SchemaMetaFieldDef,
  TypeMetaFieldDef,
  TypeNameMetaFieldDef,
  isSchema,
  validateSchema,
  typeFromAST,
  TypeInfo,
  visitWithTypeInfo,
  isSelectionNode,
  ExecutableDefinitionsRule,
  FragmentsOnCompositeTypesRule,
  KnownDirectivesRule,
  KnownFragmentNamesRule,
  KnownTypeNamesRule,
  LoneSchemaDefinitionRule,
  NoUnusedFragmentsRule,
  PossibleTypeExtensionsRule,
  ProvidedRequiredArgumentsRule,
  UniqueArgumentNamesRule,
  UniqueDirectiveNamesRule,
  UniqueDirectivesPerLocationRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueInputFieldNamesRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueVariableNamesRule,
  specifiedRules,
  validate,
  NoDeprecatedCustomRule,
  getIntrospectionQuery,
  buildClientSchema,
  graphql_exports,
  init_graphql2 as init_graphql
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNodW5rLUZJRUlBS1BDLmpzP3Y9MjI2ZjcyODYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgX19lc20sXG4gIF9fZXhwb3J0XG59IGZyb20gXCIuL2NodW5rLVhQWkxKUUxXLmpzXCI7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvaXNPYmplY3RMaWtlLm1qc1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbnZhciBpbml0X2lzT2JqZWN0TGlrZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2lzT2JqZWN0TGlrZS5tanNcIigpIHtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvaW52YXJpYW50Lm1qc1xuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBjb25zdCBib29sZWFuQ29uZGl0aW9uID0gQm9vbGVhbihjb25kaXRpb24pO1xuICBpZiAoIWJvb2xlYW5Db25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBtZXNzYWdlICE9IG51bGwgPyBtZXNzYWdlIDogXCJVbmV4cGVjdGVkIGludmFyaWFudCB0cmlnZ2VyZWQuXCJcbiAgICApO1xuICB9XG59XG52YXIgaW5pdF9pbnZhcmlhbnQgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9pbnZhcmlhbnQubWpzXCIoKSB7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9sb2NhdGlvbi5tanNcbmZ1bmN0aW9uIGdldExvY2F0aW9uKHNvdXJjZSwgcG9zaXRpb24pIHtcbiAgbGV0IGxhc3RMaW5lU3RhcnQgPSAwO1xuICBsZXQgbGluZSA9IDE7XG4gIGZvciAoY29uc3QgbWF0Y2ggb2Ygc291cmNlLmJvZHkubWF0Y2hBbGwoTGluZVJlZ0V4cCkpIHtcbiAgICB0eXBlb2YgbWF0Y2guaW5kZXggPT09IFwibnVtYmVyXCIgfHwgaW52YXJpYW50KGZhbHNlKTtcbiAgICBpZiAobWF0Y2guaW5kZXggPj0gcG9zaXRpb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsYXN0TGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgbGluZSArPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgbGluZSxcbiAgICBjb2x1bW46IHBvc2l0aW9uICsgMSAtIGxhc3RMaW5lU3RhcnRcbiAgfTtcbn1cbnZhciBMaW5lUmVnRXhwO1xudmFyIGluaXRfbG9jYXRpb24gPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvbG9jYXRpb24ubWpzXCIoKSB7XG4gICAgaW5pdF9pbnZhcmlhbnQoKTtcbiAgICBMaW5lUmVnRXhwID0gL1xcclxcbnxbXFxuXFxyXS9nO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvcHJpbnRMb2NhdGlvbi5tanNcbmZ1bmN0aW9uIHByaW50TG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIHByaW50U291cmNlTG9jYXRpb24oXG4gICAgbG9jYXRpb24uc291cmNlLFxuICAgIGdldExvY2F0aW9uKGxvY2F0aW9uLnNvdXJjZSwgbG9jYXRpb24uc3RhcnQpXG4gICk7XG59XG5mdW5jdGlvbiBwcmludFNvdXJjZUxvY2F0aW9uKHNvdXJjZSwgc291cmNlTG9jYXRpb24pIHtcbiAgY29uc3QgZmlyc3RMaW5lQ29sdW1uT2Zmc2V0ID0gc291cmNlLmxvY2F0aW9uT2Zmc2V0LmNvbHVtbiAtIDE7XG4gIGNvbnN0IGJvZHkgPSBcIlwiLnBhZFN0YXJ0KGZpcnN0TGluZUNvbHVtbk9mZnNldCkgKyBzb3VyY2UuYm9keTtcbiAgY29uc3QgbGluZUluZGV4ID0gc291cmNlTG9jYXRpb24ubGluZSAtIDE7XG4gIGNvbnN0IGxpbmVPZmZzZXQgPSBzb3VyY2UubG9jYXRpb25PZmZzZXQubGluZSAtIDE7XG4gIGNvbnN0IGxpbmVOdW0gPSBzb3VyY2VMb2NhdGlvbi5saW5lICsgbGluZU9mZnNldDtcbiAgY29uc3QgY29sdW1uT2Zmc2V0ID0gc291cmNlTG9jYXRpb24ubGluZSA9PT0gMSA/IGZpcnN0TGluZUNvbHVtbk9mZnNldCA6IDA7XG4gIGNvbnN0IGNvbHVtbk51bSA9IHNvdXJjZUxvY2F0aW9uLmNvbHVtbiArIGNvbHVtbk9mZnNldDtcbiAgY29uc3QgbG9jYXRpb25TdHIgPSBgJHtzb3VyY2UubmFtZX06JHtsaW5lTnVtfToke2NvbHVtbk51bX1cbmA7XG4gIGNvbnN0IGxpbmVzID0gYm9keS5zcGxpdCgvXFxyXFxufFtcXG5cXHJdL2cpO1xuICBjb25zdCBsb2NhdGlvbkxpbmUgPSBsaW5lc1tsaW5lSW5kZXhdO1xuICBpZiAobG9jYXRpb25MaW5lLmxlbmd0aCA+IDEyMCkge1xuICAgIGNvbnN0IHN1YkxpbmVJbmRleCA9IE1hdGguZmxvb3IoY29sdW1uTnVtIC8gODApO1xuICAgIGNvbnN0IHN1YkxpbmVDb2x1bW5OdW0gPSBjb2x1bW5OdW0gJSA4MDtcbiAgICBjb25zdCBzdWJMaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb25MaW5lLmxlbmd0aDsgaSArPSA4MCkge1xuICAgICAgc3ViTGluZXMucHVzaChsb2NhdGlvbkxpbmUuc2xpY2UoaSwgaSArIDgwKSk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhdGlvblN0ciArIHByaW50UHJlZml4ZWRMaW5lcyhbXG4gICAgICBbYCR7bGluZU51bX0gfGAsIHN1YkxpbmVzWzBdXSxcbiAgICAgIC4uLnN1YkxpbmVzLnNsaWNlKDEsIHN1YkxpbmVJbmRleCArIDEpLm1hcCgoc3ViTGluZSkgPT4gW1wifFwiLCBzdWJMaW5lXSksXG4gICAgICBbXCJ8XCIsIFwiXlwiLnBhZFN0YXJ0KHN1YkxpbmVDb2x1bW5OdW0pXSxcbiAgICAgIFtcInxcIiwgc3ViTGluZXNbc3ViTGluZUluZGV4ICsgMV1dXG4gICAgXSk7XG4gIH1cbiAgcmV0dXJuIGxvY2F0aW9uU3RyICsgcHJpbnRQcmVmaXhlZExpbmVzKFtcbiAgICAvLyBMaW5lcyBzcGVjaWZpZWQgbGlrZSB0aGlzOiBbXCJwcmVmaXhcIiwgXCJzdHJpbmdcIl0sXG4gICAgW2Ake2xpbmVOdW0gLSAxfSB8YCwgbGluZXNbbGluZUluZGV4IC0gMV1dLFxuICAgIFtgJHtsaW5lTnVtfSB8YCwgbG9jYXRpb25MaW5lXSxcbiAgICBbXCJ8XCIsIFwiXlwiLnBhZFN0YXJ0KGNvbHVtbk51bSldLFxuICAgIFtgJHtsaW5lTnVtICsgMX0gfGAsIGxpbmVzW2xpbmVJbmRleCArIDFdXVxuICBdKTtcbn1cbmZ1bmN0aW9uIHByaW50UHJlZml4ZWRMaW5lcyhsaW5lcykge1xuICBjb25zdCBleGlzdGluZ0xpbmVzID0gbGluZXMuZmlsdGVyKChbXywgbGluZV0pID0+IGxpbmUgIT09IHZvaWQgMCk7XG4gIGNvbnN0IHBhZExlbiA9IE1hdGgubWF4KC4uLmV4aXN0aW5nTGluZXMubWFwKChbcHJlZml4XSkgPT4gcHJlZml4Lmxlbmd0aCkpO1xuICByZXR1cm4gZXhpc3RpbmdMaW5lcy5tYXAoKFtwcmVmaXgsIGxpbmVdKSA9PiBwcmVmaXgucGFkU3RhcnQocGFkTGVuKSArIChsaW5lID8gXCIgXCIgKyBsaW5lIDogXCJcIikpLmpvaW4oXCJcXG5cIik7XG59XG52YXIgaW5pdF9wcmludExvY2F0aW9uID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3ByaW50TG9jYXRpb24ubWpzXCIoKSB7XG4gICAgaW5pdF9sb2NhdGlvbigpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvZXJyb3IvR3JhcGhRTEVycm9yLm1qc1xuZnVuY3Rpb24gdG9Ob3JtYWxpemVkT3B0aW9ucyhhcmdzKSB7XG4gIGNvbnN0IGZpcnN0QXJnID0gYXJnc1swXTtcbiAgaWYgKGZpcnN0QXJnID09IG51bGwgfHwgXCJraW5kXCIgaW4gZmlyc3RBcmcgfHwgXCJsZW5ndGhcIiBpbiBmaXJzdEFyZykge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlczogZmlyc3RBcmcsXG4gICAgICBzb3VyY2U6IGFyZ3NbMV0sXG4gICAgICBwb3NpdGlvbnM6IGFyZ3NbMl0sXG4gICAgICBwYXRoOiBhcmdzWzNdLFxuICAgICAgb3JpZ2luYWxFcnJvcjogYXJnc1s0XSxcbiAgICAgIGV4dGVuc2lvbnM6IGFyZ3NbNV1cbiAgICB9O1xuICB9XG4gIHJldHVybiBmaXJzdEFyZztcbn1cbmZ1bmN0aW9uIHVuZGVmaW5lZElmRW1wdHkoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5ID09PSB2b2lkIDAgfHwgYXJyYXkubGVuZ3RoID09PSAwID8gdm9pZCAwIDogYXJyYXk7XG59XG5mdW5jdGlvbiBwcmludEVycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvci50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gZm9ybWF0RXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yLnRvSlNPTigpO1xufVxudmFyIEdyYXBoUUxFcnJvcjtcbnZhciBpbml0X0dyYXBoUUxFcnJvciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC9lcnJvci9HcmFwaFFMRXJyb3IubWpzXCIoKSB7XG4gICAgaW5pdF9pc09iamVjdExpa2UoKTtcbiAgICBpbml0X2xvY2F0aW9uKCk7XG4gICAgaW5pdF9wcmludExvY2F0aW9uKCk7XG4gICAgR3JhcGhRTEVycm9yID0gY2xhc3MgX0dyYXBoUUxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAgIC8qKlxuICAgICAgICogQW4gYXJyYXkgb2YgYHsgbGluZSwgY29sdW1uIH1gIGxvY2F0aW9ucyB3aXRoaW4gdGhlIHNvdXJjZSBHcmFwaFFMIGRvY3VtZW50XG4gICAgICAgKiB3aGljaCBjb3JyZXNwb25kIHRvIHRoaXMgZXJyb3IuXG4gICAgICAgKlxuICAgICAgICogRXJyb3JzIGR1cmluZyB2YWxpZGF0aW9uIG9mdGVuIGNvbnRhaW4gbXVsdGlwbGUgbG9jYXRpb25zLCBmb3IgZXhhbXBsZSB0b1xuICAgICAgICogcG9pbnQgb3V0IHR3byB0aGluZ3Mgd2l0aCB0aGUgc2FtZSBuYW1lLiBFcnJvcnMgZHVyaW5nIGV4ZWN1dGlvbiBpbmNsdWRlIGFcbiAgICAgICAqIHNpbmdsZSBsb2NhdGlvbiwgdGhlIGZpZWxkIHdoaWNoIHByb2R1Y2VkIHRoZSBlcnJvci5cbiAgICAgICAqXG4gICAgICAgKiBFbnVtZXJhYmxlLCBhbmQgYXBwZWFycyBpbiB0aGUgcmVzdWx0IG9mIEpTT04uc3RyaW5naWZ5KCkuXG4gICAgICAgKi9cbiAgICAgIC8qKlxuICAgICAgICogQW4gYXJyYXkgZGVzY3JpYmluZyB0aGUgSlNPTi1wYXRoIGludG8gdGhlIGV4ZWN1dGlvbiByZXNwb25zZSB3aGljaFxuICAgICAgICogY29ycmVzcG9uZHMgdG8gdGhpcyBlcnJvci4gT25seSBpbmNsdWRlZCBmb3IgZXJyb3JzIGR1cmluZyBleGVjdXRpb24uXG4gICAgICAgKlxuICAgICAgICogRW51bWVyYWJsZSwgYW5kIGFwcGVhcnMgaW4gdGhlIHJlc3VsdCBvZiBKU09OLnN0cmluZ2lmeSgpLlxuICAgICAgICovXG4gICAgICAvKipcbiAgICAgICAqIEFuIGFycmF5IG9mIEdyYXBoUUwgQVNUIE5vZGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBlcnJvci5cbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgc291cmNlIEdyYXBoUUwgZG9jdW1lbnQgZm9yIHRoZSBmaXJzdCBsb2NhdGlvbiBvZiB0aGlzIGVycm9yLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhhdCBpZiB0aGlzIEVycm9yIHJlcHJlc2VudHMgbW9yZSB0aGFuIG9uZSBub2RlLCB0aGUgc291cmNlIG1heSBub3RcbiAgICAgICAqIHJlcHJlc2VudCBub2RlcyBhZnRlciB0aGUgZmlyc3Qgbm9kZS5cbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiBBbiBhcnJheSBvZiBjaGFyYWN0ZXIgb2Zmc2V0cyB3aXRoaW4gdGhlIHNvdXJjZSBHcmFwaFFMIGRvY3VtZW50XG4gICAgICAgKiB3aGljaCBjb3JyZXNwb25kIHRvIHRoaXMgZXJyb3IuXG4gICAgICAgKi9cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG9yaWdpbmFsIGVycm9yIHRocm93biBmcm9tIGEgZmllbGQgcmVzb2x2ZXIgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiBFeHRlbnNpb24gZmllbGRzIHRvIGFkZCB0byB0aGUgZm9ybWF0dGVkIGVycm9yLlxuICAgICAgICovXG4gICAgICAvKipcbiAgICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgdGhlIGBHcmFwaFFMRXJyb3JPcHRpb25zYCBjb25zdHJ1Y3RvciBvdmVybG9hZCBpbnN0ZWFkLlxuICAgICAgICovXG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCAuLi5yYXdBcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyRub2RlcywgX25vZGVMb2NhdGlvbnMkLCBfcmVmO1xuICAgICAgICBjb25zdCB7IG5vZGVzLCBzb3VyY2UsIHBvc2l0aW9ucywgcGF0aCwgb3JpZ2luYWxFcnJvciwgZXh0ZW5zaW9ucyB9ID0gdG9Ob3JtYWxpemVkT3B0aW9ucyhyYXdBcmdzKTtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiR3JhcGhRTEVycm9yXCI7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGggIT09IG51bGwgJiYgcGF0aCAhPT0gdm9pZCAwID8gcGF0aCA6IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvciAhPT0gbnVsbCAmJiBvcmlnaW5hbEVycm9yICE9PSB2b2lkIDAgPyBvcmlnaW5hbEVycm9yIDogdm9pZCAwO1xuICAgICAgICB0aGlzLm5vZGVzID0gdW5kZWZpbmVkSWZFbXB0eShcbiAgICAgICAgICBBcnJheS5pc0FycmF5KG5vZGVzKSA/IG5vZGVzIDogbm9kZXMgPyBbbm9kZXNdIDogdm9pZCAwXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG5vZGVMb2NhdGlvbnMgPSB1bmRlZmluZWRJZkVtcHR5KFxuICAgICAgICAgIChfdGhpcyRub2RlcyA9IHRoaXMubm9kZXMpID09PSBudWxsIHx8IF90aGlzJG5vZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUubG9jKS5maWx0ZXIoKGxvYykgPT4gbG9jICE9IG51bGwpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlICE9PSBudWxsICYmIHNvdXJjZSAhPT0gdm9pZCAwID8gc291cmNlIDogbm9kZUxvY2F0aW9ucyA9PT0gbnVsbCB8fCBub2RlTG9jYXRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX25vZGVMb2NhdGlvbnMkID0gbm9kZUxvY2F0aW9uc1swXSkgPT09IG51bGwgfHwgX25vZGVMb2NhdGlvbnMkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZUxvY2F0aW9ucyQuc291cmNlO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucyAhPT0gbnVsbCAmJiBwb3NpdGlvbnMgIT09IHZvaWQgMCA/IHBvc2l0aW9ucyA6IG5vZGVMb2NhdGlvbnMgPT09IG51bGwgfHwgbm9kZUxvY2F0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZUxvY2F0aW9ucy5tYXAoKGxvYykgPT4gbG9jLnN0YXJ0KTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbnMgPSBwb3NpdGlvbnMgJiYgc291cmNlID8gcG9zaXRpb25zLm1hcCgocG9zKSA9PiBnZXRMb2NhdGlvbihzb3VyY2UsIHBvcykpIDogbm9kZUxvY2F0aW9ucyA9PT0gbnVsbCB8fCBub2RlTG9jYXRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlTG9jYXRpb25zLm1hcCgobG9jKSA9PiBnZXRMb2NhdGlvbihsb2Muc291cmNlLCBsb2Muc3RhcnQpKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxFeHRlbnNpb25zID0gaXNPYmplY3RMaWtlKFxuICAgICAgICAgIG9yaWdpbmFsRXJyb3IgPT09IG51bGwgfHwgb3JpZ2luYWxFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWxFcnJvci5leHRlbnNpb25zXG4gICAgICAgICkgPyBvcmlnaW5hbEVycm9yID09PSBudWxsIHx8IG9yaWdpbmFsRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsRXJyb3IuZXh0ZW5zaW9ucyA6IHZvaWQgMDtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gKF9yZWYgPSBleHRlbnNpb25zICE9PSBudWxsICYmIGV4dGVuc2lvbnMgIT09IHZvaWQgMCA/IGV4dGVuc2lvbnMgOiBvcmlnaW5hbEV4dGVuc2lvbnMpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5vZGVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9zaXRpb25zOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3JpZ2luYWxFcnJvcjoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3JpZ2luYWxFcnJvciAhPT0gbnVsbCAmJiBvcmlnaW5hbEVycm9yICE9PSB2b2lkIDAgJiYgb3JpZ2luYWxFcnJvci5zdGFjaykge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbEVycm9yLnN0YWNrLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIF9HcmFwaFFMRXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBFcnJvcigpLnN0YWNrLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJHcmFwaFFMRXJyb3JcIjtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgb3V0cHV0ID0gdGhpcy5tZXNzYWdlO1xuICAgICAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sb2MpIHtcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IFwiXFxuXFxuXCIgKyBwcmludExvY2F0aW9uKG5vZGUubG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zb3VyY2UgJiYgdGhpcy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGxvY2F0aW9uIG9mIHRoaXMubG9jYXRpb25zKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gXCJcXG5cXG5cIiArIHByaW50U291cmNlTG9jYXRpb24odGhpcy5zb3VyY2UsIGxvY2F0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH1cbiAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkRXJyb3IgPSB7XG4gICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmxvY2F0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgZm9ybWF0dGVkRXJyb3IubG9jYXRpb25zID0gdGhpcy5sb2NhdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgZm9ybWF0dGVkRXJyb3IucGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leHRlbnNpb25zICE9IG51bGwgJiYgT2JqZWN0LmtleXModGhpcy5leHRlbnNpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9ybWF0dGVkRXJyb3IuZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkRXJyb3I7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2Vycm9yL3N5bnRheEVycm9yLm1qc1xuZnVuY3Rpb24gc3ludGF4RXJyb3Ioc291cmNlLCBwb3NpdGlvbiwgZGVzY3JpcHRpb24pIHtcbiAgcmV0dXJuIG5ldyBHcmFwaFFMRXJyb3IoYFN5bnRheCBFcnJvcjogJHtkZXNjcmlwdGlvbn1gLCB7XG4gICAgc291cmNlLFxuICAgIHBvc2l0aW9uczogW3Bvc2l0aW9uXVxuICB9KTtcbn1cbnZhciBpbml0X3N5bnRheEVycm9yID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2Vycm9yL3N5bnRheEVycm9yLm1qc1wiKCkge1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9hc3QubWpzXG5mdW5jdGlvbiBpc05vZGUobWF5YmVOb2RlKSB7XG4gIGNvbnN0IG1heWJlS2luZCA9IG1heWJlTm9kZSA9PT0gbnVsbCB8fCBtYXliZU5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heWJlTm9kZS5raW5kO1xuICByZXR1cm4gdHlwZW9mIG1heWJlS2luZCA9PT0gXCJzdHJpbmdcIiAmJiBraW5kVmFsdWVzLmhhcyhtYXliZUtpbmQpO1xufVxudmFyIExvY2F0aW9uLCBUb2tlbiwgUXVlcnlEb2N1bWVudEtleXMsIGtpbmRWYWx1ZXMsIE9wZXJhdGlvblR5cGVOb2RlO1xudmFyIGluaXRfYXN0ID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2FzdC5tanNcIigpIHtcbiAgICBMb2NhdGlvbiA9IGNsYXNzIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGNoYXJhY3RlciBvZmZzZXQgYXQgd2hpY2ggdGhpcyBOb2RlIGJlZ2lucy5cbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY2hhcmFjdGVyIG9mZnNldCBhdCB3aGljaCB0aGlzIE5vZGUgZW5kcy5cbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgVG9rZW4gYXQgd2hpY2ggdGhpcyBOb2RlIGJlZ2lucy5cbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgVG9rZW4gYXQgd2hpY2ggdGhpcyBOb2RlIGVuZHMuXG4gICAgICAgKi9cbiAgICAgIC8qKlxuICAgICAgICogVGhlIFNvdXJjZSBkb2N1bWVudCB0aGUgQVNUIHJlcHJlc2VudHMuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0cnVjdG9yKHN0YXJ0VG9rZW4sIGVuZFRva2VuLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0VG9rZW4uc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kVG9rZW4uZW5kO1xuICAgICAgICB0aGlzLnN0YXJ0VG9rZW4gPSBzdGFydFRva2VuO1xuICAgICAgICB0aGlzLmVuZFRva2VuID0gZW5kVG9rZW47XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJMb2NhdGlvblwiO1xuICAgICAgfVxuICAgICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgICAgIGVuZDogdGhpcy5lbmRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuID0gY2xhc3Mge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUga2luZCBvZiBUb2tlbi5cbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY2hhcmFjdGVyIG9mZnNldCBhdCB3aGljaCB0aGlzIE5vZGUgYmVnaW5zLlxuICAgICAgICovXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjaGFyYWN0ZXIgb2Zmc2V0IGF0IHdoaWNoIHRoaXMgTm9kZSBlbmRzLlxuICAgICAgICovXG4gICAgICAvKipcbiAgICAgICAqIFRoZSAxLWluZGV4ZWQgbGluZSBudW1iZXIgb24gd2hpY2ggdGhpcyBUb2tlbiBhcHBlYXJzLlxuICAgICAgICovXG4gICAgICAvKipcbiAgICAgICAqIFRoZSAxLWluZGV4ZWQgY29sdW1uIG51bWJlciBhdCB3aGljaCB0aGlzIFRva2VuIGJlZ2lucy5cbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiBGb3Igbm9uLXB1bmN0dWF0aW9uIHRva2VucywgcmVwcmVzZW50cyB0aGUgaW50ZXJwcmV0ZWQgdmFsdWUgb2YgdGhlIHRva2VuLlxuICAgICAgICpcbiAgICAgICAqIE5vdGU6IGlzIHVuZGVmaW5lZCBmb3IgcHVuY3R1YXRpb24gdG9rZW5zLCBidXQgdHlwZWQgYXMgc3RyaW5nIGZvclxuICAgICAgICogY29udmVuaWVuY2UgaW4gdGhlIHBhcnNlci5cbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiBUb2tlbnMgZXhpc3QgYXMgbm9kZXMgaW4gYSBkb3VibGUtbGlua2VkLWxpc3QgYW1vbmdzdCBhbGwgdG9rZW5zXG4gICAgICAgKiBpbmNsdWRpbmcgaWdub3JlZCB0b2tlbnMuIDxTT0Y+IGlzIGFsd2F5cyB0aGUgZmlyc3Qgbm9kZSBhbmQgPEVPRj5cbiAgICAgICAqIHRoZSBsYXN0LlxuICAgICAgICovXG4gICAgICBjb25zdHJ1Y3RvcihraW5kLCBzdGFydCwgZW5kLCBsaW5lLCBjb2x1bW4sIHZhbHVlKSB7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICB9XG4gICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiBcIlRva2VuXCI7XG4gICAgICB9XG4gICAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBRdWVyeURvY3VtZW50S2V5cyA9IHtcbiAgICAgIE5hbWU6IFtdLFxuICAgICAgRG9jdW1lbnQ6IFtcImRlZmluaXRpb25zXCJdLFxuICAgICAgT3BlcmF0aW9uRGVmaW5pdGlvbjogW1xuICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgXCJ2YXJpYWJsZURlZmluaXRpb25zXCIsXG4gICAgICAgIFwiZGlyZWN0aXZlc1wiLFxuICAgICAgICBcInNlbGVjdGlvblNldFwiXG4gICAgICBdLFxuICAgICAgVmFyaWFibGVEZWZpbml0aW9uOiBbXCJ2YXJpYWJsZVwiLCBcInR5cGVcIiwgXCJkZWZhdWx0VmFsdWVcIiwgXCJkaXJlY3RpdmVzXCJdLFxuICAgICAgVmFyaWFibGU6IFtcIm5hbWVcIl0sXG4gICAgICBTZWxlY3Rpb25TZXQ6IFtcInNlbGVjdGlvbnNcIl0sXG4gICAgICBGaWVsZDogW1wiYWxpYXNcIiwgXCJuYW1lXCIsIFwiYXJndW1lbnRzXCIsIFwiZGlyZWN0aXZlc1wiLCBcInNlbGVjdGlvblNldFwiXSxcbiAgICAgIEFyZ3VtZW50OiBbXCJuYW1lXCIsIFwidmFsdWVcIl0sXG4gICAgICBGcmFnbWVudFNwcmVhZDogW1wibmFtZVwiLCBcImRpcmVjdGl2ZXNcIl0sXG4gICAgICBJbmxpbmVGcmFnbWVudDogW1widHlwZUNvbmRpdGlvblwiLCBcImRpcmVjdGl2ZXNcIiwgXCJzZWxlY3Rpb25TZXRcIl0sXG4gICAgICBGcmFnbWVudERlZmluaXRpb246IFtcbiAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgIC8vIE5vdGU6IGZyYWdtZW50IHZhcmlhYmxlIGRlZmluaXRpb25zIGFyZSBkZXByZWNhdGVkIGFuZCB3aWxsIHJlbW92ZWQgaW4gdjE3LjAuMFxuICAgICAgICBcInZhcmlhYmxlRGVmaW5pdGlvbnNcIixcbiAgICAgICAgXCJ0eXBlQ29uZGl0aW9uXCIsXG4gICAgICAgIFwiZGlyZWN0aXZlc1wiLFxuICAgICAgICBcInNlbGVjdGlvblNldFwiXG4gICAgICBdLFxuICAgICAgSW50VmFsdWU6IFtdLFxuICAgICAgRmxvYXRWYWx1ZTogW10sXG4gICAgICBTdHJpbmdWYWx1ZTogW10sXG4gICAgICBCb29sZWFuVmFsdWU6IFtdLFxuICAgICAgTnVsbFZhbHVlOiBbXSxcbiAgICAgIEVudW1WYWx1ZTogW10sXG4gICAgICBMaXN0VmFsdWU6IFtcInZhbHVlc1wiXSxcbiAgICAgIE9iamVjdFZhbHVlOiBbXCJmaWVsZHNcIl0sXG4gICAgICBPYmplY3RGaWVsZDogW1wibmFtZVwiLCBcInZhbHVlXCJdLFxuICAgICAgRGlyZWN0aXZlOiBbXCJuYW1lXCIsIFwiYXJndW1lbnRzXCJdLFxuICAgICAgTmFtZWRUeXBlOiBbXCJuYW1lXCJdLFxuICAgICAgTGlzdFR5cGU6IFtcInR5cGVcIl0sXG4gICAgICBOb25OdWxsVHlwZTogW1widHlwZVwiXSxcbiAgICAgIFNjaGVtYURlZmluaXRpb246IFtcImRlc2NyaXB0aW9uXCIsIFwiZGlyZWN0aXZlc1wiLCBcIm9wZXJhdGlvblR5cGVzXCJdLFxuICAgICAgT3BlcmF0aW9uVHlwZURlZmluaXRpb246IFtcInR5cGVcIl0sXG4gICAgICBTY2FsYXJUeXBlRGVmaW5pdGlvbjogW1wiZGVzY3JpcHRpb25cIiwgXCJuYW1lXCIsIFwiZGlyZWN0aXZlc1wiXSxcbiAgICAgIE9iamVjdFR5cGVEZWZpbml0aW9uOiBbXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIixcbiAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgIFwiaW50ZXJmYWNlc1wiLFxuICAgICAgICBcImRpcmVjdGl2ZXNcIixcbiAgICAgICAgXCJmaWVsZHNcIlxuICAgICAgXSxcbiAgICAgIEZpZWxkRGVmaW5pdGlvbjogW1wiZGVzY3JpcHRpb25cIiwgXCJuYW1lXCIsIFwiYXJndW1lbnRzXCIsIFwidHlwZVwiLCBcImRpcmVjdGl2ZXNcIl0sXG4gICAgICBJbnB1dFZhbHVlRGVmaW5pdGlvbjogW1xuICAgICAgICBcImRlc2NyaXB0aW9uXCIsXG4gICAgICAgIFwibmFtZVwiLFxuICAgICAgICBcInR5cGVcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIixcbiAgICAgICAgXCJkaXJlY3RpdmVzXCJcbiAgICAgIF0sXG4gICAgICBJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbjogW1xuICAgICAgICBcImRlc2NyaXB0aW9uXCIsXG4gICAgICAgIFwibmFtZVwiLFxuICAgICAgICBcImludGVyZmFjZXNcIixcbiAgICAgICAgXCJkaXJlY3RpdmVzXCIsXG4gICAgICAgIFwiZmllbGRzXCJcbiAgICAgIF0sXG4gICAgICBVbmlvblR5cGVEZWZpbml0aW9uOiBbXCJkZXNjcmlwdGlvblwiLCBcIm5hbWVcIiwgXCJkaXJlY3RpdmVzXCIsIFwidHlwZXNcIl0sXG4gICAgICBFbnVtVHlwZURlZmluaXRpb246IFtcImRlc2NyaXB0aW9uXCIsIFwibmFtZVwiLCBcImRpcmVjdGl2ZXNcIiwgXCJ2YWx1ZXNcIl0sXG4gICAgICBFbnVtVmFsdWVEZWZpbml0aW9uOiBbXCJkZXNjcmlwdGlvblwiLCBcIm5hbWVcIiwgXCJkaXJlY3RpdmVzXCJdLFxuICAgICAgSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbjogW1wiZGVzY3JpcHRpb25cIiwgXCJuYW1lXCIsIFwiZGlyZWN0aXZlc1wiLCBcImZpZWxkc1wiXSxcbiAgICAgIERpcmVjdGl2ZURlZmluaXRpb246IFtcImRlc2NyaXB0aW9uXCIsIFwibmFtZVwiLCBcImFyZ3VtZW50c1wiLCBcImxvY2F0aW9uc1wiXSxcbiAgICAgIFNjaGVtYUV4dGVuc2lvbjogW1wiZGlyZWN0aXZlc1wiLCBcIm9wZXJhdGlvblR5cGVzXCJdLFxuICAgICAgU2NhbGFyVHlwZUV4dGVuc2lvbjogW1wibmFtZVwiLCBcImRpcmVjdGl2ZXNcIl0sXG4gICAgICBPYmplY3RUeXBlRXh0ZW5zaW9uOiBbXCJuYW1lXCIsIFwiaW50ZXJmYWNlc1wiLCBcImRpcmVjdGl2ZXNcIiwgXCJmaWVsZHNcIl0sXG4gICAgICBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uOiBbXCJuYW1lXCIsIFwiaW50ZXJmYWNlc1wiLCBcImRpcmVjdGl2ZXNcIiwgXCJmaWVsZHNcIl0sXG4gICAgICBVbmlvblR5cGVFeHRlbnNpb246IFtcIm5hbWVcIiwgXCJkaXJlY3RpdmVzXCIsIFwidHlwZXNcIl0sXG4gICAgICBFbnVtVHlwZUV4dGVuc2lvbjogW1wibmFtZVwiLCBcImRpcmVjdGl2ZXNcIiwgXCJ2YWx1ZXNcIl0sXG4gICAgICBJbnB1dE9iamVjdFR5cGVFeHRlbnNpb246IFtcIm5hbWVcIiwgXCJkaXJlY3RpdmVzXCIsIFwiZmllbGRzXCJdXG4gICAgfTtcbiAgICBraW5kVmFsdWVzID0gbmV3IFNldChPYmplY3Qua2V5cyhRdWVyeURvY3VtZW50S2V5cykpO1xuICAgIChmdW5jdGlvbihPcGVyYXRpb25UeXBlTm9kZTIpIHtcbiAgICAgIE9wZXJhdGlvblR5cGVOb2RlMltcIlFVRVJZXCJdID0gXCJxdWVyeVwiO1xuICAgICAgT3BlcmF0aW9uVHlwZU5vZGUyW1wiTVVUQVRJT05cIl0gPSBcIm11dGF0aW9uXCI7XG4gICAgICBPcGVyYXRpb25UeXBlTm9kZTJbXCJTVUJTQ1JJUFRJT05cIl0gPSBcInN1YnNjcmlwdGlvblwiO1xuICAgIH0pKE9wZXJhdGlvblR5cGVOb2RlIHx8IChPcGVyYXRpb25UeXBlTm9kZSA9IHt9KSk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9kaXJlY3RpdmVMb2NhdGlvbi5tanNcbnZhciBEaXJlY3RpdmVMb2NhdGlvbjtcbnZhciBpbml0X2RpcmVjdGl2ZUxvY2F0aW9uID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2RpcmVjdGl2ZUxvY2F0aW9uLm1qc1wiKCkge1xuICAgIChmdW5jdGlvbihEaXJlY3RpdmVMb2NhdGlvbjIpIHtcbiAgICAgIERpcmVjdGl2ZUxvY2F0aW9uMltcIlFVRVJZXCJdID0gXCJRVUVSWVwiO1xuICAgICAgRGlyZWN0aXZlTG9jYXRpb24yW1wiTVVUQVRJT05cIl0gPSBcIk1VVEFUSU9OXCI7XG4gICAgICBEaXJlY3RpdmVMb2NhdGlvbjJbXCJTVUJTQ1JJUFRJT05cIl0gPSBcIlNVQlNDUklQVElPTlwiO1xuICAgICAgRGlyZWN0aXZlTG9jYXRpb24yW1wiRklFTERcIl0gPSBcIkZJRUxEXCI7XG4gICAgICBEaXJlY3RpdmVMb2NhdGlvbjJbXCJGUkFHTUVOVF9ERUZJTklUSU9OXCJdID0gXCJGUkFHTUVOVF9ERUZJTklUSU9OXCI7XG4gICAgICBEaXJlY3RpdmVMb2NhdGlvbjJbXCJGUkFHTUVOVF9TUFJFQURcIl0gPSBcIkZSQUdNRU5UX1NQUkVBRFwiO1xuICAgICAgRGlyZWN0aXZlTG9jYXRpb24yW1wiSU5MSU5FX0ZSQUdNRU5UXCJdID0gXCJJTkxJTkVfRlJBR01FTlRcIjtcbiAgICAgIERpcmVjdGl2ZUxvY2F0aW9uMltcIlZBUklBQkxFX0RFRklOSVRJT05cIl0gPSBcIlZBUklBQkxFX0RFRklOSVRJT05cIjtcbiAgICAgIERpcmVjdGl2ZUxvY2F0aW9uMltcIlNDSEVNQVwiXSA9IFwiU0NIRU1BXCI7XG4gICAgICBEaXJlY3RpdmVMb2NhdGlvbjJbXCJTQ0FMQVJcIl0gPSBcIlNDQUxBUlwiO1xuICAgICAgRGlyZWN0aXZlTG9jYXRpb24yW1wiT0JKRUNUXCJdID0gXCJPQkpFQ1RcIjtcbiAgICAgIERpcmVjdGl2ZUxvY2F0aW9uMltcIkZJRUxEX0RFRklOSVRJT05cIl0gPSBcIkZJRUxEX0RFRklOSVRJT05cIjtcbiAgICAgIERpcmVjdGl2ZUxvY2F0aW9uMltcIkFSR1VNRU5UX0RFRklOSVRJT05cIl0gPSBcIkFSR1VNRU5UX0RFRklOSVRJT05cIjtcbiAgICAgIERpcmVjdGl2ZUxvY2F0aW9uMltcIklOVEVSRkFDRVwiXSA9IFwiSU5URVJGQUNFXCI7XG4gICAgICBEaXJlY3RpdmVMb2NhdGlvbjJbXCJVTklPTlwiXSA9IFwiVU5JT05cIjtcbiAgICAgIERpcmVjdGl2ZUxvY2F0aW9uMltcIkVOVU1cIl0gPSBcIkVOVU1cIjtcbiAgICAgIERpcmVjdGl2ZUxvY2F0aW9uMltcIkVOVU1fVkFMVUVcIl0gPSBcIkVOVU1fVkFMVUVcIjtcbiAgICAgIERpcmVjdGl2ZUxvY2F0aW9uMltcIklOUFVUX09CSkVDVFwiXSA9IFwiSU5QVVRfT0JKRUNUXCI7XG4gICAgICBEaXJlY3RpdmVMb2NhdGlvbjJbXCJJTlBVVF9GSUVMRF9ERUZJTklUSU9OXCJdID0gXCJJTlBVVF9GSUVMRF9ERUZJTklUSU9OXCI7XG4gICAgfSkoRGlyZWN0aXZlTG9jYXRpb24gfHwgKERpcmVjdGl2ZUxvY2F0aW9uID0ge30pKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2tpbmRzLm1qc1xudmFyIEtpbmQ7XG52YXIgaW5pdF9raW5kcyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9raW5kcy5tanNcIigpIHtcbiAgICAoZnVuY3Rpb24oS2luZDIpIHtcbiAgICAgIEtpbmQyW1wiTkFNRVwiXSA9IFwiTmFtZVwiO1xuICAgICAgS2luZDJbXCJET0NVTUVOVFwiXSA9IFwiRG9jdW1lbnRcIjtcbiAgICAgIEtpbmQyW1wiT1BFUkFUSU9OX0RFRklOSVRJT05cIl0gPSBcIk9wZXJhdGlvbkRlZmluaXRpb25cIjtcbiAgICAgIEtpbmQyW1wiVkFSSUFCTEVfREVGSU5JVElPTlwiXSA9IFwiVmFyaWFibGVEZWZpbml0aW9uXCI7XG4gICAgICBLaW5kMltcIlNFTEVDVElPTl9TRVRcIl0gPSBcIlNlbGVjdGlvblNldFwiO1xuICAgICAgS2luZDJbXCJGSUVMRFwiXSA9IFwiRmllbGRcIjtcbiAgICAgIEtpbmQyW1wiQVJHVU1FTlRcIl0gPSBcIkFyZ3VtZW50XCI7XG4gICAgICBLaW5kMltcIkZSQUdNRU5UX1NQUkVBRFwiXSA9IFwiRnJhZ21lbnRTcHJlYWRcIjtcbiAgICAgIEtpbmQyW1wiSU5MSU5FX0ZSQUdNRU5UXCJdID0gXCJJbmxpbmVGcmFnbWVudFwiO1xuICAgICAgS2luZDJbXCJGUkFHTUVOVF9ERUZJTklUSU9OXCJdID0gXCJGcmFnbWVudERlZmluaXRpb25cIjtcbiAgICAgIEtpbmQyW1wiVkFSSUFCTEVcIl0gPSBcIlZhcmlhYmxlXCI7XG4gICAgICBLaW5kMltcIklOVFwiXSA9IFwiSW50VmFsdWVcIjtcbiAgICAgIEtpbmQyW1wiRkxPQVRcIl0gPSBcIkZsb2F0VmFsdWVcIjtcbiAgICAgIEtpbmQyW1wiU1RSSU5HXCJdID0gXCJTdHJpbmdWYWx1ZVwiO1xuICAgICAgS2luZDJbXCJCT09MRUFOXCJdID0gXCJCb29sZWFuVmFsdWVcIjtcbiAgICAgIEtpbmQyW1wiTlVMTFwiXSA9IFwiTnVsbFZhbHVlXCI7XG4gICAgICBLaW5kMltcIkVOVU1cIl0gPSBcIkVudW1WYWx1ZVwiO1xuICAgICAgS2luZDJbXCJMSVNUXCJdID0gXCJMaXN0VmFsdWVcIjtcbiAgICAgIEtpbmQyW1wiT0JKRUNUXCJdID0gXCJPYmplY3RWYWx1ZVwiO1xuICAgICAgS2luZDJbXCJPQkpFQ1RfRklFTERcIl0gPSBcIk9iamVjdEZpZWxkXCI7XG4gICAgICBLaW5kMltcIkRJUkVDVElWRVwiXSA9IFwiRGlyZWN0aXZlXCI7XG4gICAgICBLaW5kMltcIk5BTUVEX1RZUEVcIl0gPSBcIk5hbWVkVHlwZVwiO1xuICAgICAgS2luZDJbXCJMSVNUX1RZUEVcIl0gPSBcIkxpc3RUeXBlXCI7XG4gICAgICBLaW5kMltcIk5PTl9OVUxMX1RZUEVcIl0gPSBcIk5vbk51bGxUeXBlXCI7XG4gICAgICBLaW5kMltcIlNDSEVNQV9ERUZJTklUSU9OXCJdID0gXCJTY2hlbWFEZWZpbml0aW9uXCI7XG4gICAgICBLaW5kMltcIk9QRVJBVElPTl9UWVBFX0RFRklOSVRJT05cIl0gPSBcIk9wZXJhdGlvblR5cGVEZWZpbml0aW9uXCI7XG4gICAgICBLaW5kMltcIlNDQUxBUl9UWVBFX0RFRklOSVRJT05cIl0gPSBcIlNjYWxhclR5cGVEZWZpbml0aW9uXCI7XG4gICAgICBLaW5kMltcIk9CSkVDVF9UWVBFX0RFRklOSVRJT05cIl0gPSBcIk9iamVjdFR5cGVEZWZpbml0aW9uXCI7XG4gICAgICBLaW5kMltcIkZJRUxEX0RFRklOSVRJT05cIl0gPSBcIkZpZWxkRGVmaW5pdGlvblwiO1xuICAgICAgS2luZDJbXCJJTlBVVF9WQUxVRV9ERUZJTklUSU9OXCJdID0gXCJJbnB1dFZhbHVlRGVmaW5pdGlvblwiO1xuICAgICAgS2luZDJbXCJJTlRFUkZBQ0VfVFlQRV9ERUZJTklUSU9OXCJdID0gXCJJbnRlcmZhY2VUeXBlRGVmaW5pdGlvblwiO1xuICAgICAgS2luZDJbXCJVTklPTl9UWVBFX0RFRklOSVRJT05cIl0gPSBcIlVuaW9uVHlwZURlZmluaXRpb25cIjtcbiAgICAgIEtpbmQyW1wiRU5VTV9UWVBFX0RFRklOSVRJT05cIl0gPSBcIkVudW1UeXBlRGVmaW5pdGlvblwiO1xuICAgICAgS2luZDJbXCJFTlVNX1ZBTFVFX0RFRklOSVRJT05cIl0gPSBcIkVudW1WYWx1ZURlZmluaXRpb25cIjtcbiAgICAgIEtpbmQyW1wiSU5QVVRfT0JKRUNUX1RZUEVfREVGSU5JVElPTlwiXSA9IFwiSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvblwiO1xuICAgICAgS2luZDJbXCJESVJFQ1RJVkVfREVGSU5JVElPTlwiXSA9IFwiRGlyZWN0aXZlRGVmaW5pdGlvblwiO1xuICAgICAgS2luZDJbXCJTQ0hFTUFfRVhURU5TSU9OXCJdID0gXCJTY2hlbWFFeHRlbnNpb25cIjtcbiAgICAgIEtpbmQyW1wiU0NBTEFSX1RZUEVfRVhURU5TSU9OXCJdID0gXCJTY2FsYXJUeXBlRXh0ZW5zaW9uXCI7XG4gICAgICBLaW5kMltcIk9CSkVDVF9UWVBFX0VYVEVOU0lPTlwiXSA9IFwiT2JqZWN0VHlwZUV4dGVuc2lvblwiO1xuICAgICAgS2luZDJbXCJJTlRFUkZBQ0VfVFlQRV9FWFRFTlNJT05cIl0gPSBcIkludGVyZmFjZVR5cGVFeHRlbnNpb25cIjtcbiAgICAgIEtpbmQyW1wiVU5JT05fVFlQRV9FWFRFTlNJT05cIl0gPSBcIlVuaW9uVHlwZUV4dGVuc2lvblwiO1xuICAgICAgS2luZDJbXCJFTlVNX1RZUEVfRVhURU5TSU9OXCJdID0gXCJFbnVtVHlwZUV4dGVuc2lvblwiO1xuICAgICAgS2luZDJbXCJJTlBVVF9PQkpFQ1RfVFlQRV9FWFRFTlNJT05cIl0gPSBcIklucHV0T2JqZWN0VHlwZUV4dGVuc2lvblwiO1xuICAgIH0pKEtpbmQgfHwgKEtpbmQgPSB7fSkpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvY2hhcmFjdGVyQ2xhc3Nlcy5tanNcbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSA5IHx8IGNvZGUgPT09IDMyO1xufVxuZnVuY3Rpb24gaXNEaWdpdChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTc7XG59XG5mdW5jdGlvbiBpc0xldHRlcihjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyIHx8IC8vIEEtWlxuICBjb2RlID49IDY1ICYmIGNvZGUgPD0gOTA7XG59XG5mdW5jdGlvbiBpc05hbWVTdGFydChjb2RlKSB7XG4gIHJldHVybiBpc0xldHRlcihjb2RlKSB8fCBjb2RlID09PSA5NTtcbn1cbmZ1bmN0aW9uIGlzTmFtZUNvbnRpbnVlKGNvZGUpIHtcbiAgcmV0dXJuIGlzTGV0dGVyKGNvZGUpIHx8IGlzRGlnaXQoY29kZSkgfHwgY29kZSA9PT0gOTU7XG59XG52YXIgaW5pdF9jaGFyYWN0ZXJDbGFzc2VzID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2NoYXJhY3RlckNsYXNzZXMubWpzXCIoKSB7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9ibG9ja1N0cmluZy5tanNcbmZ1bmN0aW9uIGRlZGVudEJsb2NrU3RyaW5nTGluZXMobGluZXMpIHtcbiAgdmFyIF9maXJzdE5vbkVtcHR5TGluZTI7XG4gIGxldCBjb21tb25JbmRlbnQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgbGV0IGZpcnN0Tm9uRW1wdHlMaW5lID0gbnVsbDtcbiAgbGV0IGxhc3ROb25FbXB0eUxpbmUgPSAtMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBfZmlyc3ROb25FbXB0eUxpbmU7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgIGNvbnN0IGluZGVudDIgPSBsZWFkaW5nV2hpdGVzcGFjZShsaW5lKTtcbiAgICBpZiAoaW5kZW50MiA9PT0gbGluZS5sZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmaXJzdE5vbkVtcHR5TGluZSA9IChfZmlyc3ROb25FbXB0eUxpbmUgPSBmaXJzdE5vbkVtcHR5TGluZSkgIT09IG51bGwgJiYgX2ZpcnN0Tm9uRW1wdHlMaW5lICE9PSB2b2lkIDAgPyBfZmlyc3ROb25FbXB0eUxpbmUgOiBpO1xuICAgIGxhc3ROb25FbXB0eUxpbmUgPSBpO1xuICAgIGlmIChpICE9PSAwICYmIGluZGVudDIgPCBjb21tb25JbmRlbnQpIHtcbiAgICAgIGNvbW1vbkluZGVudCA9IGluZGVudDI7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaW5lcy5tYXAoKGxpbmUsIGkpID0+IGkgPT09IDAgPyBsaW5lIDogbGluZS5zbGljZShjb21tb25JbmRlbnQpKS5zbGljZShcbiAgICAoX2ZpcnN0Tm9uRW1wdHlMaW5lMiA9IGZpcnN0Tm9uRW1wdHlMaW5lKSAhPT0gbnVsbCAmJiBfZmlyc3ROb25FbXB0eUxpbmUyICE9PSB2b2lkIDAgPyBfZmlyc3ROb25FbXB0eUxpbmUyIDogMCxcbiAgICBsYXN0Tm9uRW1wdHlMaW5lICsgMVxuICApO1xufVxuZnVuY3Rpb24gbGVhZGluZ1doaXRlc3BhY2Uoc3RyKSB7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoICYmIGlzV2hpdGVTcGFjZShzdHIuY2hhckNvZGVBdChpKSkpIHtcbiAgICArK2k7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBpc1ByaW50YWJsZUFzQmxvY2tTdHJpbmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbGV0IGlzRW1wdHlMaW5lID0gdHJ1ZTtcbiAgbGV0IGhhc0luZGVudCA9IGZhbHNlO1xuICBsZXQgaGFzQ29tbW9uSW5kZW50ID0gdHJ1ZTtcbiAgbGV0IHNlZW5Ob25FbXB0eUxpbmUgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgIHN3aXRjaCAodmFsdWUuY29kZVBvaW50QXQoaSkpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgIGNhc2UgMjpcbiAgICAgIGNhc2UgMzpcbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgNTpcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgNzpcbiAgICAgIGNhc2UgODpcbiAgICAgIGNhc2UgMTE6XG4gICAgICBjYXNlIDEyOlxuICAgICAgY2FzZSAxNDpcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIGlmIChpc0VtcHR5TGluZSAmJiAhc2Vlbk5vbkVtcHR5TGluZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuTm9uRW1wdHlMaW5lID0gdHJ1ZTtcbiAgICAgICAgaXNFbXB0eUxpbmUgPSB0cnVlO1xuICAgICAgICBoYXNJbmRlbnQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDk6XG4gICAgICBjYXNlIDMyOlxuICAgICAgICBoYXNJbmRlbnQgfHwgKGhhc0luZGVudCA9IGlzRW1wdHlMaW5lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBoYXNDb21tb25JbmRlbnQgJiYgKGhhc0NvbW1vbkluZGVudCA9IGhhc0luZGVudCk7XG4gICAgICAgIGlzRW1wdHlMaW5lID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0VtcHR5TGluZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaGFzQ29tbW9uSW5kZW50ICYmIHNlZW5Ob25FbXB0eUxpbmUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBwcmludEJsb2NrU3RyaW5nKHZhbHVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGVzY2FwZWRWYWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1wiXCJcIi9nLCAnXFxcXFwiXCJcIicpO1xuICBjb25zdCBsaW5lcyA9IGVzY2FwZWRWYWx1ZS5zcGxpdCgvXFxyXFxufFtcXG5cXHJdL2cpO1xuICBjb25zdCBpc1NpbmdsZUxpbmUgPSBsaW5lcy5sZW5ndGggPT09IDE7XG4gIGNvbnN0IGZvcmNlTGVhZGluZ05ld0xpbmUgPSBsaW5lcy5sZW5ndGggPiAxICYmIGxpbmVzLnNsaWNlKDEpLmV2ZXJ5KChsaW5lKSA9PiBsaW5lLmxlbmd0aCA9PT0gMCB8fCBpc1doaXRlU3BhY2UobGluZS5jaGFyQ29kZUF0KDApKSk7XG4gIGNvbnN0IGhhc1RyYWlsaW5nVHJpcGxlUXVvdGVzID0gZXNjYXBlZFZhbHVlLmVuZHNXaXRoKCdcXFxcXCJcIlwiJyk7XG4gIGNvbnN0IGhhc1RyYWlsaW5nUXVvdGUgPSB2YWx1ZS5lbmRzV2l0aCgnXCInKSAmJiAhaGFzVHJhaWxpbmdUcmlwbGVRdW90ZXM7XG4gIGNvbnN0IGhhc1RyYWlsaW5nU2xhc2ggPSB2YWx1ZS5lbmRzV2l0aChcIlxcXFxcIik7XG4gIGNvbnN0IGZvcmNlVHJhaWxpbmdOZXdsaW5lID0gaGFzVHJhaWxpbmdRdW90ZSB8fCBoYXNUcmFpbGluZ1NsYXNoO1xuICBjb25zdCBwcmludEFzTXVsdGlwbGVMaW5lcyA9ICEob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5taW5pbWl6ZSkgJiYgLy8gYWRkIGxlYWRpbmcgYW5kIHRyYWlsaW5nIG5ldyBsaW5lcyBvbmx5IGlmIGl0IGltcHJvdmVzIHJlYWRhYmlsaXR5XG4gICghaXNTaW5nbGVMaW5lIHx8IHZhbHVlLmxlbmd0aCA+IDcwIHx8IGZvcmNlVHJhaWxpbmdOZXdsaW5lIHx8IGZvcmNlTGVhZGluZ05ld0xpbmUgfHwgaGFzVHJhaWxpbmdUcmlwbGVRdW90ZXMpO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgY29uc3Qgc2tpcExlYWRpbmdOZXdMaW5lID0gaXNTaW5nbGVMaW5lICYmIGlzV2hpdGVTcGFjZSh2YWx1ZS5jaGFyQ29kZUF0KDApKTtcbiAgaWYgKHByaW50QXNNdWx0aXBsZUxpbmVzICYmICFza2lwTGVhZGluZ05ld0xpbmUgfHwgZm9yY2VMZWFkaW5nTmV3TGluZSkge1xuICAgIHJlc3VsdCArPSBcIlxcblwiO1xuICB9XG4gIHJlc3VsdCArPSBlc2NhcGVkVmFsdWU7XG4gIGlmIChwcmludEFzTXVsdGlwbGVMaW5lcyB8fCBmb3JjZVRyYWlsaW5nTmV3bGluZSkge1xuICAgIHJlc3VsdCArPSBcIlxcblwiO1xuICB9XG4gIHJldHVybiAnXCJcIlwiJyArIHJlc3VsdCArICdcIlwiXCInO1xufVxudmFyIGluaXRfYmxvY2tTdHJpbmcgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvYmxvY2tTdHJpbmcubWpzXCIoKSB7XG4gICAgaW5pdF9jaGFyYWN0ZXJDbGFzc2VzKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS90b2tlbktpbmQubWpzXG52YXIgVG9rZW5LaW5kO1xudmFyIGluaXRfdG9rZW5LaW5kID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3Rva2VuS2luZC5tanNcIigpIHtcbiAgICAoZnVuY3Rpb24oVG9rZW5LaW5kMikge1xuICAgICAgVG9rZW5LaW5kMltcIlNPRlwiXSA9IFwiPFNPRj5cIjtcbiAgICAgIFRva2VuS2luZDJbXCJFT0ZcIl0gPSBcIjxFT0Y+XCI7XG4gICAgICBUb2tlbktpbmQyW1wiQkFOR1wiXSA9IFwiIVwiO1xuICAgICAgVG9rZW5LaW5kMltcIkRPTExBUlwiXSA9IFwiJFwiO1xuICAgICAgVG9rZW5LaW5kMltcIkFNUFwiXSA9IFwiJlwiO1xuICAgICAgVG9rZW5LaW5kMltcIlBBUkVOX0xcIl0gPSBcIihcIjtcbiAgICAgIFRva2VuS2luZDJbXCJQQVJFTl9SXCJdID0gXCIpXCI7XG4gICAgICBUb2tlbktpbmQyW1wiU1BSRUFEXCJdID0gXCIuLi5cIjtcbiAgICAgIFRva2VuS2luZDJbXCJDT0xPTlwiXSA9IFwiOlwiO1xuICAgICAgVG9rZW5LaW5kMltcIkVRVUFMU1wiXSA9IFwiPVwiO1xuICAgICAgVG9rZW5LaW5kMltcIkFUXCJdID0gXCJAXCI7XG4gICAgICBUb2tlbktpbmQyW1wiQlJBQ0tFVF9MXCJdID0gXCJbXCI7XG4gICAgICBUb2tlbktpbmQyW1wiQlJBQ0tFVF9SXCJdID0gXCJdXCI7XG4gICAgICBUb2tlbktpbmQyW1wiQlJBQ0VfTFwiXSA9IFwie1wiO1xuICAgICAgVG9rZW5LaW5kMltcIlBJUEVcIl0gPSBcInxcIjtcbiAgICAgIFRva2VuS2luZDJbXCJCUkFDRV9SXCJdID0gXCJ9XCI7XG4gICAgICBUb2tlbktpbmQyW1wiTkFNRVwiXSA9IFwiTmFtZVwiO1xuICAgICAgVG9rZW5LaW5kMltcIklOVFwiXSA9IFwiSW50XCI7XG4gICAgICBUb2tlbktpbmQyW1wiRkxPQVRcIl0gPSBcIkZsb2F0XCI7XG4gICAgICBUb2tlbktpbmQyW1wiU1RSSU5HXCJdID0gXCJTdHJpbmdcIjtcbiAgICAgIFRva2VuS2luZDJbXCJCTE9DS19TVFJJTkdcIl0gPSBcIkJsb2NrU3RyaW5nXCI7XG4gICAgICBUb2tlbktpbmQyW1wiQ09NTUVOVFwiXSA9IFwiQ29tbWVudFwiO1xuICAgIH0pKFRva2VuS2luZCB8fCAoVG9rZW5LaW5kID0ge30pKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2xleGVyLm1qc1xuZnVuY3Rpb24gaXNQdW5jdHVhdG9yVG9rZW5LaW5kKGtpbmQpIHtcbiAgcmV0dXJuIGtpbmQgPT09IFRva2VuS2luZC5CQU5HIHx8IGtpbmQgPT09IFRva2VuS2luZC5ET0xMQVIgfHwga2luZCA9PT0gVG9rZW5LaW5kLkFNUCB8fCBraW5kID09PSBUb2tlbktpbmQuUEFSRU5fTCB8fCBraW5kID09PSBUb2tlbktpbmQuUEFSRU5fUiB8fCBraW5kID09PSBUb2tlbktpbmQuU1BSRUFEIHx8IGtpbmQgPT09IFRva2VuS2luZC5DT0xPTiB8fCBraW5kID09PSBUb2tlbktpbmQuRVFVQUxTIHx8IGtpbmQgPT09IFRva2VuS2luZC5BVCB8fCBraW5kID09PSBUb2tlbktpbmQuQlJBQ0tFVF9MIHx8IGtpbmQgPT09IFRva2VuS2luZC5CUkFDS0VUX1IgfHwga2luZCA9PT0gVG9rZW5LaW5kLkJSQUNFX0wgfHwga2luZCA9PT0gVG9rZW5LaW5kLlBJUEUgfHwga2luZCA9PT0gVG9rZW5LaW5kLkJSQUNFX1I7XG59XG5mdW5jdGlvbiBpc1VuaWNvZGVTY2FsYXJWYWx1ZShjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDAgJiYgY29kZSA8PSA1NTI5NSB8fCBjb2RlID49IDU3MzQ0ICYmIGNvZGUgPD0gMTExNDExMTtcbn1cbmZ1bmN0aW9uIGlzU3VwcGxlbWVudGFyeUNvZGVQb2ludChib2R5LCBsb2NhdGlvbikge1xuICByZXR1cm4gaXNMZWFkaW5nU3Vycm9nYXRlKGJvZHkuY2hhckNvZGVBdChsb2NhdGlvbikpICYmIGlzVHJhaWxpbmdTdXJyb2dhdGUoYm9keS5jaGFyQ29kZUF0KGxvY2F0aW9uICsgMSkpO1xufVxuZnVuY3Rpb24gaXNMZWFkaW5nU3Vycm9nYXRlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gNTUyOTYgJiYgY29kZSA8PSA1NjMxOTtcbn1cbmZ1bmN0aW9uIGlzVHJhaWxpbmdTdXJyb2dhdGUoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSA1NjMyMCAmJiBjb2RlIDw9IDU3MzQzO1xufVxuZnVuY3Rpb24gcHJpbnRDb2RlUG9pbnRBdChsZXhlciwgbG9jYXRpb24pIHtcbiAgY29uc3QgY29kZSA9IGxleGVyLnNvdXJjZS5ib2R5LmNvZGVQb2ludEF0KGxvY2F0aW9uKTtcbiAgaWYgKGNvZGUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBUb2tlbktpbmQuRU9GO1xuICB9IGVsc2UgaWYgKGNvZGUgPj0gMzIgJiYgY29kZSA8PSAxMjYpIHtcbiAgICBjb25zdCBjaGFyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSk7XG4gICAgcmV0dXJuIGNoYXIgPT09ICdcIicgPyBgJ1wiJ2AgOiBgXCIke2NoYXJ9XCJgO1xuICB9XG4gIHJldHVybiBcIlUrXCIgKyBjb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDQsIFwiMFwiKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuKGxleGVyLCBraW5kLCBzdGFydCwgZW5kLCB2YWx1ZSkge1xuICBjb25zdCBsaW5lID0gbGV4ZXIubGluZTtcbiAgY29uc3QgY29sID0gMSArIHN0YXJ0IC0gbGV4ZXIubGluZVN0YXJ0O1xuICByZXR1cm4gbmV3IFRva2VuKGtpbmQsIHN0YXJ0LCBlbmQsIGxpbmUsIGNvbCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gcmVhZE5leHRUb2tlbihsZXhlciwgc3RhcnQpIHtcbiAgY29uc3QgYm9keSA9IGxleGVyLnNvdXJjZS5ib2R5O1xuICBjb25zdCBib2R5TGVuZ3RoID0gYm9keS5sZW5ndGg7XG4gIGxldCBwb3NpdGlvbiA9IHN0YXJ0O1xuICB3aGlsZSAocG9zaXRpb24gPCBib2R5TGVuZ3RoKSB7XG4gICAgY29uc3QgY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbik7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlIDY1Mjc5OlxuICAgICAgY2FzZSA5OlxuICAgICAgY2FzZSAzMjpcbiAgICAgIGNhc2UgNDQ6XG4gICAgICAgICsrcG9zaXRpb247XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgKytwb3NpdGlvbjtcbiAgICAgICAgKytsZXhlci5saW5lO1xuICAgICAgICBsZXhlci5saW5lU3RhcnQgPSBwb3NpdGlvbjtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIDEzOlxuICAgICAgICBpZiAoYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkgPT09IDEwKSB7XG4gICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgICsrbGV4ZXIubGluZTtcbiAgICAgICAgbGV4ZXIubGluZVN0YXJ0ID0gcG9zaXRpb247XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSAzNTpcbiAgICAgICAgcmV0dXJuIHJlYWRDb21tZW50KGxleGVyLCBwb3NpdGlvbik7XG4gICAgICBjYXNlIDMzOlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5CQU5HLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcbiAgICAgIGNhc2UgMzY6XG4gICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihsZXhlciwgVG9rZW5LaW5kLkRPTExBUiwgcG9zaXRpb24sIHBvc2l0aW9uICsgMSk7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5BTVAsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDEpO1xuICAgICAgY2FzZSA0MDpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuUEFSRU5fTCwgcG9zaXRpb24sIHBvc2l0aW9uICsgMSk7XG4gICAgICBjYXNlIDQxOlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5QQVJFTl9SLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcbiAgICAgIGNhc2UgNDY6XG4gICAgICAgIGlmIChib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSA9PT0gNDYgJiYgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMikgPT09IDQ2KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuU1BSRUFELCBwb3NpdGlvbiwgcG9zaXRpb24gKyAzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNTg6XG4gICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihsZXhlciwgVG9rZW5LaW5kLkNPTE9OLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcbiAgICAgIGNhc2UgNjE6XG4gICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihsZXhlciwgVG9rZW5LaW5kLkVRVUFMUywgcG9zaXRpb24sIHBvc2l0aW9uICsgMSk7XG4gICAgICBjYXNlIDY0OlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5BVCwgcG9zaXRpb24sIHBvc2l0aW9uICsgMSk7XG4gICAgICBjYXNlIDkxOlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5CUkFDS0VUX0wsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDEpO1xuICAgICAgY2FzZSA5MzpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuQlJBQ0tFVF9SLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcbiAgICAgIGNhc2UgMTIzOlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5CUkFDRV9MLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcbiAgICAgIGNhc2UgMTI0OlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5QSVBFLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcbiAgICAgIGNhc2UgMTI1OlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5CUkFDRV9SLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcbiAgICAgIGNhc2UgMzQ6XG4gICAgICAgIGlmIChib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSA9PT0gMzQgJiYgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMikgPT09IDM0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRCbG9ja1N0cmluZyhsZXhlciwgcG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWFkU3RyaW5nKGxleGVyLCBwb3NpdGlvbik7XG4gICAgfVxuICAgIGlmIChpc0RpZ2l0KGNvZGUpIHx8IGNvZGUgPT09IDQ1KSB7XG4gICAgICByZXR1cm4gcmVhZE51bWJlcihsZXhlciwgcG9zaXRpb24sIGNvZGUpO1xuICAgIH1cbiAgICBpZiAoaXNOYW1lU3RhcnQoY29kZSkpIHtcbiAgICAgIHJldHVybiByZWFkTmFtZShsZXhlciwgcG9zaXRpb24pO1xuICAgIH1cbiAgICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICAgIGxleGVyLnNvdXJjZSxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgY29kZSA9PT0gMzkgPyBgVW5leHBlY3RlZCBzaW5nbGUgcXVvdGUgY2hhcmFjdGVyICgnKSwgZGlkIHlvdSBtZWFuIHRvIHVzZSBhIGRvdWJsZSBxdW90ZSAoXCIpP2AgOiBpc1VuaWNvZGVTY2FsYXJWYWx1ZShjb2RlKSB8fCBpc1N1cHBsZW1lbnRhcnlDb2RlUG9pbnQoYm9keSwgcG9zaXRpb24pID8gYFVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAke3ByaW50Q29kZVBvaW50QXQobGV4ZXIsIHBvc2l0aW9uKX0uYCA6IGBJbnZhbGlkIGNoYXJhY3RlcjogJHtwcmludENvZGVQb2ludEF0KGxleGVyLCBwb3NpdGlvbil9LmBcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVUb2tlbihsZXhlciwgVG9rZW5LaW5kLkVPRiwgYm9keUxlbmd0aCwgYm9keUxlbmd0aCk7XG59XG5mdW5jdGlvbiByZWFkQ29tbWVudChsZXhlciwgc3RhcnQpIHtcbiAgY29uc3QgYm9keSA9IGxleGVyLnNvdXJjZS5ib2R5O1xuICBjb25zdCBib2R5TGVuZ3RoID0gYm9keS5sZW5ndGg7XG4gIGxldCBwb3NpdGlvbiA9IHN0YXJ0ICsgMTtcbiAgd2hpbGUgKHBvc2l0aW9uIDwgYm9keUxlbmd0aCkge1xuICAgIGNvbnN0IGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICAgIGlmIChjb2RlID09PSAxMCB8fCBjb2RlID09PSAxMykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChpc1VuaWNvZGVTY2FsYXJWYWx1ZShjb2RlKSkge1xuICAgICAgKytwb3NpdGlvbjtcbiAgICB9IGVsc2UgaWYgKGlzU3VwcGxlbWVudGFyeUNvZGVQb2ludChib2R5LCBwb3NpdGlvbikpIHtcbiAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlVG9rZW4oXG4gICAgbGV4ZXIsXG4gICAgVG9rZW5LaW5kLkNPTU1FTlQsXG4gICAgc3RhcnQsXG4gICAgcG9zaXRpb24sXG4gICAgYm9keS5zbGljZShzdGFydCArIDEsIHBvc2l0aW9uKVxuICApO1xufVxuZnVuY3Rpb24gcmVhZE51bWJlcihsZXhlciwgc3RhcnQsIGZpcnN0Q29kZSkge1xuICBjb25zdCBib2R5ID0gbGV4ZXIuc291cmNlLmJvZHk7XG4gIGxldCBwb3NpdGlvbiA9IHN0YXJ0O1xuICBsZXQgY29kZSA9IGZpcnN0Q29kZTtcbiAgbGV0IGlzRmxvYXQgPSBmYWxzZTtcbiAgaWYgKGNvZGUgPT09IDQ1KSB7XG4gICAgY29kZSA9IGJvZHkuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcbiAgfVxuICBpZiAoY29kZSA9PT0gNDgpIHtcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xuICAgIGlmIChpc0RpZ2l0KGNvZGUpKSB7XG4gICAgICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICAgICAgbGV4ZXIuc291cmNlLFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgYEludmFsaWQgbnVtYmVyLCB1bmV4cGVjdGVkIGRpZ2l0IGFmdGVyIDA6ICR7cHJpbnRDb2RlUG9pbnRBdChcbiAgICAgICAgICBsZXhlcixcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICApfS5gXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwb3NpdGlvbiA9IHJlYWREaWdpdHMobGV4ZXIsIHBvc2l0aW9uLCBjb2RlKTtcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgfVxuICBpZiAoY29kZSA9PT0gNDYpIHtcbiAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xuICAgIHBvc2l0aW9uID0gcmVhZERpZ2l0cyhsZXhlciwgcG9zaXRpb24sIGNvZGUpO1xuICAgIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICB9XG4gIGlmIChjb2RlID09PSA2OSB8fCBjb2RlID09PSAxMDEpIHtcbiAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xuICAgIGlmIChjb2RlID09PSA0MyB8fCBjb2RlID09PSA0NSkge1xuICAgICAgY29kZSA9IGJvZHkuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcbiAgICB9XG4gICAgcG9zaXRpb24gPSByZWFkRGlnaXRzKGxleGVyLCBwb3NpdGlvbiwgY29kZSk7XG4gICAgY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbik7XG4gIH1cbiAgaWYgKGNvZGUgPT09IDQ2IHx8IGlzTmFtZVN0YXJ0KGNvZGUpKSB7XG4gICAgdGhyb3cgc3ludGF4RXJyb3IoXG4gICAgICBsZXhlci5zb3VyY2UsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIGBJbnZhbGlkIG51bWJlciwgZXhwZWN0ZWQgZGlnaXQgYnV0IGdvdDogJHtwcmludENvZGVQb2ludEF0KFxuICAgICAgICBsZXhlcixcbiAgICAgICAgcG9zaXRpb25cbiAgICAgICl9LmBcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVUb2tlbihcbiAgICBsZXhlcixcbiAgICBpc0Zsb2F0ID8gVG9rZW5LaW5kLkZMT0FUIDogVG9rZW5LaW5kLklOVCxcbiAgICBzdGFydCxcbiAgICBwb3NpdGlvbixcbiAgICBib2R5LnNsaWNlKHN0YXJ0LCBwb3NpdGlvbilcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlYWREaWdpdHMobGV4ZXIsIHN0YXJ0LCBmaXJzdENvZGUpIHtcbiAgaWYgKCFpc0RpZ2l0KGZpcnN0Q29kZSkpIHtcbiAgICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICAgIGxleGVyLnNvdXJjZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgYEludmFsaWQgbnVtYmVyLCBleHBlY3RlZCBkaWdpdCBidXQgZ290OiAke3ByaW50Q29kZVBvaW50QXQoXG4gICAgICAgIGxleGVyLFxuICAgICAgICBzdGFydFxuICAgICAgKX0uYFxuICAgICk7XG4gIH1cbiAgY29uc3QgYm9keSA9IGxleGVyLnNvdXJjZS5ib2R5O1xuICBsZXQgcG9zaXRpb24gPSBzdGFydCArIDE7XG4gIHdoaWxlIChpc0RpZ2l0KGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbikpKSB7XG4gICAgKytwb3NpdGlvbjtcbiAgfVxuICByZXR1cm4gcG9zaXRpb247XG59XG5mdW5jdGlvbiByZWFkU3RyaW5nKGxleGVyLCBzdGFydCkge1xuICBjb25zdCBib2R5ID0gbGV4ZXIuc291cmNlLmJvZHk7XG4gIGNvbnN0IGJvZHlMZW5ndGggPSBib2R5Lmxlbmd0aDtcbiAgbGV0IHBvc2l0aW9uID0gc3RhcnQgKyAxO1xuICBsZXQgY2h1bmtTdGFydCA9IHBvc2l0aW9uO1xuICBsZXQgdmFsdWUgPSBcIlwiO1xuICB3aGlsZSAocG9zaXRpb24gPCBib2R5TGVuZ3RoKSB7XG4gICAgY29uc3QgY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbik7XG4gICAgaWYgKGNvZGUgPT09IDM0KSB7XG4gICAgICB2YWx1ZSArPSBib2R5LnNsaWNlKGNodW5rU3RhcnQsIHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiBjcmVhdGVUb2tlbihsZXhlciwgVG9rZW5LaW5kLlNUUklORywgc3RhcnQsIHBvc2l0aW9uICsgMSwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gOTIpIHtcbiAgICAgIHZhbHVlICs9IGJvZHkuc2xpY2UoY2h1bmtTdGFydCwgcG9zaXRpb24pO1xuICAgICAgY29uc3QgZXNjYXBlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkgPT09IDExNyA/IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDIpID09PSAxMjMgPyByZWFkRXNjYXBlZFVuaWNvZGVWYXJpYWJsZVdpZHRoKGxleGVyLCBwb3NpdGlvbikgOiByZWFkRXNjYXBlZFVuaWNvZGVGaXhlZFdpZHRoKGxleGVyLCBwb3NpdGlvbikgOiByZWFkRXNjYXBlZENoYXJhY3RlcihsZXhlciwgcG9zaXRpb24pO1xuICAgICAgdmFsdWUgKz0gZXNjYXBlLnZhbHVlO1xuICAgICAgcG9zaXRpb24gKz0gZXNjYXBlLnNpemU7XG4gICAgICBjaHVua1N0YXJ0ID0gcG9zaXRpb247XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDEwIHx8IGNvZGUgPT09IDEzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGlzVW5pY29kZVNjYWxhclZhbHVlKGNvZGUpKSB7XG4gICAgICArK3Bvc2l0aW9uO1xuICAgIH0gZWxzZSBpZiAoaXNTdXBwbGVtZW50YXJ5Q29kZVBvaW50KGJvZHksIHBvc2l0aW9uKSkge1xuICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXG4gICAgICAgIGxleGVyLnNvdXJjZSxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIGBJbnZhbGlkIGNoYXJhY3RlciB3aXRoaW4gU3RyaW5nOiAke3ByaW50Q29kZVBvaW50QXQoXG4gICAgICAgICAgbGV4ZXIsXG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgKX0uYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgc3ludGF4RXJyb3IobGV4ZXIuc291cmNlLCBwb3NpdGlvbiwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nLlwiKTtcbn1cbmZ1bmN0aW9uIHJlYWRFc2NhcGVkVW5pY29kZVZhcmlhYmxlV2lkdGgobGV4ZXIsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IGJvZHkgPSBsZXhlci5zb3VyY2UuYm9keTtcbiAgbGV0IHBvaW50ID0gMDtcbiAgbGV0IHNpemUgPSAzO1xuICB3aGlsZSAoc2l6ZSA8IDEyKSB7XG4gICAgY29uc3QgY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIHNpemUrKyk7XG4gICAgaWYgKGNvZGUgPT09IDEyNSkge1xuICAgICAgaWYgKHNpemUgPCA1IHx8ICFpc1VuaWNvZGVTY2FsYXJWYWx1ZShwb2ludCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21Db2RlUG9pbnQocG9pbnQpLFxuICAgICAgICBzaXplXG4gICAgICB9O1xuICAgIH1cbiAgICBwb2ludCA9IHBvaW50IDw8IDQgfCByZWFkSGV4RGlnaXQoY29kZSk7XG4gICAgaWYgKHBvaW50IDwgMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRocm93IHN5bnRheEVycm9yKFxuICAgIGxleGVyLnNvdXJjZSxcbiAgICBwb3NpdGlvbixcbiAgICBgSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZTogXCIke2JvZHkuc2xpY2UoXG4gICAgICBwb3NpdGlvbixcbiAgICAgIHBvc2l0aW9uICsgc2l6ZVxuICAgICl9XCIuYFxuICApO1xufVxuZnVuY3Rpb24gcmVhZEVzY2FwZWRVbmljb2RlRml4ZWRXaWR0aChsZXhlciwgcG9zaXRpb24pIHtcbiAgY29uc3QgYm9keSA9IGxleGVyLnNvdXJjZS5ib2R5O1xuICBjb25zdCBjb2RlID0gcmVhZDE2Qml0SGV4Q29kZShib2R5LCBwb3NpdGlvbiArIDIpO1xuICBpZiAoaXNVbmljb2RlU2NhbGFyVmFsdWUoY29kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpLFxuICAgICAgc2l6ZTogNlxuICAgIH07XG4gIH1cbiAgaWYgKGlzTGVhZGluZ1N1cnJvZ2F0ZShjb2RlKSkge1xuICAgIGlmIChib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyA2KSA9PT0gOTIgJiYgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgNykgPT09IDExNykge1xuICAgICAgY29uc3QgdHJhaWxpbmdDb2RlID0gcmVhZDE2Qml0SGV4Q29kZShib2R5LCBwb3NpdGlvbiArIDgpO1xuICAgICAgaWYgKGlzVHJhaWxpbmdTdXJyb2dhdGUodHJhaWxpbmdDb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlLCB0cmFpbGluZ0NvZGUpLFxuICAgICAgICAgIHNpemU6IDEyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRocm93IHN5bnRheEVycm9yKFxuICAgIGxleGVyLnNvdXJjZSxcbiAgICBwb3NpdGlvbixcbiAgICBgSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZTogXCIke2JvZHkuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgNil9XCIuYFxuICApO1xufVxuZnVuY3Rpb24gcmVhZDE2Qml0SGV4Q29kZShib2R5LCBwb3NpdGlvbikge1xuICByZXR1cm4gcmVhZEhleERpZ2l0KGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbikpIDw8IDEyIHwgcmVhZEhleERpZ2l0KGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpKSA8PCA4IHwgcmVhZEhleERpZ2l0KGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDIpKSA8PCA0IHwgcmVhZEhleERpZ2l0KGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDMpKTtcbn1cbmZ1bmN0aW9uIHJlYWRIZXhEaWdpdChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcgPyBjb2RlIC0gNDggOiBjb2RlID49IDY1ICYmIGNvZGUgPD0gNzAgPyBjb2RlIC0gNTUgOiBjb2RlID49IDk3ICYmIGNvZGUgPD0gMTAyID8gY29kZSAtIDg3IDogLTE7XG59XG5mdW5jdGlvbiByZWFkRXNjYXBlZENoYXJhY3RlcihsZXhlciwgcG9zaXRpb24pIHtcbiAgY29uc3QgYm9keSA9IGxleGVyLnNvdXJjZS5ib2R5O1xuICBjb25zdCBjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSk7XG4gIHN3aXRjaCAoY29kZSkge1xuICAgIGNhc2UgMzQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogJ1wiJyxcbiAgICAgICAgc2l6ZTogMlxuICAgICAgfTtcbiAgICBjYXNlIDkyOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IFwiXFxcXFwiLFxuICAgICAgICBzaXplOiAyXG4gICAgICB9O1xuICAgIGNhc2UgNDc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogXCIvXCIsXG4gICAgICAgIHNpemU6IDJcbiAgICAgIH07XG4gICAgY2FzZSA5ODpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBcIlxcYlwiLFxuICAgICAgICBzaXplOiAyXG4gICAgICB9O1xuICAgIGNhc2UgMTAyOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IFwiXFxmXCIsXG4gICAgICAgIHNpemU6IDJcbiAgICAgIH07XG4gICAgY2FzZSAxMTA6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogXCJcXG5cIixcbiAgICAgICAgc2l6ZTogMlxuICAgICAgfTtcbiAgICBjYXNlIDExNDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBcIlxcclwiLFxuICAgICAgICBzaXplOiAyXG4gICAgICB9O1xuICAgIGNhc2UgMTE2OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IFwiXHRcIixcbiAgICAgICAgc2l6ZTogMlxuICAgICAgfTtcbiAgfVxuICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICBsZXhlci5zb3VyY2UsXG4gICAgcG9zaXRpb24sXG4gICAgYEludmFsaWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZTogXCIke2JvZHkuc2xpY2UoXG4gICAgICBwb3NpdGlvbixcbiAgICAgIHBvc2l0aW9uICsgMlxuICAgICl9XCIuYFxuICApO1xufVxuZnVuY3Rpb24gcmVhZEJsb2NrU3RyaW5nKGxleGVyLCBzdGFydCkge1xuICBjb25zdCBib2R5ID0gbGV4ZXIuc291cmNlLmJvZHk7XG4gIGNvbnN0IGJvZHlMZW5ndGggPSBib2R5Lmxlbmd0aDtcbiAgbGV0IGxpbmVTdGFydCA9IGxleGVyLmxpbmVTdGFydDtcbiAgbGV0IHBvc2l0aW9uID0gc3RhcnQgKyAzO1xuICBsZXQgY2h1bmtTdGFydCA9IHBvc2l0aW9uO1xuICBsZXQgY3VycmVudExpbmUgPSBcIlwiO1xuICBjb25zdCBibG9ja0xpbmVzID0gW107XG4gIHdoaWxlIChwb3NpdGlvbiA8IGJvZHlMZW5ndGgpIHtcbiAgICBjb25zdCBjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgICBpZiAoY29kZSA9PT0gMzQgJiYgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkgPT09IDM0ICYmIGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDIpID09PSAzNCkge1xuICAgICAgY3VycmVudExpbmUgKz0gYm9keS5zbGljZShjaHVua1N0YXJ0LCBwb3NpdGlvbik7XG4gICAgICBibG9ja0xpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgY29uc3QgdG9rZW4gPSBjcmVhdGVUb2tlbihcbiAgICAgICAgbGV4ZXIsXG4gICAgICAgIFRva2VuS2luZC5CTE9DS19TVFJJTkcsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBwb3NpdGlvbiArIDMsXG4gICAgICAgIC8vIFJldHVybiBhIHN0cmluZyBvZiB0aGUgbGluZXMgam9pbmVkIHdpdGggVSswMDBBLlxuICAgICAgICBkZWRlbnRCbG9ja1N0cmluZ0xpbmVzKGJsb2NrTGluZXMpLmpvaW4oXCJcXG5cIilcbiAgICAgICk7XG4gICAgICBsZXhlci5saW5lICs9IGJsb2NrTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIGxleGVyLmxpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDkyICYmIGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpID09PSAzNCAmJiBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAyKSA9PT0gMzQgJiYgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMykgPT09IDM0KSB7XG4gICAgICBjdXJyZW50TGluZSArPSBib2R5LnNsaWNlKGNodW5rU3RhcnQsIHBvc2l0aW9uKTtcbiAgICAgIGNodW5rU3RhcnQgPSBwb3NpdGlvbiArIDE7XG4gICAgICBwb3NpdGlvbiArPSA0O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSAxMCB8fCBjb2RlID09PSAxMykge1xuICAgICAgY3VycmVudExpbmUgKz0gYm9keS5zbGljZShjaHVua1N0YXJ0LCBwb3NpdGlvbik7XG4gICAgICBibG9ja0xpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgaWYgKGNvZGUgPT09IDEzICYmIGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpID09PSAxMCkge1xuICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKytwb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRMaW5lID0gXCJcIjtcbiAgICAgIGNodW5rU3RhcnQgPSBwb3NpdGlvbjtcbiAgICAgIGxpbmVTdGFydCA9IHBvc2l0aW9uO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpc1VuaWNvZGVTY2FsYXJWYWx1ZShjb2RlKSkge1xuICAgICAgKytwb3NpdGlvbjtcbiAgICB9IGVsc2UgaWYgKGlzU3VwcGxlbWVudGFyeUNvZGVQb2ludChib2R5LCBwb3NpdGlvbikpIHtcbiAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHN5bnRheEVycm9yKFxuICAgICAgICBsZXhlci5zb3VyY2UsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBgSW52YWxpZCBjaGFyYWN0ZXIgd2l0aGluIFN0cmluZzogJHtwcmludENvZGVQb2ludEF0KFxuICAgICAgICAgIGxleGVyLFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICl9LmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRocm93IHN5bnRheEVycm9yKGxleGVyLnNvdXJjZSwgcG9zaXRpb24sIFwiVW50ZXJtaW5hdGVkIHN0cmluZy5cIik7XG59XG5mdW5jdGlvbiByZWFkTmFtZShsZXhlciwgc3RhcnQpIHtcbiAgY29uc3QgYm9keSA9IGxleGVyLnNvdXJjZS5ib2R5O1xuICBjb25zdCBib2R5TGVuZ3RoID0gYm9keS5sZW5ndGg7XG4gIGxldCBwb3NpdGlvbiA9IHN0YXJ0ICsgMTtcbiAgd2hpbGUgKHBvc2l0aW9uIDwgYm9keUxlbmd0aCkge1xuICAgIGNvbnN0IGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICAgIGlmIChpc05hbWVDb250aW51ZShjb2RlKSkge1xuICAgICAgKytwb3NpdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVUb2tlbihcbiAgICBsZXhlcixcbiAgICBUb2tlbktpbmQuTkFNRSxcbiAgICBzdGFydCxcbiAgICBwb3NpdGlvbixcbiAgICBib2R5LnNsaWNlKHN0YXJ0LCBwb3NpdGlvbilcbiAgKTtcbn1cbnZhciBMZXhlcjtcbnZhciBpbml0X2xleGVyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2xleGVyLm1qc1wiKCkge1xuICAgIGluaXRfc3ludGF4RXJyb3IoKTtcbiAgICBpbml0X2FzdCgpO1xuICAgIGluaXRfYmxvY2tTdHJpbmcoKTtcbiAgICBpbml0X2NoYXJhY3RlckNsYXNzZXMoKTtcbiAgICBpbml0X3Rva2VuS2luZCgpO1xuICAgIExleGVyID0gY2xhc3Mge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcHJldmlvdXNseSBmb2N1c2VkIG5vbi1pZ25vcmVkIHRva2VuLlxuICAgICAgICovXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjdXJyZW50bHkgZm9jdXNlZCBub24taWdub3JlZCB0b2tlbi5cbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgKDEtaW5kZXhlZCkgbGluZSBjb250YWluaW5nIHRoZSBjdXJyZW50IHRva2VuLlxuICAgICAgICovXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjaGFyYWN0ZXIgb2Zmc2V0IGF0IHdoaWNoIHRoZSBjdXJyZW50IGxpbmUgYmVnaW5zLlxuICAgICAgICovXG4gICAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRPZkZpbGVUb2tlbiA9IG5ldyBUb2tlbihUb2tlbktpbmQuU09GLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMubGFzdFRva2VuID0gc3RhcnRPZkZpbGVUb2tlbjtcbiAgICAgICAgdGhpcy50b2tlbiA9IHN0YXJ0T2ZGaWxlVG9rZW47XG4gICAgICAgIHRoaXMubGluZSA9IDE7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgcmV0dXJuIFwiTGV4ZXJcIjtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQWR2YW5jZXMgdGhlIHRva2VuIHN0cmVhbSB0byB0aGUgbmV4dCBub24taWdub3JlZCB0b2tlbi5cbiAgICAgICAqL1xuICAgICAgYWR2YW5jZSgpIHtcbiAgICAgICAgdGhpcy5sYXN0VG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMudG9rZW4gPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIExvb2tzIGFoZWFkIGFuZCByZXR1cm5zIHRoZSBuZXh0IG5vbi1pZ25vcmVkIHRva2VuLCBidXQgZG9lcyBub3QgY2hhbmdlXG4gICAgICAgKiB0aGUgc3RhdGUgb2YgTGV4ZXIuXG4gICAgICAgKi9cbiAgICAgIGxvb2thaGVhZCgpIHtcbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy50b2tlbjtcbiAgICAgICAgaWYgKHRva2VuLmtpbmQgIT09IFRva2VuS2luZC5FT0YpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAodG9rZW4ubmV4dCkge1xuICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuLm5leHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSByZWFkTmV4dFRva2VuKHRoaXMsIHRva2VuLmVuZCk7XG4gICAgICAgICAgICAgIHRva2VuLm5leHQgPSBuZXh0VG9rZW47XG4gICAgICAgICAgICAgIG5leHRUb2tlbi5wcmV2ID0gdG9rZW47XG4gICAgICAgICAgICAgIHRva2VuID0gbmV4dFRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKHRva2VuLmtpbmQgPT09IFRva2VuS2luZC5DT01NRU5UKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvZGV2QXNzZXJ0Lm1qc1xuZnVuY3Rpb24gZGV2QXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBjb25zdCBib29sZWFuQ29uZGl0aW9uID0gQm9vbGVhbihjb25kaXRpb24pO1xuICBpZiAoIWJvb2xlYW5Db25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbnZhciBpbml0X2RldkFzc2VydCA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2RldkFzc2VydC5tanNcIigpIHtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvaW5zcGVjdC5tanNcbmZ1bmN0aW9uIGluc3BlY3QodmFsdWUpIHtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKHZhbHVlLCBbXSk7XG59XG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSwgc2VlblZhbHVlcykge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICByZXR1cm4gdmFsdWUubmFtZSA/IGBbZnVuY3Rpb24gJHt2YWx1ZS5uYW1lfV1gIDogXCJbZnVuY3Rpb25dXCI7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIGZvcm1hdE9iamVjdFZhbHVlKHZhbHVlLCBzZWVuVmFsdWVzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdE9iamVjdFZhbHVlKHZhbHVlLCBwcmV2aW91c2x5U2VlblZhbHVlcykge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgaWYgKHByZXZpb3VzbHlTZWVuVmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgIHJldHVybiBcIltDaXJjdWxhcl1cIjtcbiAgfVxuICBjb25zdCBzZWVuVmFsdWVzID0gWy4uLnByZXZpb3VzbHlTZWVuVmFsdWVzLCB2YWx1ZV07XG4gIGlmIChpc0pTT05hYmxlKHZhbHVlKSkge1xuICAgIGNvbnN0IGpzb25WYWx1ZSA9IHZhbHVlLnRvSlNPTigpO1xuICAgIGlmIChqc29uVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGpzb25WYWx1ZSA9PT0gXCJzdHJpbmdcIiA/IGpzb25WYWx1ZSA6IGZvcm1hdFZhbHVlKGpzb25WYWx1ZSwgc2VlblZhbHVlcyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZvcm1hdEFycmF5KHZhbHVlLCBzZWVuVmFsdWVzKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0T2JqZWN0KHZhbHVlLCBzZWVuVmFsdWVzKTtcbn1cbmZ1bmN0aW9uIGlzSlNPTmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGZvcm1hdE9iamVjdChvYmplY3QsIHNlZW5WYWx1ZXMpIHtcbiAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG9iamVjdCk7XG4gIGlmIChlbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcInt9XCI7XG4gIH1cbiAgaWYgKHNlZW5WYWx1ZXMubGVuZ3RoID4gTUFYX1JFQ1VSU0lWRV9ERVBUSCkge1xuICAgIHJldHVybiBcIltcIiArIGdldE9iamVjdFRhZyhvYmplY3QpICsgXCJdXCI7XG4gIH1cbiAgY29uc3QgcHJvcGVydGllcyA9IGVudHJpZXMubWFwKFxuICAgIChba2V5LCB2YWx1ZV0pID0+IGtleSArIFwiOiBcIiArIGZvcm1hdFZhbHVlKHZhbHVlLCBzZWVuVmFsdWVzKVxuICApO1xuICByZXR1cm4gXCJ7IFwiICsgcHJvcGVydGllcy5qb2luKFwiLCBcIikgKyBcIiB9XCI7XG59XG5mdW5jdGlvbiBmb3JtYXRBcnJheShhcnJheSwgc2VlblZhbHVlcykge1xuICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwiW11cIjtcbiAgfVxuICBpZiAoc2VlblZhbHVlcy5sZW5ndGggPiBNQVhfUkVDVVJTSVZFX0RFUFRIKSB7XG4gICAgcmV0dXJuIFwiW0FycmF5XVwiO1xuICB9XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKE1BWF9BUlJBWV9MRU5HVEgsIGFycmF5Lmxlbmd0aCk7XG4gIGNvbnN0IHJlbWFpbmluZyA9IGFycmF5Lmxlbmd0aCAtIGxlbjtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGl0ZW1zLnB1c2goZm9ybWF0VmFsdWUoYXJyYXlbaV0sIHNlZW5WYWx1ZXMpKTtcbiAgfVxuICBpZiAocmVtYWluaW5nID09PSAxKSB7XG4gICAgaXRlbXMucHVzaChcIi4uLiAxIG1vcmUgaXRlbVwiKTtcbiAgfSBlbHNlIGlmIChyZW1haW5pbmcgPiAxKSB7XG4gICAgaXRlbXMucHVzaChgLi4uICR7cmVtYWluaW5nfSBtb3JlIGl0ZW1zYCk7XG4gIH1cbiAgcmV0dXJuIFwiW1wiICsgaXRlbXMuam9pbihcIiwgXCIpICsgXCJdXCI7XG59XG5mdW5jdGlvbiBnZXRPYmplY3RUYWcob2JqZWN0KSB7XG4gIGNvbnN0IHRhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpLnJlcGxhY2UoL15cXFtvYmplY3QgLywgXCJcIikucmVwbGFjZSgvXSQvLCBcIlwiKTtcbiAgaWYgKHRhZyA9PT0gXCJPYmplY3RcIiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCBuYW1lID0gb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmIG5hbWUgIT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFnO1xufVxudmFyIE1BWF9BUlJBWV9MRU5HVEgsIE1BWF9SRUNVUlNJVkVfREVQVEg7XG52YXIgaW5pdF9pbnNwZWN0ID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvaW5zcGVjdC5tanNcIigpIHtcbiAgICBNQVhfQVJSQVlfTEVOR1RIID0gMTA7XG4gICAgTUFYX1JFQ1VSU0lWRV9ERVBUSCA9IDI7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2luc3RhbmNlT2YubWpzXG52YXIgaW5zdGFuY2VPZjtcbnZhciBpbml0X2luc3RhbmNlT2YgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9pbnN0YW5jZU9mLm1qc1wiKCkge1xuICAgIGluaXRfaW5zcGVjdCgpO1xuICAgIGluc3RhbmNlT2YgPSAvKiBjOCBpZ25vcmUgbmV4dCA2ICovXG4gICAgLy8gRklYTUU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2dyYXBocWwtanMvaXNzdWVzLzIzMTdcbiAgICBnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmdW5jdGlvbiBpbnN0YW5jZU9mMih2YWx1ZSwgY29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yO1xuICAgIH0gOiBmdW5jdGlvbiBpbnN0YW5jZU9mMyh2YWx1ZSwgY29uc3RydWN0b3IpIHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3ZhbHVlJGNvbnN0cnVjdG9yO1xuICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXTtcbiAgICAgICAgY29uc3QgdmFsdWVDbGFzc05hbWUgPSAoXG4gICAgICAgICAgLy8gV2Ugc3RpbGwgbmVlZCB0byBzdXBwb3J0IGNvbnN0cnVjdG9yJ3MgbmFtZSB0byBkZXRlY3QgY29uZmxpY3RzIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgdGhpcyBsaWJyYXJ5LlxuICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSA/IHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gOiAoX3ZhbHVlJGNvbnN0cnVjdG9yID0gdmFsdWUuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF92YWx1ZSRjb25zdHJ1Y3RvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZhbHVlJGNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gdmFsdWVDbGFzc05hbWUpIHtcbiAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZFZhbHVlID0gaW5zcGVjdCh2YWx1ZSk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXNlICR7Y2xhc3NOYW1lfSBcIiR7c3RyaW5naWZpZWRWYWx1ZX1cIiBmcm9tIGFub3RoZXIgbW9kdWxlIG9yIHJlYWxtLlxuXG5FbnN1cmUgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBpbnN0YW5jZSBvZiBcImdyYXBocWxcIiBpbiB0aGUgbm9kZV9tb2R1bGVzXG5kaXJlY3RvcnkuIElmIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBcImdyYXBocWxcIiBhcmUgdGhlIGRlcGVuZGVuY2llcyBvZiBvdGhlclxucmVsaWVkIG9uIG1vZHVsZXMsIHVzZSBcInJlc29sdXRpb25zXCIgdG8gZW5zdXJlIG9ubHkgb25lIHZlcnNpb24gaXMgaW5zdGFsbGVkLlxuXG5odHRwczovL3lhcm5wa2cuY29tL2VuL2RvY3Mvc2VsZWN0aXZlLXZlcnNpb24tcmVzb2x1dGlvbnNcblxuRHVwbGljYXRlIFwiZ3JhcGhxbFwiIG1vZHVsZXMgY2Fubm90IGJlIHVzZWQgYXQgdGhlIHNhbWUgdGltZSBzaW5jZSBkaWZmZXJlbnRcbnZlcnNpb25zIG1heSBoYXZlIGRpZmZlcmVudCBjYXBhYmlsaXRpZXMgYW5kIGJlaGF2aW9yLiBUaGUgZGF0YSBmcm9tIG9uZVxudmVyc2lvbiB1c2VkIGluIHRoZSBmdW5jdGlvbiBmcm9tIGFub3RoZXIgY291bGQgcHJvZHVjZSBjb25mdXNpbmcgYW5kXG5zcHVyaW91cyByZXN1bHRzLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3NvdXJjZS5tanNcbmZ1bmN0aW9uIGlzU291cmNlKHNvdXJjZSkge1xuICByZXR1cm4gaW5zdGFuY2VPZihzb3VyY2UsIFNvdXJjZSk7XG59XG52YXIgU291cmNlO1xudmFyIGluaXRfc291cmNlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3NvdXJjZS5tanNcIigpIHtcbiAgICBpbml0X2RldkFzc2VydCgpO1xuICAgIGluaXRfaW5zcGVjdCgpO1xuICAgIGluaXRfaW5zdGFuY2VPZigpO1xuICAgIFNvdXJjZSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGJvZHksIG5hbWUgPSBcIkdyYXBoUUwgcmVxdWVzdFwiLCBsb2NhdGlvbk9mZnNldCA9IHtcbiAgICAgICAgbGluZTogMSxcbiAgICAgICAgY29sdW1uOiAxXG4gICAgICB9KSB7XG4gICAgICAgIHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiIHx8IGRldkFzc2VydChmYWxzZSwgYEJvZHkgbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQ6ICR7aW5zcGVjdChib2R5KX0uYCk7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubG9jYXRpb25PZmZzZXQgPSBsb2NhdGlvbk9mZnNldDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbk9mZnNldC5saW5lID4gMCB8fCBkZXZBc3NlcnQoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJsaW5lIGluIGxvY2F0aW9uT2Zmc2V0IGlzIDEtaW5kZXhlZCBhbmQgbXVzdCBiZSBwb3NpdGl2ZS5cIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLmxvY2F0aW9uT2Zmc2V0LmNvbHVtbiA+IDAgfHwgZGV2QXNzZXJ0KFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiY29sdW1uIGluIGxvY2F0aW9uT2Zmc2V0IGlzIDEtaW5kZXhlZCBhbmQgbXVzdCBiZSBwb3NpdGl2ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJTb3VyY2VcIjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvcGFyc2VyLm1qc1xuZnVuY3Rpb24gcGFyc2Uoc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoc291cmNlLCBvcHRpb25zKTtcbiAgcmV0dXJuIHBhcnNlci5wYXJzZURvY3VtZW50KCk7XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlKHNvdXJjZSwgb3B0aW9ucykge1xuICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKHNvdXJjZSwgb3B0aW9ucyk7XG4gIHBhcnNlci5leHBlY3RUb2tlbihUb2tlbktpbmQuU09GKTtcbiAgY29uc3QgdmFsdWUgPSBwYXJzZXIucGFyc2VWYWx1ZUxpdGVyYWwoZmFsc2UpO1xuICBwYXJzZXIuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkVPRik7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29uc3RWYWx1ZShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihzb3VyY2UsIG9wdGlvbnMpO1xuICBwYXJzZXIuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLlNPRik7XG4gIGNvbnN0IHZhbHVlID0gcGFyc2VyLnBhcnNlQ29uc3RWYWx1ZUxpdGVyYWwoKTtcbiAgcGFyc2VyLmV4cGVjdFRva2VuKFRva2VuS2luZC5FT0YpO1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBwYXJzZVR5cGUoc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoc291cmNlLCBvcHRpb25zKTtcbiAgcGFyc2VyLmV4cGVjdFRva2VuKFRva2VuS2luZC5TT0YpO1xuICBjb25zdCB0eXBlID0gcGFyc2VyLnBhcnNlVHlwZVJlZmVyZW5jZSgpO1xuICBwYXJzZXIuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkVPRik7XG4gIHJldHVybiB0eXBlO1xufVxuZnVuY3Rpb24gZ2V0VG9rZW5EZXNjKHRva2VuKSB7XG4gIGNvbnN0IHZhbHVlID0gdG9rZW4udmFsdWU7XG4gIHJldHVybiBnZXRUb2tlbktpbmREZXNjKHRva2VuLmtpbmQpICsgKHZhbHVlICE9IG51bGwgPyBgIFwiJHt2YWx1ZX1cImAgOiBcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldFRva2VuS2luZERlc2Moa2luZCkge1xuICByZXR1cm4gaXNQdW5jdHVhdG9yVG9rZW5LaW5kKGtpbmQpID8gYFwiJHtraW5kfVwiYCA6IGtpbmQ7XG59XG52YXIgUGFyc2VyO1xudmFyIGluaXRfcGFyc2VyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3BhcnNlci5tanNcIigpIHtcbiAgICBpbml0X3N5bnRheEVycm9yKCk7XG4gICAgaW5pdF9hc3QoKTtcbiAgICBpbml0X2RpcmVjdGl2ZUxvY2F0aW9uKCk7XG4gICAgaW5pdF9raW5kcygpO1xuICAgIGluaXRfbGV4ZXIoKTtcbiAgICBpbml0X3NvdXJjZSgpO1xuICAgIGluaXRfdG9rZW5LaW5kKCk7XG4gICAgUGFyc2VyID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qgc291cmNlT2JqID0gaXNTb3VyY2Uoc291cmNlKSA/IHNvdXJjZSA6IG5ldyBTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgdGhpcy5fbGV4ZXIgPSBuZXcgTGV4ZXIoc291cmNlT2JqKTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3Rva2VuQ291bnRlciA9IDA7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIGEgbmFtZSBsZXggdG9rZW4gaW50byBhIG5hbWUgcGFyc2Ugbm9kZS5cbiAgICAgICAqL1xuICAgICAgcGFyc2VOYW1lKCkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLk5BTUUpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHRva2VuLCB7XG4gICAgICAgICAga2luZDogS2luZC5OQU1FLFxuICAgICAgICAgIHZhbHVlOiB0b2tlbi52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIERvY3VtZW50IHNlY3Rpb24uXG4gICAgICAvKipcbiAgICAgICAqIERvY3VtZW50IDogRGVmaW5pdGlvbitcbiAgICAgICAqL1xuICAgICAgcGFyc2VEb2N1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZSh0aGlzLl9sZXhlci50b2tlbiwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuRE9DVU1FTlQsXG4gICAgICAgICAgZGVmaW5pdGlvbnM6IHRoaXMubWFueShcbiAgICAgICAgICAgIFRva2VuS2luZC5TT0YsXG4gICAgICAgICAgICB0aGlzLnBhcnNlRGVmaW5pdGlvbixcbiAgICAgICAgICAgIFRva2VuS2luZC5FT0ZcbiAgICAgICAgICApXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBEZWZpbml0aW9uIDpcbiAgICAgICAqICAgLSBFeGVjdXRhYmxlRGVmaW5pdGlvblxuICAgICAgICogICAtIFR5cGVTeXN0ZW1EZWZpbml0aW9uXG4gICAgICAgKiAgIC0gVHlwZVN5c3RlbUV4dGVuc2lvblxuICAgICAgICpcbiAgICAgICAqIEV4ZWN1dGFibGVEZWZpbml0aW9uIDpcbiAgICAgICAqICAgLSBPcGVyYXRpb25EZWZpbml0aW9uXG4gICAgICAgKiAgIC0gRnJhZ21lbnREZWZpbml0aW9uXG4gICAgICAgKlxuICAgICAgICogVHlwZVN5c3RlbURlZmluaXRpb24gOlxuICAgICAgICogICAtIFNjaGVtYURlZmluaXRpb25cbiAgICAgICAqICAgLSBUeXBlRGVmaW5pdGlvblxuICAgICAgICogICAtIERpcmVjdGl2ZURlZmluaXRpb25cbiAgICAgICAqXG4gICAgICAgKiBUeXBlRGVmaW5pdGlvbiA6XG4gICAgICAgKiAgIC0gU2NhbGFyVHlwZURlZmluaXRpb25cbiAgICAgICAqICAgLSBPYmplY3RUeXBlRGVmaW5pdGlvblxuICAgICAgICogICAtIEludGVyZmFjZVR5cGVEZWZpbml0aW9uXG4gICAgICAgKiAgIC0gVW5pb25UeXBlRGVmaW5pdGlvblxuICAgICAgICogICAtIEVudW1UeXBlRGVmaW5pdGlvblxuICAgICAgICogICAtIElucHV0T2JqZWN0VHlwZURlZmluaXRpb25cbiAgICAgICAqL1xuICAgICAgcGFyc2VEZWZpbml0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wZWVrKFRva2VuS2luZC5CUkFDRV9MKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmF0aW9uRGVmaW5pdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc0Rlc2NyaXB0aW9uID0gdGhpcy5wZWVrRGVzY3JpcHRpb24oKTtcbiAgICAgICAgY29uc3Qga2V5d29yZFRva2VuID0gaGFzRGVzY3JpcHRpb24gPyB0aGlzLl9sZXhlci5sb29rYWhlYWQoKSA6IHRoaXMuX2xleGVyLnRva2VuO1xuICAgICAgICBpZiAoa2V5d29yZFRva2VuLmtpbmQgPT09IFRva2VuS2luZC5OQU1FKSB7XG4gICAgICAgICAgc3dpdGNoIChrZXl3b3JkVG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzY2hlbWFcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTY2hlbWFEZWZpbml0aW9uKCk7XG4gICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2NhbGFyVHlwZURlZmluaXRpb24oKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0VHlwZURlZmluaXRpb24oKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnRlcmZhY2VcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgY2FzZSBcInVuaW9uXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVW5pb25UeXBlRGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFbnVtVHlwZURlZmluaXRpb24oKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUlucHV0T2JqZWN0VHlwZURlZmluaXRpb24oKTtcbiAgICAgICAgICAgIGNhc2UgXCJkaXJlY3RpdmVcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEaXJlY3RpdmVEZWZpbml0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXG4gICAgICAgICAgICAgIHRoaXMuX2xleGVyLnNvdXJjZSxcbiAgICAgICAgICAgICAgdGhpcy5fbGV4ZXIudG9rZW4uc3RhcnQsXG4gICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBkZXNjcmlwdGlvbiwgZGVzY3JpcHRpb25zIGFyZSBzdXBwb3J0ZWQgb25seSBvbiB0eXBlIGRlZmluaXRpb25zLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKGtleXdvcmRUb2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInF1ZXJ5XCI6XG4gICAgICAgICAgICBjYXNlIFwibXV0YXRpb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJzdWJzY3JpcHRpb25cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYXRpb25EZWZpbml0aW9uKCk7XG4gICAgICAgICAgICBjYXNlIFwiZnJhZ21lbnRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGcmFnbWVudERlZmluaXRpb24oKTtcbiAgICAgICAgICAgIGNhc2UgXCJleHRlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUeXBlU3lzdGVtRXh0ZW5zaW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZChrZXl3b3JkVG9rZW4pO1xuICAgICAgfVxuICAgICAgLy8gSW1wbGVtZW50cyB0aGUgcGFyc2luZyBydWxlcyBpbiB0aGUgT3BlcmF0aW9ucyBzZWN0aW9uLlxuICAgICAgLyoqXG4gICAgICAgKiBPcGVyYXRpb25EZWZpbml0aW9uIDpcbiAgICAgICAqICAtIFNlbGVjdGlvblNldFxuICAgICAgICogIC0gT3BlcmF0aW9uVHlwZSBOYW1lPyBWYXJpYWJsZURlZmluaXRpb25zPyBEaXJlY3RpdmVzPyBTZWxlY3Rpb25TZXRcbiAgICAgICAqL1xuICAgICAgcGFyc2VPcGVyYXRpb25EZWZpbml0aW9uKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgICAgICBpZiAodGhpcy5wZWVrKFRva2VuS2luZC5CUkFDRV9MKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgICAgICAgIGtpbmQ6IEtpbmQuT1BFUkFUSU9OX0RFRklOSVRJT04sXG4gICAgICAgICAgICBvcGVyYXRpb246IE9wZXJhdGlvblR5cGVOb2RlLlFVRVJZLFxuICAgICAgICAgICAgbmFtZTogdm9pZCAwLFxuICAgICAgICAgICAgdmFyaWFibGVEZWZpbml0aW9uczogW10sXG4gICAgICAgICAgICBkaXJlY3RpdmVzOiBbXSxcbiAgICAgICAgICAgIHNlbGVjdGlvblNldDogdGhpcy5wYXJzZVNlbGVjdGlvblNldCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5wYXJzZU9wZXJhdGlvblR5cGUoKTtcbiAgICAgICAgbGV0IG5hbWU7XG4gICAgICAgIGlmICh0aGlzLnBlZWsoVG9rZW5LaW5kLk5BTUUpKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuT1BFUkFUSU9OX0RFRklOSVRJT04sXG4gICAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdmFyaWFibGVEZWZpbml0aW9uczogdGhpcy5wYXJzZVZhcmlhYmxlRGVmaW5pdGlvbnMoKSxcbiAgICAgICAgICBkaXJlY3RpdmVzOiB0aGlzLnBhcnNlRGlyZWN0aXZlcyhmYWxzZSksXG4gICAgICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIE9wZXJhdGlvblR5cGUgOiBvbmUgb2YgcXVlcnkgbXV0YXRpb24gc3Vic2NyaXB0aW9uXG4gICAgICAgKi9cbiAgICAgIHBhcnNlT3BlcmF0aW9uVHlwZSgpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uVG9rZW4gPSB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5OQU1FKTtcbiAgICAgICAgc3dpdGNoIChvcGVyYXRpb25Ub2tlbi52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJxdWVyeVwiOlxuICAgICAgICAgICAgcmV0dXJuIE9wZXJhdGlvblR5cGVOb2RlLlFVRVJZO1xuICAgICAgICAgIGNhc2UgXCJtdXRhdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIE9wZXJhdGlvblR5cGVOb2RlLk1VVEFUSU9OO1xuICAgICAgICAgIGNhc2UgXCJzdWJzY3JpcHRpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBPcGVyYXRpb25UeXBlTm9kZS5TVUJTQ1JJUFRJT047XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKG9wZXJhdGlvblRva2VuKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVmFyaWFibGVEZWZpbml0aW9ucyA6ICggVmFyaWFibGVEZWZpbml0aW9uKyApXG4gICAgICAgKi9cbiAgICAgIHBhcnNlVmFyaWFibGVEZWZpbml0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KFxuICAgICAgICAgIFRva2VuS2luZC5QQVJFTl9MLFxuICAgICAgICAgIHRoaXMucGFyc2VWYXJpYWJsZURlZmluaXRpb24sXG4gICAgICAgICAgVG9rZW5LaW5kLlBBUkVOX1JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVmFyaWFibGVEZWZpbml0aW9uIDogVmFyaWFibGUgOiBUeXBlIERlZmF1bHRWYWx1ZT8gRGlyZWN0aXZlc1tDb25zdF0/XG4gICAgICAgKi9cbiAgICAgIHBhcnNlVmFyaWFibGVEZWZpbml0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHRoaXMuX2xleGVyLnRva2VuLCB7XG4gICAgICAgICAga2luZDogS2luZC5WQVJJQUJMRV9ERUZJTklUSU9OLFxuICAgICAgICAgIHZhcmlhYmxlOiB0aGlzLnBhcnNlVmFyaWFibGUoKSxcbiAgICAgICAgICB0eXBlOiAodGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuQ09MT04pLCB0aGlzLnBhcnNlVHlwZVJlZmVyZW5jZSgpKSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihUb2tlbktpbmQuRVFVQUxTKSA/IHRoaXMucGFyc2VDb25zdFZhbHVlTGl0ZXJhbCgpIDogdm9pZCAwLFxuICAgICAgICAgIGRpcmVjdGl2ZXM6IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVmFyaWFibGUgOiAkIE5hbWVcbiAgICAgICAqL1xuICAgICAgcGFyc2VWYXJpYWJsZSgpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICAgICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuRE9MTEFSKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuVkFSSUFCTEUsXG4gICAgICAgICAgbmFtZTogdGhpcy5wYXJzZU5hbWUoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogYGBgXG4gICAgICAgKiBTZWxlY3Rpb25TZXQgOiB7IFNlbGVjdGlvbisgfVxuICAgICAgICogYGBgXG4gICAgICAgKi9cbiAgICAgIHBhcnNlU2VsZWN0aW9uU2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHRoaXMuX2xleGVyLnRva2VuLCB7XG4gICAgICAgICAga2luZDogS2luZC5TRUxFQ1RJT05fU0VULFxuICAgICAgICAgIHNlbGVjdGlvbnM6IHRoaXMubWFueShcbiAgICAgICAgICAgIFRva2VuS2luZC5CUkFDRV9MLFxuICAgICAgICAgICAgdGhpcy5wYXJzZVNlbGVjdGlvbixcbiAgICAgICAgICAgIFRva2VuS2luZC5CUkFDRV9SXG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0aW9uIDpcbiAgICAgICAqICAgLSBGaWVsZFxuICAgICAgICogICAtIEZyYWdtZW50U3ByZWFkXG4gICAgICAgKiAgIC0gSW5saW5lRnJhZ21lbnRcbiAgICAgICAqL1xuICAgICAgcGFyc2VTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlZWsoVG9rZW5LaW5kLlNQUkVBRCkgPyB0aGlzLnBhcnNlRnJhZ21lbnQoKSA6IHRoaXMucGFyc2VGaWVsZCgpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBGaWVsZCA6IEFsaWFzPyBOYW1lIEFyZ3VtZW50cz8gRGlyZWN0aXZlcz8gU2VsZWN0aW9uU2V0P1xuICAgICAgICpcbiAgICAgICAqIEFsaWFzIDogTmFtZSA6XG4gICAgICAgKi9cbiAgICAgIHBhcnNlRmllbGQoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgICAgIGNvbnN0IG5hbWVPckFsaWFzID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICAgICAgbGV0IGFsaWFzO1xuICAgICAgICBsZXQgbmFtZTtcbiAgICAgICAgaWYgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihUb2tlbktpbmQuQ09MT04pKSB7XG4gICAgICAgICAgYWxpYXMgPSBuYW1lT3JBbGlhcztcbiAgICAgICAgICBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gbmFtZU9yQWxpYXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuRklFTEQsXG4gICAgICAgICAgYWxpYXMsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBhcmd1bWVudHM6IHRoaXMucGFyc2VBcmd1bWVudHMoZmFsc2UpLFxuICAgICAgICAgIGRpcmVjdGl2ZXM6IHRoaXMucGFyc2VEaXJlY3RpdmVzKGZhbHNlKSxcbiAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHRoaXMucGVlayhUb2tlbktpbmQuQlJBQ0VfTCkgPyB0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCkgOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEFyZ3VtZW50c1tDb25zdF0gOiAoIEFyZ3VtZW50Wz9Db25zdF0rIClcbiAgICAgICAqL1xuICAgICAgcGFyc2VBcmd1bWVudHMoaXNDb25zdCkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXNDb25zdCA/IHRoaXMucGFyc2VDb25zdEFyZ3VtZW50IDogdGhpcy5wYXJzZUFyZ3VtZW50O1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkoVG9rZW5LaW5kLlBBUkVOX0wsIGl0ZW0sIFRva2VuS2luZC5QQVJFTl9SKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQXJndW1lbnRbQ29uc3RdIDogTmFtZSA6IFZhbHVlWz9Db25zdF1cbiAgICAgICAqL1xuICAgICAgcGFyc2VBcmd1bWVudChpc0NvbnN0ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkNPTE9OKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuQVJHVU1FTlQsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5wYXJzZVZhbHVlTGl0ZXJhbChpc0NvbnN0KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHBhcnNlQ29uc3RBcmd1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcmd1bWVudCh0cnVlKTtcbiAgICAgIH1cbiAgICAgIC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIEZyYWdtZW50cyBzZWN0aW9uLlxuICAgICAgLyoqXG4gICAgICAgKiBDb3JyZXNwb25kcyB0byBib3RoIEZyYWdtZW50U3ByZWFkIGFuZCBJbmxpbmVGcmFnbWVudCBpbiB0aGUgc3BlYy5cbiAgICAgICAqXG4gICAgICAgKiBGcmFnbWVudFNwcmVhZCA6IC4uLiBGcmFnbWVudE5hbWUgRGlyZWN0aXZlcz9cbiAgICAgICAqXG4gICAgICAgKiBJbmxpbmVGcmFnbWVudCA6IC4uLiBUeXBlQ29uZGl0aW9uPyBEaXJlY3RpdmVzPyBTZWxlY3Rpb25TZXRcbiAgICAgICAqL1xuICAgICAgcGFyc2VGcmFnbWVudCgpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICAgICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuU1BSRUFEKTtcbiAgICAgICAgY29uc3QgaGFzVHlwZUNvbmRpdGlvbiA9IHRoaXMuZXhwZWN0T3B0aW9uYWxLZXl3b3JkKFwib25cIik7XG4gICAgICAgIGlmICghaGFzVHlwZUNvbmRpdGlvbiAmJiB0aGlzLnBlZWsoVG9rZW5LaW5kLk5BTUUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICAgICAga2luZDogS2luZC5GUkFHTUVOVF9TUFJFQUQsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLnBhcnNlRnJhZ21lbnROYW1lKCksXG4gICAgICAgICAgICBkaXJlY3RpdmVzOiB0aGlzLnBhcnNlRGlyZWN0aXZlcyhmYWxzZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICAgICAga2luZDogS2luZC5JTkxJTkVfRlJBR01FTlQsXG4gICAgICAgICAgdHlwZUNvbmRpdGlvbjogaGFzVHlwZUNvbmRpdGlvbiA/IHRoaXMucGFyc2VOYW1lZFR5cGUoKSA6IHZvaWQgMCxcbiAgICAgICAgICBkaXJlY3RpdmVzOiB0aGlzLnBhcnNlRGlyZWN0aXZlcyhmYWxzZSksXG4gICAgICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEZyYWdtZW50RGVmaW5pdGlvbiA6XG4gICAgICAgKiAgIC0gZnJhZ21lbnQgRnJhZ21lbnROYW1lIG9uIFR5cGVDb25kaXRpb24gRGlyZWN0aXZlcz8gU2VsZWN0aW9uU2V0XG4gICAgICAgKlxuICAgICAgICogVHlwZUNvbmRpdGlvbiA6IE5hbWVkVHlwZVxuICAgICAgICovXG4gICAgICBwYXJzZUZyYWdtZW50RGVmaW5pdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKFwiZnJhZ21lbnRcIik7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmFsbG93TGVnYWN5RnJhZ21lbnRWYXJpYWJsZXMgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICAgICAgICBraW5kOiBLaW5kLkZSQUdNRU5UX0RFRklOSVRJT04sXG4gICAgICAgICAgICBuYW1lOiB0aGlzLnBhcnNlRnJhZ21lbnROYW1lKCksXG4gICAgICAgICAgICB2YXJpYWJsZURlZmluaXRpb25zOiB0aGlzLnBhcnNlVmFyaWFibGVEZWZpbml0aW9ucygpLFxuICAgICAgICAgICAgdHlwZUNvbmRpdGlvbjogKHRoaXMuZXhwZWN0S2V5d29yZChcIm9uXCIpLCB0aGlzLnBhcnNlTmFtZWRUeXBlKCkpLFxuICAgICAgICAgICAgZGlyZWN0aXZlczogdGhpcy5wYXJzZURpcmVjdGl2ZXMoZmFsc2UpLFxuICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICAgICAga2luZDogS2luZC5GUkFHTUVOVF9ERUZJTklUSU9OLFxuICAgICAgICAgIG5hbWU6IHRoaXMucGFyc2VGcmFnbWVudE5hbWUoKSxcbiAgICAgICAgICB0eXBlQ29uZGl0aW9uOiAodGhpcy5leHBlY3RLZXl3b3JkKFwib25cIiksIHRoaXMucGFyc2VOYW1lZFR5cGUoKSksXG4gICAgICAgICAgZGlyZWN0aXZlczogdGhpcy5wYXJzZURpcmVjdGl2ZXMoZmFsc2UpLFxuICAgICAgICAgIHNlbGVjdGlvblNldDogdGhpcy5wYXJzZVNlbGVjdGlvblNldCgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBGcmFnbWVudE5hbWUgOiBOYW1lIGJ1dCBub3QgYG9uYFxuICAgICAgICovXG4gICAgICBwYXJzZUZyYWdtZW50TmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xleGVyLnRva2VuLnZhbHVlID09PSBcIm9uXCIpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICAgIH1cbiAgICAgIC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIFZhbHVlcyBzZWN0aW9uLlxuICAgICAgLyoqXG4gICAgICAgKiBWYWx1ZVtDb25zdF0gOlxuICAgICAgICogICAtIFt+Q29uc3RdIFZhcmlhYmxlXG4gICAgICAgKiAgIC0gSW50VmFsdWVcbiAgICAgICAqICAgLSBGbG9hdFZhbHVlXG4gICAgICAgKiAgIC0gU3RyaW5nVmFsdWVcbiAgICAgICAqICAgLSBCb29sZWFuVmFsdWVcbiAgICAgICAqICAgLSBOdWxsVmFsdWVcbiAgICAgICAqICAgLSBFbnVtVmFsdWVcbiAgICAgICAqICAgLSBMaXN0VmFsdWVbP0NvbnN0XVxuICAgICAgICogICAtIE9iamVjdFZhbHVlWz9Db25zdF1cbiAgICAgICAqXG4gICAgICAgKiBCb29sZWFuVmFsdWUgOiBvbmUgb2YgYHRydWVgIGBmYWxzZWBcbiAgICAgICAqXG4gICAgICAgKiBOdWxsVmFsdWUgOiBgbnVsbGBcbiAgICAgICAqXG4gICAgICAgKiBFbnVtVmFsdWUgOiBOYW1lIGJ1dCBub3QgYHRydWVgLCBgZmFsc2VgIG9yIGBudWxsYFxuICAgICAgICovXG4gICAgICBwYXJzZVZhbHVlTGl0ZXJhbChpc0NvbnN0KSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgICAgIHN3aXRjaCAodG9rZW4ua2luZCkge1xuICAgICAgICAgIGNhc2UgVG9rZW5LaW5kLkJSQUNLRVRfTDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdChpc0NvbnN0KTtcbiAgICAgICAgICBjYXNlIFRva2VuS2luZC5CUkFDRV9MOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3QoaXNDb25zdCk7XG4gICAgICAgICAgY2FzZSBUb2tlbktpbmQuSU5UOlxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlTGV4ZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUodG9rZW4sIHtcbiAgICAgICAgICAgICAga2luZDogS2luZC5JTlQsXG4gICAgICAgICAgICAgIHZhbHVlOiB0b2tlbi52YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSBUb2tlbktpbmQuRkxPQVQ6XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2VMZXhlcigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZSh0b2tlbiwge1xuICAgICAgICAgICAgICBraW5kOiBLaW5kLkZMT0FULFxuICAgICAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgVG9rZW5LaW5kLlNUUklORzpcbiAgICAgICAgICBjYXNlIFRva2VuS2luZC5CTE9DS19TVFJJTkc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwoKTtcbiAgICAgICAgICBjYXNlIFRva2VuS2luZC5OQU1FOlxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlTGV4ZXIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRydWVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHRva2VuLCB7XG4gICAgICAgICAgICAgICAgICBraW5kOiBLaW5kLkJPT0xFQU4sXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjYXNlIFwiZmFsc2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHRva2VuLCB7XG4gICAgICAgICAgICAgICAgICBraW5kOiBLaW5kLkJPT0xFQU4sXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHRva2VuLCB7XG4gICAgICAgICAgICAgICAgICBraW5kOiBLaW5kLk5VTExcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHRva2VuLCB7XG4gICAgICAgICAgICAgICAgICBraW5kOiBLaW5kLkVOVU0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFRva2VuS2luZC5ET0xMQVI6XG4gICAgICAgICAgICBpZiAoaXNDb25zdCkge1xuICAgICAgICAgICAgICB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5ET0xMQVIpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fbGV4ZXIudG9rZW4ua2luZCA9PT0gVG9rZW5LaW5kLk5BTUUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJOYW1lID0gdGhpcy5fbGV4ZXIudG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXG4gICAgICAgICAgICAgICAgICB0aGlzLl9sZXhlci5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICB0b2tlbi5zdGFydCxcbiAgICAgICAgICAgICAgICAgIGBVbmV4cGVjdGVkIHZhcmlhYmxlIFwiJCR7dmFyTmFtZX1cIiBpbiBjb25zdGFudCB2YWx1ZS5gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhcmlhYmxlKCk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJzZUNvbnN0VmFsdWVMaXRlcmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhbHVlTGl0ZXJhbCh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHBhcnNlU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICAgICAgdGhpcy5hZHZhbmNlTGV4ZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZSh0b2tlbiwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuU1RSSU5HLFxuICAgICAgICAgIHZhbHVlOiB0b2tlbi52YWx1ZSxcbiAgICAgICAgICBibG9jazogdG9rZW4ua2luZCA9PT0gVG9rZW5LaW5kLkJMT0NLX1NUUklOR1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogTGlzdFZhbHVlW0NvbnN0XSA6XG4gICAgICAgKiAgIC0gWyBdXG4gICAgICAgKiAgIC0gWyBWYWx1ZVs/Q29uc3RdKyBdXG4gICAgICAgKi9cbiAgICAgIHBhcnNlTGlzdChpc0NvbnN0KSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSAoKSA9PiB0aGlzLnBhcnNlVmFsdWVMaXRlcmFsKGlzQ29uc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHRoaXMuX2xleGVyLnRva2VuLCB7XG4gICAgICAgICAga2luZDogS2luZC5MSVNULFxuICAgICAgICAgIHZhbHVlczogdGhpcy5hbnkoVG9rZW5LaW5kLkJSQUNLRVRfTCwgaXRlbSwgVG9rZW5LaW5kLkJSQUNLRVRfUilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIGBgYFxuICAgICAgICogT2JqZWN0VmFsdWVbQ29uc3RdIDpcbiAgICAgICAqICAgLSB7IH1cbiAgICAgICAqICAgLSB7IE9iamVjdEZpZWxkWz9Db25zdF0rIH1cbiAgICAgICAqIGBgYFxuICAgICAgICovXG4gICAgICBwYXJzZU9iamVjdChpc0NvbnN0KSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSAoKSA9PiB0aGlzLnBhcnNlT2JqZWN0RmllbGQoaXNDb25zdCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4sIHtcbiAgICAgICAgICBraW5kOiBLaW5kLk9CSkVDVCxcbiAgICAgICAgICBmaWVsZHM6IHRoaXMuYW55KFRva2VuS2luZC5CUkFDRV9MLCBpdGVtLCBUb2tlbktpbmQuQlJBQ0VfUilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIE9iamVjdEZpZWxkW0NvbnN0XSA6IE5hbWUgOiBWYWx1ZVs/Q29uc3RdXG4gICAgICAgKi9cbiAgICAgIHBhcnNlT2JqZWN0RmllbGQoaXNDb25zdCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICAgICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuQ09MT04pO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICAgICAga2luZDogS2luZC5PQkpFQ1RfRklFTEQsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5wYXJzZVZhbHVlTGl0ZXJhbChpc0NvbnN0KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIERpcmVjdGl2ZXMgc2VjdGlvbi5cbiAgICAgIC8qKlxuICAgICAgICogRGlyZWN0aXZlc1tDb25zdF0gOiBEaXJlY3RpdmVbP0NvbnN0XStcbiAgICAgICAqL1xuICAgICAgcGFyc2VEaXJlY3RpdmVzKGlzQ29uc3QpIHtcbiAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wZWVrKFRva2VuS2luZC5BVCkpIHtcbiAgICAgICAgICBkaXJlY3RpdmVzLnB1c2godGhpcy5wYXJzZURpcmVjdGl2ZShpc0NvbnN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXM7XG4gICAgICB9XG4gICAgICBwYXJzZUNvbnN0RGlyZWN0aXZlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBgYGBcbiAgICAgICAqIERpcmVjdGl2ZVtDb25zdF0gOiBAIE5hbWUgQXJndW1lbnRzWz9Db25zdF0/XG4gICAgICAgKiBgYGBcbiAgICAgICAqL1xuICAgICAgcGFyc2VEaXJlY3RpdmUoaXNDb25zdCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgICAgICB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5BVCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgICAgICBraW5kOiBLaW5kLkRJUkVDVElWRSxcbiAgICAgICAgICBuYW1lOiB0aGlzLnBhcnNlTmFtZSgpLFxuICAgICAgICAgIGFyZ3VtZW50czogdGhpcy5wYXJzZUFyZ3VtZW50cyhpc0NvbnN0KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIFR5cGVzIHNlY3Rpb24uXG4gICAgICAvKipcbiAgICAgICAqIFR5cGUgOlxuICAgICAgICogICAtIE5hbWVkVHlwZVxuICAgICAgICogICAtIExpc3RUeXBlXG4gICAgICAgKiAgIC0gTm9uTnVsbFR5cGVcbiAgICAgICAqL1xuICAgICAgcGFyc2VUeXBlUmVmZXJlbmNlKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgaWYgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihUb2tlbktpbmQuQlJBQ0tFVF9MKSkge1xuICAgICAgICAgIGNvbnN0IGlubmVyVHlwZSA9IHRoaXMucGFyc2VUeXBlUmVmZXJlbmNlKCk7XG4gICAgICAgICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuQlJBQ0tFVF9SKTtcbiAgICAgICAgICB0eXBlID0gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICAgICAgICBraW5kOiBLaW5kLkxJU1RfVFlQRSxcbiAgICAgICAgICAgIHR5cGU6IGlubmVyVHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSB0aGlzLnBhcnNlTmFtZWRUeXBlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihUb2tlbktpbmQuQkFORykpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICAgICAgICBraW5kOiBLaW5kLk5PTl9OVUxMX1RZUEUsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIE5hbWVkVHlwZSA6IE5hbWVcbiAgICAgICAqL1xuICAgICAgcGFyc2VOYW1lZFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4sIHtcbiAgICAgICAgICBraW5kOiBLaW5kLk5BTUVEX1RZUEUsXG4gICAgICAgICAgbmFtZTogdGhpcy5wYXJzZU5hbWUoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIFR5cGUgRGVmaW5pdGlvbiBzZWN0aW9uLlxuICAgICAgcGVla0Rlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZWVrKFRva2VuS2luZC5TVFJJTkcpIHx8IHRoaXMucGVlayhUb2tlbktpbmQuQkxPQ0tfU1RSSU5HKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRGVzY3JpcHRpb24gOiBTdHJpbmdWYWx1ZVxuICAgICAgICovXG4gICAgICBwYXJzZURlc2NyaXB0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wZWVrRGVzY3JpcHRpb24oKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIGBgYFxuICAgICAgICogU2NoZW1hRGVmaW5pdGlvbiA6IERlc2NyaXB0aW9uPyBzY2hlbWEgRGlyZWN0aXZlc1tDb25zdF0/IHsgT3BlcmF0aW9uVHlwZURlZmluaXRpb24rIH1cbiAgICAgICAqIGBgYFxuICAgICAgICovXG4gICAgICBwYXJzZVNjaGVtYURlZmluaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZChcInNjaGVtYVwiKTtcbiAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uVHlwZXMgPSB0aGlzLm1hbnkoXG4gICAgICAgICAgVG9rZW5LaW5kLkJSQUNFX0wsXG4gICAgICAgICAgdGhpcy5wYXJzZU9wZXJhdGlvblR5cGVEZWZpbml0aW9uLFxuICAgICAgICAgIFRva2VuS2luZC5CUkFDRV9SXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgICAgICBraW5kOiBLaW5kLlNDSEVNQV9ERUZJTklUSU9OLFxuICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgIGRpcmVjdGl2ZXMsXG4gICAgICAgICAgb3BlcmF0aW9uVHlwZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIE9wZXJhdGlvblR5cGVEZWZpbml0aW9uIDogT3BlcmF0aW9uVHlwZSA6IE5hbWVkVHlwZVxuICAgICAgICovXG4gICAgICBwYXJzZU9wZXJhdGlvblR5cGVEZWZpbml0aW9uKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLnBhcnNlT3BlcmF0aW9uVHlwZSgpO1xuICAgICAgICB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5DT0xPTik7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnBhcnNlTmFtZWRUeXBlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgICAgICBraW5kOiBLaW5kLk9QRVJBVElPTl9UWVBFX0RFRklOSVRJT04sXG4gICAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFNjYWxhclR5cGVEZWZpbml0aW9uIDogRGVzY3JpcHRpb24/IHNjYWxhciBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdP1xuICAgICAgICovXG4gICAgICBwYXJzZVNjYWxhclR5cGVEZWZpbml0aW9uKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoXCJzY2FsYXJcIik7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgICAgICBjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICAgICAga2luZDogS2luZC5TQ0FMQVJfVFlQRV9ERUZJTklUSU9OLFxuICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZGlyZWN0aXZlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogT2JqZWN0VHlwZURlZmluaXRpb24gOlxuICAgICAgICogICBEZXNjcmlwdGlvbj9cbiAgICAgICAqICAgdHlwZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzPyBEaXJlY3RpdmVzW0NvbnN0XT8gRmllbGRzRGVmaW5pdGlvbj9cbiAgICAgICAqL1xuICAgICAgcGFyc2VPYmplY3RUeXBlRGVmaW5pdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKFwidHlwZVwiKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgICAgIGNvbnN0IGludGVyZmFjZXMgPSB0aGlzLnBhcnNlSW1wbGVtZW50c0ludGVyZmFjZXMoKTtcbiAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5wYXJzZUZpZWxkc0RlZmluaXRpb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuT0JKRUNUX1RZUEVfREVGSU5JVElPTixcbiAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGludGVyZmFjZXMsXG4gICAgICAgICAgZGlyZWN0aXZlcyxcbiAgICAgICAgICBmaWVsZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEltcGxlbWVudHNJbnRlcmZhY2VzIDpcbiAgICAgICAqICAgLSBpbXBsZW1lbnRzIGAmYD8gTmFtZWRUeXBlXG4gICAgICAgKiAgIC0gSW1wbGVtZW50c0ludGVyZmFjZXMgJiBOYW1lZFR5cGVcbiAgICAgICAqL1xuICAgICAgcGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0T3B0aW9uYWxLZXl3b3JkKFwiaW1wbGVtZW50c1wiKSA/IHRoaXMuZGVsaW1pdGVkTWFueShUb2tlbktpbmQuQU1QLCB0aGlzLnBhcnNlTmFtZWRUeXBlKSA6IFtdO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBgYGBcbiAgICAgICAqIEZpZWxkc0RlZmluaXRpb24gOiB7IEZpZWxkRGVmaW5pdGlvbisgfVxuICAgICAgICogYGBgXG4gICAgICAgKi9cbiAgICAgIHBhcnNlRmllbGRzRGVmaW5pdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KFxuICAgICAgICAgIFRva2VuS2luZC5CUkFDRV9MLFxuICAgICAgICAgIHRoaXMucGFyc2VGaWVsZERlZmluaXRpb24sXG4gICAgICAgICAgVG9rZW5LaW5kLkJSQUNFX1JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRmllbGREZWZpbml0aW9uIDpcbiAgICAgICAqICAgLSBEZXNjcmlwdGlvbj8gTmFtZSBBcmd1bWVudHNEZWZpbml0aW9uPyA6IFR5cGUgRGlyZWN0aXZlc1tDb25zdF0/XG4gICAgICAgKi9cbiAgICAgIHBhcnNlRmllbGREZWZpbml0aW9uKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMucGFyc2VBcmd1bWVudERlZnMoKTtcbiAgICAgICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuQ09MT04pO1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5wYXJzZVR5cGVSZWZlcmVuY2UoKTtcbiAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuRklFTERfREVGSU5JVElPTixcbiAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGFyZ3VtZW50czogYXJncyxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGRpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEFyZ3VtZW50c0RlZmluaXRpb24gOiAoIElucHV0VmFsdWVEZWZpbml0aW9uKyApXG4gICAgICAgKi9cbiAgICAgIHBhcnNlQXJndW1lbnREZWZzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkoXG4gICAgICAgICAgVG9rZW5LaW5kLlBBUkVOX0wsXG4gICAgICAgICAgdGhpcy5wYXJzZUlucHV0VmFsdWVEZWYsXG4gICAgICAgICAgVG9rZW5LaW5kLlBBUkVOX1JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSW5wdXRWYWx1ZURlZmluaXRpb24gOlxuICAgICAgICogICAtIERlc2NyaXB0aW9uPyBOYW1lIDogVHlwZSBEZWZhdWx0VmFsdWU/IERpcmVjdGl2ZXNbQ29uc3RdP1xuICAgICAgICovXG4gICAgICBwYXJzZUlucHV0VmFsdWVEZWYoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgICAgICB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5DT0xPTik7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnBhcnNlVHlwZVJlZmVyZW5jZSgpO1xuICAgICAgICBsZXQgZGVmYXVsdFZhbHVlO1xuICAgICAgICBpZiAodGhpcy5leHBlY3RPcHRpb25hbFRva2VuKFRva2VuS2luZC5FUVVBTFMpKSB7XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gdGhpcy5wYXJzZUNvbnN0VmFsdWVMaXRlcmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuSU5QVVRfVkFMVUVfREVGSU5JVElPTixcbiAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgICAgIGRpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEludGVyZmFjZVR5cGVEZWZpbml0aW9uIDpcbiAgICAgICAqICAgLSBEZXNjcmlwdGlvbj8gaW50ZXJmYWNlIE5hbWUgRGlyZWN0aXZlc1tDb25zdF0/IEZpZWxkc0RlZmluaXRpb24/XG4gICAgICAgKi9cbiAgICAgIHBhcnNlSW50ZXJmYWNlVHlwZURlZmluaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZChcImludGVyZmFjZVwiKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgICAgIGNvbnN0IGludGVyZmFjZXMgPSB0aGlzLnBhcnNlSW1wbGVtZW50c0ludGVyZmFjZXMoKTtcbiAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5wYXJzZUZpZWxkc0RlZmluaXRpb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuSU5URVJGQUNFX1RZUEVfREVGSU5JVElPTixcbiAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGludGVyZmFjZXMsXG4gICAgICAgICAgZGlyZWN0aXZlcyxcbiAgICAgICAgICBmaWVsZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFVuaW9uVHlwZURlZmluaXRpb24gOlxuICAgICAgICogICAtIERlc2NyaXB0aW9uPyB1bmlvbiBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdPyBVbmlvbk1lbWJlclR5cGVzP1xuICAgICAgICovXG4gICAgICBwYXJzZVVuaW9uVHlwZURlZmluaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZChcInVuaW9uXCIpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSB0aGlzLnBhcnNlVW5pb25NZW1iZXJUeXBlcygpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICAgICAga2luZDogS2luZC5VTklPTl9UWVBFX0RFRklOSVRJT04sXG4gICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkaXJlY3RpdmVzLFxuICAgICAgICAgIHR5cGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBVbmlvbk1lbWJlclR5cGVzIDpcbiAgICAgICAqICAgLSA9IGB8YD8gTmFtZWRUeXBlXG4gICAgICAgKiAgIC0gVW5pb25NZW1iZXJUeXBlcyB8IE5hbWVkVHlwZVxuICAgICAgICovXG4gICAgICBwYXJzZVVuaW9uTWVtYmVyVHlwZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oVG9rZW5LaW5kLkVRVUFMUykgPyB0aGlzLmRlbGltaXRlZE1hbnkoVG9rZW5LaW5kLlBJUEUsIHRoaXMucGFyc2VOYW1lZFR5cGUpIDogW107XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEVudW1UeXBlRGVmaW5pdGlvbiA6XG4gICAgICAgKiAgIC0gRGVzY3JpcHRpb24/IGVudW0gTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gRW51bVZhbHVlc0RlZmluaXRpb24/XG4gICAgICAgKi9cbiAgICAgIHBhcnNlRW51bVR5cGVEZWZpbml0aW9uKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoXCJlbnVtXCIpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5wYXJzZUVudW1WYWx1ZXNEZWZpbml0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgICAgICBraW5kOiBLaW5kLkVOVU1fVFlQRV9ERUZJTklUSU9OLFxuICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZGlyZWN0aXZlcyxcbiAgICAgICAgICB2YWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIGBgYFxuICAgICAgICogRW51bVZhbHVlc0RlZmluaXRpb24gOiB7IEVudW1WYWx1ZURlZmluaXRpb24rIH1cbiAgICAgICAqIGBgYFxuICAgICAgICovXG4gICAgICBwYXJzZUVudW1WYWx1ZXNEZWZpbml0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkoXG4gICAgICAgICAgVG9rZW5LaW5kLkJSQUNFX0wsXG4gICAgICAgICAgdGhpcy5wYXJzZUVudW1WYWx1ZURlZmluaXRpb24sXG4gICAgICAgICAgVG9rZW5LaW5kLkJSQUNFX1JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRW51bVZhbHVlRGVmaW5pdGlvbiA6IERlc2NyaXB0aW9uPyBFbnVtVmFsdWUgRGlyZWN0aXZlc1tDb25zdF0/XG4gICAgICAgKi9cbiAgICAgIHBhcnNlRW51bVZhbHVlRGVmaW5pdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VFbnVtVmFsdWVOYW1lKCk7XG4gICAgICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgICAgICBraW5kOiBLaW5kLkVOVU1fVkFMVUVfREVGSU5JVElPTixcbiAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGRpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEVudW1WYWx1ZSA6IE5hbWUgYnV0IG5vdCBgdHJ1ZWAsIGBmYWxzZWAgb3IgYG51bGxgXG4gICAgICAgKi9cbiAgICAgIHBhcnNlRW51bVZhbHVlTmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xleGVyLnRva2VuLnZhbHVlID09PSBcInRydWVcIiB8fCB0aGlzLl9sZXhlci50b2tlbi52YWx1ZSA9PT0gXCJmYWxzZVwiIHx8IHRoaXMuX2xleGVyLnRva2VuLnZhbHVlID09PSBcIm51bGxcIikge1xuICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFxuICAgICAgICAgICAgdGhpcy5fbGV4ZXIuc291cmNlLFxuICAgICAgICAgICAgdGhpcy5fbGV4ZXIudG9rZW4uc3RhcnQsXG4gICAgICAgICAgICBgJHtnZXRUb2tlbkRlc2MoXG4gICAgICAgICAgICAgIHRoaXMuX2xleGVyLnRva2VuXG4gICAgICAgICAgICApfSBpcyByZXNlcnZlZCBhbmQgY2Fubm90IGJlIHVzZWQgZm9yIGFuIGVudW0gdmFsdWUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VOYW1lKCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIElucHV0T2JqZWN0VHlwZURlZmluaXRpb24gOlxuICAgICAgICogICAtIERlc2NyaXB0aW9uPyBpbnB1dCBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdPyBJbnB1dEZpZWxkc0RlZmluaXRpb24/XG4gICAgICAgKi9cbiAgICAgIHBhcnNlSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKFwiaW5wdXRcIik7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgICAgICBjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnBhcnNlSW5wdXRGaWVsZHNEZWZpbml0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgICAgICBraW5kOiBLaW5kLklOUFVUX09CSkVDVF9UWVBFX0RFRklOSVRJT04sXG4gICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkaXJlY3RpdmVzLFxuICAgICAgICAgIGZpZWxkc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogYGBgXG4gICAgICAgKiBJbnB1dEZpZWxkc0RlZmluaXRpb24gOiB7IElucHV0VmFsdWVEZWZpbml0aW9uKyB9XG4gICAgICAgKiBgYGBcbiAgICAgICAqL1xuICAgICAgcGFyc2VJbnB1dEZpZWxkc0RlZmluaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbmFsTWFueShcbiAgICAgICAgICBUb2tlbktpbmQuQlJBQ0VfTCxcbiAgICAgICAgICB0aGlzLnBhcnNlSW5wdXRWYWx1ZURlZixcbiAgICAgICAgICBUb2tlbktpbmQuQlJBQ0VfUlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUeXBlU3lzdGVtRXh0ZW5zaW9uIDpcbiAgICAgICAqICAgLSBTY2hlbWFFeHRlbnNpb25cbiAgICAgICAqICAgLSBUeXBlRXh0ZW5zaW9uXG4gICAgICAgKlxuICAgICAgICogVHlwZUV4dGVuc2lvbiA6XG4gICAgICAgKiAgIC0gU2NhbGFyVHlwZUV4dGVuc2lvblxuICAgICAgICogICAtIE9iamVjdFR5cGVFeHRlbnNpb25cbiAgICAgICAqICAgLSBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uXG4gICAgICAgKiAgIC0gVW5pb25UeXBlRXh0ZW5zaW9uXG4gICAgICAgKiAgIC0gRW51bVR5cGVFeHRlbnNpb25cbiAgICAgICAqICAgLSBJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uXG4gICAgICAgKi9cbiAgICAgIHBhcnNlVHlwZVN5c3RlbUV4dGVuc2lvbigpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZFRva2VuID0gdGhpcy5fbGV4ZXIubG9va2FoZWFkKCk7XG4gICAgICAgIGlmIChrZXl3b3JkVG9rZW4ua2luZCA9PT0gVG9rZW5LaW5kLk5BTUUpIHtcbiAgICAgICAgICBzd2l0Y2ggKGtleXdvcmRUb2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInNjaGVtYVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNjaGVtYUV4dGVuc2lvbigpO1xuICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNjYWxhclR5cGVFeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0VHlwZUV4dGVuc2lvbigpO1xuICAgICAgICAgICAgY2FzZSBcImludGVyZmFjZVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUludGVyZmFjZVR5cGVFeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGNhc2UgXCJ1bmlvblwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVVuaW9uVHlwZUV4dGVuc2lvbigpO1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFbnVtVHlwZUV4dGVuc2lvbigpO1xuICAgICAgICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZChrZXl3b3JkVG9rZW4pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBgYGBcbiAgICAgICAqIFNjaGVtYUV4dGVuc2lvbiA6XG4gICAgICAgKiAgLSBleHRlbmQgc2NoZW1hIERpcmVjdGl2ZXNbQ29uc3RdPyB7IE9wZXJhdGlvblR5cGVEZWZpbml0aW9uKyB9XG4gICAgICAgKiAgLSBleHRlbmQgc2NoZW1hIERpcmVjdGl2ZXNbQ29uc3RdXG4gICAgICAgKiBgYGBcbiAgICAgICAqL1xuICAgICAgcGFyc2VTY2hlbWFFeHRlbnNpb24oKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZChcImV4dGVuZFwiKTtcbiAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKFwic2NoZW1hXCIpO1xuICAgICAgICBjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO1xuICAgICAgICBjb25zdCBvcGVyYXRpb25UeXBlcyA9IHRoaXMub3B0aW9uYWxNYW55KFxuICAgICAgICAgIFRva2VuS2luZC5CUkFDRV9MLFxuICAgICAgICAgIHRoaXMucGFyc2VPcGVyYXRpb25UeXBlRGVmaW5pdGlvbixcbiAgICAgICAgICBUb2tlbktpbmQuQlJBQ0VfUlxuICAgICAgICApO1xuICAgICAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPT09IDAgJiYgb3BlcmF0aW9uVHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuU0NIRU1BX0VYVEVOU0lPTixcbiAgICAgICAgICBkaXJlY3RpdmVzLFxuICAgICAgICAgIG9wZXJhdGlvblR5cGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBTY2FsYXJUeXBlRXh0ZW5zaW9uIDpcbiAgICAgICAqICAgLSBleHRlbmQgc2NhbGFyIE5hbWUgRGlyZWN0aXZlc1tDb25zdF1cbiAgICAgICAqL1xuICAgICAgcGFyc2VTY2FsYXJUeXBlRXh0ZW5zaW9uKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoXCJleHRlbmRcIik7XG4gICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZChcInNjYWxhclwiKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG4gICAgICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgICAgICBraW5kOiBLaW5kLlNDQUxBUl9UWVBFX0VYVEVOU0lPTixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGRpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIE9iamVjdFR5cGVFeHRlbnNpb24gOlxuICAgICAgICogIC0gZXh0ZW5kIHR5cGUgTmFtZSBJbXBsZW1lbnRzSW50ZXJmYWNlcz8gRGlyZWN0aXZlc1tDb25zdF0/IEZpZWxkc0RlZmluaXRpb25cbiAgICAgICAqICAtIGV4dGVuZCB0eXBlIE5hbWUgSW1wbGVtZW50c0ludGVyZmFjZXM/IERpcmVjdGl2ZXNbQ29uc3RdXG4gICAgICAgKiAgLSBleHRlbmQgdHlwZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzXG4gICAgICAgKi9cbiAgICAgIHBhcnNlT2JqZWN0VHlwZUV4dGVuc2lvbigpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKFwiZXh0ZW5kXCIpO1xuICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoXCJ0eXBlXCIpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICAgICAgY29uc3QgaW50ZXJmYWNlcyA9IHRoaXMucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpO1xuICAgICAgICBjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnBhcnNlRmllbGRzRGVmaW5pdGlvbigpO1xuICAgICAgICBpZiAoaW50ZXJmYWNlcy5sZW5ndGggPT09IDAgJiYgZGlyZWN0aXZlcy5sZW5ndGggPT09IDAgJiYgZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgICAgICBraW5kOiBLaW5kLk9CSkVDVF9UWVBFX0VYVEVOU0lPTixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGludGVyZmFjZXMsXG4gICAgICAgICAgZGlyZWN0aXZlcyxcbiAgICAgICAgICBmaWVsZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEludGVyZmFjZVR5cGVFeHRlbnNpb24gOlxuICAgICAgICogIC0gZXh0ZW5kIGludGVyZmFjZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzPyBEaXJlY3RpdmVzW0NvbnN0XT8gRmllbGRzRGVmaW5pdGlvblxuICAgICAgICogIC0gZXh0ZW5kIGludGVyZmFjZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzPyBEaXJlY3RpdmVzW0NvbnN0XVxuICAgICAgICogIC0gZXh0ZW5kIGludGVyZmFjZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzXG4gICAgICAgKi9cbiAgICAgIHBhcnNlSW50ZXJmYWNlVHlwZUV4dGVuc2lvbigpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKFwiZXh0ZW5kXCIpO1xuICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoXCJpbnRlcmZhY2VcIik7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgICAgICBjb25zdCBpbnRlcmZhY2VzID0gdGhpcy5wYXJzZUltcGxlbWVudHNJbnRlcmZhY2VzKCk7XG4gICAgICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMucGFyc2VGaWVsZHNEZWZpbml0aW9uKCk7XG4gICAgICAgIGlmIChpbnRlcmZhY2VzLmxlbmd0aCA9PT0gMCAmJiBkaXJlY3RpdmVzLmxlbmd0aCA9PT0gMCAmJiBmaWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuSU5URVJGQUNFX1RZUEVfRVhURU5TSU9OLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaW50ZXJmYWNlcyxcbiAgICAgICAgICBkaXJlY3RpdmVzLFxuICAgICAgICAgIGZpZWxkc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVW5pb25UeXBlRXh0ZW5zaW9uIDpcbiAgICAgICAqICAgLSBleHRlbmQgdW5pb24gTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gVW5pb25NZW1iZXJUeXBlc1xuICAgICAgICogICAtIGV4dGVuZCB1bmlvbiBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdXG4gICAgICAgKi9cbiAgICAgIHBhcnNlVW5pb25UeXBlRXh0ZW5zaW9uKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoXCJleHRlbmRcIik7XG4gICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZChcInVuaW9uXCIpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSB0aGlzLnBhcnNlVW5pb25NZW1iZXJUeXBlcygpO1xuICAgICAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPT09IDAgJiYgdHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuVU5JT05fVFlQRV9FWFRFTlNJT04sXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkaXJlY3RpdmVzLFxuICAgICAgICAgIHR5cGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBFbnVtVHlwZUV4dGVuc2lvbiA6XG4gICAgICAgKiAgIC0gZXh0ZW5kIGVudW0gTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gRW51bVZhbHVlc0RlZmluaXRpb25cbiAgICAgICAqICAgLSBleHRlbmQgZW51bSBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdXG4gICAgICAgKi9cbiAgICAgIHBhcnNlRW51bVR5cGVFeHRlbnNpb24oKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZChcImV4dGVuZFwiKTtcbiAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKFwiZW51bVwiKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMucGFyc2VFbnVtVmFsdWVzRGVmaW5pdGlvbigpO1xuICAgICAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPT09IDAgJiYgdmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgICAgICBraW5kOiBLaW5kLkVOVU1fVFlQRV9FWFRFTlNJT04sXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkaXJlY3RpdmVzLFxuICAgICAgICAgIHZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uIDpcbiAgICAgICAqICAgLSBleHRlbmQgaW5wdXQgTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gSW5wdXRGaWVsZHNEZWZpbml0aW9uXG4gICAgICAgKiAgIC0gZXh0ZW5kIGlucHV0IE5hbWUgRGlyZWN0aXZlc1tDb25zdF1cbiAgICAgICAqL1xuICAgICAgcGFyc2VJbnB1dE9iamVjdFR5cGVFeHRlbnNpb24oKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZChcImV4dGVuZFwiKTtcbiAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKFwiaW5wdXRcIik7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgICAgICBjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnBhcnNlSW5wdXRGaWVsZHNEZWZpbml0aW9uKCk7XG4gICAgICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCA9PT0gMCAmJiBmaWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuSU5QVVRfT0JKRUNUX1RZUEVfRVhURU5TSU9OLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZGlyZWN0aXZlcyxcbiAgICAgICAgICBmaWVsZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIGBgYFxuICAgICAgICogRGlyZWN0aXZlRGVmaW5pdGlvbiA6XG4gICAgICAgKiAgIC0gRGVzY3JpcHRpb24/IGRpcmVjdGl2ZSBAIE5hbWUgQXJndW1lbnRzRGVmaW5pdGlvbj8gYHJlcGVhdGFibGVgPyBvbiBEaXJlY3RpdmVMb2NhdGlvbnNcbiAgICAgICAqIGBgYFxuICAgICAgICovXG4gICAgICBwYXJzZURpcmVjdGl2ZURlZmluaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZChcImRpcmVjdGl2ZVwiKTtcbiAgICAgICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuQVQpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMucGFyc2VBcmd1bWVudERlZnMoKTtcbiAgICAgICAgY29uc3QgcmVwZWF0YWJsZSA9IHRoaXMuZXhwZWN0T3B0aW9uYWxLZXl3b3JkKFwicmVwZWF0YWJsZVwiKTtcbiAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKFwib25cIik7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9ucyA9IHRoaXMucGFyc2VEaXJlY3RpdmVMb2NhdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuRElSRUNUSVZFX0RFRklOSVRJT04sXG4gICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBhcmd1bWVudHM6IGFyZ3MsXG4gICAgICAgICAgcmVwZWF0YWJsZSxcbiAgICAgICAgICBsb2NhdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIERpcmVjdGl2ZUxvY2F0aW9ucyA6XG4gICAgICAgKiAgIC0gYHxgPyBEaXJlY3RpdmVMb2NhdGlvblxuICAgICAgICogICAtIERpcmVjdGl2ZUxvY2F0aW9ucyB8IERpcmVjdGl2ZUxvY2F0aW9uXG4gICAgICAgKi9cbiAgICAgIHBhcnNlRGlyZWN0aXZlTG9jYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxpbWl0ZWRNYW55KFRva2VuS2luZC5QSVBFLCB0aGlzLnBhcnNlRGlyZWN0aXZlTG9jYXRpb24pO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgICAqIERpcmVjdGl2ZUxvY2F0aW9uIDpcbiAgICAgICAqICAgLSBFeGVjdXRhYmxlRGlyZWN0aXZlTG9jYXRpb25cbiAgICAgICAqICAgLSBUeXBlU3lzdGVtRGlyZWN0aXZlTG9jYXRpb25cbiAgICAgICAqXG4gICAgICAgKiBFeGVjdXRhYmxlRGlyZWN0aXZlTG9jYXRpb24gOiBvbmUgb2ZcbiAgICAgICAqICAgYFFVRVJZYFxuICAgICAgICogICBgTVVUQVRJT05gXG4gICAgICAgKiAgIGBTVUJTQ1JJUFRJT05gXG4gICAgICAgKiAgIGBGSUVMRGBcbiAgICAgICAqICAgYEZSQUdNRU5UX0RFRklOSVRJT05gXG4gICAgICAgKiAgIGBGUkFHTUVOVF9TUFJFQURgXG4gICAgICAgKiAgIGBJTkxJTkVfRlJBR01FTlRgXG4gICAgICAgKlxuICAgICAgICogVHlwZVN5c3RlbURpcmVjdGl2ZUxvY2F0aW9uIDogb25lIG9mXG4gICAgICAgKiAgIGBTQ0hFTUFgXG4gICAgICAgKiAgIGBTQ0FMQVJgXG4gICAgICAgKiAgIGBPQkpFQ1RgXG4gICAgICAgKiAgIGBGSUVMRF9ERUZJTklUSU9OYFxuICAgICAgICogICBgQVJHVU1FTlRfREVGSU5JVElPTmBcbiAgICAgICAqICAgYElOVEVSRkFDRWBcbiAgICAgICAqICAgYFVOSU9OYFxuICAgICAgICogICBgRU5VTWBcbiAgICAgICAqICAgYEVOVU1fVkFMVUVgXG4gICAgICAgKiAgIGBJTlBVVF9PQkpFQ1RgXG4gICAgICAgKiAgIGBJTlBVVF9GSUVMRF9ERUZJTklUSU9OYFxuICAgICAgICovXG4gICAgICBwYXJzZURpcmVjdGl2ZUxvY2F0aW9uKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChEaXJlY3RpdmVMb2NhdGlvbiwgbmFtZS52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoc3RhcnQpO1xuICAgICAgfVxuICAgICAgLy8gQ29yZSBwYXJzaW5nIHV0aWxpdHkgZnVuY3Rpb25zXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBub2RlIHRoYXQsIGlmIGNvbmZpZ3VyZWQgdG8gZG8gc28sIHNldHMgYSBcImxvY1wiIGZpZWxkIGFzIGFcbiAgICAgICAqIGxvY2F0aW9uIG9iamVjdCwgdXNlZCB0byBpZGVudGlmeSB0aGUgcGxhY2UgaW4gdGhlIHNvdXJjZSB0aGF0IGNyZWF0ZWQgYVxuICAgICAgICogZ2l2ZW4gcGFyc2VkIG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgbm9kZShzdGFydFRva2VuLCBub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLm5vTG9jYXRpb24gIT09IHRydWUpIHtcbiAgICAgICAgICBub2RlLmxvYyA9IG5ldyBMb2NhdGlvbihcbiAgICAgICAgICAgIHN0YXJ0VG9rZW4sXG4gICAgICAgICAgICB0aGlzLl9sZXhlci5sYXN0VG9rZW4sXG4gICAgICAgICAgICB0aGlzLl9sZXhlci5zb3VyY2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBuZXh0IHRva2VuIGlzIG9mIGEgZ2l2ZW4ga2luZFxuICAgICAgICovXG4gICAgICBwZWVrKGtpbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xleGVyLnRva2VuLmtpbmQgPT09IGtpbmQ7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIElmIHRoZSBuZXh0IHRva2VuIGlzIG9mIHRoZSBnaXZlbiBraW5kLCByZXR1cm4gdGhhdCB0b2tlbiBhZnRlciBhZHZhbmNpbmcgdGhlIGxleGVyLlxuICAgICAgICogT3RoZXJ3aXNlLCBkbyBub3QgY2hhbmdlIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93IGFuIGVycm9yLlxuICAgICAgICovXG4gICAgICBleHBlY3RUb2tlbihraW5kKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgICAgIGlmICh0b2tlbi5raW5kID09PSBraW5kKSB7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlTGV4ZXIoKTtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXG4gICAgICAgICAgdGhpcy5fbGV4ZXIuc291cmNlLFxuICAgICAgICAgIHRva2VuLnN0YXJ0LFxuICAgICAgICAgIGBFeHBlY3RlZCAke2dldFRva2VuS2luZERlc2Moa2luZCl9LCBmb3VuZCAke2dldFRva2VuRGVzYyh0b2tlbil9LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSWYgdGhlIG5leHQgdG9rZW4gaXMgb2YgdGhlIGdpdmVuIGtpbmQsIHJldHVybiBcInRydWVcIiBhZnRlciBhZHZhbmNpbmcgdGhlIGxleGVyLlxuICAgICAgICogT3RoZXJ3aXNlLCBkbyBub3QgY2hhbmdlIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHJldHVybiBcImZhbHNlXCIuXG4gICAgICAgKi9cbiAgICAgIGV4cGVjdE9wdGlvbmFsVG9rZW4oa2luZCkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgICAgICBpZiAodG9rZW4ua2luZCA9PT0ga2luZCkge1xuICAgICAgICAgIHRoaXMuYWR2YW5jZUxleGVyKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGUgbmV4dCB0b2tlbiBpcyBhIGdpdmVuIGtleXdvcmQsIGFkdmFuY2UgdGhlIGxleGVyLlxuICAgICAgICogT3RoZXJ3aXNlLCBkbyBub3QgY2hhbmdlIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93IGFuIGVycm9yLlxuICAgICAgICovXG4gICAgICBleHBlY3RLZXl3b3JkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgICAgIGlmICh0b2tlbi5raW5kID09PSBUb2tlbktpbmQuTkFNRSAmJiB0b2tlbi52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmFkdmFuY2VMZXhlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFxuICAgICAgICAgICAgdGhpcy5fbGV4ZXIuc291cmNlLFxuICAgICAgICAgICAgdG9rZW4uc3RhcnQsXG4gICAgICAgICAgICBgRXhwZWN0ZWQgXCIke3ZhbHVlfVwiLCBmb3VuZCAke2dldFRva2VuRGVzYyh0b2tlbil9LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIElmIHRoZSBuZXh0IHRva2VuIGlzIGEgZ2l2ZW4ga2V5d29yZCwgcmV0dXJuIFwidHJ1ZVwiIGFmdGVyIGFkdmFuY2luZyB0aGUgbGV4ZXIuXG4gICAgICAgKiBPdGhlcndpc2UsIGRvIG5vdCBjaGFuZ2UgdGhlIHBhcnNlciBzdGF0ZSBhbmQgcmV0dXJuIFwiZmFsc2VcIi5cbiAgICAgICAqL1xuICAgICAgZXhwZWN0T3B0aW9uYWxLZXl3b3JkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgICAgIGlmICh0b2tlbi5raW5kID09PSBUb2tlbktpbmQuTkFNRSAmJiB0b2tlbi52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmFkdmFuY2VMZXhlcigpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhbiBlcnJvciB3aGVuIGFuIHVuZXhwZWN0ZWQgbGV4ZWQgdG9rZW4gaXMgZW5jb3VudGVyZWQuXG4gICAgICAgKi9cbiAgICAgIHVuZXhwZWN0ZWQoYXRUb2tlbikge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGF0VG9rZW4gIT09IG51bGwgJiYgYXRUb2tlbiAhPT0gdm9pZCAwID8gYXRUb2tlbiA6IHRoaXMuX2xleGVyLnRva2VuO1xuICAgICAgICByZXR1cm4gc3ludGF4RXJyb3IoXG4gICAgICAgICAgdGhpcy5fbGV4ZXIuc291cmNlLFxuICAgICAgICAgIHRva2VuLnN0YXJ0LFxuICAgICAgICAgIGBVbmV4cGVjdGVkICR7Z2V0VG9rZW5EZXNjKHRva2VuKX0uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgcG9zc2libHkgZW1wdHkgbGlzdCBvZiBwYXJzZSBub2RlcywgZGV0ZXJtaW5lZCBieSB0aGUgcGFyc2VGbi5cbiAgICAgICAqIFRoaXMgbGlzdCBiZWdpbnMgd2l0aCBhIGxleCB0b2tlbiBvZiBvcGVuS2luZCBhbmQgZW5kcyB3aXRoIGEgbGV4IHRva2VuIG9mIGNsb3NlS2luZC5cbiAgICAgICAqIEFkdmFuY2VzIHRoZSBwYXJzZXIgdG8gdGhlIG5leHQgbGV4IHRva2VuIGFmdGVyIHRoZSBjbG9zaW5nIHRva2VuLlxuICAgICAgICovXG4gICAgICBhbnkob3BlbktpbmQsIHBhcnNlRm4sIGNsb3NlS2luZCkge1xuICAgICAgICB0aGlzLmV4cGVjdFRva2VuKG9wZW5LaW5kKTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oY2xvc2VLaW5kKSkge1xuICAgICAgICAgIG5vZGVzLnB1c2gocGFyc2VGbi5jYWxsKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHBhcnNlIG5vZGVzLCBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJzZUZuLlxuICAgICAgICogSXQgY2FuIGJlIGVtcHR5IG9ubHkgaWYgb3BlbiB0b2tlbiBpcyBtaXNzaW5nIG90aGVyd2lzZSBpdCB3aWxsIGFsd2F5cyByZXR1cm4gbm9uLWVtcHR5IGxpc3RcbiAgICAgICAqIHRoYXQgYmVnaW5zIHdpdGggYSBsZXggdG9rZW4gb2Ygb3BlbktpbmQgYW5kIGVuZHMgd2l0aCBhIGxleCB0b2tlbiBvZiBjbG9zZUtpbmQuXG4gICAgICAgKiBBZHZhbmNlcyB0aGUgcGFyc2VyIHRvIHRoZSBuZXh0IGxleCB0b2tlbiBhZnRlciB0aGUgY2xvc2luZyB0b2tlbi5cbiAgICAgICAqL1xuICAgICAgb3B0aW9uYWxNYW55KG9wZW5LaW5kLCBwYXJzZUZuLCBjbG9zZUtpbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihvcGVuS2luZCkpIHtcbiAgICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gocGFyc2VGbi5jYWxsKHRoaXMpKTtcbiAgICAgICAgICB9IHdoaWxlICghdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGNsb3NlS2luZCkpO1xuICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBub24tZW1wdHkgbGlzdCBvZiBwYXJzZSBub2RlcywgZGV0ZXJtaW5lZCBieSB0aGUgcGFyc2VGbi5cbiAgICAgICAqIFRoaXMgbGlzdCBiZWdpbnMgd2l0aCBhIGxleCB0b2tlbiBvZiBvcGVuS2luZCBhbmQgZW5kcyB3aXRoIGEgbGV4IHRva2VuIG9mIGNsb3NlS2luZC5cbiAgICAgICAqIEFkdmFuY2VzIHRoZSBwYXJzZXIgdG8gdGhlIG5leHQgbGV4IHRva2VuIGFmdGVyIHRoZSBjbG9zaW5nIHRva2VuLlxuICAgICAgICovXG4gICAgICBtYW55KG9wZW5LaW5kLCBwYXJzZUZuLCBjbG9zZUtpbmQpIHtcbiAgICAgICAgdGhpcy5leHBlY3RUb2tlbihvcGVuS2luZCk7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKHBhcnNlRm4uY2FsbCh0aGlzKSk7XG4gICAgICAgIH0gd2hpbGUgKCF0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oY2xvc2VLaW5kKSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIG5vbi1lbXB0eSBsaXN0IG9mIHBhcnNlIG5vZGVzLCBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJzZUZuLlxuICAgICAgICogVGhpcyBsaXN0IG1heSBiZWdpbiB3aXRoIGEgbGV4IHRva2VuIG9mIGRlbGltaXRlcktpbmQgZm9sbG93ZWQgYnkgaXRlbXMgc2VwYXJhdGVkIGJ5IGxleCB0b2tlbnMgb2YgdG9rZW5LaW5kLlxuICAgICAgICogQWR2YW5jZXMgdGhlIHBhcnNlciB0byB0aGUgbmV4dCBsZXggdG9rZW4gYWZ0ZXIgbGFzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgICovXG4gICAgICBkZWxpbWl0ZWRNYW55KGRlbGltaXRlcktpbmQsIHBhcnNlRm4pIHtcbiAgICAgICAgdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGRlbGltaXRlcktpbmQpO1xuICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbm9kZXMucHVzaChwYXJzZUZuLmNhbGwodGhpcykpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oZGVsaW1pdGVyS2luZCkpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICB9XG4gICAgICBhZHZhbmNlTGV4ZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgbWF4VG9rZW5zIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuX2xleGVyLmFkdmFuY2UoKTtcbiAgICAgICAgaWYgKG1heFRva2VucyAhPT0gdm9pZCAwICYmIHRva2VuLmtpbmQgIT09IFRva2VuS2luZC5FT0YpIHtcbiAgICAgICAgICArK3RoaXMuX3Rva2VuQ291bnRlcjtcbiAgICAgICAgICBpZiAodGhpcy5fdG9rZW5Db3VudGVyID4gbWF4VG9rZW5zKSB7XG4gICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICAgICAgICAgICAgdGhpcy5fbGV4ZXIuc291cmNlLFxuICAgICAgICAgICAgICB0b2tlbi5zdGFydCxcbiAgICAgICAgICAgICAgYERvY3VtZW50IGNvbnRhaW5zIG1vcmUgdGhhdCAke21heFRva2Vuc30gdG9rZW5zLiBQYXJzaW5nIGFib3J0ZWQuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9kaWRZb3VNZWFuLm1qc1xuZnVuY3Rpb24gZGlkWW91TWVhbihmaXJzdEFyZywgc2Vjb25kQXJnKSB7XG4gIGNvbnN0IFtzdWJNZXNzYWdlLCBzdWdnZXN0aW9uc0FyZ10gPSBzZWNvbmRBcmcgPyBbZmlyc3RBcmcsIHNlY29uZEFyZ10gOiBbdm9pZCAwLCBmaXJzdEFyZ107XG4gIGxldCBtZXNzYWdlID0gXCIgRGlkIHlvdSBtZWFuIFwiO1xuICBpZiAoc3ViTWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgKz0gc3ViTWVzc2FnZSArIFwiIFwiO1xuICB9XG4gIGNvbnN0IHN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbnNBcmcubWFwKCh4KSA9PiBgXCIke3h9XCJgKTtcbiAgc3dpdGNoIChzdWdnZXN0aW9ucy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gbWVzc2FnZSArIHN1Z2dlc3Rpb25zWzBdICsgXCI/XCI7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIG1lc3NhZ2UgKyBzdWdnZXN0aW9uc1swXSArIFwiIG9yIFwiICsgc3VnZ2VzdGlvbnNbMV0gKyBcIj9cIjtcbiAgfVxuICBjb25zdCBzZWxlY3RlZCA9IHN1Z2dlc3Rpb25zLnNsaWNlKDAsIE1BWF9TVUdHRVNUSU9OUyk7XG4gIGNvbnN0IGxhc3RJdGVtID0gc2VsZWN0ZWQucG9wKCk7XG4gIHJldHVybiBtZXNzYWdlICsgc2VsZWN0ZWQuam9pbihcIiwgXCIpICsgXCIsIG9yIFwiICsgbGFzdEl0ZW0gKyBcIj9cIjtcbn1cbnZhciBNQVhfU1VHR0VTVElPTlM7XG52YXIgaW5pdF9kaWRZb3VNZWFuID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvZGlkWW91TWVhbi5tanNcIigpIHtcbiAgICBNQVhfU1VHR0VTVElPTlMgPSA1O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9pZGVudGl0eUZ1bmMubWpzXG5mdW5jdGlvbiBpZGVudGl0eUZ1bmMoeCkge1xuICByZXR1cm4geDtcbn1cbnZhciBpbml0X2lkZW50aXR5RnVuYyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2lkZW50aXR5RnVuYy5tanNcIigpIHtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMva2V5TWFwLm1qc1xuZnVuY3Rpb24ga2V5TWFwKGxpc3QsIGtleUZuKSB7XG4gIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbGlzdCkge1xuICAgIHJlc3VsdFtrZXlGbihpdGVtKV0gPSBpdGVtO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgaW5pdF9rZXlNYXAgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9rZXlNYXAubWpzXCIoKSB7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2tleVZhbE1hcC5tanNcbmZ1bmN0aW9uIGtleVZhbE1hcChsaXN0LCBrZXlGbiwgdmFsRm4pIHtcbiAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0KSB7XG4gICAgcmVzdWx0W2tleUZuKGl0ZW0pXSA9IHZhbEZuKGl0ZW0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgaW5pdF9rZXlWYWxNYXAgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9rZXlWYWxNYXAubWpzXCIoKSB7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL21hcFZhbHVlLm1qc1xuZnVuY3Rpb24gbWFwVmFsdWUobWFwLCBmbikge1xuICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWFwKSkge1xuICAgIHJlc3VsdFtrZXldID0gZm4obWFwW2tleV0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBpbml0X21hcFZhbHVlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvbWFwVmFsdWUubWpzXCIoKSB7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL25hdHVyYWxDb21wYXJlLm1qc1xuZnVuY3Rpb24gbmF0dXJhbENvbXBhcmUoYVN0ciwgYlN0cikge1xuICBsZXQgYUluZGV4ID0gMDtcbiAgbGV0IGJJbmRleCA9IDA7XG4gIHdoaWxlIChhSW5kZXggPCBhU3RyLmxlbmd0aCAmJiBiSW5kZXggPCBiU3RyLmxlbmd0aCkge1xuICAgIGxldCBhQ2hhciA9IGFTdHIuY2hhckNvZGVBdChhSW5kZXgpO1xuICAgIGxldCBiQ2hhciA9IGJTdHIuY2hhckNvZGVBdChiSW5kZXgpO1xuICAgIGlmIChpc0RpZ2l0MihhQ2hhcikgJiYgaXNEaWdpdDIoYkNoYXIpKSB7XG4gICAgICBsZXQgYU51bSA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgICsrYUluZGV4O1xuICAgICAgICBhTnVtID0gYU51bSAqIDEwICsgYUNoYXIgLSBESUdJVF8wO1xuICAgICAgICBhQ2hhciA9IGFTdHIuY2hhckNvZGVBdChhSW5kZXgpO1xuICAgICAgfSB3aGlsZSAoaXNEaWdpdDIoYUNoYXIpICYmIGFOdW0gPiAwKTtcbiAgICAgIGxldCBiTnVtID0gMDtcbiAgICAgIGRvIHtcbiAgICAgICAgKytiSW5kZXg7XG4gICAgICAgIGJOdW0gPSBiTnVtICogMTAgKyBiQ2hhciAtIERJR0lUXzA7XG4gICAgICAgIGJDaGFyID0gYlN0ci5jaGFyQ29kZUF0KGJJbmRleCk7XG4gICAgICB9IHdoaWxlIChpc0RpZ2l0MihiQ2hhcikgJiYgYk51bSA+IDApO1xuICAgICAgaWYgKGFOdW0gPCBiTnVtKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChhTnVtID4gYk51bSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFDaGFyIDwgYkNoYXIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKGFDaGFyID4gYkNoYXIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICArK2FJbmRleDtcbiAgICAgICsrYkluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gYVN0ci5sZW5ndGggLSBiU3RyLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGlzRGlnaXQyKGNvZGUpIHtcbiAgcmV0dXJuICFpc05hTihjb2RlKSAmJiBESUdJVF8wIDw9IGNvZGUgJiYgY29kZSA8PSBESUdJVF85O1xufVxudmFyIERJR0lUXzAsIERJR0lUXzk7XG52YXIgaW5pdF9uYXR1cmFsQ29tcGFyZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL25hdHVyYWxDb21wYXJlLm1qc1wiKCkge1xuICAgIERJR0lUXzAgPSA0ODtcbiAgICBESUdJVF85ID0gNTc7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL3N1Z2dlc3Rpb25MaXN0Lm1qc1xuZnVuY3Rpb24gc3VnZ2VzdGlvbkxpc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9uc0J5RGlzdGFuY2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgbGV4aWNhbERpc3RhbmNlID0gbmV3IExleGljYWxEaXN0YW5jZShpbnB1dCk7XG4gIGNvbnN0IHRocmVzaG9sZCA9IE1hdGguZmxvb3IoaW5wdXQubGVuZ3RoICogMC40KSArIDE7XG4gIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkaXN0YW5jZSA9IGxleGljYWxEaXN0YW5jZS5tZWFzdXJlKG9wdGlvbiwgdGhyZXNob2xkKTtcbiAgICBpZiAoZGlzdGFuY2UgIT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9uc0J5RGlzdGFuY2Vbb3B0aW9uXSA9IGRpc3RhbmNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9uc0J5RGlzdGFuY2UpLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCBkaXN0YW5jZURpZmYgPSBvcHRpb25zQnlEaXN0YW5jZVthXSAtIG9wdGlvbnNCeURpc3RhbmNlW2JdO1xuICAgIHJldHVybiBkaXN0YW5jZURpZmYgIT09IDAgPyBkaXN0YW5jZURpZmYgOiBuYXR1cmFsQ29tcGFyZShhLCBiKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cikge1xuICBjb25zdCBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICBjb25zdCBhcnJheSA9IG5ldyBBcnJheShzdHJMZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ckxlbmd0aDsgKytpKSB7XG4gICAgYXJyYXlbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG52YXIgTGV4aWNhbERpc3RhbmNlO1xudmFyIGluaXRfc3VnZ2VzdGlvbkxpc3QgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9zdWdnZXN0aW9uTGlzdC5tanNcIigpIHtcbiAgICBpbml0X25hdHVyYWxDb21wYXJlKCk7XG4gICAgTGV4aWNhbERpc3RhbmNlID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5faW5wdXRMb3dlckNhc2UgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLl9pbnB1dEFycmF5ID0gc3RyaW5nVG9BcnJheSh0aGlzLl9pbnB1dExvd2VyQ2FzZSk7XG4gICAgICAgIHRoaXMuX3Jvd3MgPSBbXG4gICAgICAgICAgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCArIDEpLmZpbGwoMCksXG4gICAgICAgICAgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCArIDEpLmZpbGwoMCksXG4gICAgICAgICAgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCArIDEpLmZpbGwoMClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIG1lYXN1cmUob3B0aW9uLCB0aHJlc2hvbGQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0ID09PSBvcHRpb24pIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25Mb3dlckNhc2UgPSBvcHRpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0TG93ZXJDYXNlID09PSBvcHRpb25Mb3dlckNhc2UpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYSA9IHN0cmluZ1RvQXJyYXkob3B0aW9uTG93ZXJDYXNlKTtcbiAgICAgICAgbGV0IGIgPSB0aGlzLl9pbnB1dEFycmF5O1xuICAgICAgICBpZiAoYS5sZW5ndGggPCBiLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHRtcCA9IGE7XG4gICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgYiA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhTGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGJMZW5ndGggPSBiLmxlbmd0aDtcbiAgICAgICAgaWYgKGFMZW5ndGggLSBiTGVuZ3RoID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gYkxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgcm93c1swXVtqXSA9IGo7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgdXBSb3cgPSByb3dzWyhpIC0gMSkgJSAzXTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50Um93ID0gcm93c1tpICUgM107XG4gICAgICAgICAgbGV0IHNtYWxsZXN0Q2VsbCA9IGN1cnJlbnRSb3dbMF0gPSBpO1xuICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGJMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgY29zdCA9IGFbaSAtIDFdID09PSBiW2ogLSAxXSA/IDAgOiAxO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRDZWxsID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgIHVwUm93W2pdICsgMSxcbiAgICAgICAgICAgICAgLy8gZGVsZXRlXG4gICAgICAgICAgICAgIGN1cnJlbnRSb3dbaiAtIDFdICsgMSxcbiAgICAgICAgICAgICAgLy8gaW5zZXJ0XG4gICAgICAgICAgICAgIHVwUm93W2ogLSAxXSArIGNvc3RcbiAgICAgICAgICAgICAgLy8gc3Vic3RpdHV0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChpID4gMSAmJiBqID4gMSAmJiBhW2kgLSAxXSA9PT0gYltqIC0gMl0gJiYgYVtpIC0gMl0gPT09IGJbaiAtIDFdKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRvdWJsZURpYWdvbmFsQ2VsbCA9IHJvd3NbKGkgLSAyKSAlIDNdW2ogLSAyXTtcbiAgICAgICAgICAgICAgY3VycmVudENlbGwgPSBNYXRoLm1pbihjdXJyZW50Q2VsbCwgZG91YmxlRGlhZ29uYWxDZWxsICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENlbGwgPCBzbWFsbGVzdENlbGwpIHtcbiAgICAgICAgICAgICAgc21hbGxlc3RDZWxsID0gY3VycmVudENlbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Um93W2pdID0gY3VycmVudENlbGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzbWFsbGVzdENlbGwgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gcm93c1thTGVuZ3RoICUgM11bYkxlbmd0aF07XG4gICAgICAgIHJldHVybiBkaXN0YW5jZSA8PSB0aHJlc2hvbGQgPyBkaXN0YW5jZSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy90b09iak1hcC5tanNcbmZ1bmN0aW9uIHRvT2JqTWFwKG9iaikge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIG1hcFtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cbnZhciBpbml0X3RvT2JqTWFwID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvdG9PYmpNYXAubWpzXCIoKSB7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9wcmludFN0cmluZy5tanNcbmZ1bmN0aW9uIHByaW50U3RyaW5nKHN0cikge1xuICByZXR1cm4gYFwiJHtzdHIucmVwbGFjZShlc2NhcGVkUmVnRXhwLCBlc2NhcGVkUmVwbGFjZXIpfVwiYDtcbn1cbmZ1bmN0aW9uIGVzY2FwZWRSZXBsYWNlcihzdHIpIHtcbiAgcmV0dXJuIGVzY2FwZVNlcXVlbmNlc1tzdHIuY2hhckNvZGVBdCgwKV07XG59XG52YXIgZXNjYXBlZFJlZ0V4cCwgZXNjYXBlU2VxdWVuY2VzO1xudmFyIGluaXRfcHJpbnRTdHJpbmcgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvcHJpbnRTdHJpbmcubWpzXCIoKSB7XG4gICAgZXNjYXBlZFJlZ0V4cCA9IC9bXFx4MDAtXFx4MWZcXHgyMlxceDVjXFx4N2YtXFx4OWZdL2c7XG4gICAgZXNjYXBlU2VxdWVuY2VzID0gW1xuICAgICAgXCJcXFxcdTAwMDBcIixcbiAgICAgIFwiXFxcXHUwMDAxXCIsXG4gICAgICBcIlxcXFx1MDAwMlwiLFxuICAgICAgXCJcXFxcdTAwMDNcIixcbiAgICAgIFwiXFxcXHUwMDA0XCIsXG4gICAgICBcIlxcXFx1MDAwNVwiLFxuICAgICAgXCJcXFxcdTAwMDZcIixcbiAgICAgIFwiXFxcXHUwMDA3XCIsXG4gICAgICBcIlxcXFxiXCIsXG4gICAgICBcIlxcXFx0XCIsXG4gICAgICBcIlxcXFxuXCIsXG4gICAgICBcIlxcXFx1MDAwQlwiLFxuICAgICAgXCJcXFxcZlwiLFxuICAgICAgXCJcXFxcclwiLFxuICAgICAgXCJcXFxcdTAwMEVcIixcbiAgICAgIFwiXFxcXHUwMDBGXCIsXG4gICAgICBcIlxcXFx1MDAxMFwiLFxuICAgICAgXCJcXFxcdTAwMTFcIixcbiAgICAgIFwiXFxcXHUwMDEyXCIsXG4gICAgICBcIlxcXFx1MDAxM1wiLFxuICAgICAgXCJcXFxcdTAwMTRcIixcbiAgICAgIFwiXFxcXHUwMDE1XCIsXG4gICAgICBcIlxcXFx1MDAxNlwiLFxuICAgICAgXCJcXFxcdTAwMTdcIixcbiAgICAgIFwiXFxcXHUwMDE4XCIsXG4gICAgICBcIlxcXFx1MDAxOVwiLFxuICAgICAgXCJcXFxcdTAwMUFcIixcbiAgICAgIFwiXFxcXHUwMDFCXCIsXG4gICAgICBcIlxcXFx1MDAxQ1wiLFxuICAgICAgXCJcXFxcdTAwMURcIixcbiAgICAgIFwiXFxcXHUwMDFFXCIsXG4gICAgICBcIlxcXFx1MDAxRlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICAnXFxcXFwiJyxcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICAvLyAyRlxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIC8vIDNGXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgLy8gNEZcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXFxcXFxcXFxcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIC8vIDVGXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgLy8gNkZcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXCIsXG4gICAgICBcIlwiLFxuICAgICAgXCJcIixcbiAgICAgIFwiXFxcXHUwMDdGXCIsXG4gICAgICBcIlxcXFx1MDA4MFwiLFxuICAgICAgXCJcXFxcdTAwODFcIixcbiAgICAgIFwiXFxcXHUwMDgyXCIsXG4gICAgICBcIlxcXFx1MDA4M1wiLFxuICAgICAgXCJcXFxcdTAwODRcIixcbiAgICAgIFwiXFxcXHUwMDg1XCIsXG4gICAgICBcIlxcXFx1MDA4NlwiLFxuICAgICAgXCJcXFxcdTAwODdcIixcbiAgICAgIFwiXFxcXHUwMDg4XCIsXG4gICAgICBcIlxcXFx1MDA4OVwiLFxuICAgICAgXCJcXFxcdTAwOEFcIixcbiAgICAgIFwiXFxcXHUwMDhCXCIsXG4gICAgICBcIlxcXFx1MDA4Q1wiLFxuICAgICAgXCJcXFxcdTAwOERcIixcbiAgICAgIFwiXFxcXHUwMDhFXCIsXG4gICAgICBcIlxcXFx1MDA4RlwiLFxuICAgICAgXCJcXFxcdTAwOTBcIixcbiAgICAgIFwiXFxcXHUwMDkxXCIsXG4gICAgICBcIlxcXFx1MDA5MlwiLFxuICAgICAgXCJcXFxcdTAwOTNcIixcbiAgICAgIFwiXFxcXHUwMDk0XCIsXG4gICAgICBcIlxcXFx1MDA5NVwiLFxuICAgICAgXCJcXFxcdTAwOTZcIixcbiAgICAgIFwiXFxcXHUwMDk3XCIsXG4gICAgICBcIlxcXFx1MDA5OFwiLFxuICAgICAgXCJcXFxcdTAwOTlcIixcbiAgICAgIFwiXFxcXHUwMDlBXCIsXG4gICAgICBcIlxcXFx1MDA5QlwiLFxuICAgICAgXCJcXFxcdTAwOUNcIixcbiAgICAgIFwiXFxcXHUwMDlEXCIsXG4gICAgICBcIlxcXFx1MDA5RVwiLFxuICAgICAgXCJcXFxcdTAwOUZcIlxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS92aXNpdG9yLm1qc1xuZnVuY3Rpb24gdmlzaXQocm9vdCwgdmlzaXRvciwgdmlzaXRvcktleXMgPSBRdWVyeURvY3VtZW50S2V5cykge1xuICBjb25zdCBlbnRlckxlYXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBraW5kIG9mIE9iamVjdC52YWx1ZXMoS2luZCkpIHtcbiAgICBlbnRlckxlYXZlTWFwLnNldChraW5kLCBnZXRFbnRlckxlYXZlRm9yS2luZCh2aXNpdG9yLCBraW5kKSk7XG4gIH1cbiAgbGV0IHN0YWNrID0gdm9pZCAwO1xuICBsZXQgaW5BcnJheSA9IEFycmF5LmlzQXJyYXkocm9vdCk7XG4gIGxldCBrZXlzID0gW3Jvb3RdO1xuICBsZXQgaW5kZXggPSAtMTtcbiAgbGV0IGVkaXRzID0gW107XG4gIGxldCBub2RlID0gcm9vdDtcbiAgbGV0IGtleSA9IHZvaWQgMDtcbiAgbGV0IHBhcmVudCA9IHZvaWQgMDtcbiAgY29uc3QgcGF0aCA9IFtdO1xuICBjb25zdCBhbmNlc3RvcnMgPSBbXTtcbiAgZG8ge1xuICAgIGluZGV4Kys7XG4gICAgY29uc3QgaXNMZWF2aW5nID0gaW5kZXggPT09IGtleXMubGVuZ3RoO1xuICAgIGNvbnN0IGlzRWRpdGVkID0gaXNMZWF2aW5nICYmIGVkaXRzLmxlbmd0aCAhPT0gMDtcbiAgICBpZiAoaXNMZWF2aW5nKSB7XG4gICAgICBrZXkgPSBhbmNlc3RvcnMubGVuZ3RoID09PSAwID8gdm9pZCAwIDogcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgIHBhcmVudCA9IGFuY2VzdG9ycy5wb3AoKTtcbiAgICAgIGlmIChpc0VkaXRlZCkge1xuICAgICAgICBpZiAoaW5BcnJheSkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNsaWNlKCk7XG4gICAgICAgICAgbGV0IGVkaXRPZmZzZXQgPSAwO1xuICAgICAgICAgIGZvciAoY29uc3QgW2VkaXRLZXksIGVkaXRWYWx1ZV0gb2YgZWRpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5S2V5ID0gZWRpdEtleSAtIGVkaXRPZmZzZXQ7XG4gICAgICAgICAgICBpZiAoZWRpdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIG5vZGUuc3BsaWNlKGFycmF5S2V5LCAxKTtcbiAgICAgICAgICAgICAgZWRpdE9mZnNldCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZVthcnJheUtleV0gPSBlZGl0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobm9kZSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGZvciAoY29uc3QgW2VkaXRLZXksIGVkaXRWYWx1ZV0gb2YgZWRpdHMpIHtcbiAgICAgICAgICAgIG5vZGVbZWRpdEtleV0gPSBlZGl0VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbmRleCA9IHN0YWNrLmluZGV4O1xuICAgICAga2V5cyA9IHN0YWNrLmtleXM7XG4gICAgICBlZGl0cyA9IHN0YWNrLmVkaXRzO1xuICAgICAgaW5BcnJheSA9IHN0YWNrLmluQXJyYXk7XG4gICAgICBzdGFjayA9IHN0YWNrLnByZXY7XG4gICAgfSBlbHNlIGlmIChwYXJlbnQpIHtcbiAgICAgIGtleSA9IGluQXJyYXkgPyBpbmRleCA6IGtleXNbaW5kZXhdO1xuICAgICAgbm9kZSA9IHBhcmVudFtrZXldO1xuICAgICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICB2YXIgX2VudGVyTGVhdmVNYXAkZ2V0LCBfZW50ZXJMZWF2ZU1hcCRnZXQyO1xuICAgICAgaXNOb2RlKG5vZGUpIHx8IGRldkFzc2VydChmYWxzZSwgYEludmFsaWQgQVNUIE5vZGU6ICR7aW5zcGVjdChub2RlKX0uYCk7XG4gICAgICBjb25zdCB2aXNpdEZuID0gaXNMZWF2aW5nID8gKF9lbnRlckxlYXZlTWFwJGdldCA9IGVudGVyTGVhdmVNYXAuZ2V0KG5vZGUua2luZCkpID09PSBudWxsIHx8IF9lbnRlckxlYXZlTWFwJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VudGVyTGVhdmVNYXAkZ2V0LmxlYXZlIDogKF9lbnRlckxlYXZlTWFwJGdldDIgPSBlbnRlckxlYXZlTWFwLmdldChub2RlLmtpbmQpKSA9PT0gbnVsbCB8fCBfZW50ZXJMZWF2ZU1hcCRnZXQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZW50ZXJMZWF2ZU1hcCRnZXQyLmVudGVyO1xuICAgICAgcmVzdWx0ID0gdmlzaXRGbiA9PT0gbnVsbCB8fCB2aXNpdEZuID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXNpdEZuLmNhbGwodmlzaXRvciwgbm9kZSwga2V5LCBwYXJlbnQsIHBhdGgsIGFuY2VzdG9ycyk7XG4gICAgICBpZiAocmVzdWx0ID09PSBCUkVBSykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICghaXNMZWF2aW5nKSB7XG4gICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICBlZGl0cy5wdXNoKFtrZXksIHJlc3VsdF0pO1xuICAgICAgICBpZiAoIWlzTGVhdmluZykge1xuICAgICAgICAgIGlmIChpc05vZGUocmVzdWx0KSkge1xuICAgICAgICAgICAgbm9kZSA9IHJlc3VsdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDAgJiYgaXNFZGl0ZWQpIHtcbiAgICAgIGVkaXRzLnB1c2goW2tleSwgbm9kZV0pO1xuICAgIH1cbiAgICBpZiAoaXNMZWF2aW5nKSB7XG4gICAgICBwYXRoLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX25vZGUka2luZDtcbiAgICAgIHN0YWNrID0ge1xuICAgICAgICBpbkFycmF5LFxuICAgICAgICBpbmRleCxcbiAgICAgICAga2V5cyxcbiAgICAgICAgZWRpdHMsXG4gICAgICAgIHByZXY6IHN0YWNrXG4gICAgICB9O1xuICAgICAgaW5BcnJheSA9IEFycmF5LmlzQXJyYXkobm9kZSk7XG4gICAgICBrZXlzID0gaW5BcnJheSA/IG5vZGUgOiAoX25vZGUka2luZCA9IHZpc2l0b3JLZXlzW25vZGUua2luZF0pICE9PSBudWxsICYmIF9ub2RlJGtpbmQgIT09IHZvaWQgMCA/IF9ub2RlJGtpbmQgOiBbXTtcbiAgICAgIGluZGV4ID0gLTE7XG4gICAgICBlZGl0cyA9IFtdO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaChwYXJlbnQpO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICB9XG4gIH0gd2hpbGUgKHN0YWNrICE9PSB2b2lkIDApO1xuICBpZiAoZWRpdHMubGVuZ3RoICE9PSAwKSB7XG4gICAgcmV0dXJuIGVkaXRzW2VkaXRzLmxlbmd0aCAtIDFdWzFdO1xuICB9XG4gIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gdmlzaXRJblBhcmFsbGVsKHZpc2l0b3JzKSB7XG4gIGNvbnN0IHNraXBwaW5nID0gbmV3IEFycmF5KHZpc2l0b3JzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgY29uc3QgbWVyZ2VkVmlzaXRvciA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IGtpbmQgb2YgT2JqZWN0LnZhbHVlcyhLaW5kKSkge1xuICAgIGxldCBoYXNWaXNpdG9yID0gZmFsc2U7XG4gICAgY29uc3QgZW50ZXJMaXN0ID0gbmV3IEFycmF5KHZpc2l0b3JzLmxlbmd0aCkuZmlsbCh2b2lkIDApO1xuICAgIGNvbnN0IGxlYXZlTGlzdCA9IG5ldyBBcnJheSh2aXNpdG9ycy5sZW5ndGgpLmZpbGwodm9pZCAwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpc2l0b3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB7IGVudGVyLCBsZWF2ZSB9ID0gZ2V0RW50ZXJMZWF2ZUZvcktpbmQodmlzaXRvcnNbaV0sIGtpbmQpO1xuICAgICAgaGFzVmlzaXRvciB8fCAoaGFzVmlzaXRvciA9IGVudGVyICE9IG51bGwgfHwgbGVhdmUgIT0gbnVsbCk7XG4gICAgICBlbnRlckxpc3RbaV0gPSBlbnRlcjtcbiAgICAgIGxlYXZlTGlzdFtpXSA9IGxlYXZlO1xuICAgIH1cbiAgICBpZiAoIWhhc1Zpc2l0b3IpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBtZXJnZWRFbnRlckxlYXZlID0ge1xuICAgICAgZW50ZXIoLi4uYXJncykge1xuICAgICAgICBjb25zdCBub2RlID0gYXJnc1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChza2lwcGluZ1tpXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9lbnRlckxpc3QkaTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChfZW50ZXJMaXN0JGkgPSBlbnRlckxpc3RbaV0pID09PSBudWxsIHx8IF9lbnRlckxpc3QkaSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VudGVyTGlzdCRpLmFwcGx5KHZpc2l0b3JzW2ldLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHNraXBwaW5nW2ldID0gbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICBza2lwcGluZ1tpXSA9IEJSRUFLO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxlYXZlKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGFyZ3NbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoc2tpcHBpbmdbaV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfbGVhdmVMaXN0JGk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoX2xlYXZlTGlzdCRpID0gbGVhdmVMaXN0W2ldKSA9PT0gbnVsbCB8fCBfbGVhdmVMaXN0JGkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sZWF2ZUxpc3QkaS5hcHBseSh2aXNpdG9yc1tpXSwgYXJncyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICBza2lwcGluZ1tpXSA9IEJSRUFLO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHZvaWQgMCAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChza2lwcGluZ1tpXSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgc2tpcHBpbmdbaV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgbWVyZ2VkVmlzaXRvcltraW5kXSA9IG1lcmdlZEVudGVyTGVhdmU7XG4gIH1cbiAgcmV0dXJuIG1lcmdlZFZpc2l0b3I7XG59XG5mdW5jdGlvbiBnZXRFbnRlckxlYXZlRm9yS2luZCh2aXNpdG9yLCBraW5kKSB7XG4gIGNvbnN0IGtpbmRWaXNpdG9yID0gdmlzaXRvcltraW5kXTtcbiAgaWYgKHR5cGVvZiBraW5kVmlzaXRvciA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBraW5kVmlzaXRvcjtcbiAgfSBlbHNlIGlmICh0eXBlb2Yga2luZFZpc2l0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICBlbnRlcjoga2luZFZpc2l0b3IsXG4gICAgICBsZWF2ZTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVudGVyOiB2aXNpdG9yLmVudGVyLFxuICAgIGxlYXZlOiB2aXNpdG9yLmxlYXZlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRWaXNpdEZuKHZpc2l0b3IsIGtpbmQsIGlzTGVhdmluZykge1xuICBjb25zdCB7IGVudGVyLCBsZWF2ZSB9ID0gZ2V0RW50ZXJMZWF2ZUZvcktpbmQodmlzaXRvciwga2luZCk7XG4gIHJldHVybiBpc0xlYXZpbmcgPyBsZWF2ZSA6IGVudGVyO1xufVxudmFyIEJSRUFLO1xudmFyIGluaXRfdmlzaXRvciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS92aXNpdG9yLm1qc1wiKCkge1xuICAgIGluaXRfZGV2QXNzZXJ0KCk7XG4gICAgaW5pdF9pbnNwZWN0KCk7XG4gICAgaW5pdF9hc3QoKTtcbiAgICBpbml0X2tpbmRzKCk7XG4gICAgQlJFQUsgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3ByaW50ZXIubWpzXG5mdW5jdGlvbiBwcmludChhc3QpIHtcbiAgcmV0dXJuIHZpc2l0KGFzdCwgcHJpbnREb2NBU1RSZWR1Y2VyKTtcbn1cbmZ1bmN0aW9uIGpvaW4obWF5YmVBcnJheSwgc2VwYXJhdG9yID0gXCJcIikge1xuICB2YXIgX21heWJlQXJyYXkkZmlsdGVyJGpvO1xuICByZXR1cm4gKF9tYXliZUFycmF5JGZpbHRlciRqbyA9IG1heWJlQXJyYXkgPT09IG51bGwgfHwgbWF5YmVBcnJheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF5YmVBcnJheS5maWx0ZXIoKHgpID0+IHgpLmpvaW4oc2VwYXJhdG9yKSkgIT09IG51bGwgJiYgX21heWJlQXJyYXkkZmlsdGVyJGpvICE9PSB2b2lkIDAgPyBfbWF5YmVBcnJheSRmaWx0ZXIkam8gOiBcIlwiO1xufVxuZnVuY3Rpb24gYmxvY2soYXJyYXkpIHtcbiAgcmV0dXJuIHdyYXAoXCJ7XFxuXCIsIGluZGVudChqb2luKGFycmF5LCBcIlxcblwiKSksIFwiXFxufVwiKTtcbn1cbmZ1bmN0aW9uIHdyYXAoc3RhcnQsIG1heWJlU3RyaW5nLCBlbmQgPSBcIlwiKSB7XG4gIHJldHVybiBtYXliZVN0cmluZyAhPSBudWxsICYmIG1heWJlU3RyaW5nICE9PSBcIlwiID8gc3RhcnQgKyBtYXliZVN0cmluZyArIGVuZCA6IFwiXCI7XG59XG5mdW5jdGlvbiBpbmRlbnQoc3RyKSB7XG4gIHJldHVybiB3cmFwKFwiICBcIiwgc3RyLnJlcGxhY2UoL1xcbi9nLCBcIlxcbiAgXCIpKTtcbn1cbmZ1bmN0aW9uIGhhc011bHRpbGluZUl0ZW1zKG1heWJlQXJyYXkpIHtcbiAgdmFyIF9tYXliZUFycmF5JHNvbWU7XG4gIHJldHVybiAoX21heWJlQXJyYXkkc29tZSA9IG1heWJlQXJyYXkgPT09IG51bGwgfHwgbWF5YmVBcnJheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF5YmVBcnJheS5zb21lKChzdHIpID0+IHN0ci5pbmNsdWRlcyhcIlxcblwiKSkpICE9PSBudWxsICYmIF9tYXliZUFycmF5JHNvbWUgIT09IHZvaWQgMCA/IF9tYXliZUFycmF5JHNvbWUgOiBmYWxzZTtcbn1cbnZhciBNQVhfTElORV9MRU5HVEgsIHByaW50RG9jQVNUUmVkdWNlcjtcbnZhciBpbml0X3ByaW50ZXIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvcHJpbnRlci5tanNcIigpIHtcbiAgICBpbml0X2Jsb2NrU3RyaW5nKCk7XG4gICAgaW5pdF9wcmludFN0cmluZygpO1xuICAgIGluaXRfdmlzaXRvcigpO1xuICAgIE1BWF9MSU5FX0xFTkdUSCA9IDgwO1xuICAgIHByaW50RG9jQVNUUmVkdWNlciA9IHtcbiAgICAgIE5hbWU6IHtcbiAgICAgICAgbGVhdmU6IChub2RlKSA9PiBub2RlLnZhbHVlXG4gICAgICB9LFxuICAgICAgVmFyaWFibGU6IHtcbiAgICAgICAgbGVhdmU6IChub2RlKSA9PiBcIiRcIiArIG5vZGUubmFtZVxuICAgICAgfSxcbiAgICAgIC8vIERvY3VtZW50XG4gICAgICBEb2N1bWVudDoge1xuICAgICAgICBsZWF2ZTogKG5vZGUpID0+IGpvaW4obm9kZS5kZWZpbml0aW9ucywgXCJcXG5cXG5cIilcbiAgICAgIH0sXG4gICAgICBPcGVyYXRpb25EZWZpbml0aW9uOiB7XG4gICAgICAgIGxlYXZlKG5vZGUpIHtcbiAgICAgICAgICBjb25zdCB2YXJEZWZzID0gd3JhcChcIihcIiwgam9pbihub2RlLnZhcmlhYmxlRGVmaW5pdGlvbnMsIFwiLCBcIiksIFwiKVwiKTtcbiAgICAgICAgICBjb25zdCBwcmVmaXggPSBqb2luKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBub2RlLm9wZXJhdGlvbixcbiAgICAgICAgICAgICAgam9pbihbbm9kZS5uYW1lLCB2YXJEZWZzXSksXG4gICAgICAgICAgICAgIGpvaW4obm9kZS5kaXJlY3RpdmVzLCBcIiBcIilcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIiBcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIChwcmVmaXggPT09IFwicXVlcnlcIiA/IFwiXCIgOiBwcmVmaXggKyBcIiBcIikgKyBub2RlLnNlbGVjdGlvblNldDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFZhcmlhYmxlRGVmaW5pdGlvbjoge1xuICAgICAgICBsZWF2ZTogKHsgdmFyaWFibGUsIHR5cGUsIGRlZmF1bHRWYWx1ZSwgZGlyZWN0aXZlcyB9KSA9PiB2YXJpYWJsZSArIFwiOiBcIiArIHR5cGUgKyB3cmFwKFwiID0gXCIsIGRlZmF1bHRWYWx1ZSkgKyB3cmFwKFwiIFwiLCBqb2luKGRpcmVjdGl2ZXMsIFwiIFwiKSlcbiAgICAgIH0sXG4gICAgICBTZWxlY3Rpb25TZXQ6IHtcbiAgICAgICAgbGVhdmU6ICh7IHNlbGVjdGlvbnMgfSkgPT4gYmxvY2soc2VsZWN0aW9ucylcbiAgICAgIH0sXG4gICAgICBGaWVsZDoge1xuICAgICAgICBsZWF2ZSh7IGFsaWFzLCBuYW1lLCBhcmd1bWVudHM6IGFyZ3MsIGRpcmVjdGl2ZXMsIHNlbGVjdGlvblNldCB9KSB7XG4gICAgICAgICAgY29uc3QgcHJlZml4ID0gd3JhcChcIlwiLCBhbGlhcywgXCI6IFwiKSArIG5hbWU7XG4gICAgICAgICAgbGV0IGFyZ3NMaW5lID0gcHJlZml4ICsgd3JhcChcIihcIiwgam9pbihhcmdzLCBcIiwgXCIpLCBcIilcIik7XG4gICAgICAgICAgaWYgKGFyZ3NMaW5lLmxlbmd0aCA+IE1BWF9MSU5FX0xFTkdUSCkge1xuICAgICAgICAgICAgYXJnc0xpbmUgPSBwcmVmaXggKyB3cmFwKFwiKFxcblwiLCBpbmRlbnQoam9pbihhcmdzLCBcIlxcblwiKSksIFwiXFxuKVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGpvaW4oW2FyZ3NMaW5lLCBqb2luKGRpcmVjdGl2ZXMsIFwiIFwiKSwgc2VsZWN0aW9uU2V0XSwgXCIgXCIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQXJndW1lbnQ6IHtcbiAgICAgICAgbGVhdmU6ICh7IG5hbWUsIHZhbHVlIH0pID0+IG5hbWUgKyBcIjogXCIgKyB2YWx1ZVxuICAgICAgfSxcbiAgICAgIC8vIEZyYWdtZW50c1xuICAgICAgRnJhZ21lbnRTcHJlYWQ6IHtcbiAgICAgICAgbGVhdmU6ICh7IG5hbWUsIGRpcmVjdGl2ZXMgfSkgPT4gXCIuLi5cIiArIG5hbWUgKyB3cmFwKFwiIFwiLCBqb2luKGRpcmVjdGl2ZXMsIFwiIFwiKSlcbiAgICAgIH0sXG4gICAgICBJbmxpbmVGcmFnbWVudDoge1xuICAgICAgICBsZWF2ZTogKHsgdHlwZUNvbmRpdGlvbiwgZGlyZWN0aXZlcywgc2VsZWN0aW9uU2V0IH0pID0+IGpvaW4oXG4gICAgICAgICAgW1xuICAgICAgICAgICAgXCIuLi5cIixcbiAgICAgICAgICAgIHdyYXAoXCJvbiBcIiwgdHlwZUNvbmRpdGlvbiksXG4gICAgICAgICAgICBqb2luKGRpcmVjdGl2ZXMsIFwiIFwiKSxcbiAgICAgICAgICAgIHNlbGVjdGlvblNldFxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCIgXCJcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIEZyYWdtZW50RGVmaW5pdGlvbjoge1xuICAgICAgICBsZWF2ZTogKHsgbmFtZSwgdHlwZUNvbmRpdGlvbiwgdmFyaWFibGVEZWZpbml0aW9ucywgZGlyZWN0aXZlcywgc2VsZWN0aW9uU2V0IH0pID0+IChcbiAgICAgICAgICAvLyBvciByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgYGZyYWdtZW50ICR7bmFtZX0ke3dyYXAoXCIoXCIsIGpvaW4odmFyaWFibGVEZWZpbml0aW9ucywgXCIsIFwiKSwgXCIpXCIpfSBvbiAke3R5cGVDb25kaXRpb259ICR7d3JhcChcIlwiLCBqb2luKGRpcmVjdGl2ZXMsIFwiIFwiKSwgXCIgXCIpfWAgKyBzZWxlY3Rpb25TZXRcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIC8vIFZhbHVlXG4gICAgICBJbnRWYWx1ZToge1xuICAgICAgICBsZWF2ZTogKHsgdmFsdWUgfSkgPT4gdmFsdWVcbiAgICAgIH0sXG4gICAgICBGbG9hdFZhbHVlOiB7XG4gICAgICAgIGxlYXZlOiAoeyB2YWx1ZSB9KSA9PiB2YWx1ZVxuICAgICAgfSxcbiAgICAgIFN0cmluZ1ZhbHVlOiB7XG4gICAgICAgIGxlYXZlOiAoeyB2YWx1ZSwgYmxvY2s6IGlzQmxvY2tTdHJpbmcgfSkgPT4gaXNCbG9ja1N0cmluZyA/IHByaW50QmxvY2tTdHJpbmcodmFsdWUpIDogcHJpbnRTdHJpbmcodmFsdWUpXG4gICAgICB9LFxuICAgICAgQm9vbGVhblZhbHVlOiB7XG4gICAgICAgIGxlYXZlOiAoeyB2YWx1ZSB9KSA9PiB2YWx1ZSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiXG4gICAgICB9LFxuICAgICAgTnVsbFZhbHVlOiB7XG4gICAgICAgIGxlYXZlOiAoKSA9PiBcIm51bGxcIlxuICAgICAgfSxcbiAgICAgIEVudW1WYWx1ZToge1xuICAgICAgICBsZWF2ZTogKHsgdmFsdWUgfSkgPT4gdmFsdWVcbiAgICAgIH0sXG4gICAgICBMaXN0VmFsdWU6IHtcbiAgICAgICAgbGVhdmU6ICh7IHZhbHVlcyB9KSA9PiBcIltcIiArIGpvaW4odmFsdWVzLCBcIiwgXCIpICsgXCJdXCJcbiAgICAgIH0sXG4gICAgICBPYmplY3RWYWx1ZToge1xuICAgICAgICBsZWF2ZTogKHsgZmllbGRzIH0pID0+IFwie1wiICsgam9pbihmaWVsZHMsIFwiLCBcIikgKyBcIn1cIlxuICAgICAgfSxcbiAgICAgIE9iamVjdEZpZWxkOiB7XG4gICAgICAgIGxlYXZlOiAoeyBuYW1lLCB2YWx1ZSB9KSA9PiBuYW1lICsgXCI6IFwiICsgdmFsdWVcbiAgICAgIH0sXG4gICAgICAvLyBEaXJlY3RpdmVcbiAgICAgIERpcmVjdGl2ZToge1xuICAgICAgICBsZWF2ZTogKHsgbmFtZSwgYXJndW1lbnRzOiBhcmdzIH0pID0+IFwiQFwiICsgbmFtZSArIHdyYXAoXCIoXCIsIGpvaW4oYXJncywgXCIsIFwiKSwgXCIpXCIpXG4gICAgICB9LFxuICAgICAgLy8gVHlwZVxuICAgICAgTmFtZWRUeXBlOiB7XG4gICAgICAgIGxlYXZlOiAoeyBuYW1lIH0pID0+IG5hbWVcbiAgICAgIH0sXG4gICAgICBMaXN0VHlwZToge1xuICAgICAgICBsZWF2ZTogKHsgdHlwZSB9KSA9PiBcIltcIiArIHR5cGUgKyBcIl1cIlxuICAgICAgfSxcbiAgICAgIE5vbk51bGxUeXBlOiB7XG4gICAgICAgIGxlYXZlOiAoeyB0eXBlIH0pID0+IHR5cGUgKyBcIiFcIlxuICAgICAgfSxcbiAgICAgIC8vIFR5cGUgU3lzdGVtIERlZmluaXRpb25zXG4gICAgICBTY2hlbWFEZWZpbml0aW9uOiB7XG4gICAgICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgZGlyZWN0aXZlcywgb3BlcmF0aW9uVHlwZXMgfSkgPT4gd3JhcChcIlwiLCBkZXNjcmlwdGlvbiwgXCJcXG5cIikgKyBqb2luKFtcInNjaGVtYVwiLCBqb2luKGRpcmVjdGl2ZXMsIFwiIFwiKSwgYmxvY2sob3BlcmF0aW9uVHlwZXMpXSwgXCIgXCIpXG4gICAgICB9LFxuICAgICAgT3BlcmF0aW9uVHlwZURlZmluaXRpb246IHtcbiAgICAgICAgbGVhdmU6ICh7IG9wZXJhdGlvbiwgdHlwZSB9KSA9PiBvcGVyYXRpb24gKyBcIjogXCIgKyB0eXBlXG4gICAgICB9LFxuICAgICAgU2NhbGFyVHlwZURlZmluaXRpb246IHtcbiAgICAgICAgbGVhdmU6ICh7IGRlc2NyaXB0aW9uLCBuYW1lLCBkaXJlY3RpdmVzIH0pID0+IHdyYXAoXCJcIiwgZGVzY3JpcHRpb24sIFwiXFxuXCIpICsgam9pbihbXCJzY2FsYXJcIiwgbmFtZSwgam9pbihkaXJlY3RpdmVzLCBcIiBcIildLCBcIiBcIilcbiAgICAgIH0sXG4gICAgICBPYmplY3RUeXBlRGVmaW5pdGlvbjoge1xuICAgICAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGludGVyZmFjZXMsIGRpcmVjdGl2ZXMsIGZpZWxkcyB9KSA9PiB3cmFwKFwiXCIsIGRlc2NyaXB0aW9uLCBcIlxcblwiKSArIGpvaW4oXG4gICAgICAgICAgW1xuICAgICAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgd3JhcChcImltcGxlbWVudHMgXCIsIGpvaW4oaW50ZXJmYWNlcywgXCIgJiBcIikpLFxuICAgICAgICAgICAgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksXG4gICAgICAgICAgICBibG9jayhmaWVsZHMpXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgRmllbGREZWZpbml0aW9uOiB7XG4gICAgICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgYXJndW1lbnRzOiBhcmdzLCB0eXBlLCBkaXJlY3RpdmVzIH0pID0+IHdyYXAoXCJcIiwgZGVzY3JpcHRpb24sIFwiXFxuXCIpICsgbmFtZSArIChoYXNNdWx0aWxpbmVJdGVtcyhhcmdzKSA/IHdyYXAoXCIoXFxuXCIsIGluZGVudChqb2luKGFyZ3MsIFwiXFxuXCIpKSwgXCJcXG4pXCIpIDogd3JhcChcIihcIiwgam9pbihhcmdzLCBcIiwgXCIpLCBcIilcIikpICsgXCI6IFwiICsgdHlwZSArIHdyYXAoXCIgXCIsIGpvaW4oZGlyZWN0aXZlcywgXCIgXCIpKVxuICAgICAgfSxcbiAgICAgIElucHV0VmFsdWVEZWZpbml0aW9uOiB7XG4gICAgICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgdHlwZSwgZGVmYXVsdFZhbHVlLCBkaXJlY3RpdmVzIH0pID0+IHdyYXAoXCJcIiwgZGVzY3JpcHRpb24sIFwiXFxuXCIpICsgam9pbihcbiAgICAgICAgICBbbmFtZSArIFwiOiBcIiArIHR5cGUsIHdyYXAoXCI9IFwiLCBkZWZhdWx0VmFsdWUpLCBqb2luKGRpcmVjdGl2ZXMsIFwiIFwiKV0sXG4gICAgICAgICAgXCIgXCJcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIEludGVyZmFjZVR5cGVEZWZpbml0aW9uOiB7XG4gICAgICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgaW50ZXJmYWNlcywgZGlyZWN0aXZlcywgZmllbGRzIH0pID0+IHdyYXAoXCJcIiwgZGVzY3JpcHRpb24sIFwiXFxuXCIpICsgam9pbihcbiAgICAgICAgICBbXG4gICAgICAgICAgICBcImludGVyZmFjZVwiLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHdyYXAoXCJpbXBsZW1lbnRzIFwiLCBqb2luKGludGVyZmFjZXMsIFwiICYgXCIpKSxcbiAgICAgICAgICAgIGpvaW4oZGlyZWN0aXZlcywgXCIgXCIpLFxuICAgICAgICAgICAgYmxvY2soZmllbGRzKVxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCIgXCJcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIFVuaW9uVHlwZURlZmluaXRpb246IHtcbiAgICAgICAgbGVhdmU6ICh7IGRlc2NyaXB0aW9uLCBuYW1lLCBkaXJlY3RpdmVzLCB0eXBlcyB9KSA9PiB3cmFwKFwiXCIsIGRlc2NyaXB0aW9uLCBcIlxcblwiKSArIGpvaW4oXG4gICAgICAgICAgW1widW5pb25cIiwgbmFtZSwgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksIHdyYXAoXCI9IFwiLCBqb2luKHR5cGVzLCBcIiB8IFwiKSldLFxuICAgICAgICAgIFwiIFwiXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBFbnVtVHlwZURlZmluaXRpb246IHtcbiAgICAgICAgbGVhdmU6ICh7IGRlc2NyaXB0aW9uLCBuYW1lLCBkaXJlY3RpdmVzLCB2YWx1ZXMgfSkgPT4gd3JhcChcIlwiLCBkZXNjcmlwdGlvbiwgXCJcXG5cIikgKyBqb2luKFtcImVudW1cIiwgbmFtZSwgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksIGJsb2NrKHZhbHVlcyldLCBcIiBcIilcbiAgICAgIH0sXG4gICAgICBFbnVtVmFsdWVEZWZpbml0aW9uOiB7XG4gICAgICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgZGlyZWN0aXZlcyB9KSA9PiB3cmFwKFwiXCIsIGRlc2NyaXB0aW9uLCBcIlxcblwiKSArIGpvaW4oW25hbWUsIGpvaW4oZGlyZWN0aXZlcywgXCIgXCIpXSwgXCIgXCIpXG4gICAgICB9LFxuICAgICAgSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbjoge1xuICAgICAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGRpcmVjdGl2ZXMsIGZpZWxkcyB9KSA9PiB3cmFwKFwiXCIsIGRlc2NyaXB0aW9uLCBcIlxcblwiKSArIGpvaW4oW1wiaW5wdXRcIiwgbmFtZSwgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksIGJsb2NrKGZpZWxkcyldLCBcIiBcIilcbiAgICAgIH0sXG4gICAgICBEaXJlY3RpdmVEZWZpbml0aW9uOiB7XG4gICAgICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgYXJndW1lbnRzOiBhcmdzLCByZXBlYXRhYmxlLCBsb2NhdGlvbnMgfSkgPT4gd3JhcChcIlwiLCBkZXNjcmlwdGlvbiwgXCJcXG5cIikgKyBcImRpcmVjdGl2ZSBAXCIgKyBuYW1lICsgKGhhc011bHRpbGluZUl0ZW1zKGFyZ3MpID8gd3JhcChcIihcXG5cIiwgaW5kZW50KGpvaW4oYXJncywgXCJcXG5cIikpLCBcIlxcbilcIikgOiB3cmFwKFwiKFwiLCBqb2luKGFyZ3MsIFwiLCBcIiksIFwiKVwiKSkgKyAocmVwZWF0YWJsZSA/IFwiIHJlcGVhdGFibGVcIiA6IFwiXCIpICsgXCIgb24gXCIgKyBqb2luKGxvY2F0aW9ucywgXCIgfCBcIilcbiAgICAgIH0sXG4gICAgICBTY2hlbWFFeHRlbnNpb246IHtcbiAgICAgICAgbGVhdmU6ICh7IGRpcmVjdGl2ZXMsIG9wZXJhdGlvblR5cGVzIH0pID0+IGpvaW4oXG4gICAgICAgICAgW1wiZXh0ZW5kIHNjaGVtYVwiLCBqb2luKGRpcmVjdGl2ZXMsIFwiIFwiKSwgYmxvY2sob3BlcmF0aW9uVHlwZXMpXSxcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgU2NhbGFyVHlwZUV4dGVuc2lvbjoge1xuICAgICAgICBsZWF2ZTogKHsgbmFtZSwgZGlyZWN0aXZlcyB9KSA9PiBqb2luKFtcImV4dGVuZCBzY2FsYXJcIiwgbmFtZSwgam9pbihkaXJlY3RpdmVzLCBcIiBcIildLCBcIiBcIilcbiAgICAgIH0sXG4gICAgICBPYmplY3RUeXBlRXh0ZW5zaW9uOiB7XG4gICAgICAgIGxlYXZlOiAoeyBuYW1lLCBpbnRlcmZhY2VzLCBkaXJlY3RpdmVzLCBmaWVsZHMgfSkgPT4gam9pbihcbiAgICAgICAgICBbXG4gICAgICAgICAgICBcImV4dGVuZCB0eXBlXCIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgd3JhcChcImltcGxlbWVudHMgXCIsIGpvaW4oaW50ZXJmYWNlcywgXCIgJiBcIikpLFxuICAgICAgICAgICAgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksXG4gICAgICAgICAgICBibG9jayhmaWVsZHMpXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgSW50ZXJmYWNlVHlwZUV4dGVuc2lvbjoge1xuICAgICAgICBsZWF2ZTogKHsgbmFtZSwgaW50ZXJmYWNlcywgZGlyZWN0aXZlcywgZmllbGRzIH0pID0+IGpvaW4oXG4gICAgICAgICAgW1xuICAgICAgICAgICAgXCJleHRlbmQgaW50ZXJmYWNlXCIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgd3JhcChcImltcGxlbWVudHMgXCIsIGpvaW4oaW50ZXJmYWNlcywgXCIgJiBcIikpLFxuICAgICAgICAgICAgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksXG4gICAgICAgICAgICBibG9jayhmaWVsZHMpXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgVW5pb25UeXBlRXh0ZW5zaW9uOiB7XG4gICAgICAgIGxlYXZlOiAoeyBuYW1lLCBkaXJlY3RpdmVzLCB0eXBlcyB9KSA9PiBqb2luKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIFwiZXh0ZW5kIHVuaW9uXCIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksXG4gICAgICAgICAgICB3cmFwKFwiPSBcIiwgam9pbih0eXBlcywgXCIgfCBcIikpXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgRW51bVR5cGVFeHRlbnNpb246IHtcbiAgICAgICAgbGVhdmU6ICh7IG5hbWUsIGRpcmVjdGl2ZXMsIHZhbHVlcyB9KSA9PiBqb2luKFtcImV4dGVuZCBlbnVtXCIsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgXCIgXCIpLCBibG9jayh2YWx1ZXMpXSwgXCIgXCIpXG4gICAgICB9LFxuICAgICAgSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uOiB7XG4gICAgICAgIGxlYXZlOiAoeyBuYW1lLCBkaXJlY3RpdmVzLCBmaWVsZHMgfSkgPT4gam9pbihbXCJleHRlbmQgaW5wdXRcIiwgbmFtZSwgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksIGJsb2NrKGZpZWxkcyldLCBcIiBcIilcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdXRpbGl0aWVzL3ZhbHVlRnJvbUFTVFVudHlwZWQubWpzXG5mdW5jdGlvbiB2YWx1ZUZyb21BU1RVbnR5cGVkKHZhbHVlTm9kZSwgdmFyaWFibGVzKSB7XG4gIHN3aXRjaCAodmFsdWVOb2RlLmtpbmQpIHtcbiAgICBjYXNlIEtpbmQuTlVMTDpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgS2luZC5JTlQ6XG4gICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWVOb2RlLnZhbHVlLCAxMCk7XG4gICAgY2FzZSBLaW5kLkZMT0FUOlxuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWVOb2RlLnZhbHVlKTtcbiAgICBjYXNlIEtpbmQuU1RSSU5HOlxuICAgIGNhc2UgS2luZC5FTlVNOlxuICAgIGNhc2UgS2luZC5CT09MRUFOOlxuICAgICAgcmV0dXJuIHZhbHVlTm9kZS52YWx1ZTtcbiAgICBjYXNlIEtpbmQuTElTVDpcbiAgICAgIHJldHVybiB2YWx1ZU5vZGUudmFsdWVzLm1hcChcbiAgICAgICAgKG5vZGUpID0+IHZhbHVlRnJvbUFTVFVudHlwZWQobm9kZSwgdmFyaWFibGVzKVxuICAgICAgKTtcbiAgICBjYXNlIEtpbmQuT0JKRUNUOlxuICAgICAgcmV0dXJuIGtleVZhbE1hcChcbiAgICAgICAgdmFsdWVOb2RlLmZpZWxkcyxcbiAgICAgICAgKGZpZWxkKSA9PiBmaWVsZC5uYW1lLnZhbHVlLFxuICAgICAgICAoZmllbGQpID0+IHZhbHVlRnJvbUFTVFVudHlwZWQoZmllbGQudmFsdWUsIHZhcmlhYmxlcylcbiAgICAgICk7XG4gICAgY2FzZSBLaW5kLlZBUklBQkxFOlxuICAgICAgcmV0dXJuIHZhcmlhYmxlcyA9PT0gbnVsbCB8fCB2YXJpYWJsZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhcmlhYmxlc1t2YWx1ZU5vZGUubmFtZS52YWx1ZV07XG4gIH1cbn1cbnZhciBpbml0X3ZhbHVlRnJvbUFTVFVudHlwZWQgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdXRpbGl0aWVzL3ZhbHVlRnJvbUFTVFVudHlwZWQubWpzXCIoKSB7XG4gICAgaW5pdF9rZXlWYWxNYXAoKTtcbiAgICBpbml0X2tpbmRzKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC90eXBlL2Fzc2VydE5hbWUubWpzXG5mdW5jdGlvbiBhc3NlcnROYW1lKG5hbWUpIHtcbiAgbmFtZSAhPSBudWxsIHx8IGRldkFzc2VydChmYWxzZSwgXCJNdXN0IHByb3ZpZGUgbmFtZS5cIik7XG4gIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiIHx8IGRldkFzc2VydChmYWxzZSwgXCJFeHBlY3RlZCBuYW1lIHRvIGJlIGEgc3RyaW5nLlwiKTtcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihcIkV4cGVjdGVkIG5hbWUgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nLlwiKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMTsgaSA8IG5hbWUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIWlzTmFtZUNvbnRpbnVlKG5hbWUuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgIGBOYW1lcyBtdXN0IG9ubHkgY29udGFpbiBbX2EtekEtWjAtOV0gYnV0IFwiJHtuYW1lfVwiIGRvZXMgbm90LmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICghaXNOYW1lU3RhcnQobmFtZS5jaGFyQ29kZUF0KDApKSkge1xuICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICBgTmFtZXMgbXVzdCBzdGFydCB3aXRoIFtfYS16QS1aXSBidXQgXCIke25hbWV9XCIgZG9lcyBub3QuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBhc3NlcnRFbnVtVmFsdWVOYW1lKG5hbWUpIHtcbiAgaWYgKG5hbWUgPT09IFwidHJ1ZVwiIHx8IG5hbWUgPT09IFwiZmFsc2VcIiB8fCBuYW1lID09PSBcIm51bGxcIikge1xuICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoYEVudW0gdmFsdWVzIGNhbm5vdCBiZSBuYW1lZDogJHtuYW1lfWApO1xuICB9XG4gIHJldHVybiBhc3NlcnROYW1lKG5hbWUpO1xufVxudmFyIGluaXRfYXNzZXJ0TmFtZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC90eXBlL2Fzc2VydE5hbWUubWpzXCIoKSB7XG4gICAgaW5pdF9kZXZBc3NlcnQoKTtcbiAgICBpbml0X0dyYXBoUUxFcnJvcigpO1xuICAgIGluaXRfY2hhcmFjdGVyQ2xhc3NlcygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdHlwZS9kZWZpbml0aW9uLm1qc1xuZnVuY3Rpb24gaXNUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGlzU2NhbGFyVHlwZSh0eXBlKSB8fCBpc09iamVjdFR5cGUodHlwZSkgfHwgaXNJbnRlcmZhY2VUeXBlKHR5cGUpIHx8IGlzVW5pb25UeXBlKHR5cGUpIHx8IGlzRW51bVR5cGUodHlwZSkgfHwgaXNJbnB1dE9iamVjdFR5cGUodHlwZSkgfHwgaXNMaXN0VHlwZSh0eXBlKSB8fCBpc05vbk51bGxUeXBlKHR5cGUpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VHlwZSh0eXBlKSB7XG4gIGlmICghaXNUeXBlKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke2luc3BlY3QodHlwZSl9IHRvIGJlIGEgR3JhcGhRTCB0eXBlLmApO1xuICB9XG4gIHJldHVybiB0eXBlO1xufVxuZnVuY3Rpb24gaXNTY2FsYXJUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGluc3RhbmNlT2YodHlwZSwgR3JhcGhRTFNjYWxhclR5cGUpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U2NhbGFyVHlwZSh0eXBlKSB7XG4gIGlmICghaXNTY2FsYXJUeXBlKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke2luc3BlY3QodHlwZSl9IHRvIGJlIGEgR3JhcGhRTCBTY2FsYXIgdHlwZS5gKTtcbiAgfVxuICByZXR1cm4gdHlwZTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0VHlwZSh0eXBlKSB7XG4gIHJldHVybiBpbnN0YW5jZU9mKHR5cGUsIEdyYXBoUUxPYmplY3RUeXBlKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUodHlwZSkge1xuICBpZiAoIWlzT2JqZWN0VHlwZSh0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHtpbnNwZWN0KHR5cGUpfSB0byBiZSBhIEdyYXBoUUwgT2JqZWN0IHR5cGUuYCk7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59XG5mdW5jdGlvbiBpc0ludGVyZmFjZVR5cGUodHlwZSkge1xuICByZXR1cm4gaW5zdGFuY2VPZih0eXBlLCBHcmFwaFFMSW50ZXJmYWNlVHlwZSk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbnRlcmZhY2VUeXBlKHR5cGUpIHtcbiAgaWYgKCFpc0ludGVyZmFjZVR5cGUodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgJHtpbnNwZWN0KHR5cGUpfSB0byBiZSBhIEdyYXBoUUwgSW50ZXJmYWNlIHR5cGUuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59XG5mdW5jdGlvbiBpc1VuaW9uVHlwZSh0eXBlKSB7XG4gIHJldHVybiBpbnN0YW5jZU9mKHR5cGUsIEdyYXBoUUxVbmlvblR5cGUpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VW5pb25UeXBlKHR5cGUpIHtcbiAgaWYgKCFpc1VuaW9uVHlwZSh0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHtpbnNwZWN0KHR5cGUpfSB0byBiZSBhIEdyYXBoUUwgVW5pb24gdHlwZS5gKTtcbiAgfVxuICByZXR1cm4gdHlwZTtcbn1cbmZ1bmN0aW9uIGlzRW51bVR5cGUodHlwZSkge1xuICByZXR1cm4gaW5zdGFuY2VPZih0eXBlLCBHcmFwaFFMRW51bVR5cGUpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RW51bVR5cGUodHlwZSkge1xuICBpZiAoIWlzRW51bVR5cGUodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7aW5zcGVjdCh0eXBlKX0gdG8gYmUgYSBHcmFwaFFMIEVudW0gdHlwZS5gKTtcbiAgfVxuICByZXR1cm4gdHlwZTtcbn1cbmZ1bmN0aW9uIGlzSW5wdXRPYmplY3RUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGluc3RhbmNlT2YodHlwZSwgR3JhcGhRTElucHV0T2JqZWN0VHlwZSk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbnB1dE9iamVjdFR5cGUodHlwZSkge1xuICBpZiAoIWlzSW5wdXRPYmplY3RUeXBlKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkICR7aW5zcGVjdCh0eXBlKX0gdG8gYmUgYSBHcmFwaFFMIElucHV0IE9iamVjdCB0eXBlLmBcbiAgICApO1xuICB9XG4gIHJldHVybiB0eXBlO1xufVxuZnVuY3Rpb24gaXNMaXN0VHlwZSh0eXBlKSB7XG4gIHJldHVybiBpbnN0YW5jZU9mKHR5cGUsIEdyYXBoUUxMaXN0KTtcbn1cbmZ1bmN0aW9uIGFzc2VydExpc3RUeXBlKHR5cGUpIHtcbiAgaWYgKCFpc0xpc3RUeXBlKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke2luc3BlY3QodHlwZSl9IHRvIGJlIGEgR3JhcGhRTCBMaXN0IHR5cGUuYCk7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59XG5mdW5jdGlvbiBpc05vbk51bGxUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGluc3RhbmNlT2YodHlwZSwgR3JhcGhRTE5vbk51bGwpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Tm9uTnVsbFR5cGUodHlwZSkge1xuICBpZiAoIWlzTm9uTnVsbFR5cGUodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7aW5zcGVjdCh0eXBlKX0gdG8gYmUgYSBHcmFwaFFMIE5vbi1OdWxsIHR5cGUuYCk7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59XG5mdW5jdGlvbiBpc0lucHV0VHlwZSh0eXBlKSB7XG4gIHJldHVybiBpc1NjYWxhclR5cGUodHlwZSkgfHwgaXNFbnVtVHlwZSh0eXBlKSB8fCBpc0lucHV0T2JqZWN0VHlwZSh0eXBlKSB8fCBpc1dyYXBwaW5nVHlwZSh0eXBlKSAmJiBpc0lucHV0VHlwZSh0eXBlLm9mVHlwZSk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbnB1dFR5cGUodHlwZSkge1xuICBpZiAoIWlzSW5wdXRUeXBlKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke2luc3BlY3QodHlwZSl9IHRvIGJlIGEgR3JhcGhRTCBpbnB1dCB0eXBlLmApO1xuICB9XG4gIHJldHVybiB0eXBlO1xufVxuZnVuY3Rpb24gaXNPdXRwdXRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGlzU2NhbGFyVHlwZSh0eXBlKSB8fCBpc09iamVjdFR5cGUodHlwZSkgfHwgaXNJbnRlcmZhY2VUeXBlKHR5cGUpIHx8IGlzVW5pb25UeXBlKHR5cGUpIHx8IGlzRW51bVR5cGUodHlwZSkgfHwgaXNXcmFwcGluZ1R5cGUodHlwZSkgJiYgaXNPdXRwdXRUeXBlKHR5cGUub2ZUeXBlKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE91dHB1dFR5cGUodHlwZSkge1xuICBpZiAoIWlzT3V0cHV0VHlwZSh0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHtpbnNwZWN0KHR5cGUpfSB0byBiZSBhIEdyYXBoUUwgb3V0cHV0IHR5cGUuYCk7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59XG5mdW5jdGlvbiBpc0xlYWZUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGlzU2NhbGFyVHlwZSh0eXBlKSB8fCBpc0VudW1UeXBlKHR5cGUpO1xufVxuZnVuY3Rpb24gYXNzZXJ0TGVhZlR5cGUodHlwZSkge1xuICBpZiAoIWlzTGVhZlR5cGUodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7aW5zcGVjdCh0eXBlKX0gdG8gYmUgYSBHcmFwaFFMIGxlYWYgdHlwZS5gKTtcbiAgfVxuICByZXR1cm4gdHlwZTtcbn1cbmZ1bmN0aW9uIGlzQ29tcG9zaXRlVHlwZSh0eXBlKSB7XG4gIHJldHVybiBpc09iamVjdFR5cGUodHlwZSkgfHwgaXNJbnRlcmZhY2VUeXBlKHR5cGUpIHx8IGlzVW5pb25UeXBlKHR5cGUpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q29tcG9zaXRlVHlwZSh0eXBlKSB7XG4gIGlmICghaXNDb21wb3NpdGVUeXBlKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkICR7aW5zcGVjdCh0eXBlKX0gdG8gYmUgYSBHcmFwaFFMIGNvbXBvc2l0ZSB0eXBlLmBcbiAgICApO1xuICB9XG4gIHJldHVybiB0eXBlO1xufVxuZnVuY3Rpb24gaXNBYnN0cmFjdFR5cGUodHlwZSkge1xuICByZXR1cm4gaXNJbnRlcmZhY2VUeXBlKHR5cGUpIHx8IGlzVW5pb25UeXBlKHR5cGUpO1xufVxuZnVuY3Rpb24gYXNzZXJ0QWJzdHJhY3RUeXBlKHR5cGUpIHtcbiAgaWYgKCFpc0Fic3RyYWN0VHlwZSh0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHtpbnNwZWN0KHR5cGUpfSB0byBiZSBhIEdyYXBoUUwgYWJzdHJhY3QgdHlwZS5gKTtcbiAgfVxuICByZXR1cm4gdHlwZTtcbn1cbmZ1bmN0aW9uIGlzV3JhcHBpbmdUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGlzTGlzdFR5cGUodHlwZSkgfHwgaXNOb25OdWxsVHlwZSh0eXBlKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFdyYXBwaW5nVHlwZSh0eXBlKSB7XG4gIGlmICghaXNXcmFwcGluZ1R5cGUodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7aW5zcGVjdCh0eXBlKX0gdG8gYmUgYSBHcmFwaFFMIHdyYXBwaW5nIHR5cGUuYCk7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59XG5mdW5jdGlvbiBpc051bGxhYmxlVHlwZSh0eXBlKSB7XG4gIHJldHVybiBpc1R5cGUodHlwZSkgJiYgIWlzTm9uTnVsbFR5cGUodHlwZSk7XG59XG5mdW5jdGlvbiBhc3NlcnROdWxsYWJsZVR5cGUodHlwZSkge1xuICBpZiAoIWlzTnVsbGFibGVUeXBlKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke2luc3BlY3QodHlwZSl9IHRvIGJlIGEgR3JhcGhRTCBudWxsYWJsZSB0eXBlLmApO1xuICB9XG4gIHJldHVybiB0eXBlO1xufVxuZnVuY3Rpb24gZ2V0TnVsbGFibGVUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUpIHtcbiAgICByZXR1cm4gaXNOb25OdWxsVHlwZSh0eXBlKSA/IHR5cGUub2ZUeXBlIDogdHlwZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNOYW1lZFR5cGUodHlwZSkge1xuICByZXR1cm4gaXNTY2FsYXJUeXBlKHR5cGUpIHx8IGlzT2JqZWN0VHlwZSh0eXBlKSB8fCBpc0ludGVyZmFjZVR5cGUodHlwZSkgfHwgaXNVbmlvblR5cGUodHlwZSkgfHwgaXNFbnVtVHlwZSh0eXBlKSB8fCBpc0lucHV0T2JqZWN0VHlwZSh0eXBlKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE5hbWVkVHlwZSh0eXBlKSB7XG4gIGlmICghaXNOYW1lZFR5cGUodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7aW5zcGVjdCh0eXBlKX0gdG8gYmUgYSBHcmFwaFFMIG5hbWVkIHR5cGUuYCk7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59XG5mdW5jdGlvbiBnZXROYW1lZFR5cGUodHlwZSkge1xuICBpZiAodHlwZSkge1xuICAgIGxldCB1bndyYXBwZWRUeXBlID0gdHlwZTtcbiAgICB3aGlsZSAoaXNXcmFwcGluZ1R5cGUodW53cmFwcGVkVHlwZSkpIHtcbiAgICAgIHVud3JhcHBlZFR5cGUgPSB1bndyYXBwZWRUeXBlLm9mVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHVud3JhcHBlZFR5cGU7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVSZWFkb25seUFycmF5VGh1bmsodGh1bmspIHtcbiAgcmV0dXJuIHR5cGVvZiB0aHVuayA9PT0gXCJmdW5jdGlvblwiID8gdGh1bmsoKSA6IHRodW5rO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU9iak1hcFRodW5rKHRodW5rKSB7XG4gIHJldHVybiB0eXBlb2YgdGh1bmsgPT09IFwiZnVuY3Rpb25cIiA/IHRodW5rKCkgOiB0aHVuaztcbn1cbmZ1bmN0aW9uIGRlZmluZUludGVyZmFjZXMoY29uZmlnKSB7XG4gIHZhciBfY29uZmlnJGludGVyZmFjZXM7XG4gIGNvbnN0IGludGVyZmFjZXMgPSByZXNvbHZlUmVhZG9ubHlBcnJheVRodW5rKFxuICAgIChfY29uZmlnJGludGVyZmFjZXMgPSBjb25maWcuaW50ZXJmYWNlcykgIT09IG51bGwgJiYgX2NvbmZpZyRpbnRlcmZhY2VzICE9PSB2b2lkIDAgPyBfY29uZmlnJGludGVyZmFjZXMgOiBbXVxuICApO1xuICBBcnJheS5pc0FycmF5KGludGVyZmFjZXMpIHx8IGRldkFzc2VydChcbiAgICBmYWxzZSxcbiAgICBgJHtjb25maWcubmFtZX0gaW50ZXJmYWNlcyBtdXN0IGJlIGFuIEFycmF5IG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBBcnJheS5gXG4gICk7XG4gIHJldHVybiBpbnRlcmZhY2VzO1xufVxuZnVuY3Rpb24gZGVmaW5lRmllbGRNYXAoY29uZmlnKSB7XG4gIGNvbnN0IGZpZWxkTWFwID0gcmVzb2x2ZU9iak1hcFRodW5rKGNvbmZpZy5maWVsZHMpO1xuICBpc1BsYWluT2JqKGZpZWxkTWFwKSB8fCBkZXZBc3NlcnQoXG4gICAgZmFsc2UsXG4gICAgYCR7Y29uZmlnLm5hbWV9IGZpZWxkcyBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIGZpZWxkIG5hbWVzIGFzIGtleXMgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHN1Y2ggYW4gb2JqZWN0LmBcbiAgKTtcbiAgcmV0dXJuIG1hcFZhbHVlKGZpZWxkTWFwLCAoZmllbGRDb25maWcsIGZpZWxkTmFtZSkgPT4ge1xuICAgIHZhciBfZmllbGRDb25maWckYXJncztcbiAgICBpc1BsYWluT2JqKGZpZWxkQ29uZmlnKSB8fCBkZXZBc3NlcnQoXG4gICAgICBmYWxzZSxcbiAgICAgIGAke2NvbmZpZy5uYW1lfS4ke2ZpZWxkTmFtZX0gZmllbGQgY29uZmlnIG11c3QgYmUgYW4gb2JqZWN0LmBcbiAgICApO1xuICAgIGZpZWxkQ29uZmlnLnJlc29sdmUgPT0gbnVsbCB8fCB0eXBlb2YgZmllbGRDb25maWcucmVzb2x2ZSA9PT0gXCJmdW5jdGlvblwiIHx8IGRldkFzc2VydChcbiAgICAgIGZhbHNlLFxuICAgICAgYCR7Y29uZmlnLm5hbWV9LiR7ZmllbGROYW1lfSBmaWVsZCByZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24gaWYgcHJvdmlkZWQsIGJ1dCBnb3Q6ICR7aW5zcGVjdChmaWVsZENvbmZpZy5yZXNvbHZlKX0uYFxuICAgICk7XG4gICAgY29uc3QgYXJnc0NvbmZpZyA9IChfZmllbGRDb25maWckYXJncyA9IGZpZWxkQ29uZmlnLmFyZ3MpICE9PSBudWxsICYmIF9maWVsZENvbmZpZyRhcmdzICE9PSB2b2lkIDAgPyBfZmllbGRDb25maWckYXJncyA6IHt9O1xuICAgIGlzUGxhaW5PYmooYXJnc0NvbmZpZykgfHwgZGV2QXNzZXJ0KFxuICAgICAgZmFsc2UsXG4gICAgICBgJHtjb25maWcubmFtZX0uJHtmaWVsZE5hbWV9IGFyZ3MgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBhcmd1bWVudCBuYW1lcyBhcyBrZXlzLmBcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBhc3NlcnROYW1lKGZpZWxkTmFtZSksXG4gICAgICBkZXNjcmlwdGlvbjogZmllbGRDb25maWcuZGVzY3JpcHRpb24sXG4gICAgICB0eXBlOiBmaWVsZENvbmZpZy50eXBlLFxuICAgICAgYXJnczogZGVmaW5lQXJndW1lbnRzKGFyZ3NDb25maWcpLFxuICAgICAgcmVzb2x2ZTogZmllbGRDb25maWcucmVzb2x2ZSxcbiAgICAgIHN1YnNjcmliZTogZmllbGRDb25maWcuc3Vic2NyaWJlLFxuICAgICAgZGVwcmVjYXRpb25SZWFzb246IGZpZWxkQ29uZmlnLmRlcHJlY2F0aW9uUmVhc29uLFxuICAgICAgZXh0ZW5zaW9uczogdG9PYmpNYXAoZmllbGRDb25maWcuZXh0ZW5zaW9ucyksXG4gICAgICBhc3ROb2RlOiBmaWVsZENvbmZpZy5hc3ROb2RlXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkZWZpbmVBcmd1bWVudHMoY29uZmlnKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhjb25maWcpLm1hcCgoW2FyZ05hbWUsIGFyZ0NvbmZpZ10pID0+ICh7XG4gICAgbmFtZTogYXNzZXJ0TmFtZShhcmdOYW1lKSxcbiAgICBkZXNjcmlwdGlvbjogYXJnQ29uZmlnLmRlc2NyaXB0aW9uLFxuICAgIHR5cGU6IGFyZ0NvbmZpZy50eXBlLFxuICAgIGRlZmF1bHRWYWx1ZTogYXJnQ29uZmlnLmRlZmF1bHRWYWx1ZSxcbiAgICBkZXByZWNhdGlvblJlYXNvbjogYXJnQ29uZmlnLmRlcHJlY2F0aW9uUmVhc29uLFxuICAgIGV4dGVuc2lvbnM6IHRvT2JqTWFwKGFyZ0NvbmZpZy5leHRlbnNpb25zKSxcbiAgICBhc3ROb2RlOiBhcmdDb25maWcuYXN0Tm9kZVxuICB9KSk7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqKG9iaikge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKG9iaikgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn1cbmZ1bmN0aW9uIGZpZWxkc1RvRmllbGRzQ29uZmlnKGZpZWxkcykge1xuICByZXR1cm4gbWFwVmFsdWUoZmllbGRzLCAoZmllbGQpID0+ICh7XG4gICAgZGVzY3JpcHRpb246IGZpZWxkLmRlc2NyaXB0aW9uLFxuICAgIHR5cGU6IGZpZWxkLnR5cGUsXG4gICAgYXJnczogYXJnc1RvQXJnc0NvbmZpZyhmaWVsZC5hcmdzKSxcbiAgICByZXNvbHZlOiBmaWVsZC5yZXNvbHZlLFxuICAgIHN1YnNjcmliZTogZmllbGQuc3Vic2NyaWJlLFxuICAgIGRlcHJlY2F0aW9uUmVhc29uOiBmaWVsZC5kZXByZWNhdGlvblJlYXNvbixcbiAgICBleHRlbnNpb25zOiBmaWVsZC5leHRlbnNpb25zLFxuICAgIGFzdE5vZGU6IGZpZWxkLmFzdE5vZGVcbiAgfSkpO1xufVxuZnVuY3Rpb24gYXJnc1RvQXJnc0NvbmZpZyhhcmdzKSB7XG4gIHJldHVybiBrZXlWYWxNYXAoXG4gICAgYXJncyxcbiAgICAoYXJnKSA9PiBhcmcubmFtZSxcbiAgICAoYXJnKSA9PiAoe1xuICAgICAgZGVzY3JpcHRpb246IGFyZy5kZXNjcmlwdGlvbixcbiAgICAgIHR5cGU6IGFyZy50eXBlLFxuICAgICAgZGVmYXVsdFZhbHVlOiBhcmcuZGVmYXVsdFZhbHVlLFxuICAgICAgZGVwcmVjYXRpb25SZWFzb246IGFyZy5kZXByZWNhdGlvblJlYXNvbixcbiAgICAgIGV4dGVuc2lvbnM6IGFyZy5leHRlbnNpb25zLFxuICAgICAgYXN0Tm9kZTogYXJnLmFzdE5vZGVcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gaXNSZXF1aXJlZEFyZ3VtZW50KGFyZykge1xuICByZXR1cm4gaXNOb25OdWxsVHlwZShhcmcudHlwZSkgJiYgYXJnLmRlZmF1bHRWYWx1ZSA9PT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gZGVmaW5lVHlwZXMoY29uZmlnKSB7XG4gIGNvbnN0IHR5cGVzID0gcmVzb2x2ZVJlYWRvbmx5QXJyYXlUaHVuayhjb25maWcudHlwZXMpO1xuICBBcnJheS5pc0FycmF5KHR5cGVzKSB8fCBkZXZBc3NlcnQoXG4gICAgZmFsc2UsXG4gICAgYE11c3QgcHJvdmlkZSBBcnJheSBvZiB0eXBlcyBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgc3VjaCBhbiBhcnJheSBmb3IgVW5pb24gJHtjb25maWcubmFtZX0uYFxuICApO1xuICByZXR1cm4gdHlwZXM7XG59XG5mdW5jdGlvbiBkaWRZb3VNZWFuRW51bVZhbHVlKGVudW1UeXBlLCB1bmtub3duVmFsdWVTdHIpIHtcbiAgY29uc3QgYWxsTmFtZXMgPSBlbnVtVHlwZS5nZXRWYWx1ZXMoKS5tYXAoKHZhbHVlKSA9PiB2YWx1ZS5uYW1lKTtcbiAgY29uc3Qgc3VnZ2VzdGVkVmFsdWVzID0gc3VnZ2VzdGlvbkxpc3QodW5rbm93blZhbHVlU3RyLCBhbGxOYW1lcyk7XG4gIHJldHVybiBkaWRZb3VNZWFuKFwidGhlIGVudW0gdmFsdWVcIiwgc3VnZ2VzdGVkVmFsdWVzKTtcbn1cbmZ1bmN0aW9uIGRlZmluZUVudW1WYWx1ZXModHlwZU5hbWUsIHZhbHVlTWFwKSB7XG4gIGlzUGxhaW5PYmoodmFsdWVNYXApIHx8IGRldkFzc2VydChcbiAgICBmYWxzZSxcbiAgICBgJHt0eXBlTmFtZX0gdmFsdWVzIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggdmFsdWUgbmFtZXMgYXMga2V5cy5gXG4gICk7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyh2YWx1ZU1hcCkubWFwKChbdmFsdWVOYW1lLCB2YWx1ZUNvbmZpZ10pID0+IHtcbiAgICBpc1BsYWluT2JqKHZhbHVlQ29uZmlnKSB8fCBkZXZBc3NlcnQoXG4gICAgICBmYWxzZSxcbiAgICAgIGAke3R5cGVOYW1lfS4ke3ZhbHVlTmFtZX0gbXVzdCByZWZlciB0byBhbiBvYmplY3Qgd2l0aCBhIFwidmFsdWVcIiBrZXkgcmVwcmVzZW50aW5nIGFuIGludGVybmFsIHZhbHVlIGJ1dCBnb3Q6ICR7aW5zcGVjdCh2YWx1ZUNvbmZpZyl9LmBcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBhc3NlcnRFbnVtVmFsdWVOYW1lKHZhbHVlTmFtZSksXG4gICAgICBkZXNjcmlwdGlvbjogdmFsdWVDb25maWcuZGVzY3JpcHRpb24sXG4gICAgICB2YWx1ZTogdmFsdWVDb25maWcudmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlQ29uZmlnLnZhbHVlIDogdmFsdWVOYW1lLFxuICAgICAgZGVwcmVjYXRpb25SZWFzb246IHZhbHVlQ29uZmlnLmRlcHJlY2F0aW9uUmVhc29uLFxuICAgICAgZXh0ZW5zaW9uczogdG9PYmpNYXAodmFsdWVDb25maWcuZXh0ZW5zaW9ucyksXG4gICAgICBhc3ROb2RlOiB2YWx1ZUNvbmZpZy5hc3ROb2RlXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkZWZpbmVJbnB1dEZpZWxkTWFwKGNvbmZpZykge1xuICBjb25zdCBmaWVsZE1hcCA9IHJlc29sdmVPYmpNYXBUaHVuayhjb25maWcuZmllbGRzKTtcbiAgaXNQbGFpbk9iaihmaWVsZE1hcCkgfHwgZGV2QXNzZXJ0KFxuICAgIGZhbHNlLFxuICAgIGAke2NvbmZpZy5uYW1lfSBmaWVsZHMgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBmaWVsZCBuYW1lcyBhcyBrZXlzIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBzdWNoIGFuIG9iamVjdC5gXG4gICk7XG4gIHJldHVybiBtYXBWYWx1ZShmaWVsZE1hcCwgKGZpZWxkQ29uZmlnLCBmaWVsZE5hbWUpID0+IHtcbiAgICAhKFwicmVzb2x2ZVwiIGluIGZpZWxkQ29uZmlnKSB8fCBkZXZBc3NlcnQoXG4gICAgICBmYWxzZSxcbiAgICAgIGAke2NvbmZpZy5uYW1lfS4ke2ZpZWxkTmFtZX0gZmllbGQgaGFzIGEgcmVzb2x2ZSBwcm9wZXJ0eSwgYnV0IElucHV0IFR5cGVzIGNhbm5vdCBkZWZpbmUgcmVzb2x2ZXJzLmBcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBhc3NlcnROYW1lKGZpZWxkTmFtZSksXG4gICAgICBkZXNjcmlwdGlvbjogZmllbGRDb25maWcuZGVzY3JpcHRpb24sXG4gICAgICB0eXBlOiBmaWVsZENvbmZpZy50eXBlLFxuICAgICAgZGVmYXVsdFZhbHVlOiBmaWVsZENvbmZpZy5kZWZhdWx0VmFsdWUsXG4gICAgICBkZXByZWNhdGlvblJlYXNvbjogZmllbGRDb25maWcuZGVwcmVjYXRpb25SZWFzb24sXG4gICAgICBleHRlbnNpb25zOiB0b09iak1hcChmaWVsZENvbmZpZy5leHRlbnNpb25zKSxcbiAgICAgIGFzdE5vZGU6IGZpZWxkQ29uZmlnLmFzdE5vZGVcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzUmVxdWlyZWRJbnB1dEZpZWxkKGZpZWxkKSB7XG4gIHJldHVybiBpc05vbk51bGxUeXBlKGZpZWxkLnR5cGUpICYmIGZpZWxkLmRlZmF1bHRWYWx1ZSA9PT0gdm9pZCAwO1xufVxudmFyIEdyYXBoUUxMaXN0LCBHcmFwaFFMTm9uTnVsbCwgR3JhcGhRTFNjYWxhclR5cGUsIEdyYXBoUUxPYmplY3RUeXBlLCBHcmFwaFFMSW50ZXJmYWNlVHlwZSwgR3JhcGhRTFVuaW9uVHlwZSwgR3JhcGhRTEVudW1UeXBlLCBHcmFwaFFMSW5wdXRPYmplY3RUeXBlO1xudmFyIGluaXRfZGVmaW5pdGlvbiA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC90eXBlL2RlZmluaXRpb24ubWpzXCIoKSB7XG4gICAgaW5pdF9kZXZBc3NlcnQoKTtcbiAgICBpbml0X2RpZFlvdU1lYW4oKTtcbiAgICBpbml0X2lkZW50aXR5RnVuYygpO1xuICAgIGluaXRfaW5zcGVjdCgpO1xuICAgIGluaXRfaW5zdGFuY2VPZigpO1xuICAgIGluaXRfaXNPYmplY3RMaWtlKCk7XG4gICAgaW5pdF9rZXlNYXAoKTtcbiAgICBpbml0X2tleVZhbE1hcCgpO1xuICAgIGluaXRfbWFwVmFsdWUoKTtcbiAgICBpbml0X3N1Z2dlc3Rpb25MaXN0KCk7XG4gICAgaW5pdF90b09iak1hcCgpO1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gICAgaW5pdF9raW5kcygpO1xuICAgIGluaXRfcHJpbnRlcigpO1xuICAgIGluaXRfdmFsdWVGcm9tQVNUVW50eXBlZCgpO1xuICAgIGluaXRfYXNzZXJ0TmFtZSgpO1xuICAgIEdyYXBoUUxMaXN0ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3Iob2ZUeXBlKSB7XG4gICAgICAgIGlzVHlwZShvZlR5cGUpIHx8IGRldkFzc2VydChmYWxzZSwgYEV4cGVjdGVkICR7aW5zcGVjdChvZlR5cGUpfSB0byBiZSBhIEdyYXBoUUwgdHlwZS5gKTtcbiAgICAgICAgdGhpcy5vZlR5cGUgPSBvZlR5cGU7XG4gICAgICB9XG4gICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiBcIkdyYXBoUUxMaXN0XCI7XG4gICAgICB9XG4gICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgU3RyaW5nKHRoaXMub2ZUeXBlKSArIFwiXVwiO1xuICAgICAgfVxuICAgICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH07XG4gICAgR3JhcGhRTE5vbk51bGwgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihvZlR5cGUpIHtcbiAgICAgICAgaXNOdWxsYWJsZVR5cGUob2ZUeXBlKSB8fCBkZXZBc3NlcnQoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgYEV4cGVjdGVkICR7aW5zcGVjdChvZlR5cGUpfSB0byBiZSBhIEdyYXBoUUwgbnVsbGFibGUgdHlwZS5gXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMub2ZUeXBlID0gb2ZUeXBlO1xuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJHcmFwaFFMTm9uTnVsbFwiO1xuICAgICAgfVxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy5vZlR5cGUpICsgXCIhXCI7XG4gICAgICB9XG4gICAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBHcmFwaFFMU2NhbGFyVHlwZSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB2YXIgX2NvbmZpZyRwYXJzZVZhbHVlLCBfY29uZmlnJHNlcmlhbGl6ZSwgX2NvbmZpZyRwYXJzZUxpdGVyYWwsIF9jb25maWckZXh0ZW5zaW9uQVNUTjtcbiAgICAgICAgY29uc3QgcGFyc2VWYWx1ZTIgPSAoX2NvbmZpZyRwYXJzZVZhbHVlID0gY29uZmlnLnBhcnNlVmFsdWUpICE9PSBudWxsICYmIF9jb25maWckcGFyc2VWYWx1ZSAhPT0gdm9pZCAwID8gX2NvbmZpZyRwYXJzZVZhbHVlIDogaWRlbnRpdHlGdW5jO1xuICAgICAgICB0aGlzLm5hbWUgPSBhc3NlcnROYW1lKGNvbmZpZy5uYW1lKTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGNvbmZpZy5kZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5zcGVjaWZpZWRCeVVSTCA9IGNvbmZpZy5zcGVjaWZpZWRCeVVSTDtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSAoX2NvbmZpZyRzZXJpYWxpemUgPSBjb25maWcuc2VyaWFsaXplKSAhPT0gbnVsbCAmJiBfY29uZmlnJHNlcmlhbGl6ZSAhPT0gdm9pZCAwID8gX2NvbmZpZyRzZXJpYWxpemUgOiBpZGVudGl0eUZ1bmM7XG4gICAgICAgIHRoaXMucGFyc2VWYWx1ZSA9IHBhcnNlVmFsdWUyO1xuICAgICAgICB0aGlzLnBhcnNlTGl0ZXJhbCA9IChfY29uZmlnJHBhcnNlTGl0ZXJhbCA9IGNvbmZpZy5wYXJzZUxpdGVyYWwpICE9PSBudWxsICYmIF9jb25maWckcGFyc2VMaXRlcmFsICE9PSB2b2lkIDAgPyBfY29uZmlnJHBhcnNlTGl0ZXJhbCA6IChub2RlLCB2YXJpYWJsZXMpID0+IHBhcnNlVmFsdWUyKHZhbHVlRnJvbUFTVFVudHlwZWQobm9kZSwgdmFyaWFibGVzKSk7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHRvT2JqTWFwKGNvbmZpZy5leHRlbnNpb25zKTtcbiAgICAgICAgdGhpcy5hc3ROb2RlID0gY29uZmlnLmFzdE5vZGU7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uQVNUTm9kZXMgPSAoX2NvbmZpZyRleHRlbnNpb25BU1ROID0gY29uZmlnLmV4dGVuc2lvbkFTVE5vZGVzKSAhPT0gbnVsbCAmJiBfY29uZmlnJGV4dGVuc2lvbkFTVE4gIT09IHZvaWQgMCA/IF9jb25maWckZXh0ZW5zaW9uQVNUTiA6IFtdO1xuICAgICAgICBjb25maWcuc3BlY2lmaWVkQnlVUkwgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLnNwZWNpZmllZEJ5VVJMID09PSBcInN0cmluZ1wiIHx8IGRldkFzc2VydChcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBgJHt0aGlzLm5hbWV9IG11c3QgcHJvdmlkZSBcInNwZWNpZmllZEJ5VVJMXCIgYXMgYSBzdHJpbmcsIGJ1dCBnb3Q6ICR7aW5zcGVjdChjb25maWcuc3BlY2lmaWVkQnlVUkwpfS5gXG4gICAgICAgICk7XG4gICAgICAgIGNvbmZpZy5zZXJpYWxpemUgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLnNlcmlhbGl6ZSA9PT0gXCJmdW5jdGlvblwiIHx8IGRldkFzc2VydChcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBgJHt0aGlzLm5hbWV9IG11c3QgcHJvdmlkZSBcInNlcmlhbGl6ZVwiIGZ1bmN0aW9uLiBJZiB0aGlzIGN1c3RvbSBTY2FsYXIgaXMgYWxzbyB1c2VkIGFzIGFuIGlucHV0IHR5cGUsIGVuc3VyZSBcInBhcnNlVmFsdWVcIiBhbmQgXCJwYXJzZUxpdGVyYWxcIiBmdW5jdGlvbnMgYXJlIGFsc28gcHJvdmlkZWQuYFxuICAgICAgICApO1xuICAgICAgICBpZiAoY29uZmlnLnBhcnNlTGl0ZXJhbCkge1xuICAgICAgICAgIHR5cGVvZiBjb25maWcucGFyc2VWYWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBjb25maWcucGFyc2VMaXRlcmFsID09PSBcImZ1bmN0aW9uXCIgfHwgZGV2QXNzZXJ0KFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBgJHt0aGlzLm5hbWV9IG11c3QgcHJvdmlkZSBib3RoIFwicGFyc2VWYWx1ZVwiIGFuZCBcInBhcnNlTGl0ZXJhbFwiIGZ1bmN0aW9ucy5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJHcmFwaFFMU2NhbGFyVHlwZVwiO1xuICAgICAgfVxuICAgICAgdG9Db25maWcoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIHNwZWNpZmllZEJ5VVJMOiB0aGlzLnNwZWNpZmllZEJ5VVJMLFxuICAgICAgICAgIHNlcmlhbGl6ZTogdGhpcy5zZXJpYWxpemUsXG4gICAgICAgICAgcGFyc2VWYWx1ZTogdGhpcy5wYXJzZVZhbHVlLFxuICAgICAgICAgIHBhcnNlTGl0ZXJhbDogdGhpcy5wYXJzZUxpdGVyYWwsXG4gICAgICAgICAgZXh0ZW5zaW9uczogdGhpcy5leHRlbnNpb25zLFxuICAgICAgICAgIGFzdE5vZGU6IHRoaXMuYXN0Tm9kZSxcbiAgICAgICAgICBleHRlbnNpb25BU1ROb2RlczogdGhpcy5leHRlbnNpb25BU1ROb2Rlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICB9XG4gICAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBHcmFwaFFMT2JqZWN0VHlwZSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB2YXIgX2NvbmZpZyRleHRlbnNpb25BU1ROMjtcbiAgICAgICAgdGhpcy5uYW1lID0gYXNzZXJ0TmFtZShjb25maWcubmFtZSk7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBjb25maWcuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuaXNUeXBlT2YgPSBjb25maWcuaXNUeXBlT2Y7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHRvT2JqTWFwKGNvbmZpZy5leHRlbnNpb25zKTtcbiAgICAgICAgdGhpcy5hc3ROb2RlID0gY29uZmlnLmFzdE5vZGU7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uQVNUTm9kZXMgPSAoX2NvbmZpZyRleHRlbnNpb25BU1ROMiA9IGNvbmZpZy5leHRlbnNpb25BU1ROb2RlcykgIT09IG51bGwgJiYgX2NvbmZpZyRleHRlbnNpb25BU1ROMiAhPT0gdm9pZCAwID8gX2NvbmZpZyRleHRlbnNpb25BU1ROMiA6IFtdO1xuICAgICAgICB0aGlzLl9maWVsZHMgPSAoKSA9PiBkZWZpbmVGaWVsZE1hcChjb25maWcpO1xuICAgICAgICB0aGlzLl9pbnRlcmZhY2VzID0gKCkgPT4gZGVmaW5lSW50ZXJmYWNlcyhjb25maWcpO1xuICAgICAgICBjb25maWcuaXNUeXBlT2YgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLmlzVHlwZU9mID09PSBcImZ1bmN0aW9uXCIgfHwgZGV2QXNzZXJ0KFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGAke3RoaXMubmFtZX0gbXVzdCBwcm92aWRlIFwiaXNUeXBlT2ZcIiBhcyBhIGZ1bmN0aW9uLCBidXQgZ290OiAke2luc3BlY3QoY29uZmlnLmlzVHlwZU9mKX0uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJHcmFwaFFMT2JqZWN0VHlwZVwiO1xuICAgICAgfVxuICAgICAgZ2V0RmllbGRzKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2ZpZWxkcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5fZmllbGRzID0gdGhpcy5fZmllbGRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkcztcbiAgICAgIH1cbiAgICAgIGdldEludGVyZmFjZXMoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5faW50ZXJmYWNlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5faW50ZXJmYWNlcyA9IHRoaXMuX2ludGVyZmFjZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJmYWNlcztcbiAgICAgIH1cbiAgICAgIHRvQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICBpbnRlcmZhY2VzOiB0aGlzLmdldEludGVyZmFjZXMoKSxcbiAgICAgICAgICBmaWVsZHM6IGZpZWxkc1RvRmllbGRzQ29uZmlnKHRoaXMuZ2V0RmllbGRzKCkpLFxuICAgICAgICAgIGlzVHlwZU9mOiB0aGlzLmlzVHlwZU9mLFxuICAgICAgICAgIGV4dGVuc2lvbnM6IHRoaXMuZXh0ZW5zaW9ucyxcbiAgICAgICAgICBhc3ROb2RlOiB0aGlzLmFzdE5vZGUsXG4gICAgICAgICAgZXh0ZW5zaW9uQVNUTm9kZXM6IHRoaXMuZXh0ZW5zaW9uQVNUTm9kZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgfVxuICAgICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH07XG4gICAgR3JhcGhRTEludGVyZmFjZVR5cGUgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdmFyIF9jb25maWckZXh0ZW5zaW9uQVNUTjM7XG4gICAgICAgIHRoaXMubmFtZSA9IGFzc2VydE5hbWUoY29uZmlnLm5hbWUpO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gY29uZmlnLmRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnJlc29sdmVUeXBlID0gY29uZmlnLnJlc29sdmVUeXBlO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB0b09iak1hcChjb25maWcuZXh0ZW5zaW9ucyk7XG4gICAgICAgIHRoaXMuYXN0Tm9kZSA9IGNvbmZpZy5hc3ROb2RlO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbkFTVE5vZGVzID0gKF9jb25maWckZXh0ZW5zaW9uQVNUTjMgPSBjb25maWcuZXh0ZW5zaW9uQVNUTm9kZXMpICE9PSBudWxsICYmIF9jb25maWckZXh0ZW5zaW9uQVNUTjMgIT09IHZvaWQgMCA/IF9jb25maWckZXh0ZW5zaW9uQVNUTjMgOiBbXTtcbiAgICAgICAgdGhpcy5fZmllbGRzID0gZGVmaW5lRmllbGRNYXAuYmluZCh2b2lkIDAsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2ludGVyZmFjZXMgPSBkZWZpbmVJbnRlcmZhY2VzLmJpbmQodm9pZCAwLCBjb25maWcpO1xuICAgICAgICBjb25maWcucmVzb2x2ZVR5cGUgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLnJlc29sdmVUeXBlID09PSBcImZ1bmN0aW9uXCIgfHwgZGV2QXNzZXJ0KFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGAke3RoaXMubmFtZX0gbXVzdCBwcm92aWRlIFwicmVzb2x2ZVR5cGVcIiBhcyBhIGZ1bmN0aW9uLCBidXQgZ290OiAke2luc3BlY3QoY29uZmlnLnJlc29sdmVUeXBlKX0uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJHcmFwaFFMSW50ZXJmYWNlVHlwZVwiO1xuICAgICAgfVxuICAgICAgZ2V0RmllbGRzKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2ZpZWxkcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5fZmllbGRzID0gdGhpcy5fZmllbGRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkcztcbiAgICAgIH1cbiAgICAgIGdldEludGVyZmFjZXMoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5faW50ZXJmYWNlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5faW50ZXJmYWNlcyA9IHRoaXMuX2ludGVyZmFjZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJmYWNlcztcbiAgICAgIH1cbiAgICAgIHRvQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICBpbnRlcmZhY2VzOiB0aGlzLmdldEludGVyZmFjZXMoKSxcbiAgICAgICAgICBmaWVsZHM6IGZpZWxkc1RvRmllbGRzQ29uZmlnKHRoaXMuZ2V0RmllbGRzKCkpLFxuICAgICAgICAgIHJlc29sdmVUeXBlOiB0aGlzLnJlc29sdmVUeXBlLFxuICAgICAgICAgIGV4dGVuc2lvbnM6IHRoaXMuZXh0ZW5zaW9ucyxcbiAgICAgICAgICBhc3ROb2RlOiB0aGlzLmFzdE5vZGUsXG4gICAgICAgICAgZXh0ZW5zaW9uQVNUTm9kZXM6IHRoaXMuZXh0ZW5zaW9uQVNUTm9kZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgfVxuICAgICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH07XG4gICAgR3JhcGhRTFVuaW9uVHlwZSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB2YXIgX2NvbmZpZyRleHRlbnNpb25BU1RONDtcbiAgICAgICAgdGhpcy5uYW1lID0gYXNzZXJ0TmFtZShjb25maWcubmFtZSk7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBjb25maWcuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMucmVzb2x2ZVR5cGUgPSBjb25maWcucmVzb2x2ZVR5cGU7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHRvT2JqTWFwKGNvbmZpZy5leHRlbnNpb25zKTtcbiAgICAgICAgdGhpcy5hc3ROb2RlID0gY29uZmlnLmFzdE5vZGU7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uQVNUTm9kZXMgPSAoX2NvbmZpZyRleHRlbnNpb25BU1RONCA9IGNvbmZpZy5leHRlbnNpb25BU1ROb2RlcykgIT09IG51bGwgJiYgX2NvbmZpZyRleHRlbnNpb25BU1RONCAhPT0gdm9pZCAwID8gX2NvbmZpZyRleHRlbnNpb25BU1RONCA6IFtdO1xuICAgICAgICB0aGlzLl90eXBlcyA9IGRlZmluZVR5cGVzLmJpbmQodm9pZCAwLCBjb25maWcpO1xuICAgICAgICBjb25maWcucmVzb2x2ZVR5cGUgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLnJlc29sdmVUeXBlID09PSBcImZ1bmN0aW9uXCIgfHwgZGV2QXNzZXJ0KFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGAke3RoaXMubmFtZX0gbXVzdCBwcm92aWRlIFwicmVzb2x2ZVR5cGVcIiBhcyBhIGZ1bmN0aW9uLCBidXQgZ290OiAke2luc3BlY3QoY29uZmlnLnJlc29sdmVUeXBlKX0uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJHcmFwaFFMVW5pb25UeXBlXCI7XG4gICAgICB9XG4gICAgICBnZXRUeXBlcygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl90eXBlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5fdHlwZXMgPSB0aGlzLl90eXBlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlcztcbiAgICAgIH1cbiAgICAgIHRvQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICB0eXBlczogdGhpcy5nZXRUeXBlcygpLFxuICAgICAgICAgIHJlc29sdmVUeXBlOiB0aGlzLnJlc29sdmVUeXBlLFxuICAgICAgICAgIGV4dGVuc2lvbnM6IHRoaXMuZXh0ZW5zaW9ucyxcbiAgICAgICAgICBhc3ROb2RlOiB0aGlzLmFzdE5vZGUsXG4gICAgICAgICAgZXh0ZW5zaW9uQVNUTm9kZXM6IHRoaXMuZXh0ZW5zaW9uQVNUTm9kZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgfVxuICAgICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH07XG4gICAgR3JhcGhRTEVudW1UeXBlID0gY2xhc3Mge1xuICAgICAgLyogPFQ+ICovXG4gICAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdmFyIF9jb25maWckZXh0ZW5zaW9uQVNUTjU7XG4gICAgICAgIHRoaXMubmFtZSA9IGFzc2VydE5hbWUoY29uZmlnLm5hbWUpO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gY29uZmlnLmRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB0b09iak1hcChjb25maWcuZXh0ZW5zaW9ucyk7XG4gICAgICAgIHRoaXMuYXN0Tm9kZSA9IGNvbmZpZy5hc3ROb2RlO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbkFTVE5vZGVzID0gKF9jb25maWckZXh0ZW5zaW9uQVNUTjUgPSBjb25maWcuZXh0ZW5zaW9uQVNUTm9kZXMpICE9PSBudWxsICYmIF9jb25maWckZXh0ZW5zaW9uQVNUTjUgIT09IHZvaWQgMCA/IF9jb25maWckZXh0ZW5zaW9uQVNUTjUgOiBbXTtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gZGVmaW5lRW51bVZhbHVlcyh0aGlzLm5hbWUsIGNvbmZpZy52YWx1ZXMpO1xuICAgICAgICB0aGlzLl92YWx1ZUxvb2t1cCA9IG5ldyBNYXAoXG4gICAgICAgICAgdGhpcy5fdmFsdWVzLm1hcCgoZW51bVZhbHVlKSA9PiBbZW51bVZhbHVlLnZhbHVlLCBlbnVtVmFsdWVdKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9uYW1lTG9va3VwID0ga2V5TWFwKHRoaXMuX3ZhbHVlcywgKHZhbHVlKSA9PiB2YWx1ZS5uYW1lKTtcbiAgICAgIH1cbiAgICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgcmV0dXJuIFwiR3JhcGhRTEVudW1UeXBlXCI7XG4gICAgICB9XG4gICAgICBnZXRWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXM7XG4gICAgICB9XG4gICAgICBnZXRWYWx1ZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lTG9va3VwW25hbWVdO1xuICAgICAgfVxuICAgICAgc2VyaWFsaXplKG91dHB1dFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHRoaXMuX3ZhbHVlTG9va3VwLmdldChvdXRwdXRWYWx1ZSk7XG4gICAgICAgIGlmIChlbnVtVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBgRW51bSBcIiR7dGhpcy5uYW1lfVwiIGNhbm5vdCByZXByZXNlbnQgdmFsdWU6ICR7aW5zcGVjdChvdXRwdXRWYWx1ZSl9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZS5uYW1lO1xuICAgICAgfVxuICAgICAgcGFyc2VWYWx1ZShpbnB1dFZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXRWYWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHZhbHVlU3RyID0gaW5zcGVjdChpbnB1dFZhbHVlKTtcbiAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYEVudW0gXCIke3RoaXMubmFtZX1cIiBjYW5ub3QgcmVwcmVzZW50IG5vbi1zdHJpbmcgdmFsdWU6ICR7dmFsdWVTdHJ9LmAgKyBkaWRZb3VNZWFuRW51bVZhbHVlKHRoaXMsIHZhbHVlU3RyKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW51bVZhbHVlID0gdGhpcy5nZXRWYWx1ZShpbnB1dFZhbHVlKTtcbiAgICAgICAgaWYgKGVudW1WYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBWYWx1ZSBcIiR7aW5wdXRWYWx1ZX1cIiBkb2VzIG5vdCBleGlzdCBpbiBcIiR7dGhpcy5uYW1lfVwiIGVudW0uYCArIGRpZFlvdU1lYW5FbnVtVmFsdWUodGhpcywgaW5wdXRWYWx1ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWUudmFsdWU7XG4gICAgICB9XG4gICAgICBwYXJzZUxpdGVyYWwodmFsdWVOb2RlLCBfdmFyaWFibGVzKSB7XG4gICAgICAgIGlmICh2YWx1ZU5vZGUua2luZCAhPT0gS2luZC5FTlVNKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWVTdHIgPSBwcmludCh2YWx1ZU5vZGUpO1xuICAgICAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBgRW51bSBcIiR7dGhpcy5uYW1lfVwiIGNhbm5vdCByZXByZXNlbnQgbm9uLWVudW0gdmFsdWU6ICR7dmFsdWVTdHJ9LmAgKyBkaWRZb3VNZWFuRW51bVZhbHVlKHRoaXMsIHZhbHVlU3RyKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbm9kZXM6IHZhbHVlTm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW51bVZhbHVlID0gdGhpcy5nZXRWYWx1ZSh2YWx1ZU5vZGUudmFsdWUpO1xuICAgICAgICBpZiAoZW51bVZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZVN0ciA9IHByaW50KHZhbHVlTm9kZSk7XG4gICAgICAgICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBWYWx1ZSBcIiR7dmFsdWVTdHJ9XCIgZG9lcyBub3QgZXhpc3QgaW4gXCIke3RoaXMubmFtZX1cIiBlbnVtLmAgKyBkaWRZb3VNZWFuRW51bVZhbHVlKHRoaXMsIHZhbHVlU3RyKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbm9kZXM6IHZhbHVlTm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRvQ29uZmlnKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBrZXlWYWxNYXAoXG4gICAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKSxcbiAgICAgICAgICAodmFsdWUpID0+IHZhbHVlLm5hbWUsXG4gICAgICAgICAgKHZhbHVlKSA9PiAoe1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IHZhbHVlLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgZGVwcmVjYXRpb25SZWFzb246IHZhbHVlLmRlcHJlY2F0aW9uUmVhc29uLFxuICAgICAgICAgICAgZXh0ZW5zaW9uczogdmFsdWUuZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIGFzdE5vZGU6IHZhbHVlLmFzdE5vZGVcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgZXh0ZW5zaW9uczogdGhpcy5leHRlbnNpb25zLFxuICAgICAgICAgIGFzdE5vZGU6IHRoaXMuYXN0Tm9kZSxcbiAgICAgICAgICBleHRlbnNpb25BU1ROb2RlczogdGhpcy5leHRlbnNpb25BU1ROb2Rlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICB9XG4gICAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBHcmFwaFFMSW5wdXRPYmplY3RUeXBlID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHZhciBfY29uZmlnJGV4dGVuc2lvbkFTVE42O1xuICAgICAgICB0aGlzLm5hbWUgPSBhc3NlcnROYW1lKGNvbmZpZy5uYW1lKTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGNvbmZpZy5kZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gdG9PYmpNYXAoY29uZmlnLmV4dGVuc2lvbnMpO1xuICAgICAgICB0aGlzLmFzdE5vZGUgPSBjb25maWcuYXN0Tm9kZTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25BU1ROb2RlcyA9IChfY29uZmlnJGV4dGVuc2lvbkFTVE42ID0gY29uZmlnLmV4dGVuc2lvbkFTVE5vZGVzKSAhPT0gbnVsbCAmJiBfY29uZmlnJGV4dGVuc2lvbkFTVE42ICE9PSB2b2lkIDAgPyBfY29uZmlnJGV4dGVuc2lvbkFTVE42IDogW107XG4gICAgICAgIHRoaXMuX2ZpZWxkcyA9IGRlZmluZUlucHV0RmllbGRNYXAuYmluZCh2b2lkIDAsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiBcIkdyYXBoUUxJbnB1dE9iamVjdFR5cGVcIjtcbiAgICAgIH1cbiAgICAgIGdldEZpZWxkcygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9maWVsZHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRoaXMuX2ZpZWxkcyA9IHRoaXMuX2ZpZWxkcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9maWVsZHM7XG4gICAgICB9XG4gICAgICB0b0NvbmZpZygpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gbWFwVmFsdWUodGhpcy5nZXRGaWVsZHMoKSwgKGZpZWxkKSA9PiAoe1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBmaWVsZC5kZXNjcmlwdGlvbixcbiAgICAgICAgICB0eXBlOiBmaWVsZC50eXBlLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZmllbGQuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgIGRlcHJlY2F0aW9uUmVhc29uOiBmaWVsZC5kZXByZWNhdGlvblJlYXNvbixcbiAgICAgICAgICBleHRlbnNpb25zOiBmaWVsZC5leHRlbnNpb25zLFxuICAgICAgICAgIGFzdE5vZGU6IGZpZWxkLmFzdE5vZGVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgZXh0ZW5zaW9uczogdGhpcy5leHRlbnNpb25zLFxuICAgICAgICAgIGFzdE5vZGU6IHRoaXMuYXN0Tm9kZSxcbiAgICAgICAgICBleHRlbnNpb25BU1ROb2RlczogdGhpcy5leHRlbnNpb25BU1ROb2Rlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICB9XG4gICAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3R5cGUvc2NhbGFycy5tanNcbmZ1bmN0aW9uIGlzU3BlY2lmaWVkU2NhbGFyVHlwZSh0eXBlKSB7XG4gIHJldHVybiBzcGVjaWZpZWRTY2FsYXJUeXBlcy5zb21lKCh7IG5hbWUgfSkgPT4gdHlwZS5uYW1lID09PSBuYW1lKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdChvdXRwdXRWYWx1ZSkge1xuICBpZiAoaXNPYmplY3RMaWtlKG91dHB1dFZhbHVlKSkge1xuICAgIGlmICh0eXBlb2Ygb3V0cHV0VmFsdWUudmFsdWVPZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCB2YWx1ZU9mUmVzdWx0ID0gb3V0cHV0VmFsdWUudmFsdWVPZigpO1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWVPZlJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlT2ZSZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3V0cHV0VmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBvdXRwdXRWYWx1ZS50b0pTT04oKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xufVxudmFyIEdSQVBIUUxfTUFYX0lOVCwgR1JBUEhRTF9NSU5fSU5ULCBHcmFwaFFMSW50LCBHcmFwaFFMRmxvYXQsIEdyYXBoUUxTdHJpbmcsIEdyYXBoUUxCb29sZWFuLCBHcmFwaFFMSUQsIHNwZWNpZmllZFNjYWxhclR5cGVzO1xudmFyIGluaXRfc2NhbGFycyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC90eXBlL3NjYWxhcnMubWpzXCIoKSB7XG4gICAgaW5pdF9pbnNwZWN0KCk7XG4gICAgaW5pdF9pc09iamVjdExpa2UoKTtcbiAgICBpbml0X0dyYXBoUUxFcnJvcigpO1xuICAgIGluaXRfa2luZHMoKTtcbiAgICBpbml0X3ByaW50ZXIoKTtcbiAgICBpbml0X2RlZmluaXRpb24oKTtcbiAgICBHUkFQSFFMX01BWF9JTlQgPSAyMTQ3NDgzNjQ3O1xuICAgIEdSQVBIUUxfTUlOX0lOVCA9IC0yMTQ3NDgzNjQ4O1xuICAgIEdyYXBoUUxJbnQgPSBuZXcgR3JhcGhRTFNjYWxhclR5cGUoe1xuICAgICAgbmFtZTogXCJJbnRcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBgSW50YCBzY2FsYXIgdHlwZSByZXByZXNlbnRzIG5vbi1mcmFjdGlvbmFsIHNpZ25lZCB3aG9sZSBudW1lcmljIHZhbHVlcy4gSW50IGNhbiByZXByZXNlbnQgdmFsdWVzIGJldHdlZW4gLSgyXjMxKSBhbmQgMl4zMSAtIDEuXCIsXG4gICAgICBzZXJpYWxpemUob3V0cHV0VmFsdWUpIHtcbiAgICAgICAgY29uc3QgY29lcmNlZFZhbHVlID0gc2VyaWFsaXplT2JqZWN0KG91dHB1dFZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2VyY2VkVmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNvZXJjZWRWYWx1ZSA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW0gPSBjb2VyY2VkVmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgY29lcmNlZFZhbHVlID09PSBcInN0cmluZ1wiICYmIGNvZXJjZWRWYWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgIG51bSA9IE51bWJlcihjb2VyY2VkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSBcIm51bWJlclwiIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKG51bSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYEludCBjYW5ub3QgcmVwcmVzZW50IG5vbi1pbnRlZ2VyIHZhbHVlOiAke2luc3BlY3QoY29lcmNlZFZhbHVlKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtID4gR1JBUEhRTF9NQVhfSU5UIHx8IG51bSA8IEdSQVBIUUxfTUlOX0lOVCkge1xuICAgICAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBcIkludCBjYW5ub3QgcmVwcmVzZW50IG5vbiAzMi1iaXQgc2lnbmVkIGludGVnZXIgdmFsdWU6IFwiICsgaW5zcGVjdChjb2VyY2VkVmFsdWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgfSxcbiAgICAgIHBhcnNlVmFsdWUoaW5wdXRWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0VmFsdWUgIT09IFwibnVtYmVyXCIgfHwgIU51bWJlci5pc0ludGVnZXIoaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYEludCBjYW5ub3QgcmVwcmVzZW50IG5vbi1pbnRlZ2VyIHZhbHVlOiAke2luc3BlY3QoaW5wdXRWYWx1ZSl9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0VmFsdWUgPiBHUkFQSFFMX01BWF9JTlQgfHwgaW5wdXRWYWx1ZSA8IEdSQVBIUUxfTUlOX0lOVCkge1xuICAgICAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBgSW50IGNhbm5vdCByZXByZXNlbnQgbm9uIDMyLWJpdCBzaWduZWQgaW50ZWdlciB2YWx1ZTogJHtpbnB1dFZhbHVlfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgfSxcbiAgICAgIHBhcnNlTGl0ZXJhbCh2YWx1ZU5vZGUpIHtcbiAgICAgICAgaWYgKHZhbHVlTm9kZS5raW5kICE9PSBLaW5kLklOVCkge1xuICAgICAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBgSW50IGNhbm5vdCByZXByZXNlbnQgbm9uLWludGVnZXIgdmFsdWU6ICR7cHJpbnQodmFsdWVOb2RlKX1gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBub2RlczogdmFsdWVOb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW0gPSBwYXJzZUludCh2YWx1ZU5vZGUudmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKG51bSA+IEdSQVBIUUxfTUFYX0lOVCB8fCBudW0gPCBHUkFQSFFMX01JTl9JTlQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYEludCBjYW5ub3QgcmVwcmVzZW50IG5vbiAzMi1iaXQgc2lnbmVkIGludGVnZXIgdmFsdWU6ICR7dmFsdWVOb2RlLnZhbHVlfWAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5vZGVzOiB2YWx1ZU5vZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW07XG4gICAgICB9XG4gICAgfSk7XG4gICAgR3JhcGhRTEZsb2F0ID0gbmV3IEdyYXBoUUxTY2FsYXJUeXBlKHtcbiAgICAgIG5hbWU6IFwiRmxvYXRcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBgRmxvYXRgIHNjYWxhciB0eXBlIHJlcHJlc2VudHMgc2lnbmVkIGRvdWJsZS1wcmVjaXNpb24gZnJhY3Rpb25hbCB2YWx1ZXMgYXMgc3BlY2lmaWVkIGJ5IFtJRUVFIDc1NF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSUVFRV9mbG9hdGluZ19wb2ludCkuXCIsXG4gICAgICBzZXJpYWxpemUob3V0cHV0VmFsdWUpIHtcbiAgICAgICAgY29uc3QgY29lcmNlZFZhbHVlID0gc2VyaWFsaXplT2JqZWN0KG91dHB1dFZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2VyY2VkVmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNvZXJjZWRWYWx1ZSA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW0gPSBjb2VyY2VkVmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgY29lcmNlZFZhbHVlID09PSBcInN0cmluZ1wiICYmIGNvZXJjZWRWYWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgIG51bSA9IE51bWJlcihjb2VyY2VkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSBcIm51bWJlclwiIHx8ICFOdW1iZXIuaXNGaW5pdGUobnVtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBgRmxvYXQgY2Fubm90IHJlcHJlc2VudCBub24gbnVtZXJpYyB2YWx1ZTogJHtpbnNwZWN0KGNvZXJjZWRWYWx1ZSl9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVZhbHVlKGlucHV0VmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dFZhbHVlICE9PSBcIm51bWJlclwiIHx8ICFOdW1iZXIuaXNGaW5pdGUoaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYEZsb2F0IGNhbm5vdCByZXByZXNlbnQgbm9uIG51bWVyaWMgdmFsdWU6ICR7aW5zcGVjdChpbnB1dFZhbHVlKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUxpdGVyYWwodmFsdWVOb2RlKSB7XG4gICAgICAgIGlmICh2YWx1ZU5vZGUua2luZCAhPT0gS2luZC5GTE9BVCAmJiB2YWx1ZU5vZGUua2luZCAhPT0gS2luZC5JTlQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYEZsb2F0IGNhbm5vdCByZXByZXNlbnQgbm9uIG51bWVyaWMgdmFsdWU6ICR7cHJpbnQodmFsdWVOb2RlKX1gLFxuICAgICAgICAgICAgdmFsdWVOb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZU5vZGUudmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIEdyYXBoUUxTdHJpbmcgPSBuZXcgR3JhcGhRTFNjYWxhclR5cGUoe1xuICAgICAgbmFtZTogXCJTdHJpbmdcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBgU3RyaW5nYCBzY2FsYXIgdHlwZSByZXByZXNlbnRzIHRleHR1YWwgZGF0YSwgcmVwcmVzZW50ZWQgYXMgVVRGLTggY2hhcmFjdGVyIHNlcXVlbmNlcy4gVGhlIFN0cmluZyB0eXBlIGlzIG1vc3Qgb2Z0ZW4gdXNlZCBieSBHcmFwaFFMIHRvIHJlcHJlc2VudCBmcmVlLWZvcm0gaHVtYW4tcmVhZGFibGUgdGV4dC5cIixcbiAgICAgIHNlcmlhbGl6ZShvdXRwdXRWYWx1ZSkge1xuICAgICAgICBjb25zdCBjb2VyY2VkVmFsdWUgPSBzZXJpYWxpemVPYmplY3Qob3V0cHV0VmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIGNvZXJjZWRWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiBjb2VyY2VkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb2VyY2VkVmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNvZXJjZWRWYWx1ZSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29lcmNlZFZhbHVlID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0Zpbml0ZShjb2VyY2VkVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvZXJjZWRWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgYFN0cmluZyBjYW5ub3QgcmVwcmVzZW50IHZhbHVlOiAke2luc3BlY3Qob3V0cHV0VmFsdWUpfWBcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVZhbHVlKGlucHV0VmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dFZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBTdHJpbmcgY2Fubm90IHJlcHJlc2VudCBhIG5vbiBzdHJpbmcgdmFsdWU6ICR7aW5zcGVjdChpbnB1dFZhbHVlKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUxpdGVyYWwodmFsdWVOb2RlKSB7XG4gICAgICAgIGlmICh2YWx1ZU5vZGUua2luZCAhPT0gS2luZC5TVFJJTkcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYFN0cmluZyBjYW5ub3QgcmVwcmVzZW50IGEgbm9uIHN0cmluZyB2YWx1ZTogJHtwcmludCh2YWx1ZU5vZGUpfWAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5vZGVzOiB2YWx1ZU5vZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZU5vZGUudmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgR3JhcGhRTEJvb2xlYW4gPSBuZXcgR3JhcGhRTFNjYWxhclR5cGUoe1xuICAgICAgbmFtZTogXCJCb29sZWFuXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJUaGUgYEJvb2xlYW5gIHNjYWxhciB0eXBlIHJlcHJlc2VudHMgYHRydWVgIG9yIGBmYWxzZWAuXCIsXG4gICAgICBzZXJpYWxpemUob3V0cHV0VmFsdWUpIHtcbiAgICAgICAgY29uc3QgY29lcmNlZFZhbHVlID0gc2VyaWFsaXplT2JqZWN0KG91dHB1dFZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2VyY2VkVmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNvZXJjZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGNvZXJjZWRWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gY29lcmNlZFZhbHVlICE9PSAwO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgYEJvb2xlYW4gY2Fubm90IHJlcHJlc2VudCBhIG5vbiBib29sZWFuIHZhbHVlOiAke2luc3BlY3QoY29lcmNlZFZhbHVlKX1gXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgcGFyc2VWYWx1ZShpbnB1dFZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXRWYWx1ZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYEJvb2xlYW4gY2Fubm90IHJlcHJlc2VudCBhIG5vbiBib29sZWFuIHZhbHVlOiAke2luc3BlY3QoaW5wdXRWYWx1ZSl9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0VmFsdWU7XG4gICAgICB9LFxuICAgICAgcGFyc2VMaXRlcmFsKHZhbHVlTm9kZSkge1xuICAgICAgICBpZiAodmFsdWVOb2RlLmtpbmQgIT09IEtpbmQuQk9PTEVBTikge1xuICAgICAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBgQm9vbGVhbiBjYW5ub3QgcmVwcmVzZW50IGEgbm9uIGJvb2xlYW4gdmFsdWU6ICR7cHJpbnQodmFsdWVOb2RlKX1gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBub2RlczogdmFsdWVOb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVOb2RlLnZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIEdyYXBoUUxJRCA9IG5ldyBHcmFwaFFMU2NhbGFyVHlwZSh7XG4gICAgICBuYW1lOiBcIklEXCIsXG4gICAgICBkZXNjcmlwdGlvbjogJ1RoZSBgSURgIHNjYWxhciB0eXBlIHJlcHJlc2VudHMgYSB1bmlxdWUgaWRlbnRpZmllciwgb2Z0ZW4gdXNlZCB0byByZWZldGNoIGFuIG9iamVjdCBvciBhcyBrZXkgZm9yIGEgY2FjaGUuIFRoZSBJRCB0eXBlIGFwcGVhcnMgaW4gYSBKU09OIHJlc3BvbnNlIGFzIGEgU3RyaW5nOyBob3dldmVyLCBpdCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgaHVtYW4tcmVhZGFibGUuIFdoZW4gZXhwZWN0ZWQgYXMgYW4gaW5wdXQgdHlwZSwgYW55IHN0cmluZyAoc3VjaCBhcyBgXCI0XCJgKSBvciBpbnRlZ2VyIChzdWNoIGFzIGA0YCkgaW5wdXQgdmFsdWUgd2lsbCBiZSBhY2NlcHRlZCBhcyBhbiBJRC4nLFxuICAgICAgc2VyaWFsaXplKG91dHB1dFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvZXJjZWRWYWx1ZSA9IHNlcmlhbGl6ZU9iamVjdChvdXRwdXRWYWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgY29lcmNlZFZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIGNvZXJjZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihjb2VyY2VkVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhjb2VyY2VkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgYElEIGNhbm5vdCByZXByZXNlbnQgdmFsdWU6ICR7aW5zcGVjdChvdXRwdXRWYWx1ZSl9YFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHBhcnNlVmFsdWUoaW5wdXRWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0VmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGlucHV0VmFsdWUgPT09IFwibnVtYmVyXCIgJiYgTnVtYmVyLmlzSW50ZWdlcihpbnB1dFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihgSUQgY2Fubm90IHJlcHJlc2VudCB2YWx1ZTogJHtpbnNwZWN0KGlucHV0VmFsdWUpfWApO1xuICAgICAgfSxcbiAgICAgIHBhcnNlTGl0ZXJhbCh2YWx1ZU5vZGUpIHtcbiAgICAgICAgaWYgKHZhbHVlTm9kZS5raW5kICE9PSBLaW5kLlNUUklORyAmJiB2YWx1ZU5vZGUua2luZCAhPT0gS2luZC5JTlQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgXCJJRCBjYW5ub3QgcmVwcmVzZW50IGEgbm9uLXN0cmluZyBhbmQgbm9uLWludGVnZXIgdmFsdWU6IFwiICsgcHJpbnQodmFsdWVOb2RlKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbm9kZXM6IHZhbHVlTm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlTm9kZS52YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzcGVjaWZpZWRTY2FsYXJUeXBlcyA9IE9iamVjdC5mcmVlemUoW1xuICAgICAgR3JhcGhRTFN0cmluZyxcbiAgICAgIEdyYXBoUUxJbnQsXG4gICAgICBHcmFwaFFMRmxvYXQsXG4gICAgICBHcmFwaFFMQm9vbGVhbixcbiAgICAgIEdyYXBoUUxJRFxuICAgIF0pO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdHlwZS9kaXJlY3RpdmVzLm1qc1xuZnVuY3Rpb24gaXNEaXJlY3RpdmUoZGlyZWN0aXZlKSB7XG4gIHJldHVybiBpbnN0YW5jZU9mKGRpcmVjdGl2ZSwgR3JhcGhRTERpcmVjdGl2ZSk7XG59XG5mdW5jdGlvbiBhc3NlcnREaXJlY3RpdmUoZGlyZWN0aXZlKSB7XG4gIGlmICghaXNEaXJlY3RpdmUoZGlyZWN0aXZlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCAke2luc3BlY3QoZGlyZWN0aXZlKX0gdG8gYmUgYSBHcmFwaFFMIGRpcmVjdGl2ZS5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZGlyZWN0aXZlO1xufVxuZnVuY3Rpb24gaXNTcGVjaWZpZWREaXJlY3RpdmUoZGlyZWN0aXZlKSB7XG4gIHJldHVybiBzcGVjaWZpZWREaXJlY3RpdmVzLnNvbWUoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBkaXJlY3RpdmUubmFtZSk7XG59XG52YXIgR3JhcGhRTERpcmVjdGl2ZSwgR3JhcGhRTEluY2x1ZGVEaXJlY3RpdmUsIEdyYXBoUUxTa2lwRGlyZWN0aXZlLCBERUZBVUxUX0RFUFJFQ0FUSU9OX1JFQVNPTiwgR3JhcGhRTERlcHJlY2F0ZWREaXJlY3RpdmUsIEdyYXBoUUxTcGVjaWZpZWRCeURpcmVjdGl2ZSwgc3BlY2lmaWVkRGlyZWN0aXZlcztcbnZhciBpbml0X2RpcmVjdGl2ZXMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdHlwZS9kaXJlY3RpdmVzLm1qc1wiKCkge1xuICAgIGluaXRfZGV2QXNzZXJ0KCk7XG4gICAgaW5pdF9pbnNwZWN0KCk7XG4gICAgaW5pdF9pbnN0YW5jZU9mKCk7XG4gICAgaW5pdF9pc09iamVjdExpa2UoKTtcbiAgICBpbml0X3RvT2JqTWFwKCk7XG4gICAgaW5pdF9kaXJlY3RpdmVMb2NhdGlvbigpO1xuICAgIGluaXRfYXNzZXJ0TmFtZSgpO1xuICAgIGluaXRfZGVmaW5pdGlvbigpO1xuICAgIGluaXRfc2NhbGFycygpO1xuICAgIEdyYXBoUUxEaXJlY3RpdmUgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdmFyIF9jb25maWckaXNSZXBlYXRhYmxlLCBfY29uZmlnJGFyZ3M7XG4gICAgICAgIHRoaXMubmFtZSA9IGFzc2VydE5hbWUoY29uZmlnLm5hbWUpO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gY29uZmlnLmRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmxvY2F0aW9ucyA9IGNvbmZpZy5sb2NhdGlvbnM7XG4gICAgICAgIHRoaXMuaXNSZXBlYXRhYmxlID0gKF9jb25maWckaXNSZXBlYXRhYmxlID0gY29uZmlnLmlzUmVwZWF0YWJsZSkgIT09IG51bGwgJiYgX2NvbmZpZyRpc1JlcGVhdGFibGUgIT09IHZvaWQgMCA/IF9jb25maWckaXNSZXBlYXRhYmxlIDogZmFsc2U7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHRvT2JqTWFwKGNvbmZpZy5leHRlbnNpb25zKTtcbiAgICAgICAgdGhpcy5hc3ROb2RlID0gY29uZmlnLmFzdE5vZGU7XG4gICAgICAgIEFycmF5LmlzQXJyYXkoY29uZmlnLmxvY2F0aW9ucykgfHwgZGV2QXNzZXJ0KGZhbHNlLCBgQCR7Y29uZmlnLm5hbWV9IGxvY2F0aW9ucyBtdXN0IGJlIGFuIEFycmF5LmApO1xuICAgICAgICBjb25zdCBhcmdzID0gKF9jb25maWckYXJncyA9IGNvbmZpZy5hcmdzKSAhPT0gbnVsbCAmJiBfY29uZmlnJGFyZ3MgIT09IHZvaWQgMCA/IF9jb25maWckYXJncyA6IHt9O1xuICAgICAgICBpc09iamVjdExpa2UoYXJncykgJiYgIUFycmF5LmlzQXJyYXkoYXJncykgfHwgZGV2QXNzZXJ0KFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGBAJHtjb25maWcubmFtZX0gYXJncyBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIGFyZ3VtZW50IG5hbWVzIGFzIGtleXMuYFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmFyZ3MgPSBkZWZpbmVBcmd1bWVudHMoYXJncyk7XG4gICAgICB9XG4gICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiBcIkdyYXBoUUxEaXJlY3RpdmVcIjtcbiAgICAgIH1cbiAgICAgIHRvQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICBsb2NhdGlvbnM6IHRoaXMubG9jYXRpb25zLFxuICAgICAgICAgIGFyZ3M6IGFyZ3NUb0FyZ3NDb25maWcodGhpcy5hcmdzKSxcbiAgICAgICAgICBpc1JlcGVhdGFibGU6IHRoaXMuaXNSZXBlYXRhYmxlLFxuICAgICAgICAgIGV4dGVuc2lvbnM6IHRoaXMuZXh0ZW5zaW9ucyxcbiAgICAgICAgICBhc3ROb2RlOiB0aGlzLmFzdE5vZGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJAXCIgKyB0aGlzLm5hbWU7XG4gICAgICB9XG4gICAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBHcmFwaFFMSW5jbHVkZURpcmVjdGl2ZSA9IG5ldyBHcmFwaFFMRGlyZWN0aXZlKHtcbiAgICAgIG5hbWU6IFwiaW5jbHVkZVwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiRGlyZWN0cyB0aGUgZXhlY3V0b3IgdG8gaW5jbHVkZSB0aGlzIGZpZWxkIG9yIGZyYWdtZW50IG9ubHkgd2hlbiB0aGUgYGlmYCBhcmd1bWVudCBpcyB0cnVlLlwiLFxuICAgICAgbG9jYXRpb25zOiBbXG4gICAgICAgIERpcmVjdGl2ZUxvY2F0aW9uLkZJRUxELFxuICAgICAgICBEaXJlY3RpdmVMb2NhdGlvbi5GUkFHTUVOVF9TUFJFQUQsXG4gICAgICAgIERpcmVjdGl2ZUxvY2F0aW9uLklOTElORV9GUkFHTUVOVFxuICAgICAgXSxcbiAgICAgIGFyZ3M6IHtcbiAgICAgICAgaWY6IHtcbiAgICAgICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoR3JhcGhRTEJvb2xlYW4pLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkluY2x1ZGVkIHdoZW4gdHJ1ZS5cIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgR3JhcGhRTFNraXBEaXJlY3RpdmUgPSBuZXcgR3JhcGhRTERpcmVjdGl2ZSh7XG4gICAgICBuYW1lOiBcInNraXBcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkRpcmVjdHMgdGhlIGV4ZWN1dG9yIHRvIHNraXAgdGhpcyBmaWVsZCBvciBmcmFnbWVudCB3aGVuIHRoZSBgaWZgIGFyZ3VtZW50IGlzIHRydWUuXCIsXG4gICAgICBsb2NhdGlvbnM6IFtcbiAgICAgICAgRGlyZWN0aXZlTG9jYXRpb24uRklFTEQsXG4gICAgICAgIERpcmVjdGl2ZUxvY2F0aW9uLkZSQUdNRU5UX1NQUkVBRCxcbiAgICAgICAgRGlyZWN0aXZlTG9jYXRpb24uSU5MSU5FX0ZSQUdNRU5UXG4gICAgICBdLFxuICAgICAgYXJnczoge1xuICAgICAgICBpZjoge1xuICAgICAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChHcmFwaFFMQm9vbGVhbiksXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiU2tpcHBlZCB3aGVuIHRydWUuXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIERFRkFVTFRfREVQUkVDQVRJT05fUkVBU09OID0gXCJObyBsb25nZXIgc3VwcG9ydGVkXCI7XG4gICAgR3JhcGhRTERlcHJlY2F0ZWREaXJlY3RpdmUgPSBuZXcgR3JhcGhRTERpcmVjdGl2ZSh7XG4gICAgICBuYW1lOiBcImRlcHJlY2F0ZWRcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk1hcmtzIGFuIGVsZW1lbnQgb2YgYSBHcmFwaFFMIHNjaGVtYSBhcyBubyBsb25nZXIgc3VwcG9ydGVkLlwiLFxuICAgICAgbG9jYXRpb25zOiBbXG4gICAgICAgIERpcmVjdGl2ZUxvY2F0aW9uLkZJRUxEX0RFRklOSVRJT04sXG4gICAgICAgIERpcmVjdGl2ZUxvY2F0aW9uLkFSR1VNRU5UX0RFRklOSVRJT04sXG4gICAgICAgIERpcmVjdGl2ZUxvY2F0aW9uLklOUFVUX0ZJRUxEX0RFRklOSVRJT04sXG4gICAgICAgIERpcmVjdGl2ZUxvY2F0aW9uLkVOVU1fVkFMVUVcbiAgICAgIF0sXG4gICAgICBhcmdzOiB7XG4gICAgICAgIHJlYXNvbjoge1xuICAgICAgICAgIHR5cGU6IEdyYXBoUUxTdHJpbmcsXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiRXhwbGFpbnMgd2h5IHRoaXMgZWxlbWVudCB3YXMgZGVwcmVjYXRlZCwgdXN1YWxseSBhbHNvIGluY2x1ZGluZyBhIHN1Z2dlc3Rpb24gZm9yIGhvdyB0byBhY2Nlc3Mgc3VwcG9ydGVkIHNpbWlsYXIgZGF0YS4gRm9ybWF0dGVkIHVzaW5nIHRoZSBNYXJrZG93biBzeW50YXgsIGFzIHNwZWNpZmllZCBieSBbQ29tbW9uTWFya10oaHR0cHM6Ly9jb21tb25tYXJrLm9yZy8pLlwiLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogREVGQVVMVF9ERVBSRUNBVElPTl9SRUFTT05cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIEdyYXBoUUxTcGVjaWZpZWRCeURpcmVjdGl2ZSA9IG5ldyBHcmFwaFFMRGlyZWN0aXZlKHtcbiAgICAgIG5hbWU6IFwic3BlY2lmaWVkQnlcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkV4cG9zZXMgYSBVUkwgdGhhdCBzcGVjaWZpZXMgdGhlIGJlaGF2aW9yIG9mIHRoaXMgc2NhbGFyLlwiLFxuICAgICAgbG9jYXRpb25zOiBbRGlyZWN0aXZlTG9jYXRpb24uU0NBTEFSXSxcbiAgICAgIGFyZ3M6IHtcbiAgICAgICAgdXJsOiB7XG4gICAgICAgICAgdHlwZTogbmV3IEdyYXBoUUxOb25OdWxsKEdyYXBoUUxTdHJpbmcpLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBVUkwgdGhhdCBzcGVjaWZpZXMgdGhlIGJlaGF2aW9yIG9mIHRoaXMgc2NhbGFyLlwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBzcGVjaWZpZWREaXJlY3RpdmVzID0gT2JqZWN0LmZyZWV6ZShbXG4gICAgICBHcmFwaFFMSW5jbHVkZURpcmVjdGl2ZSxcbiAgICAgIEdyYXBoUUxTa2lwRGlyZWN0aXZlLFxuICAgICAgR3JhcGhRTERlcHJlY2F0ZWREaXJlY3RpdmUsXG4gICAgICBHcmFwaFFMU3BlY2lmaWVkQnlEaXJlY3RpdmVcbiAgICBdKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvaXNJdGVyYWJsZU9iamVjdC5tanNcbmZ1bmN0aW9uIGlzSXRlcmFibGVPYmplY3QobWF5YmVJdGVyYWJsZSkge1xuICByZXR1cm4gdHlwZW9mIG1heWJlSXRlcmFibGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IG1heWJlSXRlcmFibGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heWJlSXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSkgPT09IFwiZnVuY3Rpb25cIjtcbn1cbnZhciBpbml0X2lzSXRlcmFibGVPYmplY3QgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9pc0l0ZXJhYmxlT2JqZWN0Lm1qc1wiKCkge1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdXRpbGl0aWVzL2FzdEZyb21WYWx1ZS5tanNcbmZ1bmN0aW9uIGFzdEZyb21WYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICBpZiAoaXNOb25OdWxsVHlwZSh0eXBlKSkge1xuICAgIGNvbnN0IGFzdFZhbHVlID0gYXN0RnJvbVZhbHVlKHZhbHVlLCB0eXBlLm9mVHlwZSk7XG4gICAgaWYgKChhc3RWYWx1ZSA9PT0gbnVsbCB8fCBhc3RWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXN0VmFsdWUua2luZCkgPT09IEtpbmQuTlVMTCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBhc3RWYWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5OVUxMXG4gICAgfTtcbiAgfVxuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0xpc3RUeXBlKHR5cGUpKSB7XG4gICAgY29uc3QgaXRlbVR5cGUgPSB0eXBlLm9mVHlwZTtcbiAgICBpZiAoaXNJdGVyYWJsZU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IHZhbHVlc05vZGVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgaXRlbU5vZGUgPSBhc3RGcm9tVmFsdWUoaXRlbSwgaXRlbVR5cGUpO1xuICAgICAgICBpZiAoaXRlbU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlc05vZGVzLnB1c2goaXRlbU5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBLaW5kLkxJU1QsXG4gICAgICAgIHZhbHVlczogdmFsdWVzTm9kZXNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhc3RGcm9tVmFsdWUodmFsdWUsIGl0ZW1UeXBlKTtcbiAgfVxuICBpZiAoaXNJbnB1dE9iamVjdFR5cGUodHlwZSkpIHtcbiAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBmaWVsZE5vZGVzID0gW107XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBPYmplY3QudmFsdWVzKHR5cGUuZ2V0RmllbGRzKCkpKSB7XG4gICAgICBjb25zdCBmaWVsZFZhbHVlID0gYXN0RnJvbVZhbHVlKHZhbHVlW2ZpZWxkLm5hbWVdLCBmaWVsZC50eXBlKTtcbiAgICAgIGlmIChmaWVsZFZhbHVlKSB7XG4gICAgICAgIGZpZWxkTm9kZXMucHVzaCh7XG4gICAgICAgICAga2luZDogS2luZC5PQkpFQ1RfRklFTEQsXG4gICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAga2luZDogS2luZC5OQU1FLFxuICAgICAgICAgICAgdmFsdWU6IGZpZWxkLm5hbWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZhbHVlOiBmaWVsZFZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5PQkpFQ1QsXG4gICAgICBmaWVsZHM6IGZpZWxkTm9kZXNcbiAgICB9O1xuICB9XG4gIGlmIChpc0xlYWZUeXBlKHR5cGUpKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHR5cGUuc2VyaWFsaXplKHZhbHVlKTtcbiAgICBpZiAoc2VyaWFsaXplZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZXJpYWxpemVkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogS2luZC5CT09MRUFOLFxuICAgICAgICB2YWx1ZTogc2VyaWFsaXplZFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZXJpYWxpemVkID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0Zpbml0ZShzZXJpYWxpemVkKSkge1xuICAgICAgY29uc3Qgc3RyaW5nTnVtID0gU3RyaW5nKHNlcmlhbGl6ZWQpO1xuICAgICAgcmV0dXJuIGludGVnZXJTdHJpbmdSZWdFeHAudGVzdChzdHJpbmdOdW0pID8ge1xuICAgICAgICBraW5kOiBLaW5kLklOVCxcbiAgICAgICAgdmFsdWU6IHN0cmluZ051bVxuICAgICAgfSA6IHtcbiAgICAgICAga2luZDogS2luZC5GTE9BVCxcbiAgICAgICAgdmFsdWU6IHN0cmluZ051bVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZXJpYWxpemVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoaXNFbnVtVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuRU5VTSxcbiAgICAgICAgICB2YWx1ZTogc2VyaWFsaXplZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IEdyYXBoUUxJRCAmJiBpbnRlZ2VyU3RyaW5nUmVnRXhwLnRlc3Qoc2VyaWFsaXplZCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBraW5kOiBLaW5kLklOVCxcbiAgICAgICAgICB2YWx1ZTogc2VyaWFsaXplZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogS2luZC5TVFJJTkcsXG4gICAgICAgIHZhbHVlOiBzZXJpYWxpemVkXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgY29udmVydCB2YWx1ZSB0byBBU1Q6ICR7aW5zcGVjdChzZXJpYWxpemVkKX0uYCk7XG4gIH1cbiAgaW52YXJpYW50KGZhbHNlLCBcIlVuZXhwZWN0ZWQgaW5wdXQgdHlwZTogXCIgKyBpbnNwZWN0KHR5cGUpKTtcbn1cbnZhciBpbnRlZ2VyU3RyaW5nUmVnRXhwO1xudmFyIGluaXRfYXN0RnJvbVZhbHVlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9hc3RGcm9tVmFsdWUubWpzXCIoKSB7XG4gICAgaW5pdF9pbnNwZWN0KCk7XG4gICAgaW5pdF9pbnZhcmlhbnQoKTtcbiAgICBpbml0X2lzSXRlcmFibGVPYmplY3QoKTtcbiAgICBpbml0X2lzT2JqZWN0TGlrZSgpO1xuICAgIGluaXRfa2luZHMoKTtcbiAgICBpbml0X2RlZmluaXRpb24oKTtcbiAgICBpbml0X3NjYWxhcnMoKTtcbiAgICBpbnRlZ2VyU3RyaW5nUmVnRXhwID0gL14tPyg/OjB8WzEtOV1bMC05XSopJC87XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC90eXBlL2ludHJvc3BlY3Rpb24ubWpzXG5mdW5jdGlvbiBpc0ludHJvc3BlY3Rpb25UeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGludHJvc3BlY3Rpb25UeXBlcy5zb21lKCh7IG5hbWUgfSkgPT4gdHlwZS5uYW1lID09PSBuYW1lKTtcbn1cbnZhciBfX1NjaGVtYSwgX19EaXJlY3RpdmUsIF9fRGlyZWN0aXZlTG9jYXRpb24sIF9fVHlwZSwgX19GaWVsZCwgX19JbnB1dFZhbHVlLCBfX0VudW1WYWx1ZSwgVHlwZUtpbmQsIF9fVHlwZUtpbmQsIFNjaGVtYU1ldGFGaWVsZERlZiwgVHlwZU1ldGFGaWVsZERlZiwgVHlwZU5hbWVNZXRhRmllbGREZWYsIGludHJvc3BlY3Rpb25UeXBlcztcbnZhciBpbml0X2ludHJvc3BlY3Rpb24gPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdHlwZS9pbnRyb3NwZWN0aW9uLm1qc1wiKCkge1xuICAgIGluaXRfaW5zcGVjdCgpO1xuICAgIGluaXRfaW52YXJpYW50KCk7XG4gICAgaW5pdF9kaXJlY3RpdmVMb2NhdGlvbigpO1xuICAgIGluaXRfcHJpbnRlcigpO1xuICAgIGluaXRfYXN0RnJvbVZhbHVlKCk7XG4gICAgaW5pdF9kZWZpbml0aW9uKCk7XG4gICAgaW5pdF9zY2FsYXJzKCk7XG4gICAgX19TY2hlbWEgPSBuZXcgR3JhcGhRTE9iamVjdFR5cGUoe1xuICAgICAgbmFtZTogXCJfX1NjaGVtYVwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQSBHcmFwaFFMIFNjaGVtYSBkZWZpbmVzIHRoZSBjYXBhYmlsaXRpZXMgb2YgYSBHcmFwaFFMIHNlcnZlci4gSXQgZXhwb3NlcyBhbGwgYXZhaWxhYmxlIHR5cGVzIGFuZCBkaXJlY3RpdmVzIG9uIHRoZSBzZXJ2ZXIsIGFzIHdlbGwgYXMgdGhlIGVudHJ5IHBvaW50cyBmb3IgcXVlcnksIG11dGF0aW9uLCBhbmQgc3Vic2NyaXB0aW9uIG9wZXJhdGlvbnMuXCIsXG4gICAgICBmaWVsZHM6ICgpID0+ICh7XG4gICAgICAgIGRlc2NyaXB0aW9uOiB7XG4gICAgICAgICAgdHlwZTogR3JhcGhRTFN0cmluZyxcbiAgICAgICAgICByZXNvbHZlOiAoc2NoZW1hKSA9PiBzY2hlbWEuZGVzY3JpcHRpb25cbiAgICAgICAgfSxcbiAgICAgICAgdHlwZXM6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJBIGxpc3Qgb2YgYWxsIHR5cGVzIHN1cHBvcnRlZCBieSB0aGlzIHNlcnZlci5cIixcbiAgICAgICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwobmV3IEdyYXBoUUxMaXN0KG5ldyBHcmFwaFFMTm9uTnVsbChfX1R5cGUpKSksXG4gICAgICAgICAgcmVzb2x2ZShzY2hlbWEpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHNjaGVtYS5nZXRUeXBlTWFwKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcXVlcnlUeXBlOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiVGhlIHR5cGUgdGhhdCBxdWVyeSBvcGVyYXRpb25zIHdpbGwgYmUgcm9vdGVkIGF0LlwiLFxuICAgICAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChfX1R5cGUpLFxuICAgICAgICAgIHJlc29sdmU6IChzY2hlbWEpID0+IHNjaGVtYS5nZXRRdWVyeVR5cGUoKVxuICAgICAgICB9LFxuICAgICAgICBtdXRhdGlvblR5cGU6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJJZiB0aGlzIHNlcnZlciBzdXBwb3J0cyBtdXRhdGlvbiwgdGhlIHR5cGUgdGhhdCBtdXRhdGlvbiBvcGVyYXRpb25zIHdpbGwgYmUgcm9vdGVkIGF0LlwiLFxuICAgICAgICAgIHR5cGU6IF9fVHlwZSxcbiAgICAgICAgICByZXNvbHZlOiAoc2NoZW1hKSA9PiBzY2hlbWEuZ2V0TXV0YXRpb25UeXBlKClcbiAgICAgICAgfSxcbiAgICAgICAgc3Vic2NyaXB0aW9uVHlwZToge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIklmIHRoaXMgc2VydmVyIHN1cHBvcnQgc3Vic2NyaXB0aW9uLCB0aGUgdHlwZSB0aGF0IHN1YnNjcmlwdGlvbiBvcGVyYXRpb25zIHdpbGwgYmUgcm9vdGVkIGF0LlwiLFxuICAgICAgICAgIHR5cGU6IF9fVHlwZSxcbiAgICAgICAgICByZXNvbHZlOiAoc2NoZW1hKSA9PiBzY2hlbWEuZ2V0U3Vic2NyaXB0aW9uVHlwZSgpXG4gICAgICAgIH0sXG4gICAgICAgIGRpcmVjdGl2ZXM6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJBIGxpc3Qgb2YgYWxsIGRpcmVjdGl2ZXMgc3VwcG9ydGVkIGJ5IHRoaXMgc2VydmVyLlwiLFxuICAgICAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChcbiAgICAgICAgICAgIG5ldyBHcmFwaFFMTGlzdChuZXcgR3JhcGhRTE5vbk51bGwoX19EaXJlY3RpdmUpKVxuICAgICAgICAgICksXG4gICAgICAgICAgcmVzb2x2ZTogKHNjaGVtYSkgPT4gc2NoZW1hLmdldERpcmVjdGl2ZXMoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuICAgIF9fRGlyZWN0aXZlID0gbmV3IEdyYXBoUUxPYmplY3RUeXBlKHtcbiAgICAgIG5hbWU6IFwiX19EaXJlY3RpdmVcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkEgRGlyZWN0aXZlIHByb3ZpZGVzIGEgd2F5IHRvIGRlc2NyaWJlIGFsdGVybmF0ZSBydW50aW1lIGV4ZWN1dGlvbiBhbmQgdHlwZSB2YWxpZGF0aW9uIGJlaGF2aW9yIGluIGEgR3JhcGhRTCBkb2N1bWVudC5cXG5cXG5JbiBzb21lIGNhc2VzLCB5b3UgbmVlZCB0byBwcm92aWRlIG9wdGlvbnMgdG8gYWx0ZXIgR3JhcGhRTCdzIGV4ZWN1dGlvbiBiZWhhdmlvciBpbiB3YXlzIGZpZWxkIGFyZ3VtZW50cyB3aWxsIG5vdCBzdWZmaWNlLCBzdWNoIGFzIGNvbmRpdGlvbmFsbHkgaW5jbHVkaW5nIG9yIHNraXBwaW5nIGEgZmllbGQuIERpcmVjdGl2ZXMgcHJvdmlkZSB0aGlzIGJ5IGRlc2NyaWJpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byB0aGUgZXhlY3V0b3IuXCIsXG4gICAgICBmaWVsZHM6ICgpID0+ICh7XG4gICAgICAgIG5hbWU6IHtcbiAgICAgICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoR3JhcGhRTFN0cmluZyksXG4gICAgICAgICAgcmVzb2x2ZTogKGRpcmVjdGl2ZSkgPT4gZGlyZWN0aXZlLm5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgZGVzY3JpcHRpb246IHtcbiAgICAgICAgICB0eXBlOiBHcmFwaFFMU3RyaW5nLFxuICAgICAgICAgIHJlc29sdmU6IChkaXJlY3RpdmUpID0+IGRpcmVjdGl2ZS5kZXNjcmlwdGlvblxuICAgICAgICB9LFxuICAgICAgICBpc1JlcGVhdGFibGU6IHtcbiAgICAgICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoR3JhcGhRTEJvb2xlYW4pLFxuICAgICAgICAgIHJlc29sdmU6IChkaXJlY3RpdmUpID0+IGRpcmVjdGl2ZS5pc1JlcGVhdGFibGVcbiAgICAgICAgfSxcbiAgICAgICAgbG9jYXRpb25zOiB7XG4gICAgICAgICAgdHlwZTogbmV3IEdyYXBoUUxOb25OdWxsKFxuICAgICAgICAgICAgbmV3IEdyYXBoUUxMaXN0KG5ldyBHcmFwaFFMTm9uTnVsbChfX0RpcmVjdGl2ZUxvY2F0aW9uKSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlc29sdmU6IChkaXJlY3RpdmUpID0+IGRpcmVjdGl2ZS5sb2NhdGlvbnNcbiAgICAgICAgfSxcbiAgICAgICAgYXJnczoge1xuICAgICAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChcbiAgICAgICAgICAgIG5ldyBHcmFwaFFMTGlzdChuZXcgR3JhcGhRTE5vbk51bGwoX19JbnB1dFZhbHVlKSlcbiAgICAgICAgICApLFxuICAgICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICAgIGluY2x1ZGVEZXByZWNhdGVkOiB7XG4gICAgICAgICAgICAgIHR5cGU6IEdyYXBoUUxCb29sZWFuLFxuICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNvbHZlKGZpZWxkLCB7IGluY2x1ZGVEZXByZWNhdGVkIH0pIHtcbiAgICAgICAgICAgIHJldHVybiBpbmNsdWRlRGVwcmVjYXRlZCA/IGZpZWxkLmFyZ3MgOiBmaWVsZC5hcmdzLmZpbHRlcigoYXJnKSA9PiBhcmcuZGVwcmVjYXRpb25SZWFzb24gPT0gbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuICAgIF9fRGlyZWN0aXZlTG9jYXRpb24gPSBuZXcgR3JhcGhRTEVudW1UeXBlKHtcbiAgICAgIG5hbWU6IFwiX19EaXJlY3RpdmVMb2NhdGlvblwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQSBEaXJlY3RpdmUgY2FuIGJlIGFkamFjZW50IHRvIG1hbnkgcGFydHMgb2YgdGhlIEdyYXBoUUwgbGFuZ3VhZ2UsIGEgX19EaXJlY3RpdmVMb2NhdGlvbiBkZXNjcmliZXMgb25lIHN1Y2ggcG9zc2libGUgYWRqYWNlbmNpZXMuXCIsXG4gICAgICB2YWx1ZXM6IHtcbiAgICAgICAgUVVFUlk6IHtcbiAgICAgICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uUVVFUlksXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYSBxdWVyeSBvcGVyYXRpb24uXCJcbiAgICAgICAgfSxcbiAgICAgICAgTVVUQVRJT046IHtcbiAgICAgICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uTVVUQVRJT04sXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYSBtdXRhdGlvbiBvcGVyYXRpb24uXCJcbiAgICAgICAgfSxcbiAgICAgICAgU1VCU0NSSVBUSU9OOiB7XG4gICAgICAgICAgdmFsdWU6IERpcmVjdGl2ZUxvY2F0aW9uLlNVQlNDUklQVElPTixcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJMb2NhdGlvbiBhZGphY2VudCB0byBhIHN1YnNjcmlwdGlvbiBvcGVyYXRpb24uXCJcbiAgICAgICAgfSxcbiAgICAgICAgRklFTEQ6IHtcbiAgICAgICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uRklFTEQsXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYSBmaWVsZC5cIlxuICAgICAgICB9LFxuICAgICAgICBGUkFHTUVOVF9ERUZJTklUSU9OOiB7XG4gICAgICAgICAgdmFsdWU6IERpcmVjdGl2ZUxvY2F0aW9uLkZSQUdNRU5UX0RFRklOSVRJT04sXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYSBmcmFnbWVudCBkZWZpbml0aW9uLlwiXG4gICAgICAgIH0sXG4gICAgICAgIEZSQUdNRU5UX1NQUkVBRDoge1xuICAgICAgICAgIHZhbHVlOiBEaXJlY3RpdmVMb2NhdGlvbi5GUkFHTUVOVF9TUFJFQUQsXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYSBmcmFnbWVudCBzcHJlYWQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgSU5MSU5FX0ZSQUdNRU5UOiB7XG4gICAgICAgICAgdmFsdWU6IERpcmVjdGl2ZUxvY2F0aW9uLklOTElORV9GUkFHTUVOVCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJMb2NhdGlvbiBhZGphY2VudCB0byBhbiBpbmxpbmUgZnJhZ21lbnQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgVkFSSUFCTEVfREVGSU5JVElPTjoge1xuICAgICAgICAgIHZhbHVlOiBEaXJlY3RpdmVMb2NhdGlvbi5WQVJJQUJMRV9ERUZJTklUSU9OLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkxvY2F0aW9uIGFkamFjZW50IHRvIGEgdmFyaWFibGUgZGVmaW5pdGlvbi5cIlxuICAgICAgICB9LFxuICAgICAgICBTQ0hFTUE6IHtcbiAgICAgICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uU0NIRU1BLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkxvY2F0aW9uIGFkamFjZW50IHRvIGEgc2NoZW1hIGRlZmluaXRpb24uXCJcbiAgICAgICAgfSxcbiAgICAgICAgU0NBTEFSOiB7XG4gICAgICAgICAgdmFsdWU6IERpcmVjdGl2ZUxvY2F0aW9uLlNDQUxBUixcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJMb2NhdGlvbiBhZGphY2VudCB0byBhIHNjYWxhciBkZWZpbml0aW9uLlwiXG4gICAgICAgIH0sXG4gICAgICAgIE9CSkVDVDoge1xuICAgICAgICAgIHZhbHVlOiBEaXJlY3RpdmVMb2NhdGlvbi5PQkpFQ1QsXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYW4gb2JqZWN0IHR5cGUgZGVmaW5pdGlvbi5cIlxuICAgICAgICB9LFxuICAgICAgICBGSUVMRF9ERUZJTklUSU9OOiB7XG4gICAgICAgICAgdmFsdWU6IERpcmVjdGl2ZUxvY2F0aW9uLkZJRUxEX0RFRklOSVRJT04sXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYSBmaWVsZCBkZWZpbml0aW9uLlwiXG4gICAgICAgIH0sXG4gICAgICAgIEFSR1VNRU5UX0RFRklOSVRJT046IHtcbiAgICAgICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uQVJHVU1FTlRfREVGSU5JVElPTixcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJMb2NhdGlvbiBhZGphY2VudCB0byBhbiBhcmd1bWVudCBkZWZpbml0aW9uLlwiXG4gICAgICAgIH0sXG4gICAgICAgIElOVEVSRkFDRToge1xuICAgICAgICAgIHZhbHVlOiBEaXJlY3RpdmVMb2NhdGlvbi5JTlRFUkZBQ0UsXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYW4gaW50ZXJmYWNlIGRlZmluaXRpb24uXCJcbiAgICAgICAgfSxcbiAgICAgICAgVU5JT046IHtcbiAgICAgICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uVU5JT04sXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYSB1bmlvbiBkZWZpbml0aW9uLlwiXG4gICAgICAgIH0sXG4gICAgICAgIEVOVU06IHtcbiAgICAgICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uRU5VTSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJMb2NhdGlvbiBhZGphY2VudCB0byBhbiBlbnVtIGRlZmluaXRpb24uXCJcbiAgICAgICAgfSxcbiAgICAgICAgRU5VTV9WQUxVRToge1xuICAgICAgICAgIHZhbHVlOiBEaXJlY3RpdmVMb2NhdGlvbi5FTlVNX1ZBTFVFLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkxvY2F0aW9uIGFkamFjZW50IHRvIGFuIGVudW0gdmFsdWUgZGVmaW5pdGlvbi5cIlxuICAgICAgICB9LFxuICAgICAgICBJTlBVVF9PQkpFQ1Q6IHtcbiAgICAgICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uSU5QVVRfT0JKRUNULFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkxvY2F0aW9uIGFkamFjZW50IHRvIGFuIGlucHV0IG9iamVjdCB0eXBlIGRlZmluaXRpb24uXCJcbiAgICAgICAgfSxcbiAgICAgICAgSU5QVVRfRklFTERfREVGSU5JVElPTjoge1xuICAgICAgICAgIHZhbHVlOiBEaXJlY3RpdmVMb2NhdGlvbi5JTlBVVF9GSUVMRF9ERUZJTklUSU9OLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkxvY2F0aW9uIGFkamFjZW50IHRvIGFuIGlucHV0IG9iamVjdCBmaWVsZCBkZWZpbml0aW9uLlwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX1R5cGUgPSBuZXcgR3JhcGhRTE9iamVjdFR5cGUoe1xuICAgICAgbmFtZTogXCJfX1R5cGVcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBmdW5kYW1lbnRhbCB1bml0IG9mIGFueSBHcmFwaFFMIFNjaGVtYSBpcyB0aGUgdHlwZS4gVGhlcmUgYXJlIG1hbnkga2luZHMgb2YgdHlwZXMgaW4gR3JhcGhRTCBhcyByZXByZXNlbnRlZCBieSB0aGUgYF9fVHlwZUtpbmRgIGVudW0uXFxuXFxuRGVwZW5kaW5nIG9uIHRoZSBraW5kIG9mIGEgdHlwZSwgY2VydGFpbiBmaWVsZHMgZGVzY3JpYmUgaW5mb3JtYXRpb24gYWJvdXQgdGhhdCB0eXBlLiBTY2FsYXIgdHlwZXMgcHJvdmlkZSBubyBpbmZvcm1hdGlvbiBiZXlvbmQgYSBuYW1lLCBkZXNjcmlwdGlvbiBhbmQgb3B0aW9uYWwgYHNwZWNpZmllZEJ5VVJMYCwgd2hpbGUgRW51bSB0eXBlcyBwcm92aWRlIHRoZWlyIHZhbHVlcy4gT2JqZWN0IGFuZCBJbnRlcmZhY2UgdHlwZXMgcHJvdmlkZSB0aGUgZmllbGRzIHRoZXkgZGVzY3JpYmUuIEFic3RyYWN0IHR5cGVzLCBVbmlvbiBhbmQgSW50ZXJmYWNlLCBwcm92aWRlIHRoZSBPYmplY3QgdHlwZXMgcG9zc2libGUgYXQgcnVudGltZS4gTGlzdCBhbmQgTm9uTnVsbCB0eXBlcyBjb21wb3NlIG90aGVyIHR5cGVzLlwiLFxuICAgICAgZmllbGRzOiAoKSA9PiAoe1xuICAgICAgICBraW5kOiB7XG4gICAgICAgICAgdHlwZTogbmV3IEdyYXBoUUxOb25OdWxsKF9fVHlwZUtpbmQpLFxuICAgICAgICAgIHJlc29sdmUodHlwZSkge1xuICAgICAgICAgICAgaWYgKGlzU2NhbGFyVHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gVHlwZUtpbmQuU0NBTEFSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0VHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gVHlwZUtpbmQuT0JKRUNUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSW50ZXJmYWNlVHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gVHlwZUtpbmQuSU5URVJGQUNFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVW5pb25UeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBUeXBlS2luZC5VTklPTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0VudW1UeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBUeXBlS2luZC5FTlVNO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSW5wdXRPYmplY3RUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBUeXBlS2luZC5JTlBVVF9PQkpFQ1Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMaXN0VHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gVHlwZUtpbmQuTElTVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05vbk51bGxUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBUeXBlS2luZC5OT05fTlVMTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgYFVuZXhwZWN0ZWQgdHlwZTogXCIke2luc3BlY3QodHlwZSl9XCIuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgdHlwZTogR3JhcGhRTFN0cmluZyxcbiAgICAgICAgICByZXNvbHZlOiAodHlwZSkgPT4gXCJuYW1lXCIgaW4gdHlwZSA/IHR5cGUubmFtZSA6IHZvaWQgMFxuICAgICAgICB9LFxuICAgICAgICBkZXNjcmlwdGlvbjoge1xuICAgICAgICAgIHR5cGU6IEdyYXBoUUxTdHJpbmcsXG4gICAgICAgICAgcmVzb2x2ZTogKHR5cGUpID0+IChcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBcImRlc2NyaXB0aW9uXCIgaW4gdHlwZSA/IHR5cGUuZGVzY3JpcHRpb24gOiB2b2lkIDBcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIHNwZWNpZmllZEJ5VVJMOiB7XG4gICAgICAgICAgdHlwZTogR3JhcGhRTFN0cmluZyxcbiAgICAgICAgICByZXNvbHZlOiAob2JqKSA9PiBcInNwZWNpZmllZEJ5VVJMXCIgaW4gb2JqID8gb2JqLnNwZWNpZmllZEJ5VVJMIDogdm9pZCAwXG4gICAgICAgIH0sXG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTGlzdChuZXcgR3JhcGhRTE5vbk51bGwoX19GaWVsZCkpLFxuICAgICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICAgIGluY2x1ZGVEZXByZWNhdGVkOiB7XG4gICAgICAgICAgICAgIHR5cGU6IEdyYXBoUUxCb29sZWFuLFxuICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNvbHZlKHR5cGUsIHsgaW5jbHVkZURlcHJlY2F0ZWQgfSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0VHlwZSh0eXBlKSB8fCBpc0ludGVyZmFjZVR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgZmllbGRzID0gT2JqZWN0LnZhbHVlcyh0eXBlLmdldEZpZWxkcygpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGluY2x1ZGVEZXByZWNhdGVkID8gZmllbGRzIDogZmllbGRzLmZpbHRlcigoZmllbGQpID0+IGZpZWxkLmRlcHJlY2F0aW9uUmVhc29uID09IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW50ZXJmYWNlczoge1xuICAgICAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTGlzdChuZXcgR3JhcGhRTE5vbk51bGwoX19UeXBlKSksXG4gICAgICAgICAgcmVzb2x2ZSh0eXBlKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3RUeXBlKHR5cGUpIHx8IGlzSW50ZXJmYWNlVHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZS5nZXRJbnRlcmZhY2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwb3NzaWJsZVR5cGVzOiB7XG4gICAgICAgICAgdHlwZTogbmV3IEdyYXBoUUxMaXN0KG5ldyBHcmFwaFFMTm9uTnVsbChfX1R5cGUpKSxcbiAgICAgICAgICByZXNvbHZlKHR5cGUsIF9hcmdzLCBfY29udGV4dCwgeyBzY2hlbWEgfSkge1xuICAgICAgICAgICAgaWYgKGlzQWJzdHJhY3RUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzY2hlbWEuZ2V0UG9zc2libGVUeXBlcyh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1WYWx1ZXM6IHtcbiAgICAgICAgICB0eXBlOiBuZXcgR3JhcGhRTExpc3QobmV3IEdyYXBoUUxOb25OdWxsKF9fRW51bVZhbHVlKSksXG4gICAgICAgICAgYXJnczoge1xuICAgICAgICAgICAgaW5jbHVkZURlcHJlY2F0ZWQ6IHtcbiAgICAgICAgICAgICAgdHlwZTogR3JhcGhRTEJvb2xlYW4sXG4gICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc29sdmUodHlwZSwgeyBpbmNsdWRlRGVwcmVjYXRlZCB9KSB7XG4gICAgICAgICAgICBpZiAoaXNFbnVtVHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB0eXBlLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgICByZXR1cm4gaW5jbHVkZURlcHJlY2F0ZWQgPyB2YWx1ZXMgOiB2YWx1ZXMuZmlsdGVyKChmaWVsZCkgPT4gZmllbGQuZGVwcmVjYXRpb25SZWFzb24gPT0gbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnB1dEZpZWxkczoge1xuICAgICAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTGlzdChuZXcgR3JhcGhRTE5vbk51bGwoX19JbnB1dFZhbHVlKSksXG4gICAgICAgICAgYXJnczoge1xuICAgICAgICAgICAgaW5jbHVkZURlcHJlY2F0ZWQ6IHtcbiAgICAgICAgICAgICAgdHlwZTogR3JhcGhRTEJvb2xlYW4sXG4gICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc29sdmUodHlwZSwgeyBpbmNsdWRlRGVwcmVjYXRlZCB9KSB7XG4gICAgICAgICAgICBpZiAoaXNJbnB1dE9iamVjdFR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyh0eXBlLmdldEZpZWxkcygpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGluY2x1ZGVEZXByZWNhdGVkID8gdmFsdWVzIDogdmFsdWVzLmZpbHRlcigoZmllbGQpID0+IGZpZWxkLmRlcHJlY2F0aW9uUmVhc29uID09IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb2ZUeXBlOiB7XG4gICAgICAgICAgdHlwZTogX19UeXBlLFxuICAgICAgICAgIHJlc29sdmU6ICh0eXBlKSA9PiBcIm9mVHlwZVwiIGluIHR5cGUgPyB0eXBlLm9mVHlwZSA6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuICAgIF9fRmllbGQgPSBuZXcgR3JhcGhRTE9iamVjdFR5cGUoe1xuICAgICAgbmFtZTogXCJfX0ZpZWxkXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJPYmplY3QgYW5kIEludGVyZmFjZSB0eXBlcyBhcmUgZGVzY3JpYmVkIGJ5IGEgbGlzdCBvZiBGaWVsZHMsIGVhY2ggb2Ygd2hpY2ggaGFzIGEgbmFtZSwgcG90ZW50aWFsbHkgYSBsaXN0IG9mIGFyZ3VtZW50cywgYW5kIGEgcmV0dXJuIHR5cGUuXCIsXG4gICAgICBmaWVsZHM6ICgpID0+ICh7XG4gICAgICAgIG5hbWU6IHtcbiAgICAgICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoR3JhcGhRTFN0cmluZyksXG4gICAgICAgICAgcmVzb2x2ZTogKGZpZWxkKSA9PiBmaWVsZC5uYW1lXG4gICAgICAgIH0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiB7XG4gICAgICAgICAgdHlwZTogR3JhcGhRTFN0cmluZyxcbiAgICAgICAgICByZXNvbHZlOiAoZmllbGQpID0+IGZpZWxkLmRlc2NyaXB0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoXG4gICAgICAgICAgICBuZXcgR3JhcGhRTExpc3QobmV3IEdyYXBoUUxOb25OdWxsKF9fSW5wdXRWYWx1ZSkpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBhcmdzOiB7XG4gICAgICAgICAgICBpbmNsdWRlRGVwcmVjYXRlZDoge1xuICAgICAgICAgICAgICB0eXBlOiBHcmFwaFFMQm9vbGVhbixcbiAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzb2x2ZShmaWVsZCwgeyBpbmNsdWRlRGVwcmVjYXRlZCB9KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5jbHVkZURlcHJlY2F0ZWQgPyBmaWVsZC5hcmdzIDogZmllbGQuYXJncy5maWx0ZXIoKGFyZykgPT4gYXJnLmRlcHJlY2F0aW9uUmVhc29uID09IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChfX1R5cGUpLFxuICAgICAgICAgIHJlc29sdmU6IChmaWVsZCkgPT4gZmllbGQudHlwZVxuICAgICAgICB9LFxuICAgICAgICBpc0RlcHJlY2F0ZWQ6IHtcbiAgICAgICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoR3JhcGhRTEJvb2xlYW4pLFxuICAgICAgICAgIHJlc29sdmU6IChmaWVsZCkgPT4gZmllbGQuZGVwcmVjYXRpb25SZWFzb24gIT0gbnVsbFxuICAgICAgICB9LFxuICAgICAgICBkZXByZWNhdGlvblJlYXNvbjoge1xuICAgICAgICAgIHR5cGU6IEdyYXBoUUxTdHJpbmcsXG4gICAgICAgICAgcmVzb2x2ZTogKGZpZWxkKSA9PiBmaWVsZC5kZXByZWNhdGlvblJlYXNvblxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuICAgIF9fSW5wdXRWYWx1ZSA9IG5ldyBHcmFwaFFMT2JqZWN0VHlwZSh7XG4gICAgICBuYW1lOiBcIl9fSW5wdXRWYWx1ZVwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQXJndW1lbnRzIHByb3ZpZGVkIHRvIEZpZWxkcyBvciBEaXJlY3RpdmVzIGFuZCB0aGUgaW5wdXQgZmllbGRzIG9mIGFuIElucHV0T2JqZWN0IGFyZSByZXByZXNlbnRlZCBhcyBJbnB1dCBWYWx1ZXMgd2hpY2ggZGVzY3JpYmUgdGhlaXIgdHlwZSBhbmQgb3B0aW9uYWxseSBhIGRlZmF1bHQgdmFsdWUuXCIsXG4gICAgICBmaWVsZHM6ICgpID0+ICh7XG4gICAgICAgIG5hbWU6IHtcbiAgICAgICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoR3JhcGhRTFN0cmluZyksXG4gICAgICAgICAgcmVzb2x2ZTogKGlucHV0VmFsdWUpID0+IGlucHV0VmFsdWUubmFtZVxuICAgICAgICB9LFxuICAgICAgICBkZXNjcmlwdGlvbjoge1xuICAgICAgICAgIHR5cGU6IEdyYXBoUUxTdHJpbmcsXG4gICAgICAgICAgcmVzb2x2ZTogKGlucHV0VmFsdWUpID0+IGlucHV0VmFsdWUuZGVzY3JpcHRpb25cbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChfX1R5cGUpLFxuICAgICAgICAgIHJlc29sdmU6IChpbnB1dFZhbHVlKSA9PiBpbnB1dFZhbHVlLnR5cGVcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB7XG4gICAgICAgICAgdHlwZTogR3JhcGhRTFN0cmluZyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJBIEdyYXBoUUwtZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoaXMgaW5wdXQgdmFsdWUuXCIsXG4gICAgICAgICAgcmVzb2x2ZShpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGUsIGRlZmF1bHRWYWx1ZSB9ID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlQVNUID0gYXN0RnJvbVZhbHVlKGRlZmF1bHRWYWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVBU1QgPyBwcmludCh2YWx1ZUFTVCkgOiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXNEZXByZWNhdGVkOiB7XG4gICAgICAgICAgdHlwZTogbmV3IEdyYXBoUUxOb25OdWxsKEdyYXBoUUxCb29sZWFuKSxcbiAgICAgICAgICByZXNvbHZlOiAoZmllbGQpID0+IGZpZWxkLmRlcHJlY2F0aW9uUmVhc29uICE9IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgZGVwcmVjYXRpb25SZWFzb246IHtcbiAgICAgICAgICB0eXBlOiBHcmFwaFFMU3RyaW5nLFxuICAgICAgICAgIHJlc29sdmU6IChvYmopID0+IG9iai5kZXByZWNhdGlvblJlYXNvblxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuICAgIF9fRW51bVZhbHVlID0gbmV3IEdyYXBoUUxPYmplY3RUeXBlKHtcbiAgICAgIG5hbWU6IFwiX19FbnVtVmFsdWVcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk9uZSBwb3NzaWJsZSB2YWx1ZSBmb3IgYSBnaXZlbiBFbnVtLiBFbnVtIHZhbHVlcyBhcmUgdW5pcXVlIHZhbHVlcywgbm90IGEgcGxhY2Vob2xkZXIgZm9yIGEgc3RyaW5nIG9yIG51bWVyaWMgdmFsdWUuIEhvd2V2ZXIgYW4gRW51bSB2YWx1ZSBpcyByZXR1cm5lZCBpbiBhIEpTT04gcmVzcG9uc2UgYXMgYSBzdHJpbmcuXCIsXG4gICAgICBmaWVsZHM6ICgpID0+ICh7XG4gICAgICAgIG5hbWU6IHtcbiAgICAgICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoR3JhcGhRTFN0cmluZyksXG4gICAgICAgICAgcmVzb2x2ZTogKGVudW1WYWx1ZSkgPT4gZW51bVZhbHVlLm5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgZGVzY3JpcHRpb246IHtcbiAgICAgICAgICB0eXBlOiBHcmFwaFFMU3RyaW5nLFxuICAgICAgICAgIHJlc29sdmU6IChlbnVtVmFsdWUpID0+IGVudW1WYWx1ZS5kZXNjcmlwdGlvblxuICAgICAgICB9LFxuICAgICAgICBpc0RlcHJlY2F0ZWQ6IHtcbiAgICAgICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoR3JhcGhRTEJvb2xlYW4pLFxuICAgICAgICAgIHJlc29sdmU6IChlbnVtVmFsdWUpID0+IGVudW1WYWx1ZS5kZXByZWNhdGlvblJlYXNvbiAhPSBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGRlcHJlY2F0aW9uUmVhc29uOiB7XG4gICAgICAgICAgdHlwZTogR3JhcGhRTFN0cmluZyxcbiAgICAgICAgICByZXNvbHZlOiAoZW51bVZhbHVlKSA9PiBlbnVtVmFsdWUuZGVwcmVjYXRpb25SZWFzb25cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KTtcbiAgICAoZnVuY3Rpb24oVHlwZUtpbmQyKSB7XG4gICAgICBUeXBlS2luZDJbXCJTQ0FMQVJcIl0gPSBcIlNDQUxBUlwiO1xuICAgICAgVHlwZUtpbmQyW1wiT0JKRUNUXCJdID0gXCJPQkpFQ1RcIjtcbiAgICAgIFR5cGVLaW5kMltcIklOVEVSRkFDRVwiXSA9IFwiSU5URVJGQUNFXCI7XG4gICAgICBUeXBlS2luZDJbXCJVTklPTlwiXSA9IFwiVU5JT05cIjtcbiAgICAgIFR5cGVLaW5kMltcIkVOVU1cIl0gPSBcIkVOVU1cIjtcbiAgICAgIFR5cGVLaW5kMltcIklOUFVUX09CSkVDVFwiXSA9IFwiSU5QVVRfT0JKRUNUXCI7XG4gICAgICBUeXBlS2luZDJbXCJMSVNUXCJdID0gXCJMSVNUXCI7XG4gICAgICBUeXBlS2luZDJbXCJOT05fTlVMTFwiXSA9IFwiTk9OX05VTExcIjtcbiAgICB9KShUeXBlS2luZCB8fCAoVHlwZUtpbmQgPSB7fSkpO1xuICAgIF9fVHlwZUtpbmQgPSBuZXcgR3JhcGhRTEVudW1UeXBlKHtcbiAgICAgIG5hbWU6IFwiX19UeXBlS2luZFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQW4gZW51bSBkZXNjcmliaW5nIHdoYXQga2luZCBvZiB0eXBlIGEgZ2l2ZW4gYF9fVHlwZWAgaXMuXCIsXG4gICAgICB2YWx1ZXM6IHtcbiAgICAgICAgU0NBTEFSOiB7XG4gICAgICAgICAgdmFsdWU6IFR5cGVLaW5kLlNDQUxBUixcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJJbmRpY2F0ZXMgdGhpcyB0eXBlIGlzIGEgc2NhbGFyLlwiXG4gICAgICAgIH0sXG4gICAgICAgIE9CSkVDVDoge1xuICAgICAgICAgIHZhbHVlOiBUeXBlS2luZC5PQkpFQ1QsXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiSW5kaWNhdGVzIHRoaXMgdHlwZSBpcyBhbiBvYmplY3QuIGBmaWVsZHNgIGFuZCBgaW50ZXJmYWNlc2AgYXJlIHZhbGlkIGZpZWxkcy5cIlxuICAgICAgICB9LFxuICAgICAgICBJTlRFUkZBQ0U6IHtcbiAgICAgICAgICB2YWx1ZTogVHlwZUtpbmQuSU5URVJGQUNFLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkluZGljYXRlcyB0aGlzIHR5cGUgaXMgYW4gaW50ZXJmYWNlLiBgZmllbGRzYCwgYGludGVyZmFjZXNgLCBhbmQgYHBvc3NpYmxlVHlwZXNgIGFyZSB2YWxpZCBmaWVsZHMuXCJcbiAgICAgICAgfSxcbiAgICAgICAgVU5JT046IHtcbiAgICAgICAgICB2YWx1ZTogVHlwZUtpbmQuVU5JT04sXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiSW5kaWNhdGVzIHRoaXMgdHlwZSBpcyBhIHVuaW9uLiBgcG9zc2libGVUeXBlc2AgaXMgYSB2YWxpZCBmaWVsZC5cIlxuICAgICAgICB9LFxuICAgICAgICBFTlVNOiB7XG4gICAgICAgICAgdmFsdWU6IFR5cGVLaW5kLkVOVU0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiSW5kaWNhdGVzIHRoaXMgdHlwZSBpcyBhbiBlbnVtLiBgZW51bVZhbHVlc2AgaXMgYSB2YWxpZCBmaWVsZC5cIlxuICAgICAgICB9LFxuICAgICAgICBJTlBVVF9PQkpFQ1Q6IHtcbiAgICAgICAgICB2YWx1ZTogVHlwZUtpbmQuSU5QVVRfT0JKRUNULFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkluZGljYXRlcyB0aGlzIHR5cGUgaXMgYW4gaW5wdXQgb2JqZWN0LiBgaW5wdXRGaWVsZHNgIGlzIGEgdmFsaWQgZmllbGQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgTElTVDoge1xuICAgICAgICAgIHZhbHVlOiBUeXBlS2luZC5MSVNULFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkluZGljYXRlcyB0aGlzIHR5cGUgaXMgYSBsaXN0LiBgb2ZUeXBlYCBpcyBhIHZhbGlkIGZpZWxkLlwiXG4gICAgICAgIH0sXG4gICAgICAgIE5PTl9OVUxMOiB7XG4gICAgICAgICAgdmFsdWU6IFR5cGVLaW5kLk5PTl9OVUxMLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkluZGljYXRlcyB0aGlzIHR5cGUgaXMgYSBub24tbnVsbC4gYG9mVHlwZWAgaXMgYSB2YWxpZCBmaWVsZC5cIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgU2NoZW1hTWV0YUZpZWxkRGVmID0ge1xuICAgICAgbmFtZTogXCJfX3NjaGVtYVwiLFxuICAgICAgdHlwZTogbmV3IEdyYXBoUUxOb25OdWxsKF9fU2NoZW1hKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkFjY2VzcyB0aGUgY3VycmVudCB0eXBlIHNjaGVtYSBvZiB0aGlzIHNlcnZlci5cIixcbiAgICAgIGFyZ3M6IFtdLFxuICAgICAgcmVzb2x2ZTogKF9zb3VyY2UsIF9hcmdzLCBfY29udGV4dCwgeyBzY2hlbWEgfSkgPT4gc2NoZW1hLFxuICAgICAgZGVwcmVjYXRpb25SZWFzb246IHZvaWQgMCxcbiAgICAgIGV4dGVuc2lvbnM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgYXN0Tm9kZTogdm9pZCAwXG4gICAgfTtcbiAgICBUeXBlTWV0YUZpZWxkRGVmID0ge1xuICAgICAgbmFtZTogXCJfX3R5cGVcIixcbiAgICAgIHR5cGU6IF9fVHlwZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlJlcXVlc3QgdGhlIHR5cGUgaW5mb3JtYXRpb24gb2YgYSBzaW5nbGUgdHlwZS5cIixcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwibmFtZVwiLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB2b2lkIDAsXG4gICAgICAgICAgdHlwZTogbmV3IEdyYXBoUUxOb25OdWxsKEdyYXBoUUxTdHJpbmcpLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdm9pZCAwLFxuICAgICAgICAgIGRlcHJlY2F0aW9uUmVhc29uOiB2b2lkIDAsXG4gICAgICAgICAgZXh0ZW5zaW9uczogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgYXN0Tm9kZTogdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICByZXNvbHZlOiAoX3NvdXJjZSwgeyBuYW1lIH0sIF9jb250ZXh0LCB7IHNjaGVtYSB9KSA9PiBzY2hlbWEuZ2V0VHlwZShuYW1lKSxcbiAgICAgIGRlcHJlY2F0aW9uUmVhc29uOiB2b2lkIDAsXG4gICAgICBleHRlbnNpb25zOiAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGFzdE5vZGU6IHZvaWQgMFxuICAgIH07XG4gICAgVHlwZU5hbWVNZXRhRmllbGREZWYgPSB7XG4gICAgICBuYW1lOiBcIl9fdHlwZW5hbWVcIixcbiAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChHcmFwaFFMU3RyaW5nKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IE9iamVjdCB0eXBlIGF0IHJ1bnRpbWUuXCIsXG4gICAgICBhcmdzOiBbXSxcbiAgICAgIHJlc29sdmU6IChfc291cmNlLCBfYXJncywgX2NvbnRleHQsIHsgcGFyZW50VHlwZSB9KSA9PiBwYXJlbnRUeXBlLm5hbWUsXG4gICAgICBkZXByZWNhdGlvblJlYXNvbjogdm9pZCAwLFxuICAgICAgZXh0ZW5zaW9uczogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBhc3ROb2RlOiB2b2lkIDBcbiAgICB9O1xuICAgIGludHJvc3BlY3Rpb25UeXBlcyA9IE9iamVjdC5mcmVlemUoW1xuICAgICAgX19TY2hlbWEsXG4gICAgICBfX0RpcmVjdGl2ZSxcbiAgICAgIF9fRGlyZWN0aXZlTG9jYXRpb24sXG4gICAgICBfX1R5cGUsXG4gICAgICBfX0ZpZWxkLFxuICAgICAgX19JbnB1dFZhbHVlLFxuICAgICAgX19FbnVtVmFsdWUsXG4gICAgICBfX1R5cGVLaW5kXG4gICAgXSk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC90eXBlL3NjaGVtYS5tanNcbmZ1bmN0aW9uIGlzU2NoZW1hKHNjaGVtYSkge1xuICByZXR1cm4gaW5zdGFuY2VPZihzY2hlbWEsIEdyYXBoUUxTY2hlbWEpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U2NoZW1hKHNjaGVtYSkge1xuICBpZiAoIWlzU2NoZW1hKHNjaGVtYSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7aW5zcGVjdChzY2hlbWEpfSB0byBiZSBhIEdyYXBoUUwgc2NoZW1hLmApO1xuICB9XG4gIHJldHVybiBzY2hlbWE7XG59XG5mdW5jdGlvbiBjb2xsZWN0UmVmZXJlbmNlZFR5cGVzKHR5cGUsIHR5cGVTZXQpIHtcbiAgY29uc3QgbmFtZWRUeXBlID0gZ2V0TmFtZWRUeXBlKHR5cGUpO1xuICBpZiAoIXR5cGVTZXQuaGFzKG5hbWVkVHlwZSkpIHtcbiAgICB0eXBlU2V0LmFkZChuYW1lZFR5cGUpO1xuICAgIGlmIChpc1VuaW9uVHlwZShuYW1lZFR5cGUpKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlclR5cGUgb2YgbmFtZWRUeXBlLmdldFR5cGVzKCkpIHtcbiAgICAgICAgY29sbGVjdFJlZmVyZW5jZWRUeXBlcyhtZW1iZXJUeXBlLCB0eXBlU2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0VHlwZShuYW1lZFR5cGUpIHx8IGlzSW50ZXJmYWNlVHlwZShuYW1lZFR5cGUpKSB7XG4gICAgICBmb3IgKGNvbnN0IGludGVyZmFjZVR5cGUgb2YgbmFtZWRUeXBlLmdldEludGVyZmFjZXMoKSkge1xuICAgICAgICBjb2xsZWN0UmVmZXJlbmNlZFR5cGVzKGludGVyZmFjZVR5cGUsIHR5cGVTZXQpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBPYmplY3QudmFsdWVzKG5hbWVkVHlwZS5nZXRGaWVsZHMoKSkpIHtcbiAgICAgICAgY29sbGVjdFJlZmVyZW5jZWRUeXBlcyhmaWVsZC50eXBlLCB0eXBlU2V0KTtcbiAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgZmllbGQuYXJncykge1xuICAgICAgICAgIGNvbGxlY3RSZWZlcmVuY2VkVHlwZXMoYXJnLnR5cGUsIHR5cGVTZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0lucHV0T2JqZWN0VHlwZShuYW1lZFR5cGUpKSB7XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIE9iamVjdC52YWx1ZXMobmFtZWRUeXBlLmdldEZpZWxkcygpKSkge1xuICAgICAgICBjb2xsZWN0UmVmZXJlbmNlZFR5cGVzKGZpZWxkLnR5cGUsIHR5cGVTZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHlwZVNldDtcbn1cbnZhciBHcmFwaFFMU2NoZW1hO1xudmFyIGluaXRfc2NoZW1hID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3R5cGUvc2NoZW1hLm1qc1wiKCkge1xuICAgIGluaXRfZGV2QXNzZXJ0KCk7XG4gICAgaW5pdF9pbnNwZWN0KCk7XG4gICAgaW5pdF9pbnN0YW5jZU9mKCk7XG4gICAgaW5pdF9pc09iamVjdExpa2UoKTtcbiAgICBpbml0X3RvT2JqTWFwKCk7XG4gICAgaW5pdF9hc3QoKTtcbiAgICBpbml0X2RlZmluaXRpb24oKTtcbiAgICBpbml0X2RpcmVjdGl2ZXMoKTtcbiAgICBpbml0X2ludHJvc3BlY3Rpb24oKTtcbiAgICBHcmFwaFFMU2NoZW1hID0gY2xhc3Mge1xuICAgICAgLy8gVXNlZCBhcyBhIGNhY2hlIGZvciB2YWxpZGF0ZVNjaGVtYSgpLlxuICAgICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHZhciBfY29uZmlnJGV4dGVuc2lvbkFTVE4sIF9jb25maWckZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5fX3ZhbGlkYXRpb25FcnJvcnMgPSBjb25maWcuYXNzdW1lVmFsaWQgPT09IHRydWUgPyBbXSA6IHZvaWQgMDtcbiAgICAgICAgaXNPYmplY3RMaWtlKGNvbmZpZykgfHwgZGV2QXNzZXJ0KGZhbHNlLCBcIk11c3QgcHJvdmlkZSBjb25maWd1cmF0aW9uIG9iamVjdC5cIik7XG4gICAgICAgICFjb25maWcudHlwZXMgfHwgQXJyYXkuaXNBcnJheShjb25maWcudHlwZXMpIHx8IGRldkFzc2VydChcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBgXCJ0eXBlc1wiIG11c3QgYmUgQXJyYXkgaWYgcHJvdmlkZWQgYnV0IGdvdDogJHtpbnNwZWN0KGNvbmZpZy50eXBlcyl9LmBcbiAgICAgICAgKTtcbiAgICAgICAgIWNvbmZpZy5kaXJlY3RpdmVzIHx8IEFycmF5LmlzQXJyYXkoY29uZmlnLmRpcmVjdGl2ZXMpIHx8IGRldkFzc2VydChcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBgXCJkaXJlY3RpdmVzXCIgbXVzdCBiZSBBcnJheSBpZiBwcm92aWRlZCBidXQgZ290OiAke2luc3BlY3QoY29uZmlnLmRpcmVjdGl2ZXMpfS5gXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBjb25maWcuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHRvT2JqTWFwKGNvbmZpZy5leHRlbnNpb25zKTtcbiAgICAgICAgdGhpcy5hc3ROb2RlID0gY29uZmlnLmFzdE5vZGU7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uQVNUTm9kZXMgPSAoX2NvbmZpZyRleHRlbnNpb25BU1ROID0gY29uZmlnLmV4dGVuc2lvbkFTVE5vZGVzKSAhPT0gbnVsbCAmJiBfY29uZmlnJGV4dGVuc2lvbkFTVE4gIT09IHZvaWQgMCA/IF9jb25maWckZXh0ZW5zaW9uQVNUTiA6IFtdO1xuICAgICAgICB0aGlzLl9xdWVyeVR5cGUgPSBjb25maWcucXVlcnk7XG4gICAgICAgIHRoaXMuX211dGF0aW9uVHlwZSA9IGNvbmZpZy5tdXRhdGlvbjtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uVHlwZSA9IGNvbmZpZy5zdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZXMgPSAoX2NvbmZpZyRkaXJlY3RpdmVzID0gY29uZmlnLmRpcmVjdGl2ZXMpICE9PSBudWxsICYmIF9jb25maWckZGlyZWN0aXZlcyAhPT0gdm9pZCAwID8gX2NvbmZpZyRkaXJlY3RpdmVzIDogc3BlY2lmaWVkRGlyZWN0aXZlcztcbiAgICAgICAgY29uc3QgYWxsUmVmZXJlbmNlZFR5cGVzID0gbmV3IFNldChjb25maWcudHlwZXMpO1xuICAgICAgICBpZiAoY29uZmlnLnR5cGVzICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgY29uZmlnLnR5cGVzKSB7XG4gICAgICAgICAgICBhbGxSZWZlcmVuY2VkVHlwZXMuZGVsZXRlKHR5cGUpO1xuICAgICAgICAgICAgY29sbGVjdFJlZmVyZW5jZWRUeXBlcyh0eXBlLCBhbGxSZWZlcmVuY2VkVHlwZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcXVlcnlUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICBjb2xsZWN0UmVmZXJlbmNlZFR5cGVzKHRoaXMuX3F1ZXJ5VHlwZSwgYWxsUmVmZXJlbmNlZFR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbXV0YXRpb25UeXBlICE9IG51bGwpIHtcbiAgICAgICAgICBjb2xsZWN0UmVmZXJlbmNlZFR5cGVzKHRoaXMuX211dGF0aW9uVHlwZSwgYWxsUmVmZXJlbmNlZFR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgY29sbGVjdFJlZmVyZW5jZWRUeXBlcyh0aGlzLl9zdWJzY3JpcHRpb25UeXBlLCBhbGxSZWZlcmVuY2VkVHlwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZGlyZWN0aXZlIG9mIHRoaXMuX2RpcmVjdGl2ZXMpIHtcbiAgICAgICAgICBpZiAoaXNEaXJlY3RpdmUoZGlyZWN0aXZlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgZGlyZWN0aXZlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgY29sbGVjdFJlZmVyZW5jZWRUeXBlcyhhcmcudHlwZSwgYWxsUmVmZXJlbmNlZFR5cGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29sbGVjdFJlZmVyZW5jZWRUeXBlcyhfX1NjaGVtYSwgYWxsUmVmZXJlbmNlZFR5cGVzKTtcbiAgICAgICAgdGhpcy5fdHlwZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9zdWJUeXBlTWFwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2ltcGxlbWVudGF0aW9uc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWVkVHlwZSBvZiBhbGxSZWZlcmVuY2VkVHlwZXMpIHtcbiAgICAgICAgICBpZiAobmFtZWRUeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0eXBlTmFtZSA9IG5hbWVkVHlwZS5uYW1lO1xuICAgICAgICAgIHR5cGVOYW1lIHx8IGRldkFzc2VydChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCJPbmUgb2YgdGhlIHByb3ZpZGVkIHR5cGVzIGZvciBidWlsZGluZyB0aGUgU2NoZW1hIGlzIG1pc3NpbmcgYSBuYW1lLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodGhpcy5fdHlwZU1hcFt0eXBlTmFtZV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgU2NoZW1hIG11c3QgY29udGFpbiB1bmlxdWVseSBuYW1lZCB0eXBlcyBidXQgY29udGFpbnMgbXVsdGlwbGUgdHlwZXMgbmFtZWQgXCIke3R5cGVOYW1lfVwiLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3R5cGVNYXBbdHlwZU5hbWVdID0gbmFtZWRUeXBlO1xuICAgICAgICAgIGlmIChpc0ludGVyZmFjZVR5cGUobmFtZWRUeXBlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZmFjZSBvZiBuYW1lZFR5cGUuZ2V0SW50ZXJmYWNlcygpKSB7XG4gICAgICAgICAgICAgIGlmIChpc0ludGVyZmFjZVR5cGUoaWZhY2UpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGltcGxlbWVudGF0aW9ucyA9IHRoaXMuX2ltcGxlbWVudGF0aW9uc01hcFtpZmFjZS5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoaW1wbGVtZW50YXRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9ucyA9IHRoaXMuX2ltcGxlbWVudGF0aW9uc01hcFtpZmFjZS5uYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0czogW10sXG4gICAgICAgICAgICAgICAgICAgIGludGVyZmFjZXM6IFtdXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbnMuaW50ZXJmYWNlcy5wdXNoKG5hbWVkVHlwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0VHlwZShuYW1lZFR5cGUpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlmYWNlIG9mIG5hbWVkVHlwZS5nZXRJbnRlcmZhY2VzKCkpIHtcbiAgICAgICAgICAgICAgaWYgKGlzSW50ZXJmYWNlVHlwZShpZmFjZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW1wbGVtZW50YXRpb25zID0gdGhpcy5faW1wbGVtZW50YXRpb25zTWFwW2lmYWNlLm5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChpbXBsZW1lbnRhdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb25zID0gdGhpcy5faW1wbGVtZW50YXRpb25zTWFwW2lmYWNlLm5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJmYWNlczogW11cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9ucy5vYmplY3RzLnB1c2gobmFtZWRUeXBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJHcmFwaFFMU2NoZW1hXCI7XG4gICAgICB9XG4gICAgICBnZXRRdWVyeVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWVyeVR5cGU7XG4gICAgICB9XG4gICAgICBnZXRNdXRhdGlvblR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tdXRhdGlvblR5cGU7XG4gICAgICB9XG4gICAgICBnZXRTdWJzY3JpcHRpb25UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaXB0aW9uVHlwZTtcbiAgICAgIH1cbiAgICAgIGdldFJvb3RUeXBlKG9wZXJhdGlvbikge1xuICAgICAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgICAgIGNhc2UgT3BlcmF0aW9uVHlwZU5vZGUuUVVFUlk6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRRdWVyeVR5cGUoKTtcbiAgICAgICAgICBjYXNlIE9wZXJhdGlvblR5cGVOb2RlLk1VVEFUSU9OOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TXV0YXRpb25UeXBlKCk7XG4gICAgICAgICAgY2FzZSBPcGVyYXRpb25UeXBlTm9kZS5TVUJTQ1JJUFRJT046XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTdWJzY3JpcHRpb25UeXBlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdldFR5cGVNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlTWFwO1xuICAgICAgfVxuICAgICAgZ2V0VHlwZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVNYXAoKVtuYW1lXTtcbiAgICAgIH1cbiAgICAgIGdldFBvc3NpYmxlVHlwZXMoYWJzdHJhY3RUeXBlKSB7XG4gICAgICAgIHJldHVybiBpc1VuaW9uVHlwZShhYnN0cmFjdFR5cGUpID8gYWJzdHJhY3RUeXBlLmdldFR5cGVzKCkgOiB0aGlzLmdldEltcGxlbWVudGF0aW9ucyhhYnN0cmFjdFR5cGUpLm9iamVjdHM7XG4gICAgICB9XG4gICAgICBnZXRJbXBsZW1lbnRhdGlvbnMoaW50ZXJmYWNlVHlwZSkge1xuICAgICAgICBjb25zdCBpbXBsZW1lbnRhdGlvbnMgPSB0aGlzLl9pbXBsZW1lbnRhdGlvbnNNYXBbaW50ZXJmYWNlVHlwZS5uYW1lXTtcbiAgICAgICAgcmV0dXJuIGltcGxlbWVudGF0aW9ucyAhPT0gbnVsbCAmJiBpbXBsZW1lbnRhdGlvbnMgIT09IHZvaWQgMCA/IGltcGxlbWVudGF0aW9ucyA6IHtcbiAgICAgICAgICBvYmplY3RzOiBbXSxcbiAgICAgICAgICBpbnRlcmZhY2VzOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaXNTdWJUeXBlKGFic3RyYWN0VHlwZSwgbWF5YmVTdWJUeXBlKSB7XG4gICAgICAgIGxldCBtYXAgPSB0aGlzLl9zdWJUeXBlTWFwW2Fic3RyYWN0VHlwZS5uYW1lXTtcbiAgICAgICAgaWYgKG1hcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgbWFwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgaWYgKGlzVW5pb25UeXBlKGFic3RyYWN0VHlwZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBhYnN0cmFjdFR5cGUuZ2V0VHlwZXMoKSkge1xuICAgICAgICAgICAgICBtYXBbdHlwZS5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGltcGxlbWVudGF0aW9ucyA9IHRoaXMuZ2V0SW1wbGVtZW50YXRpb25zKGFic3RyYWN0VHlwZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgaW1wbGVtZW50YXRpb25zLm9iamVjdHMpIHtcbiAgICAgICAgICAgICAgbWFwW3R5cGUubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGltcGxlbWVudGF0aW9ucy5pbnRlcmZhY2VzKSB7XG4gICAgICAgICAgICAgIG1hcFt0eXBlLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc3ViVHlwZU1hcFthYnN0cmFjdFR5cGUubmFtZV0gPSBtYXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcFttYXliZVN1YlR5cGUubmFtZV0gIT09IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGdldERpcmVjdGl2ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXJlY3RpdmVzO1xuICAgICAgfVxuICAgICAgZ2V0RGlyZWN0aXZlKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlyZWN0aXZlcygpLmZpbmQoKGRpcmVjdGl2ZSkgPT4gZGlyZWN0aXZlLm5hbWUgPT09IG5hbWUpO1xuICAgICAgfVxuICAgICAgdG9Db25maWcoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgcXVlcnk6IHRoaXMuZ2V0UXVlcnlUeXBlKCksXG4gICAgICAgICAgbXV0YXRpb246IHRoaXMuZ2V0TXV0YXRpb25UeXBlKCksXG4gICAgICAgICAgc3Vic2NyaXB0aW9uOiB0aGlzLmdldFN1YnNjcmlwdGlvblR5cGUoKSxcbiAgICAgICAgICB0eXBlczogT2JqZWN0LnZhbHVlcyh0aGlzLmdldFR5cGVNYXAoKSksXG4gICAgICAgICAgZGlyZWN0aXZlczogdGhpcy5nZXREaXJlY3RpdmVzKCksXG4gICAgICAgICAgZXh0ZW5zaW9uczogdGhpcy5leHRlbnNpb25zLFxuICAgICAgICAgIGFzdE5vZGU6IHRoaXMuYXN0Tm9kZSxcbiAgICAgICAgICBleHRlbnNpb25BU1ROb2RlczogdGhpcy5leHRlbnNpb25BU1ROb2RlcyxcbiAgICAgICAgICBhc3N1bWVWYWxpZDogdGhpcy5fX3ZhbGlkYXRpb25FcnJvcnMgIT09IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvdHlwZUNvbXBhcmF0b3JzLm1qc1xuZnVuY3Rpb24gaXNFcXVhbFR5cGUodHlwZUEsIHR5cGVCKSB7XG4gIGlmICh0eXBlQSA9PT0gdHlwZUIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNOb25OdWxsVHlwZSh0eXBlQSkgJiYgaXNOb25OdWxsVHlwZSh0eXBlQikpIHtcbiAgICByZXR1cm4gaXNFcXVhbFR5cGUodHlwZUEub2ZUeXBlLCB0eXBlQi5vZlR5cGUpO1xuICB9XG4gIGlmIChpc0xpc3RUeXBlKHR5cGVBKSAmJiBpc0xpc3RUeXBlKHR5cGVCKSkge1xuICAgIHJldHVybiBpc0VxdWFsVHlwZSh0eXBlQS5vZlR5cGUsIHR5cGVCLm9mVHlwZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNUeXBlU3ViVHlwZU9mKHNjaGVtYSwgbWF5YmVTdWJUeXBlLCBzdXBlclR5cGUpIHtcbiAgaWYgKG1heWJlU3ViVHlwZSA9PT0gc3VwZXJUeXBlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzTm9uTnVsbFR5cGUoc3VwZXJUeXBlKSkge1xuICAgIGlmIChpc05vbk51bGxUeXBlKG1heWJlU3ViVHlwZSkpIHtcbiAgICAgIHJldHVybiBpc1R5cGVTdWJUeXBlT2Yoc2NoZW1hLCBtYXliZVN1YlR5cGUub2ZUeXBlLCBzdXBlclR5cGUub2ZUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc05vbk51bGxUeXBlKG1heWJlU3ViVHlwZSkpIHtcbiAgICByZXR1cm4gaXNUeXBlU3ViVHlwZU9mKHNjaGVtYSwgbWF5YmVTdWJUeXBlLm9mVHlwZSwgc3VwZXJUeXBlKTtcbiAgfVxuICBpZiAoaXNMaXN0VHlwZShzdXBlclR5cGUpKSB7XG4gICAgaWYgKGlzTGlzdFR5cGUobWF5YmVTdWJUeXBlKSkge1xuICAgICAgcmV0dXJuIGlzVHlwZVN1YlR5cGVPZihzY2hlbWEsIG1heWJlU3ViVHlwZS5vZlR5cGUsIHN1cGVyVHlwZS5vZlR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzTGlzdFR5cGUobWF5YmVTdWJUeXBlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNBYnN0cmFjdFR5cGUoc3VwZXJUeXBlKSAmJiAoaXNJbnRlcmZhY2VUeXBlKG1heWJlU3ViVHlwZSkgfHwgaXNPYmplY3RUeXBlKG1heWJlU3ViVHlwZSkpICYmIHNjaGVtYS5pc1N1YlR5cGUoc3VwZXJUeXBlLCBtYXliZVN1YlR5cGUpO1xufVxuZnVuY3Rpb24gZG9UeXBlc092ZXJsYXAoc2NoZW1hLCB0eXBlQSwgdHlwZUIpIHtcbiAgaWYgKHR5cGVBID09PSB0eXBlQikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0Fic3RyYWN0VHlwZSh0eXBlQSkpIHtcbiAgICBpZiAoaXNBYnN0cmFjdFR5cGUodHlwZUIpKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLmdldFBvc3NpYmxlVHlwZXModHlwZUEpLnNvbWUoKHR5cGUpID0+IHNjaGVtYS5pc1N1YlR5cGUodHlwZUIsIHR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYS5pc1N1YlR5cGUodHlwZUEsIHR5cGVCKTtcbiAgfVxuICBpZiAoaXNBYnN0cmFjdFR5cGUodHlwZUIpKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5pc1N1YlR5cGUodHlwZUIsIHR5cGVBKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgaW5pdF90eXBlQ29tcGFyYXRvcnMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdXRpbGl0aWVzL3R5cGVDb21wYXJhdG9ycy5tanNcIigpIHtcbiAgICBpbml0X2RlZmluaXRpb24oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3R5cGUvdmFsaWRhdGUubWpzXG5mdW5jdGlvbiB2YWxpZGF0ZVNjaGVtYShzY2hlbWEpIHtcbiAgYXNzZXJ0U2NoZW1hKHNjaGVtYSk7XG4gIGlmIChzY2hlbWEuX192YWxpZGF0aW9uRXJyb3JzKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5fX3ZhbGlkYXRpb25FcnJvcnM7XG4gIH1cbiAgY29uc3QgY29udGV4dCA9IG5ldyBTY2hlbWFWYWxpZGF0aW9uQ29udGV4dChzY2hlbWEpO1xuICB2YWxpZGF0ZVJvb3RUeXBlcyhjb250ZXh0KTtcbiAgdmFsaWRhdGVEaXJlY3RpdmVzKGNvbnRleHQpO1xuICB2YWxpZGF0ZVR5cGVzKGNvbnRleHQpO1xuICBjb25zdCBlcnJvcnMgPSBjb250ZXh0LmdldEVycm9ycygpO1xuICBzY2hlbWEuX192YWxpZGF0aW9uRXJyb3JzID0gZXJyb3JzO1xuICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRTY2hlbWEoc2NoZW1hKSB7XG4gIGNvbnN0IGVycm9ycyA9IHZhbGlkYXRlU2NoZW1hKHNjaGVtYSk7XG4gIGlmIChlcnJvcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5tYXAoKGVycm9yKSA9PiBlcnJvci5tZXNzYWdlKS5qb2luKFwiXFxuXFxuXCIpKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVSb290VHlwZXMoY29udGV4dCkge1xuICBjb25zdCBzY2hlbWEgPSBjb250ZXh0LnNjaGVtYTtcbiAgY29uc3QgcXVlcnlUeXBlID0gc2NoZW1hLmdldFF1ZXJ5VHlwZSgpO1xuICBpZiAoIXF1ZXJ5VHlwZSkge1xuICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXCJRdWVyeSByb290IHR5cGUgbXVzdCBiZSBwcm92aWRlZC5cIiwgc2NoZW1hLmFzdE5vZGUpO1xuICB9IGVsc2UgaWYgKCFpc09iamVjdFR5cGUocXVlcnlUeXBlKSkge1xuICAgIHZhciBfZ2V0T3BlcmF0aW9uVHlwZU5vZGU7XG4gICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgIGBRdWVyeSByb290IHR5cGUgbXVzdCBiZSBPYmplY3QgdHlwZSwgaXQgY2Fubm90IGJlICR7aW5zcGVjdChcbiAgICAgICAgcXVlcnlUeXBlXG4gICAgICApfS5gLFxuICAgICAgKF9nZXRPcGVyYXRpb25UeXBlTm9kZSA9IGdldE9wZXJhdGlvblR5cGVOb2RlKFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIE9wZXJhdGlvblR5cGVOb2RlLlFVRVJZXG4gICAgICApKSAhPT0gbnVsbCAmJiBfZ2V0T3BlcmF0aW9uVHlwZU5vZGUgIT09IHZvaWQgMCA/IF9nZXRPcGVyYXRpb25UeXBlTm9kZSA6IHF1ZXJ5VHlwZS5hc3ROb2RlXG4gICAgKTtcbiAgfVxuICBjb25zdCBtdXRhdGlvblR5cGUgPSBzY2hlbWEuZ2V0TXV0YXRpb25UeXBlKCk7XG4gIGlmIChtdXRhdGlvblR5cGUgJiYgIWlzT2JqZWN0VHlwZShtdXRhdGlvblR5cGUpKSB7XG4gICAgdmFyIF9nZXRPcGVyYXRpb25UeXBlTm9kZTI7XG4gICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgIGBNdXRhdGlvbiByb290IHR5cGUgbXVzdCBiZSBPYmplY3QgdHlwZSBpZiBwcm92aWRlZCwgaXQgY2Fubm90IGJlICR7aW5zcGVjdChtdXRhdGlvblR5cGUpfS5gLFxuICAgICAgKF9nZXRPcGVyYXRpb25UeXBlTm9kZTIgPSBnZXRPcGVyYXRpb25UeXBlTm9kZShcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBPcGVyYXRpb25UeXBlTm9kZS5NVVRBVElPTlxuICAgICAgKSkgIT09IG51bGwgJiYgX2dldE9wZXJhdGlvblR5cGVOb2RlMiAhPT0gdm9pZCAwID8gX2dldE9wZXJhdGlvblR5cGVOb2RlMiA6IG11dGF0aW9uVHlwZS5hc3ROb2RlXG4gICAgKTtcbiAgfVxuICBjb25zdCBzdWJzY3JpcHRpb25UeXBlID0gc2NoZW1hLmdldFN1YnNjcmlwdGlvblR5cGUoKTtcbiAgaWYgKHN1YnNjcmlwdGlvblR5cGUgJiYgIWlzT2JqZWN0VHlwZShzdWJzY3JpcHRpb25UeXBlKSkge1xuICAgIHZhciBfZ2V0T3BlcmF0aW9uVHlwZU5vZGUzO1xuICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICBgU3Vic2NyaXB0aW9uIHJvb3QgdHlwZSBtdXN0IGJlIE9iamVjdCB0eXBlIGlmIHByb3ZpZGVkLCBpdCBjYW5ub3QgYmUgJHtpbnNwZWN0KHN1YnNjcmlwdGlvblR5cGUpfS5gLFxuICAgICAgKF9nZXRPcGVyYXRpb25UeXBlTm9kZTMgPSBnZXRPcGVyYXRpb25UeXBlTm9kZShcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBPcGVyYXRpb25UeXBlTm9kZS5TVUJTQ1JJUFRJT05cbiAgICAgICkpICE9PSBudWxsICYmIF9nZXRPcGVyYXRpb25UeXBlTm9kZTMgIT09IHZvaWQgMCA/IF9nZXRPcGVyYXRpb25UeXBlTm9kZTMgOiBzdWJzY3JpcHRpb25UeXBlLmFzdE5vZGVcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcGVyYXRpb25UeXBlTm9kZShzY2hlbWEsIG9wZXJhdGlvbikge1xuICB2YXIgX2ZsYXRNYXAkZmluZDtcbiAgcmV0dXJuIChfZmxhdE1hcCRmaW5kID0gW3NjaGVtYS5hc3ROb2RlLCAuLi5zY2hlbWEuZXh0ZW5zaW9uQVNUTm9kZXNdLmZsYXRNYXAoXG4gICAgLy8gRklYTUU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2dyYXBocWwtanMvaXNzdWVzLzIyMDNcbiAgICAoc2NoZW1hTm9kZSkgPT4ge1xuICAgICAgdmFyIF9zY2hlbWFOb2RlJG9wZXJhdGlvbjtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgIChfc2NoZW1hTm9kZSRvcGVyYXRpb24gPSBzY2hlbWFOb2RlID09PSBudWxsIHx8IHNjaGVtYU5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVtYU5vZGUub3BlcmF0aW9uVHlwZXMpICE9PSBudWxsICYmIF9zY2hlbWFOb2RlJG9wZXJhdGlvbiAhPT0gdm9pZCAwID8gX3NjaGVtYU5vZGUkb3BlcmF0aW9uIDogW11cbiAgICAgICk7XG4gICAgfVxuICApLmZpbmQoKG9wZXJhdGlvbk5vZGUpID0+IG9wZXJhdGlvbk5vZGUub3BlcmF0aW9uID09PSBvcGVyYXRpb24pKSA9PT0gbnVsbCB8fCBfZmxhdE1hcCRmaW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZmxhdE1hcCRmaW5kLnR5cGU7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZURpcmVjdGl2ZXMoY29udGV4dCkge1xuICBmb3IgKGNvbnN0IGRpcmVjdGl2ZSBvZiBjb250ZXh0LnNjaGVtYS5nZXREaXJlY3RpdmVzKCkpIHtcbiAgICBpZiAoIWlzRGlyZWN0aXZlKGRpcmVjdGl2ZSkpIHtcbiAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBkaXJlY3RpdmUgYnV0IGdvdDogJHtpbnNwZWN0KGRpcmVjdGl2ZSl9LmAsXG4gICAgICAgIGRpcmVjdGl2ZSA9PT0gbnVsbCB8fCBkaXJlY3RpdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpcmVjdGl2ZS5hc3ROb2RlXG4gICAgICApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhbGlkYXRlTmFtZShjb250ZXh0LCBkaXJlY3RpdmUpO1xuICAgIGZvciAoY29uc3QgYXJnIG9mIGRpcmVjdGl2ZS5hcmdzKSB7XG4gICAgICB2YWxpZGF0ZU5hbWUoY29udGV4dCwgYXJnKTtcbiAgICAgIGlmICghaXNJbnB1dFR5cGUoYXJnLnR5cGUpKSB7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgYFRoZSB0eXBlIG9mIEAke2RpcmVjdGl2ZS5uYW1lfSgke2FyZy5uYW1lfTopIG11c3QgYmUgSW5wdXQgVHlwZSBidXQgZ290OiAke2luc3BlY3QoYXJnLnR5cGUpfS5gLFxuICAgICAgICAgIGFyZy5hc3ROb2RlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZXF1aXJlZEFyZ3VtZW50KGFyZykgJiYgYXJnLmRlcHJlY2F0aW9uUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgdmFyIF9hcmckYXN0Tm9kZTtcbiAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICBgUmVxdWlyZWQgYXJndW1lbnQgQCR7ZGlyZWN0aXZlLm5hbWV9KCR7YXJnLm5hbWV9OikgY2Fubm90IGJlIGRlcHJlY2F0ZWQuYCxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBnZXREZXByZWNhdGVkRGlyZWN0aXZlTm9kZShhcmcuYXN0Tm9kZSksXG4gICAgICAgICAgICAoX2FyZyRhc3ROb2RlID0gYXJnLmFzdE5vZGUpID09PSBudWxsIHx8IF9hcmckYXN0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FyZyRhc3ROb2RlLnR5cGVcbiAgICAgICAgICBdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWUoY29udGV4dCwgbm9kZSkge1xuICBpZiAobm9kZS5uYW1lLnN0YXJ0c1dpdGgoXCJfX1wiKSkge1xuICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICBgTmFtZSBcIiR7bm9kZS5uYW1lfVwiIG11c3Qgbm90IGJlZ2luIHdpdGggXCJfX1wiLCB3aGljaCBpcyByZXNlcnZlZCBieSBHcmFwaFFMIGludHJvc3BlY3Rpb24uYCxcbiAgICAgIG5vZGUuYXN0Tm9kZVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZXMoY29udGV4dCkge1xuICBjb25zdCB2YWxpZGF0ZUlucHV0T2JqZWN0Q2lyY3VsYXJSZWZzID0gY3JlYXRlSW5wdXRPYmplY3RDaXJjdWxhclJlZnNWYWxpZGF0b3IoY29udGV4dCk7XG4gIGNvbnN0IHR5cGVNYXAgPSBjb250ZXh0LnNjaGVtYS5nZXRUeXBlTWFwKCk7XG4gIGZvciAoY29uc3QgdHlwZSBvZiBPYmplY3QudmFsdWVzKHR5cGVNYXApKSB7XG4gICAgaWYgKCFpc05hbWVkVHlwZSh0eXBlKSkge1xuICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgYEV4cGVjdGVkIEdyYXBoUUwgbmFtZWQgdHlwZSBidXQgZ290OiAke2luc3BlY3QodHlwZSl9LmAsXG4gICAgICAgIHR5cGUuYXN0Tm9kZVxuICAgICAgKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIWlzSW50cm9zcGVjdGlvblR5cGUodHlwZSkpIHtcbiAgICAgIHZhbGlkYXRlTmFtZShjb250ZXh0LCB0eXBlKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0VHlwZSh0eXBlKSkge1xuICAgICAgdmFsaWRhdGVGaWVsZHMoY29udGV4dCwgdHlwZSk7XG4gICAgICB2YWxpZGF0ZUludGVyZmFjZXMoY29udGV4dCwgdHlwZSk7XG4gICAgfSBlbHNlIGlmIChpc0ludGVyZmFjZVR5cGUodHlwZSkpIHtcbiAgICAgIHZhbGlkYXRlRmllbGRzKGNvbnRleHQsIHR5cGUpO1xuICAgICAgdmFsaWRhdGVJbnRlcmZhY2VzKGNvbnRleHQsIHR5cGUpO1xuICAgIH0gZWxzZSBpZiAoaXNVbmlvblR5cGUodHlwZSkpIHtcbiAgICAgIHZhbGlkYXRlVW5pb25NZW1iZXJzKGNvbnRleHQsIHR5cGUpO1xuICAgIH0gZWxzZSBpZiAoaXNFbnVtVHlwZSh0eXBlKSkge1xuICAgICAgdmFsaWRhdGVFbnVtVmFsdWVzKGNvbnRleHQsIHR5cGUpO1xuICAgIH0gZWxzZSBpZiAoaXNJbnB1dE9iamVjdFR5cGUodHlwZSkpIHtcbiAgICAgIHZhbGlkYXRlSW5wdXRGaWVsZHMoY29udGV4dCwgdHlwZSk7XG4gICAgICB2YWxpZGF0ZUlucHV0T2JqZWN0Q2lyY3VsYXJSZWZzKHR5cGUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZHMoY29udGV4dCwgdHlwZSkge1xuICBjb25zdCBmaWVsZHMgPSBPYmplY3QudmFsdWVzKHR5cGUuZ2V0RmllbGRzKCkpO1xuICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnRleHQucmVwb3J0RXJyb3IoYFR5cGUgJHt0eXBlLm5hbWV9IG11c3QgZGVmaW5lIG9uZSBvciBtb3JlIGZpZWxkcy5gLCBbXG4gICAgICB0eXBlLmFzdE5vZGUsXG4gICAgICAuLi50eXBlLmV4dGVuc2lvbkFTVE5vZGVzXG4gICAgXSk7XG4gIH1cbiAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICB2YWxpZGF0ZU5hbWUoY29udGV4dCwgZmllbGQpO1xuICAgIGlmICghaXNPdXRwdXRUeXBlKGZpZWxkLnR5cGUpKSB7XG4gICAgICB2YXIgX2ZpZWxkJGFzdE5vZGU7XG4gICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICBgVGhlIHR5cGUgb2YgJHt0eXBlLm5hbWV9LiR7ZmllbGQubmFtZX0gbXVzdCBiZSBPdXRwdXQgVHlwZSBidXQgZ290OiAke2luc3BlY3QoZmllbGQudHlwZSl9LmAsXG4gICAgICAgIChfZmllbGQkYXN0Tm9kZSA9IGZpZWxkLmFzdE5vZGUpID09PSBudWxsIHx8IF9maWVsZCRhc3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZmllbGQkYXN0Tm9kZS50eXBlXG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBmaWVsZC5hcmdzKSB7XG4gICAgICBjb25zdCBhcmdOYW1lID0gYXJnLm5hbWU7XG4gICAgICB2YWxpZGF0ZU5hbWUoY29udGV4dCwgYXJnKTtcbiAgICAgIGlmICghaXNJbnB1dFR5cGUoYXJnLnR5cGUpKSB7XG4gICAgICAgIHZhciBfYXJnJGFzdE5vZGUyO1xuICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgIGBUaGUgdHlwZSBvZiAke3R5cGUubmFtZX0uJHtmaWVsZC5uYW1lfSgke2FyZ05hbWV9OikgbXVzdCBiZSBJbnB1dCBUeXBlIGJ1dCBnb3Q6ICR7aW5zcGVjdChhcmcudHlwZSl9LmAsXG4gICAgICAgICAgKF9hcmckYXN0Tm9kZTIgPSBhcmcuYXN0Tm9kZSkgPT09IG51bGwgfHwgX2FyZyRhc3ROb2RlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FyZyRhc3ROb2RlMi50eXBlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZXF1aXJlZEFyZ3VtZW50KGFyZykgJiYgYXJnLmRlcHJlY2F0aW9uUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgdmFyIF9hcmckYXN0Tm9kZTM7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgYFJlcXVpcmVkIGFyZ3VtZW50ICR7dHlwZS5uYW1lfS4ke2ZpZWxkLm5hbWV9KCR7YXJnTmFtZX06KSBjYW5ub3QgYmUgZGVwcmVjYXRlZC5gLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIGdldERlcHJlY2F0ZWREaXJlY3RpdmVOb2RlKGFyZy5hc3ROb2RlKSxcbiAgICAgICAgICAgIChfYXJnJGFzdE5vZGUzID0gYXJnLmFzdE5vZGUpID09PSBudWxsIHx8IF9hcmckYXN0Tm9kZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hcmckYXN0Tm9kZTMudHlwZVxuICAgICAgICAgIF1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlSW50ZXJmYWNlcyhjb250ZXh0LCB0eXBlKSB7XG4gIGNvbnN0IGlmYWNlVHlwZU5hbWVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgaWZhY2Ugb2YgdHlwZS5nZXRJbnRlcmZhY2VzKCkpIHtcbiAgICBpZiAoIWlzSW50ZXJmYWNlVHlwZShpZmFjZSkpIHtcbiAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgIGBUeXBlICR7aW5zcGVjdCh0eXBlKX0gbXVzdCBvbmx5IGltcGxlbWVudCBJbnRlcmZhY2UgdHlwZXMsIGl0IGNhbm5vdCBpbXBsZW1lbnQgJHtpbnNwZWN0KGlmYWNlKX0uYCxcbiAgICAgICAgZ2V0QWxsSW1wbGVtZW50c0ludGVyZmFjZU5vZGVzKHR5cGUsIGlmYWNlKVxuICAgICAgKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gaWZhY2UpIHtcbiAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgIGBUeXBlICR7dHlwZS5uYW1lfSBjYW5ub3QgaW1wbGVtZW50IGl0c2VsZiBiZWNhdXNlIGl0IHdvdWxkIGNyZWF0ZSBhIGNpcmN1bGFyIHJlZmVyZW5jZS5gLFxuICAgICAgICBnZXRBbGxJbXBsZW1lbnRzSW50ZXJmYWNlTm9kZXModHlwZSwgaWZhY2UpXG4gICAgICApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpZmFjZVR5cGVOYW1lc1tpZmFjZS5uYW1lXSkge1xuICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgYFR5cGUgJHt0eXBlLm5hbWV9IGNhbiBvbmx5IGltcGxlbWVudCAke2lmYWNlLm5hbWV9IG9uY2UuYCxcbiAgICAgICAgZ2V0QWxsSW1wbGVtZW50c0ludGVyZmFjZU5vZGVzKHR5cGUsIGlmYWNlKVxuICAgICAgKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZmFjZVR5cGVOYW1lc1tpZmFjZS5uYW1lXSA9IHRydWU7XG4gICAgdmFsaWRhdGVUeXBlSW1wbGVtZW50c0FuY2VzdG9ycyhjb250ZXh0LCB0eXBlLCBpZmFjZSk7XG4gICAgdmFsaWRhdGVUeXBlSW1wbGVtZW50c0ludGVyZmFjZShjb250ZXh0LCB0eXBlLCBpZmFjZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZUltcGxlbWVudHNJbnRlcmZhY2UoY29udGV4dCwgdHlwZSwgaWZhY2UpIHtcbiAgY29uc3QgdHlwZUZpZWxkTWFwID0gdHlwZS5nZXRGaWVsZHMoKTtcbiAgZm9yIChjb25zdCBpZmFjZUZpZWxkIG9mIE9iamVjdC52YWx1ZXMoaWZhY2UuZ2V0RmllbGRzKCkpKSB7XG4gICAgY29uc3QgZmllbGROYW1lID0gaWZhY2VGaWVsZC5uYW1lO1xuICAgIGNvbnN0IHR5cGVGaWVsZCA9IHR5cGVGaWVsZE1hcFtmaWVsZE5hbWVdO1xuICAgIGlmICghdHlwZUZpZWxkKSB7XG4gICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICBgSW50ZXJmYWNlIGZpZWxkICR7aWZhY2UubmFtZX0uJHtmaWVsZE5hbWV9IGV4cGVjdGVkIGJ1dCAke3R5cGUubmFtZX0gZG9lcyBub3QgcHJvdmlkZSBpdC5gLFxuICAgICAgICBbaWZhY2VGaWVsZC5hc3ROb2RlLCB0eXBlLmFzdE5vZGUsIC4uLnR5cGUuZXh0ZW5zaW9uQVNUTm9kZXNdXG4gICAgICApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghaXNUeXBlU3ViVHlwZU9mKGNvbnRleHQuc2NoZW1hLCB0eXBlRmllbGQudHlwZSwgaWZhY2VGaWVsZC50eXBlKSkge1xuICAgICAgdmFyIF9pZmFjZUZpZWxkJGFzdE5vZGUsIF90eXBlRmllbGQkYXN0Tm9kZTtcbiAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgIGBJbnRlcmZhY2UgZmllbGQgJHtpZmFjZS5uYW1lfS4ke2ZpZWxkTmFtZX0gZXhwZWN0cyB0eXBlICR7aW5zcGVjdChpZmFjZUZpZWxkLnR5cGUpfSBidXQgJHt0eXBlLm5hbWV9LiR7ZmllbGROYW1lfSBpcyB0eXBlICR7aW5zcGVjdCh0eXBlRmllbGQudHlwZSl9LmAsXG4gICAgICAgIFtcbiAgICAgICAgICAoX2lmYWNlRmllbGQkYXN0Tm9kZSA9IGlmYWNlRmllbGQuYXN0Tm9kZSkgPT09IG51bGwgfHwgX2lmYWNlRmllbGQkYXN0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2lmYWNlRmllbGQkYXN0Tm9kZS50eXBlLFxuICAgICAgICAgIChfdHlwZUZpZWxkJGFzdE5vZGUgPSB0eXBlRmllbGQuYXN0Tm9kZSkgPT09IG51bGwgfHwgX3R5cGVGaWVsZCRhc3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdHlwZUZpZWxkJGFzdE5vZGUudHlwZVxuICAgICAgICBdXG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGlmYWNlQXJnIG9mIGlmYWNlRmllbGQuYXJncykge1xuICAgICAgY29uc3QgYXJnTmFtZSA9IGlmYWNlQXJnLm5hbWU7XG4gICAgICBjb25zdCB0eXBlQXJnID0gdHlwZUZpZWxkLmFyZ3MuZmluZCgoYXJnKSA9PiBhcmcubmFtZSA9PT0gYXJnTmFtZSk7XG4gICAgICBpZiAoIXR5cGVBcmcpIHtcbiAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICBgSW50ZXJmYWNlIGZpZWxkIGFyZ3VtZW50ICR7aWZhY2UubmFtZX0uJHtmaWVsZE5hbWV9KCR7YXJnTmFtZX06KSBleHBlY3RlZCBidXQgJHt0eXBlLm5hbWV9LiR7ZmllbGROYW1lfSBkb2VzIG5vdCBwcm92aWRlIGl0LmAsXG4gICAgICAgICAgW2lmYWNlQXJnLmFzdE5vZGUsIHR5cGVGaWVsZC5hc3ROb2RlXVxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNFcXVhbFR5cGUoaWZhY2VBcmcudHlwZSwgdHlwZUFyZy50eXBlKSkge1xuICAgICAgICB2YXIgX2lmYWNlQXJnJGFzdE5vZGUsIF90eXBlQXJnJGFzdE5vZGU7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgYEludGVyZmFjZSBmaWVsZCBhcmd1bWVudCAke2lmYWNlLm5hbWV9LiR7ZmllbGROYW1lfSgke2FyZ05hbWV9OikgZXhwZWN0cyB0eXBlICR7aW5zcGVjdChpZmFjZUFyZy50eXBlKX0gYnV0ICR7dHlwZS5uYW1lfS4ke2ZpZWxkTmFtZX0oJHthcmdOYW1lfTopIGlzIHR5cGUgJHtpbnNwZWN0KHR5cGVBcmcudHlwZSl9LmAsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgKF9pZmFjZUFyZyRhc3ROb2RlID0gaWZhY2VBcmcuYXN0Tm9kZSkgPT09IG51bGwgfHwgX2lmYWNlQXJnJGFzdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pZmFjZUFyZyRhc3ROb2RlLnR5cGUsXG4gICAgICAgICAgICAoX3R5cGVBcmckYXN0Tm9kZSA9IHR5cGVBcmcuYXN0Tm9kZSkgPT09IG51bGwgfHwgX3R5cGVBcmckYXN0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3R5cGVBcmckYXN0Tm9kZS50eXBlXG4gICAgICAgICAgXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGVBcmcgb2YgdHlwZUZpZWxkLmFyZ3MpIHtcbiAgICAgIGNvbnN0IGFyZ05hbWUgPSB0eXBlQXJnLm5hbWU7XG4gICAgICBjb25zdCBpZmFjZUFyZyA9IGlmYWNlRmllbGQuYXJncy5maW5kKChhcmcpID0+IGFyZy5uYW1lID09PSBhcmdOYW1lKTtcbiAgICAgIGlmICghaWZhY2VBcmcgJiYgaXNSZXF1aXJlZEFyZ3VtZW50KHR5cGVBcmcpKSB7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgYE9iamVjdCBmaWVsZCAke3R5cGUubmFtZX0uJHtmaWVsZE5hbWV9IGluY2x1ZGVzIHJlcXVpcmVkIGFyZ3VtZW50ICR7YXJnTmFtZX0gdGhhdCBpcyBtaXNzaW5nIGZyb20gdGhlIEludGVyZmFjZSBmaWVsZCAke2lmYWNlLm5hbWV9LiR7ZmllbGROYW1lfS5gLFxuICAgICAgICAgIFt0eXBlQXJnLmFzdE5vZGUsIGlmYWNlRmllbGQuYXN0Tm9kZV1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZUltcGxlbWVudHNBbmNlc3RvcnMoY29udGV4dCwgdHlwZSwgaWZhY2UpIHtcbiAgY29uc3QgaWZhY2VJbnRlcmZhY2VzID0gdHlwZS5nZXRJbnRlcmZhY2VzKCk7XG4gIGZvciAoY29uc3QgdHJhbnNpdGl2ZSBvZiBpZmFjZS5nZXRJbnRlcmZhY2VzKCkpIHtcbiAgICBpZiAoIWlmYWNlSW50ZXJmYWNlcy5pbmNsdWRlcyh0cmFuc2l0aXZlKSkge1xuICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgdHJhbnNpdGl2ZSA9PT0gdHlwZSA/IGBUeXBlICR7dHlwZS5uYW1lfSBjYW5ub3QgaW1wbGVtZW50ICR7aWZhY2UubmFtZX0gYmVjYXVzZSBpdCB3b3VsZCBjcmVhdGUgYSBjaXJjdWxhciByZWZlcmVuY2UuYCA6IGBUeXBlICR7dHlwZS5uYW1lfSBtdXN0IGltcGxlbWVudCAke3RyYW5zaXRpdmUubmFtZX0gYmVjYXVzZSBpdCBpcyBpbXBsZW1lbnRlZCBieSAke2lmYWNlLm5hbWV9LmAsXG4gICAgICAgIFtcbiAgICAgICAgICAuLi5nZXRBbGxJbXBsZW1lbnRzSW50ZXJmYWNlTm9kZXMoaWZhY2UsIHRyYW5zaXRpdmUpLFxuICAgICAgICAgIC4uLmdldEFsbEltcGxlbWVudHNJbnRlcmZhY2VOb2Rlcyh0eXBlLCBpZmFjZSlcbiAgICAgICAgXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVW5pb25NZW1iZXJzKGNvbnRleHQsIHVuaW9uKSB7XG4gIGNvbnN0IG1lbWJlclR5cGVzID0gdW5pb24uZ2V0VHlwZXMoKTtcbiAgaWYgKG1lbWJlclR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICBgVW5pb24gdHlwZSAke3VuaW9uLm5hbWV9IG11c3QgZGVmaW5lIG9uZSBvciBtb3JlIG1lbWJlciB0eXBlcy5gLFxuICAgICAgW3VuaW9uLmFzdE5vZGUsIC4uLnVuaW9uLmV4dGVuc2lvbkFTVE5vZGVzXVxuICAgICk7XG4gIH1cbiAgY29uc3QgaW5jbHVkZWRUeXBlTmFtZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBtZW1iZXJUeXBlIG9mIG1lbWJlclR5cGVzKSB7XG4gICAgaWYgKGluY2x1ZGVkVHlwZU5hbWVzW21lbWJlclR5cGUubmFtZV0pIHtcbiAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgIGBVbmlvbiB0eXBlICR7dW5pb24ubmFtZX0gY2FuIG9ubHkgaW5jbHVkZSB0eXBlICR7bWVtYmVyVHlwZS5uYW1lfSBvbmNlLmAsXG4gICAgICAgIGdldFVuaW9uTWVtYmVyVHlwZU5vZGVzKHVuaW9uLCBtZW1iZXJUeXBlLm5hbWUpXG4gICAgICApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluY2x1ZGVkVHlwZU5hbWVzW21lbWJlclR5cGUubmFtZV0gPSB0cnVlO1xuICAgIGlmICghaXNPYmplY3RUeXBlKG1lbWJlclR5cGUpKSB7XG4gICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICBgVW5pb24gdHlwZSAke3VuaW9uLm5hbWV9IGNhbiBvbmx5IGluY2x1ZGUgT2JqZWN0IHR5cGVzLCBpdCBjYW5ub3QgaW5jbHVkZSAke2luc3BlY3QobWVtYmVyVHlwZSl9LmAsXG4gICAgICAgIGdldFVuaW9uTWVtYmVyVHlwZU5vZGVzKHVuaW9uLCBTdHJpbmcobWVtYmVyVHlwZSkpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVFbnVtVmFsdWVzKGNvbnRleHQsIGVudW1UeXBlKSB7XG4gIGNvbnN0IGVudW1WYWx1ZXMgPSBlbnVtVHlwZS5nZXRWYWx1ZXMoKTtcbiAgaWYgKGVudW1WYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgIGBFbnVtIHR5cGUgJHtlbnVtVHlwZS5uYW1lfSBtdXN0IGRlZmluZSBvbmUgb3IgbW9yZSB2YWx1ZXMuYCxcbiAgICAgIFtlbnVtVHlwZS5hc3ROb2RlLCAuLi5lbnVtVHlwZS5leHRlbnNpb25BU1ROb2Rlc11cbiAgICApO1xuICB9XG4gIGZvciAoY29uc3QgZW51bVZhbHVlIG9mIGVudW1WYWx1ZXMpIHtcbiAgICB2YWxpZGF0ZU5hbWUoY29udGV4dCwgZW51bVZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVJbnB1dEZpZWxkcyhjb250ZXh0LCBpbnB1dE9iaikge1xuICBjb25zdCBmaWVsZHMgPSBPYmplY3QudmFsdWVzKGlucHV0T2JqLmdldEZpZWxkcygpKTtcbiAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgYElucHV0IE9iamVjdCB0eXBlICR7aW5wdXRPYmoubmFtZX0gbXVzdCBkZWZpbmUgb25lIG9yIG1vcmUgZmllbGRzLmAsXG4gICAgICBbaW5wdXRPYmouYXN0Tm9kZSwgLi4uaW5wdXRPYmouZXh0ZW5zaW9uQVNUTm9kZXNdXG4gICAgKTtcbiAgfVxuICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgIHZhbGlkYXRlTmFtZShjb250ZXh0LCBmaWVsZCk7XG4gICAgaWYgKCFpc0lucHV0VHlwZShmaWVsZC50eXBlKSkge1xuICAgICAgdmFyIF9maWVsZCRhc3ROb2RlMjtcbiAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgIGBUaGUgdHlwZSBvZiAke2lucHV0T2JqLm5hbWV9LiR7ZmllbGQubmFtZX0gbXVzdCBiZSBJbnB1dCBUeXBlIGJ1dCBnb3Q6ICR7aW5zcGVjdChmaWVsZC50eXBlKX0uYCxcbiAgICAgICAgKF9maWVsZCRhc3ROb2RlMiA9IGZpZWxkLmFzdE5vZGUpID09PSBudWxsIHx8IF9maWVsZCRhc3ROb2RlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZpZWxkJGFzdE5vZGUyLnR5cGVcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc1JlcXVpcmVkSW5wdXRGaWVsZChmaWVsZCkgJiYgZmllbGQuZGVwcmVjYXRpb25SZWFzb24gIT0gbnVsbCkge1xuICAgICAgdmFyIF9maWVsZCRhc3ROb2RlMztcbiAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgIGBSZXF1aXJlZCBpbnB1dCBmaWVsZCAke2lucHV0T2JqLm5hbWV9LiR7ZmllbGQubmFtZX0gY2Fubm90IGJlIGRlcHJlY2F0ZWQuYCxcbiAgICAgICAgW1xuICAgICAgICAgIGdldERlcHJlY2F0ZWREaXJlY3RpdmVOb2RlKGZpZWxkLmFzdE5vZGUpLFxuICAgICAgICAgIChfZmllbGQkYXN0Tm9kZTMgPSBmaWVsZC5hc3ROb2RlKSA9PT0gbnVsbCB8fCBfZmllbGQkYXN0Tm9kZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9maWVsZCRhc3ROb2RlMy50eXBlXG4gICAgICAgIF1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVJbnB1dE9iamVjdENpcmN1bGFyUmVmc1ZhbGlkYXRvcihjb250ZXh0KSB7XG4gIGNvbnN0IHZpc2l0ZWRUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBmaWVsZFBhdGggPSBbXTtcbiAgY29uc3QgZmllbGRQYXRoSW5kZXhCeVR5cGVOYW1lID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiBkZXRlY3RDeWNsZVJlY3Vyc2l2ZTtcbiAgZnVuY3Rpb24gZGV0ZWN0Q3ljbGVSZWN1cnNpdmUoaW5wdXRPYmopIHtcbiAgICBpZiAodmlzaXRlZFR5cGVzW2lucHV0T2JqLm5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZpc2l0ZWRUeXBlc1tpbnB1dE9iai5uYW1lXSA9IHRydWU7XG4gICAgZmllbGRQYXRoSW5kZXhCeVR5cGVOYW1lW2lucHV0T2JqLm5hbWVdID0gZmllbGRQYXRoLmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZHMgPSBPYmplY3QudmFsdWVzKGlucHV0T2JqLmdldEZpZWxkcygpKTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgaWYgKGlzTm9uTnVsbFR5cGUoZmllbGQudHlwZSkgJiYgaXNJbnB1dE9iamVjdFR5cGUoZmllbGQudHlwZS5vZlR5cGUpKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IGZpZWxkLnR5cGUub2ZUeXBlO1xuICAgICAgICBjb25zdCBjeWNsZUluZGV4ID0gZmllbGRQYXRoSW5kZXhCeVR5cGVOYW1lW2ZpZWxkVHlwZS5uYW1lXTtcbiAgICAgICAgZmllbGRQYXRoLnB1c2goZmllbGQpO1xuICAgICAgICBpZiAoY3ljbGVJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGV0ZWN0Q3ljbGVSZWN1cnNpdmUoZmllbGRUeXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjeWNsZVBhdGggPSBmaWVsZFBhdGguc2xpY2UoY3ljbGVJbmRleCk7XG4gICAgICAgICAgY29uc3QgcGF0aFN0ciA9IGN5Y2xlUGF0aC5tYXAoKGZpZWxkT2JqKSA9PiBmaWVsZE9iai5uYW1lKS5qb2luKFwiLlwiKTtcbiAgICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCByZWZlcmVuY2UgSW5wdXQgT2JqZWN0IFwiJHtmaWVsZFR5cGUubmFtZX1cIiB3aXRoaW4gaXRzZWxmIHRocm91Z2ggYSBzZXJpZXMgb2Ygbm9uLW51bGwgZmllbGRzOiBcIiR7cGF0aFN0cn1cIi5gLFxuICAgICAgICAgICAgY3ljbGVQYXRoLm1hcCgoZmllbGRPYmopID0+IGZpZWxkT2JqLmFzdE5vZGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZFBhdGgucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZpZWxkUGF0aEluZGV4QnlUeXBlTmFtZVtpbnB1dE9iai5uYW1lXSA9IHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QWxsSW1wbGVtZW50c0ludGVyZmFjZU5vZGVzKHR5cGUsIGlmYWNlKSB7XG4gIGNvbnN0IHsgYXN0Tm9kZSwgZXh0ZW5zaW9uQVNUTm9kZXMgfSA9IHR5cGU7XG4gIGNvbnN0IG5vZGVzID0gYXN0Tm9kZSAhPSBudWxsID8gW2FzdE5vZGUsIC4uLmV4dGVuc2lvbkFTVE5vZGVzXSA6IGV4dGVuc2lvbkFTVE5vZGVzO1xuICByZXR1cm4gbm9kZXMuZmxhdE1hcCgodHlwZU5vZGUpID0+IHtcbiAgICB2YXIgX3R5cGVOb2RlJGludGVyZmFjZXM7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAoX3R5cGVOb2RlJGludGVyZmFjZXMgPSB0eXBlTm9kZS5pbnRlcmZhY2VzKSAhPT0gbnVsbCAmJiBfdHlwZU5vZGUkaW50ZXJmYWNlcyAhPT0gdm9pZCAwID8gX3R5cGVOb2RlJGludGVyZmFjZXMgOiBbXVxuICAgICk7XG4gIH0pLmZpbHRlcigoaWZhY2VOb2RlKSA9PiBpZmFjZU5vZGUubmFtZS52YWx1ZSA9PT0gaWZhY2UubmFtZSk7XG59XG5mdW5jdGlvbiBnZXRVbmlvbk1lbWJlclR5cGVOb2Rlcyh1bmlvbiwgdHlwZU5hbWUpIHtcbiAgY29uc3QgeyBhc3ROb2RlLCBleHRlbnNpb25BU1ROb2RlcyB9ID0gdW5pb247XG4gIGNvbnN0IG5vZGVzID0gYXN0Tm9kZSAhPSBudWxsID8gW2FzdE5vZGUsIC4uLmV4dGVuc2lvbkFTVE5vZGVzXSA6IGV4dGVuc2lvbkFTVE5vZGVzO1xuICByZXR1cm4gbm9kZXMuZmxhdE1hcCgodW5pb25Ob2RlKSA9PiB7XG4gICAgdmFyIF91bmlvbk5vZGUkdHlwZXM7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAoX3VuaW9uTm9kZSR0eXBlcyA9IHVuaW9uTm9kZS50eXBlcykgIT09IG51bGwgJiYgX3VuaW9uTm9kZSR0eXBlcyAhPT0gdm9pZCAwID8gX3VuaW9uTm9kZSR0eXBlcyA6IFtdXG4gICAgKTtcbiAgfSkuZmlsdGVyKCh0eXBlTm9kZSkgPT4gdHlwZU5vZGUubmFtZS52YWx1ZSA9PT0gdHlwZU5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0RGVwcmVjYXRlZERpcmVjdGl2ZU5vZGUoZGVmaW5pdGlvbk5vZGUpIHtcbiAgdmFyIF9kZWZpbml0aW9uTm9kZSRkaXJlYztcbiAgcmV0dXJuIGRlZmluaXRpb25Ob2RlID09PSBudWxsIHx8IGRlZmluaXRpb25Ob2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2RlZmluaXRpb25Ob2RlJGRpcmVjID0gZGVmaW5pdGlvbk5vZGUuZGlyZWN0aXZlcykgPT09IG51bGwgfHwgX2RlZmluaXRpb25Ob2RlJGRpcmVjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGVmaW5pdGlvbk5vZGUkZGlyZWMuZmluZChcbiAgICAobm9kZSkgPT4gbm9kZS5uYW1lLnZhbHVlID09PSBHcmFwaFFMRGVwcmVjYXRlZERpcmVjdGl2ZS5uYW1lXG4gICk7XG59XG52YXIgU2NoZW1hVmFsaWRhdGlvbkNvbnRleHQ7XG52YXIgaW5pdF92YWxpZGF0ZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC90eXBlL3ZhbGlkYXRlLm1qc1wiKCkge1xuICAgIGluaXRfaW5zcGVjdCgpO1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gICAgaW5pdF9hc3QoKTtcbiAgICBpbml0X3R5cGVDb21wYXJhdG9ycygpO1xuICAgIGluaXRfZGVmaW5pdGlvbigpO1xuICAgIGluaXRfZGlyZWN0aXZlcygpO1xuICAgIGluaXRfaW50cm9zcGVjdGlvbigpO1xuICAgIGluaXRfc2NoZW1hKCk7XG4gICAgU2NoZW1hVmFsaWRhdGlvbkNvbnRleHQgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgfVxuICAgICAgcmVwb3J0RXJyb3IobWVzc2FnZSwgbm9kZXMpIHtcbiAgICAgICAgY29uc3QgX25vZGVzID0gQXJyYXkuaXNBcnJheShub2RlcykgPyBub2Rlcy5maWx0ZXIoQm9vbGVhbikgOiBub2RlcztcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihtZXNzYWdlLCB7XG4gICAgICAgICAgICBub2RlczogX25vZGVzXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGdldEVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9ycztcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdHlwZS9pbmRleC5tanNcbnZhciBpbml0X3R5cGUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdHlwZS9pbmRleC5tanNcIigpIHtcbiAgICBpbml0X3NjaGVtYSgpO1xuICAgIGluaXRfZGVmaW5pdGlvbigpO1xuICAgIGluaXRfZGlyZWN0aXZlcygpO1xuICAgIGluaXRfc2NhbGFycygpO1xuICAgIGluaXRfaW50cm9zcGVjdGlvbigpO1xuICAgIGluaXRfdmFsaWRhdGUoKTtcbiAgICBpbml0X2Fzc2VydE5hbWUoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3ByZWRpY2F0ZXMubWpzXG5mdW5jdGlvbiBpc0RlZmluaXRpb25Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIGlzRXhlY3V0YWJsZURlZmluaXRpb25Ob2RlKG5vZGUpIHx8IGlzVHlwZVN5c3RlbURlZmluaXRpb25Ob2RlKG5vZGUpIHx8IGlzVHlwZVN5c3RlbUV4dGVuc2lvbk5vZGUobm9kZSk7XG59XG5mdW5jdGlvbiBpc0V4ZWN1dGFibGVEZWZpbml0aW9uTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLmtpbmQgPT09IEtpbmQuT1BFUkFUSU9OX0RFRklOSVRJT04gfHwgbm9kZS5raW5kID09PSBLaW5kLkZSQUdNRU5UX0RFRklOSVRJT047XG59XG5mdW5jdGlvbiBpc1NlbGVjdGlvbk5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5raW5kID09PSBLaW5kLkZJRUxEIHx8IG5vZGUua2luZCA9PT0gS2luZC5GUkFHTUVOVF9TUFJFQUQgfHwgbm9kZS5raW5kID09PSBLaW5kLklOTElORV9GUkFHTUVOVDtcbn1cbmZ1bmN0aW9uIGlzVmFsdWVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUua2luZCA9PT0gS2luZC5WQVJJQUJMRSB8fCBub2RlLmtpbmQgPT09IEtpbmQuSU5UIHx8IG5vZGUua2luZCA9PT0gS2luZC5GTE9BVCB8fCBub2RlLmtpbmQgPT09IEtpbmQuU1RSSU5HIHx8IG5vZGUua2luZCA9PT0gS2luZC5CT09MRUFOIHx8IG5vZGUua2luZCA9PT0gS2luZC5OVUxMIHx8IG5vZGUua2luZCA9PT0gS2luZC5FTlVNIHx8IG5vZGUua2luZCA9PT0gS2luZC5MSVNUIHx8IG5vZGUua2luZCA9PT0gS2luZC5PQkpFQ1Q7XG59XG5mdW5jdGlvbiBpc0NvbnN0VmFsdWVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIGlzVmFsdWVOb2RlKG5vZGUpICYmIChub2RlLmtpbmQgPT09IEtpbmQuTElTVCA/IG5vZGUudmFsdWVzLnNvbWUoaXNDb25zdFZhbHVlTm9kZSkgOiBub2RlLmtpbmQgPT09IEtpbmQuT0JKRUNUID8gbm9kZS5maWVsZHMuc29tZSgoZmllbGQpID0+IGlzQ29uc3RWYWx1ZU5vZGUoZmllbGQudmFsdWUpKSA6IG5vZGUua2luZCAhPT0gS2luZC5WQVJJQUJMRSk7XG59XG5mdW5jdGlvbiBpc1R5cGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUua2luZCA9PT0gS2luZC5OQU1FRF9UWVBFIHx8IG5vZGUua2luZCA9PT0gS2luZC5MSVNUX1RZUEUgfHwgbm9kZS5raW5kID09PSBLaW5kLk5PTl9OVUxMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1R5cGVTeXN0ZW1EZWZpbml0aW9uTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLmtpbmQgPT09IEtpbmQuU0NIRU1BX0RFRklOSVRJT04gfHwgaXNUeXBlRGVmaW5pdGlvbk5vZGUobm9kZSkgfHwgbm9kZS5raW5kID09PSBLaW5kLkRJUkVDVElWRV9ERUZJTklUSU9OO1xufVxuZnVuY3Rpb24gaXNUeXBlRGVmaW5pdGlvbk5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5raW5kID09PSBLaW5kLlNDQUxBUl9UWVBFX0RFRklOSVRJT04gfHwgbm9kZS5raW5kID09PSBLaW5kLk9CSkVDVF9UWVBFX0RFRklOSVRJT04gfHwgbm9kZS5raW5kID09PSBLaW5kLklOVEVSRkFDRV9UWVBFX0RFRklOSVRJT04gfHwgbm9kZS5raW5kID09PSBLaW5kLlVOSU9OX1RZUEVfREVGSU5JVElPTiB8fCBub2RlLmtpbmQgPT09IEtpbmQuRU5VTV9UWVBFX0RFRklOSVRJT04gfHwgbm9kZS5raW5kID09PSBLaW5kLklOUFVUX09CSkVDVF9UWVBFX0RFRklOSVRJT047XG59XG5mdW5jdGlvbiBpc1R5cGVTeXN0ZW1FeHRlbnNpb25Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUua2luZCA9PT0gS2luZC5TQ0hFTUFfRVhURU5TSU9OIHx8IGlzVHlwZUV4dGVuc2lvbk5vZGUobm9kZSk7XG59XG5mdW5jdGlvbiBpc1R5cGVFeHRlbnNpb25Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUua2luZCA9PT0gS2luZC5TQ0FMQVJfVFlQRV9FWFRFTlNJT04gfHwgbm9kZS5raW5kID09PSBLaW5kLk9CSkVDVF9UWVBFX0VYVEVOU0lPTiB8fCBub2RlLmtpbmQgPT09IEtpbmQuSU5URVJGQUNFX1RZUEVfRVhURU5TSU9OIHx8IG5vZGUua2luZCA9PT0gS2luZC5VTklPTl9UWVBFX0VYVEVOU0lPTiB8fCBub2RlLmtpbmQgPT09IEtpbmQuRU5VTV9UWVBFX0VYVEVOU0lPTiB8fCBub2RlLmtpbmQgPT09IEtpbmQuSU5QVVRfT0JKRUNUX1RZUEVfRVhURU5TSU9OO1xufVxudmFyIGluaXRfcHJlZGljYXRlcyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9wcmVkaWNhdGVzLm1qc1wiKCkge1xuICAgIGluaXRfa2luZHMoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2luZGV4Lm1qc1xudmFyIGluaXRfbGFuZ3VhZ2UgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvaW5kZXgubWpzXCIoKSB7XG4gICAgaW5pdF9zb3VyY2UoKTtcbiAgICBpbml0X2xvY2F0aW9uKCk7XG4gICAgaW5pdF9wcmludExvY2F0aW9uKCk7XG4gICAgaW5pdF9raW5kcygpO1xuICAgIGluaXRfdG9rZW5LaW5kKCk7XG4gICAgaW5pdF9sZXhlcigpO1xuICAgIGluaXRfcGFyc2VyKCk7XG4gICAgaW5pdF9wcmludGVyKCk7XG4gICAgaW5pdF92aXNpdG9yKCk7XG4gICAgaW5pdF9hc3QoKTtcbiAgICBpbml0X3ByZWRpY2F0ZXMoKTtcbiAgICBpbml0X2RpcmVjdGl2ZUxvY2F0aW9uKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC92ZXJzaW9uLm1qc1xudmFyIHZlcnNpb24sIHZlcnNpb25JbmZvO1xudmFyIGluaXRfdmVyc2lvbiA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC92ZXJzaW9uLm1qc1wiKCkge1xuICAgIHZlcnNpb24gPSBcIjE2LjguMFwiO1xuICAgIHZlcnNpb25JbmZvID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBtYWpvcjogMTYsXG4gICAgICBtaW5vcjogOCxcbiAgICAgIHBhdGNoOiAwLFxuICAgICAgcHJlUmVsZWFzZVRhZzogbnVsbFxuICAgIH0pO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9pc1Byb21pc2UubWpzXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnRoZW4pID09PSBcImZ1bmN0aW9uXCI7XG59XG52YXIgaW5pdF9pc1Byb21pc2UgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9pc1Byb21pc2UubWpzXCIoKSB7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvdHlwZUZyb21BU1QubWpzXG5mdW5jdGlvbiB0eXBlRnJvbUFTVChzY2hlbWEsIHR5cGVOb2RlKSB7XG4gIHN3aXRjaCAodHlwZU5vZGUua2luZCkge1xuICAgIGNhc2UgS2luZC5MSVNUX1RZUEU6IHtcbiAgICAgIGNvbnN0IGlubmVyVHlwZSA9IHR5cGVGcm9tQVNUKHNjaGVtYSwgdHlwZU5vZGUudHlwZSk7XG4gICAgICByZXR1cm4gaW5uZXJUeXBlICYmIG5ldyBHcmFwaFFMTGlzdChpbm5lclR5cGUpO1xuICAgIH1cbiAgICBjYXNlIEtpbmQuTk9OX05VTExfVFlQRToge1xuICAgICAgY29uc3QgaW5uZXJUeXBlID0gdHlwZUZyb21BU1Qoc2NoZW1hLCB0eXBlTm9kZS50eXBlKTtcbiAgICAgIHJldHVybiBpbm5lclR5cGUgJiYgbmV3IEdyYXBoUUxOb25OdWxsKGlubmVyVHlwZSk7XG4gICAgfVxuICAgIGNhc2UgS2luZC5OQU1FRF9UWVBFOlxuICAgICAgcmV0dXJuIHNjaGVtYS5nZXRUeXBlKHR5cGVOb2RlLm5hbWUudmFsdWUpO1xuICB9XG59XG52YXIgaW5pdF90eXBlRnJvbUFTVCA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvdHlwZUZyb21BU1QubWpzXCIoKSB7XG4gICAgaW5pdF9raW5kcygpO1xuICAgIGluaXRfZGVmaW5pdGlvbigpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdXRpbGl0aWVzL1R5cGVJbmZvLm1qc1xuZnVuY3Rpb24gZ2V0RmllbGREZWYoc2NoZW1hLCBwYXJlbnRUeXBlLCBmaWVsZE5vZGUpIHtcbiAgY29uc3QgbmFtZSA9IGZpZWxkTm9kZS5uYW1lLnZhbHVlO1xuICBpZiAobmFtZSA9PT0gU2NoZW1hTWV0YUZpZWxkRGVmLm5hbWUgJiYgc2NoZW1hLmdldFF1ZXJ5VHlwZSgpID09PSBwYXJlbnRUeXBlKSB7XG4gICAgcmV0dXJuIFNjaGVtYU1ldGFGaWVsZERlZjtcbiAgfVxuICBpZiAobmFtZSA9PT0gVHlwZU1ldGFGaWVsZERlZi5uYW1lICYmIHNjaGVtYS5nZXRRdWVyeVR5cGUoKSA9PT0gcGFyZW50VHlwZSkge1xuICAgIHJldHVybiBUeXBlTWV0YUZpZWxkRGVmO1xuICB9XG4gIGlmIChuYW1lID09PSBUeXBlTmFtZU1ldGFGaWVsZERlZi5uYW1lICYmIGlzQ29tcG9zaXRlVHlwZShwYXJlbnRUeXBlKSkge1xuICAgIHJldHVybiBUeXBlTmFtZU1ldGFGaWVsZERlZjtcbiAgfVxuICBpZiAoaXNPYmplY3RUeXBlKHBhcmVudFR5cGUpIHx8IGlzSW50ZXJmYWNlVHlwZShwYXJlbnRUeXBlKSkge1xuICAgIHJldHVybiBwYXJlbnRUeXBlLmdldEZpZWxkcygpW25hbWVdO1xuICB9XG59XG5mdW5jdGlvbiB2aXNpdFdpdGhUeXBlSW5mbyh0eXBlSW5mbywgdmlzaXRvcikge1xuICByZXR1cm4ge1xuICAgIGVudGVyKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBhcmdzWzBdO1xuICAgICAgdHlwZUluZm8uZW50ZXIobm9kZSk7XG4gICAgICBjb25zdCBmbiA9IGdldEVudGVyTGVhdmVGb3JLaW5kKHZpc2l0b3IsIG5vZGUua2luZCkuZW50ZXI7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4uYXBwbHkodmlzaXRvciwgYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHR5cGVJbmZvLmxlYXZlKG5vZGUpO1xuICAgICAgICAgIGlmIChpc05vZGUocmVzdWx0KSkge1xuICAgICAgICAgICAgdHlwZUluZm8uZW50ZXIocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxlYXZlKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBhcmdzWzBdO1xuICAgICAgY29uc3QgZm4gPSBnZXRFbnRlckxlYXZlRm9yS2luZCh2aXNpdG9yLCBub2RlLmtpbmQpLmxlYXZlO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGlmIChmbikge1xuICAgICAgICByZXN1bHQgPSBmbi5hcHBseSh2aXNpdG9yLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHR5cGVJbmZvLmxlYXZlKG5vZGUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG52YXIgVHlwZUluZm87XG52YXIgaW5pdF9UeXBlSW5mbyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvVHlwZUluZm8ubWpzXCIoKSB7XG4gICAgaW5pdF9hc3QoKTtcbiAgICBpbml0X2tpbmRzKCk7XG4gICAgaW5pdF92aXNpdG9yKCk7XG4gICAgaW5pdF9kZWZpbml0aW9uKCk7XG4gICAgaW5pdF9pbnRyb3NwZWN0aW9uKCk7XG4gICAgaW5pdF90eXBlRnJvbUFTVCgpO1xuICAgIFR5cGVJbmZvID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3Ioc2NoZW1hLCBpbml0aWFsVHlwZSwgZ2V0RmllbGREZWZGbikge1xuICAgICAgICB0aGlzLl9zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuX3R5cGVTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJlbnRUeXBlU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5faW5wdXRUeXBlU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5fZmllbGREZWZTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWVTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9hcmd1bWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2VudW1WYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2dldEZpZWxkRGVmID0gZ2V0RmllbGREZWZGbiAhPT0gbnVsbCAmJiBnZXRGaWVsZERlZkZuICE9PSB2b2lkIDAgPyBnZXRGaWVsZERlZkZuIDogZ2V0RmllbGREZWY7XG4gICAgICAgIGlmIChpbml0aWFsVHlwZSkge1xuICAgICAgICAgIGlmIChpc0lucHV0VHlwZShpbml0aWFsVHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0VHlwZVN0YWNrLnB1c2goaW5pdGlhbFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb21wb3NpdGVUeXBlKGluaXRpYWxUeXBlKSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50VHlwZVN0YWNrLnB1c2goaW5pdGlhbFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNPdXRwdXRUeXBlKGluaXRpYWxUeXBlKSkge1xuICAgICAgICAgICAgdGhpcy5fdHlwZVN0YWNrLnB1c2goaW5pdGlhbFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJUeXBlSW5mb1wiO1xuICAgICAgfVxuICAgICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R5cGVTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGVTdGFja1t0aGlzLl90eXBlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdldFBhcmVudFR5cGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnRUeXBlU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRUeXBlU3RhY2tbdGhpcy5fcGFyZW50VHlwZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXRJbnB1dFR5cGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dFR5cGVTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0VHlwZVN0YWNrW3RoaXMuX2lucHV0VHlwZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXRQYXJlbnRJbnB1dFR5cGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dFR5cGVTdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0VHlwZVN0YWNrW3RoaXMuX2lucHV0VHlwZVN0YWNrLmxlbmd0aCAtIDJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXRGaWVsZERlZigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZpZWxkRGVmU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9maWVsZERlZlN0YWNrW3RoaXMuX2ZpZWxkRGVmU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdldERlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZmF1bHRWYWx1ZVN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFZhbHVlU3RhY2tbdGhpcy5fZGVmYXVsdFZhbHVlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdldERpcmVjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcmVjdGl2ZTtcbiAgICAgIH1cbiAgICAgIGdldEFyZ3VtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJndW1lbnQ7XG4gICAgICB9XG4gICAgICBnZXRFbnVtVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbnVtVmFsdWU7XG4gICAgICB9XG4gICAgICBlbnRlcihub2RlKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX3NjaGVtYTtcbiAgICAgICAgc3dpdGNoIChub2RlLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIEtpbmQuU0VMRUNUSU9OX1NFVDoge1xuICAgICAgICAgICAgY29uc3QgbmFtZWRUeXBlID0gZ2V0TmFtZWRUeXBlKHRoaXMuZ2V0VHlwZSgpKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudFR5cGVTdGFjay5wdXNoKFxuICAgICAgICAgICAgICBpc0NvbXBvc2l0ZVR5cGUobmFtZWRUeXBlKSA/IG5hbWVkVHlwZSA6IHZvaWQgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEtpbmQuRklFTEQ6IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFR5cGUgPSB0aGlzLmdldFBhcmVudFR5cGUoKTtcbiAgICAgICAgICAgIGxldCBmaWVsZERlZjtcbiAgICAgICAgICAgIGxldCBmaWVsZFR5cGU7XG4gICAgICAgICAgICBpZiAocGFyZW50VHlwZSkge1xuICAgICAgICAgICAgICBmaWVsZERlZiA9IHRoaXMuX2dldEZpZWxkRGVmKHNjaGVtYSwgcGFyZW50VHlwZSwgbm9kZSk7XG4gICAgICAgICAgICAgIGlmIChmaWVsZERlZikge1xuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSA9IGZpZWxkRGVmLnR5cGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkRGVmU3RhY2sucHVzaChmaWVsZERlZik7XG4gICAgICAgICAgICB0aGlzLl90eXBlU3RhY2sucHVzaChpc091dHB1dFR5cGUoZmllbGRUeXBlKSA/IGZpZWxkVHlwZSA6IHZvaWQgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBLaW5kLkRJUkVDVElWRTpcbiAgICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZSA9IHNjaGVtYS5nZXREaXJlY3RpdmUobm9kZS5uYW1lLnZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgS2luZC5PUEVSQVRJT05fREVGSU5JVElPTjoge1xuICAgICAgICAgICAgY29uc3Qgcm9vdFR5cGUgPSBzY2hlbWEuZ2V0Um9vdFR5cGUobm9kZS5vcGVyYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5fdHlwZVN0YWNrLnB1c2goaXNPYmplY3RUeXBlKHJvb3RUeXBlKSA/IHJvb3RUeXBlIDogdm9pZCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEtpbmQuSU5MSU5FX0ZSQUdNRU5UOlxuICAgICAgICAgIGNhc2UgS2luZC5GUkFHTUVOVF9ERUZJTklUSU9OOiB7XG4gICAgICAgICAgICBjb25zdCB0eXBlQ29uZGl0aW9uQVNUID0gbm9kZS50eXBlQ29uZGl0aW9uO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0VHlwZSA9IHR5cGVDb25kaXRpb25BU1QgPyB0eXBlRnJvbUFTVChzY2hlbWEsIHR5cGVDb25kaXRpb25BU1QpIDogZ2V0TmFtZWRUeXBlKHRoaXMuZ2V0VHlwZSgpKTtcbiAgICAgICAgICAgIHRoaXMuX3R5cGVTdGFjay5wdXNoKGlzT3V0cHV0VHlwZShvdXRwdXRUeXBlKSA/IG91dHB1dFR5cGUgOiB2b2lkIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgS2luZC5WQVJJQUJMRV9ERUZJTklUSU9OOiB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFR5cGUgPSB0eXBlRnJvbUFTVChzY2hlbWEsIG5vZGUudHlwZSk7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dFR5cGVTdGFjay5wdXNoKFxuICAgICAgICAgICAgICBpc0lucHV0VHlwZShpbnB1dFR5cGUpID8gaW5wdXRUeXBlIDogdm9pZCAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgS2luZC5BUkdVTUVOVDoge1xuICAgICAgICAgICAgdmFyIF90aGlzJGdldERpcmVjdGl2ZTtcbiAgICAgICAgICAgIGxldCBhcmdEZWY7XG4gICAgICAgICAgICBsZXQgYXJnVHlwZTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkT3JEaXJlY3RpdmUgPSAoX3RoaXMkZ2V0RGlyZWN0aXZlID0gdGhpcy5nZXREaXJlY3RpdmUoKSkgIT09IG51bGwgJiYgX3RoaXMkZ2V0RGlyZWN0aXZlICE9PSB2b2lkIDAgPyBfdGhpcyRnZXREaXJlY3RpdmUgOiB0aGlzLmdldEZpZWxkRGVmKCk7XG4gICAgICAgICAgICBpZiAoZmllbGRPckRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICBhcmdEZWYgPSBmaWVsZE9yRGlyZWN0aXZlLmFyZ3MuZmluZChcbiAgICAgICAgICAgICAgICAoYXJnKSA9PiBhcmcubmFtZSA9PT0gbm9kZS5uYW1lLnZhbHVlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChhcmdEZWYpIHtcbiAgICAgICAgICAgICAgICBhcmdUeXBlID0gYXJnRGVmLnR5cGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FyZ3VtZW50ID0gYXJnRGVmO1xuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlU3RhY2sucHVzaChhcmdEZWYgPyBhcmdEZWYuZGVmYXVsdFZhbHVlIDogdm9pZCAwKTtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0VHlwZVN0YWNrLnB1c2goaXNJbnB1dFR5cGUoYXJnVHlwZSkgPyBhcmdUeXBlIDogdm9pZCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEtpbmQuTElTVDoge1xuICAgICAgICAgICAgY29uc3QgbGlzdFR5cGUgPSBnZXROdWxsYWJsZVR5cGUodGhpcy5nZXRJbnB1dFR5cGUoKSk7XG4gICAgICAgICAgICBjb25zdCBpdGVtVHlwZSA9IGlzTGlzdFR5cGUobGlzdFR5cGUpID8gbGlzdFR5cGUub2ZUeXBlIDogbGlzdFR5cGU7XG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWVTdGFjay5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dFR5cGVTdGFjay5wdXNoKGlzSW5wdXRUeXBlKGl0ZW1UeXBlKSA/IGl0ZW1UeXBlIDogdm9pZCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEtpbmQuT0JKRUNUX0ZJRUxEOiB7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RUeXBlID0gZ2V0TmFtZWRUeXBlKHRoaXMuZ2V0SW5wdXRUeXBlKCkpO1xuICAgICAgICAgICAgbGV0IGlucHV0RmllbGRUeXBlO1xuICAgICAgICAgICAgbGV0IGlucHV0RmllbGQ7XG4gICAgICAgICAgICBpZiAoaXNJbnB1dE9iamVjdFR5cGUob2JqZWN0VHlwZSkpIHtcbiAgICAgICAgICAgICAgaW5wdXRGaWVsZCA9IG9iamVjdFR5cGUuZ2V0RmllbGRzKClbbm9kZS5uYW1lLnZhbHVlXTtcbiAgICAgICAgICAgICAgaWYgKGlucHV0RmllbGQpIHtcbiAgICAgICAgICAgICAgICBpbnB1dEZpZWxkVHlwZSA9IGlucHV0RmllbGQudHlwZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlU3RhY2sucHVzaChcbiAgICAgICAgICAgICAgaW5wdXRGaWVsZCA/IGlucHV0RmllbGQuZGVmYXVsdFZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5faW5wdXRUeXBlU3RhY2sucHVzaChcbiAgICAgICAgICAgICAgaXNJbnB1dFR5cGUoaW5wdXRGaWVsZFR5cGUpID8gaW5wdXRGaWVsZFR5cGUgOiB2b2lkIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBLaW5kLkVOVU06IHtcbiAgICAgICAgICAgIGNvbnN0IGVudW1UeXBlID0gZ2V0TmFtZWRUeXBlKHRoaXMuZ2V0SW5wdXRUeXBlKCkpO1xuICAgICAgICAgICAgbGV0IGVudW1WYWx1ZTtcbiAgICAgICAgICAgIGlmIChpc0VudW1UeXBlKGVudW1UeXBlKSkge1xuICAgICAgICAgICAgICBlbnVtVmFsdWUgPSBlbnVtVHlwZS5nZXRWYWx1ZShub2RlLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2VudW1WYWx1ZSA9IGVudW1WYWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZWF2ZShub2RlKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS5raW5kKSB7XG4gICAgICAgICAgY2FzZSBLaW5kLlNFTEVDVElPTl9TRVQ6XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRUeXBlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEtpbmQuRklFTEQ6XG4gICAgICAgICAgICB0aGlzLl9maWVsZERlZlN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5fdHlwZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBLaW5kLkRJUkVDVElWRTpcbiAgICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZSA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEtpbmQuT1BFUkFUSU9OX0RFRklOSVRJT046XG4gICAgICAgICAgY2FzZSBLaW5kLklOTElORV9GUkFHTUVOVDpcbiAgICAgICAgICBjYXNlIEtpbmQuRlJBR01FTlRfREVGSU5JVElPTjpcbiAgICAgICAgICAgIHRoaXMuX3R5cGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgS2luZC5WQVJJQUJMRV9ERUZJTklUSU9OOlxuICAgICAgICAgICAgdGhpcy5faW5wdXRUeXBlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEtpbmQuQVJHVU1FTlQ6XG4gICAgICAgICAgICB0aGlzLl9hcmd1bWVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0VHlwZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBLaW5kLkxJU1Q6XG4gICAgICAgICAgY2FzZSBLaW5kLk9CSkVDVF9GSUVMRDpcbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5faW5wdXRUeXBlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEtpbmQuRU5VTTpcbiAgICAgICAgICAgIHRoaXMuX2VudW1WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvRXhlY3V0YWJsZURlZmluaXRpb25zUnVsZS5tanNcbmZ1bmN0aW9uIEV4ZWN1dGFibGVEZWZpbml0aW9uc1J1bGUoY29udGV4dCkge1xuICByZXR1cm4ge1xuICAgIERvY3VtZW50KG5vZGUpIHtcbiAgICAgIGZvciAoY29uc3QgZGVmaW5pdGlvbiBvZiBub2RlLmRlZmluaXRpb25zKSB7XG4gICAgICAgIGlmICghaXNFeGVjdXRhYmxlRGVmaW5pdGlvbk5vZGUoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBjb25zdCBkZWZOYW1lID0gZGVmaW5pdGlvbi5raW5kID09PSBLaW5kLlNDSEVNQV9ERUZJTklUSU9OIHx8IGRlZmluaXRpb24ua2luZCA9PT0gS2luZC5TQ0hFTUFfRVhURU5TSU9OID8gXCJzY2hlbWFcIiA6ICdcIicgKyBkZWZpbml0aW9uLm5hbWUudmFsdWUgKyAnXCInO1xuICAgICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKGBUaGUgJHtkZWZOYW1lfSBkZWZpbml0aW9uIGlzIG5vdCBleGVjdXRhYmxlLmAsIHtcbiAgICAgICAgICAgICAgbm9kZXM6IGRlZmluaXRpb25cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cbnZhciBpbml0X0V4ZWN1dGFibGVEZWZpbml0aW9uc1J1bGUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9FeGVjdXRhYmxlRGVmaW5pdGlvbnNSdWxlLm1qc1wiKCkge1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gICAgaW5pdF9raW5kcygpO1xuICAgIGluaXRfcHJlZGljYXRlcygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9GaWVsZHNPbkNvcnJlY3RUeXBlUnVsZS5tanNcbmZ1bmN0aW9uIEZpZWxkc09uQ29ycmVjdFR5cGVSdWxlKGNvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICBGaWVsZChub2RlKSB7XG4gICAgICBjb25zdCB0eXBlID0gY29udGV4dC5nZXRQYXJlbnRUeXBlKCk7XG4gICAgICBpZiAodHlwZSkge1xuICAgICAgICBjb25zdCBmaWVsZERlZiA9IGNvbnRleHQuZ2V0RmllbGREZWYoKTtcbiAgICAgICAgaWYgKCFmaWVsZERlZikge1xuICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IGNvbnRleHQuZ2V0U2NoZW1hKCk7XG4gICAgICAgICAgY29uc3QgZmllbGROYW1lID0gbm9kZS5uYW1lLnZhbHVlO1xuICAgICAgICAgIGxldCBzdWdnZXN0aW9uID0gZGlkWW91TWVhbihcbiAgICAgICAgICAgIFwidG8gdXNlIGFuIGlubGluZSBmcmFnbWVudCBvblwiLFxuICAgICAgICAgICAgZ2V0U3VnZ2VzdGVkVHlwZU5hbWVzKHNjaGVtYSwgdHlwZSwgZmllbGROYW1lKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHN1Z2dlc3Rpb24gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHN1Z2dlc3Rpb24gPSBkaWRZb3VNZWFuKGdldFN1Z2dlc3RlZEZpZWxkTmFtZXModHlwZSwgZmllbGROYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgICBgQ2Fubm90IHF1ZXJ5IGZpZWxkIFwiJHtmaWVsZE5hbWV9XCIgb24gdHlwZSBcIiR7dHlwZS5uYW1lfVwiLmAgKyBzdWdnZXN0aW9uLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm9kZXM6IG5vZGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRTdWdnZXN0ZWRUeXBlTmFtZXMoc2NoZW1hLCB0eXBlLCBmaWVsZE5hbWUpIHtcbiAgaWYgKCFpc0Fic3RyYWN0VHlwZSh0eXBlKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBzdWdnZXN0ZWRUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHVzYWdlQ291bnQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBwb3NzaWJsZVR5cGUgb2Ygc2NoZW1hLmdldFBvc3NpYmxlVHlwZXModHlwZSkpIHtcbiAgICBpZiAoIXBvc3NpYmxlVHlwZS5nZXRGaWVsZHMoKVtmaWVsZE5hbWVdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc3VnZ2VzdGVkVHlwZXMuYWRkKHBvc3NpYmxlVHlwZSk7XG4gICAgdXNhZ2VDb3VudFtwb3NzaWJsZVR5cGUubmFtZV0gPSAxO1xuICAgIGZvciAoY29uc3QgcG9zc2libGVJbnRlcmZhY2Ugb2YgcG9zc2libGVUeXBlLmdldEludGVyZmFjZXMoKSkge1xuICAgICAgdmFyIF91c2FnZUNvdW50JHBvc3NpYmxlSTtcbiAgICAgIGlmICghcG9zc2libGVJbnRlcmZhY2UuZ2V0RmllbGRzKClbZmllbGROYW1lXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN1Z2dlc3RlZFR5cGVzLmFkZChwb3NzaWJsZUludGVyZmFjZSk7XG4gICAgICB1c2FnZUNvdW50W3Bvc3NpYmxlSW50ZXJmYWNlLm5hbWVdID0gKChfdXNhZ2VDb3VudCRwb3NzaWJsZUkgPSB1c2FnZUNvdW50W3Bvc3NpYmxlSW50ZXJmYWNlLm5hbWVdKSAhPT0gbnVsbCAmJiBfdXNhZ2VDb3VudCRwb3NzaWJsZUkgIT09IHZvaWQgMCA/IF91c2FnZUNvdW50JHBvc3NpYmxlSSA6IDApICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi5zdWdnZXN0ZWRUeXBlc10uc29ydCgodHlwZUEsIHR5cGVCKSA9PiB7XG4gICAgY29uc3QgdXNhZ2VDb3VudERpZmYgPSB1c2FnZUNvdW50W3R5cGVCLm5hbWVdIC0gdXNhZ2VDb3VudFt0eXBlQS5uYW1lXTtcbiAgICBpZiAodXNhZ2VDb3VudERpZmYgIT09IDApIHtcbiAgICAgIHJldHVybiB1c2FnZUNvdW50RGlmZjtcbiAgICB9XG4gICAgaWYgKGlzSW50ZXJmYWNlVHlwZSh0eXBlQSkgJiYgc2NoZW1hLmlzU3ViVHlwZSh0eXBlQSwgdHlwZUIpKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChpc0ludGVyZmFjZVR5cGUodHlwZUIpICYmIHNjaGVtYS5pc1N1YlR5cGUodHlwZUIsIHR5cGVBKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBuYXR1cmFsQ29tcGFyZSh0eXBlQS5uYW1lLCB0eXBlQi5uYW1lKTtcbiAgfSkubWFwKCh4KSA9PiB4Lm5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0U3VnZ2VzdGVkRmllbGROYW1lcyh0eXBlLCBmaWVsZE5hbWUpIHtcbiAgaWYgKGlzT2JqZWN0VHlwZSh0eXBlKSB8fCBpc0ludGVyZmFjZVR5cGUodHlwZSkpIHtcbiAgICBjb25zdCBwb3NzaWJsZUZpZWxkTmFtZXMgPSBPYmplY3Qua2V5cyh0eXBlLmdldEZpZWxkcygpKTtcbiAgICByZXR1cm4gc3VnZ2VzdGlvbkxpc3QoZmllbGROYW1lLCBwb3NzaWJsZUZpZWxkTmFtZXMpO1xuICB9XG4gIHJldHVybiBbXTtcbn1cbnZhciBpbml0X0ZpZWxkc09uQ29ycmVjdFR5cGVSdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvRmllbGRzT25Db3JyZWN0VHlwZVJ1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9kaWRZb3VNZWFuKCk7XG4gICAgaW5pdF9uYXR1cmFsQ29tcGFyZSgpO1xuICAgIGluaXRfc3VnZ2VzdGlvbkxpc3QoKTtcbiAgICBpbml0X0dyYXBoUUxFcnJvcigpO1xuICAgIGluaXRfZGVmaW5pdGlvbigpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9GcmFnbWVudHNPbkNvbXBvc2l0ZVR5cGVzUnVsZS5tanNcbmZ1bmN0aW9uIEZyYWdtZW50c09uQ29tcG9zaXRlVHlwZXNSdWxlKGNvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICBJbmxpbmVGcmFnbWVudChub2RlKSB7XG4gICAgICBjb25zdCB0eXBlQ29uZGl0aW9uID0gbm9kZS50eXBlQ29uZGl0aW9uO1xuICAgICAgaWYgKHR5cGVDb25kaXRpb24pIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVGcm9tQVNUKGNvbnRleHQuZ2V0U2NoZW1hKCksIHR5cGVDb25kaXRpb24pO1xuICAgICAgICBpZiAodHlwZSAmJiAhaXNDb21wb3NpdGVUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgY29uc3QgdHlwZVN0ciA9IHByaW50KHR5cGVDb25kaXRpb24pO1xuICAgICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgICBgRnJhZ21lbnQgY2Fubm90IGNvbmRpdGlvbiBvbiBub24gY29tcG9zaXRlIHR5cGUgXCIke3R5cGVTdHJ9XCIuYCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vZGVzOiB0eXBlQ29uZGl0aW9uXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBGcmFnbWVudERlZmluaXRpb24obm9kZSkge1xuICAgICAgY29uc3QgdHlwZSA9IHR5cGVGcm9tQVNUKGNvbnRleHQuZ2V0U2NoZW1hKCksIG5vZGUudHlwZUNvbmRpdGlvbik7XG4gICAgICBpZiAodHlwZSAmJiAhaXNDb21wb3NpdGVUeXBlKHR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHR5cGVTdHIgPSBwcmludChub2RlLnR5cGVDb25kaXRpb24pO1xuICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBgRnJhZ21lbnQgXCIke25vZGUubmFtZS52YWx1ZX1cIiBjYW5ub3QgY29uZGl0aW9uIG9uIG5vbiBjb21wb3NpdGUgdHlwZSBcIiR7dHlwZVN0cn1cIi5gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBub2Rlczogbm9kZS50eXBlQ29uZGl0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbnZhciBpbml0X0ZyYWdtZW50c09uQ29tcG9zaXRlVHlwZXNSdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvRnJhZ21lbnRzT25Db21wb3NpdGVUeXBlc1J1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgICBpbml0X3ByaW50ZXIoKTtcbiAgICBpbml0X2RlZmluaXRpb24oKTtcbiAgICBpbml0X3R5cGVGcm9tQVNUKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL0tub3duQXJndW1lbnROYW1lc1J1bGUubWpzXG5mdW5jdGlvbiBLbm93bkFyZ3VtZW50TmFtZXNSdWxlKGNvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICAgIC4uLktub3duQXJndW1lbnROYW1lc09uRGlyZWN0aXZlc1J1bGUoY29udGV4dCksXG4gICAgQXJndW1lbnQoYXJnTm9kZSkge1xuICAgICAgY29uc3QgYXJnRGVmID0gY29udGV4dC5nZXRBcmd1bWVudCgpO1xuICAgICAgY29uc3QgZmllbGREZWYgPSBjb250ZXh0LmdldEZpZWxkRGVmKCk7XG4gICAgICBjb25zdCBwYXJlbnRUeXBlID0gY29udGV4dC5nZXRQYXJlbnRUeXBlKCk7XG4gICAgICBpZiAoIWFyZ0RlZiAmJiBmaWVsZERlZiAmJiBwYXJlbnRUeXBlKSB7XG4gICAgICAgIGNvbnN0IGFyZ05hbWUgPSBhcmdOb2RlLm5hbWUudmFsdWU7XG4gICAgICAgIGNvbnN0IGtub3duQXJnc05hbWVzID0gZmllbGREZWYuYXJncy5tYXAoKGFyZykgPT4gYXJnLm5hbWUpO1xuICAgICAgICBjb25zdCBzdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25MaXN0KGFyZ05hbWUsIGtub3duQXJnc05hbWVzKTtcbiAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYFVua25vd24gYXJndW1lbnQgXCIke2FyZ05hbWV9XCIgb24gZmllbGQgXCIke3BhcmVudFR5cGUubmFtZX0uJHtmaWVsZERlZi5uYW1lfVwiLmAgKyBkaWRZb3VNZWFuKHN1Z2dlc3Rpb25zKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbm9kZXM6IGFyZ05vZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gS25vd25Bcmd1bWVudE5hbWVzT25EaXJlY3RpdmVzUnVsZShjb250ZXh0KSB7XG4gIGNvbnN0IGRpcmVjdGl2ZUFyZ3MgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgc2NoZW1hID0gY29udGV4dC5nZXRTY2hlbWEoKTtcbiAgY29uc3QgZGVmaW5lZERpcmVjdGl2ZXMgPSBzY2hlbWEgPyBzY2hlbWEuZ2V0RGlyZWN0aXZlcygpIDogc3BlY2lmaWVkRGlyZWN0aXZlcztcbiAgZm9yIChjb25zdCBkaXJlY3RpdmUgb2YgZGVmaW5lZERpcmVjdGl2ZXMpIHtcbiAgICBkaXJlY3RpdmVBcmdzW2RpcmVjdGl2ZS5uYW1lXSA9IGRpcmVjdGl2ZS5hcmdzLm1hcCgoYXJnKSA9PiBhcmcubmFtZSk7XG4gIH1cbiAgY29uc3QgYXN0RGVmaW5pdGlvbnMgPSBjb250ZXh0LmdldERvY3VtZW50KCkuZGVmaW5pdGlvbnM7XG4gIGZvciAoY29uc3QgZGVmIG9mIGFzdERlZmluaXRpb25zKSB7XG4gICAgaWYgKGRlZi5raW5kID09PSBLaW5kLkRJUkVDVElWRV9ERUZJTklUSU9OKSB7XG4gICAgICB2YXIgX2RlZiRhcmd1bWVudHM7XG4gICAgICBjb25zdCBhcmdzTm9kZXMgPSAoX2RlZiRhcmd1bWVudHMgPSBkZWYuYXJndW1lbnRzKSAhPT0gbnVsbCAmJiBfZGVmJGFyZ3VtZW50cyAhPT0gdm9pZCAwID8gX2RlZiRhcmd1bWVudHMgOiBbXTtcbiAgICAgIGRpcmVjdGl2ZUFyZ3NbZGVmLm5hbWUudmFsdWVdID0gYXJnc05vZGVzLm1hcCgoYXJnKSA9PiBhcmcubmFtZS52YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgRGlyZWN0aXZlKGRpcmVjdGl2ZU5vZGUpIHtcbiAgICAgIGNvbnN0IGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVOb2RlLm5hbWUudmFsdWU7XG4gICAgICBjb25zdCBrbm93bkFyZ3MgPSBkaXJlY3RpdmVBcmdzW2RpcmVjdGl2ZU5hbWVdO1xuICAgICAgaWYgKGRpcmVjdGl2ZU5vZGUuYXJndW1lbnRzICYmIGtub3duQXJncykge1xuICAgICAgICBmb3IgKGNvbnN0IGFyZ05vZGUgb2YgZGlyZWN0aXZlTm9kZS5hcmd1bWVudHMpIHtcbiAgICAgICAgICBjb25zdCBhcmdOYW1lID0gYXJnTm9kZS5uYW1lLnZhbHVlO1xuICAgICAgICAgIGlmICgha25vd25BcmdzLmluY2x1ZGVzKGFyZ05hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBzdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25MaXN0KGFyZ05hbWUsIGtub3duQXJncyk7XG4gICAgICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgICAgIGBVbmtub3duIGFyZ3VtZW50IFwiJHthcmdOYW1lfVwiIG9uIGRpcmVjdGl2ZSBcIkAke2RpcmVjdGl2ZU5hbWV9XCIuYCArIGRpZFlvdU1lYW4oc3VnZ2VzdGlvbnMpLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIG5vZGVzOiBhcmdOb2RlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cbnZhciBpbml0X0tub3duQXJndW1lbnROYW1lc1J1bGUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9Lbm93bkFyZ3VtZW50TmFtZXNSdWxlLm1qc1wiKCkge1xuICAgIGluaXRfZGlkWW91TWVhbigpO1xuICAgIGluaXRfc3VnZ2VzdGlvbkxpc3QoKTtcbiAgICBpbml0X0dyYXBoUUxFcnJvcigpO1xuICAgIGluaXRfa2luZHMoKTtcbiAgICBpbml0X2RpcmVjdGl2ZXMoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvS25vd25EaXJlY3RpdmVzUnVsZS5tanNcbmZ1bmN0aW9uIEtub3duRGlyZWN0aXZlc1J1bGUoY29udGV4dCkge1xuICBjb25zdCBsb2NhdGlvbnNNYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgc2NoZW1hID0gY29udGV4dC5nZXRTY2hlbWEoKTtcbiAgY29uc3QgZGVmaW5lZERpcmVjdGl2ZXMgPSBzY2hlbWEgPyBzY2hlbWEuZ2V0RGlyZWN0aXZlcygpIDogc3BlY2lmaWVkRGlyZWN0aXZlcztcbiAgZm9yIChjb25zdCBkaXJlY3RpdmUgb2YgZGVmaW5lZERpcmVjdGl2ZXMpIHtcbiAgICBsb2NhdGlvbnNNYXBbZGlyZWN0aXZlLm5hbWVdID0gZGlyZWN0aXZlLmxvY2F0aW9ucztcbiAgfVxuICBjb25zdCBhc3REZWZpbml0aW9ucyA9IGNvbnRleHQuZ2V0RG9jdW1lbnQoKS5kZWZpbml0aW9ucztcbiAgZm9yIChjb25zdCBkZWYgb2YgYXN0RGVmaW5pdGlvbnMpIHtcbiAgICBpZiAoZGVmLmtpbmQgPT09IEtpbmQuRElSRUNUSVZFX0RFRklOSVRJT04pIHtcbiAgICAgIGxvY2F0aW9uc01hcFtkZWYubmFtZS52YWx1ZV0gPSBkZWYubG9jYXRpb25zLm1hcCgobmFtZSkgPT4gbmFtZS52YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgRGlyZWN0aXZlKG5vZGUsIF9rZXksIF9wYXJlbnQsIF9wYXRoLCBhbmNlc3RvcnMpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWUudmFsdWU7XG4gICAgICBjb25zdCBsb2NhdGlvbnMgPSBsb2NhdGlvbnNNYXBbbmFtZV07XG4gICAgICBpZiAoIWxvY2F0aW9ucykge1xuICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoYFVua25vd24gZGlyZWN0aXZlIFwiQCR7bmFtZX1cIi5gLCB7XG4gICAgICAgICAgICBub2Rlczogbm9kZVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbmRpZGF0ZUxvY2F0aW9uID0gZ2V0RGlyZWN0aXZlTG9jYXRpb25Gb3JBU1RQYXRoKGFuY2VzdG9ycyk7XG4gICAgICBpZiAoY2FuZGlkYXRlTG9jYXRpb24gJiYgIWxvY2F0aW9ucy5pbmNsdWRlcyhjYW5kaWRhdGVMb2NhdGlvbikpIHtcbiAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYERpcmVjdGl2ZSBcIkAke25hbWV9XCIgbWF5IG5vdCBiZSB1c2VkIG9uICR7Y2FuZGlkYXRlTG9jYXRpb259LmAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5vZGVzOiBub2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERpcmVjdGl2ZUxvY2F0aW9uRm9yQVNUUGF0aChhbmNlc3RvcnMpIHtcbiAgY29uc3QgYXBwbGllZFRvID0gYW5jZXN0b3JzW2FuY2VzdG9ycy5sZW5ndGggLSAxXTtcbiAgXCJraW5kXCIgaW4gYXBwbGllZFRvIHx8IGludmFyaWFudChmYWxzZSk7XG4gIHN3aXRjaCAoYXBwbGllZFRvLmtpbmQpIHtcbiAgICBjYXNlIEtpbmQuT1BFUkFUSU9OX0RFRklOSVRJT046XG4gICAgICByZXR1cm4gZ2V0RGlyZWN0aXZlTG9jYXRpb25Gb3JPcGVyYXRpb24oYXBwbGllZFRvLm9wZXJhdGlvbik7XG4gICAgY2FzZSBLaW5kLkZJRUxEOlxuICAgICAgcmV0dXJuIERpcmVjdGl2ZUxvY2F0aW9uLkZJRUxEO1xuICAgIGNhc2UgS2luZC5GUkFHTUVOVF9TUFJFQUQ6XG4gICAgICByZXR1cm4gRGlyZWN0aXZlTG9jYXRpb24uRlJBR01FTlRfU1BSRUFEO1xuICAgIGNhc2UgS2luZC5JTkxJTkVfRlJBR01FTlQ6XG4gICAgICByZXR1cm4gRGlyZWN0aXZlTG9jYXRpb24uSU5MSU5FX0ZSQUdNRU5UO1xuICAgIGNhc2UgS2luZC5GUkFHTUVOVF9ERUZJTklUSU9OOlxuICAgICAgcmV0dXJuIERpcmVjdGl2ZUxvY2F0aW9uLkZSQUdNRU5UX0RFRklOSVRJT047XG4gICAgY2FzZSBLaW5kLlZBUklBQkxFX0RFRklOSVRJT046XG4gICAgICByZXR1cm4gRGlyZWN0aXZlTG9jYXRpb24uVkFSSUFCTEVfREVGSU5JVElPTjtcbiAgICBjYXNlIEtpbmQuU0NIRU1BX0RFRklOSVRJT046XG4gICAgY2FzZSBLaW5kLlNDSEVNQV9FWFRFTlNJT046XG4gICAgICByZXR1cm4gRGlyZWN0aXZlTG9jYXRpb24uU0NIRU1BO1xuICAgIGNhc2UgS2luZC5TQ0FMQVJfVFlQRV9ERUZJTklUSU9OOlxuICAgIGNhc2UgS2luZC5TQ0FMQVJfVFlQRV9FWFRFTlNJT046XG4gICAgICByZXR1cm4gRGlyZWN0aXZlTG9jYXRpb24uU0NBTEFSO1xuICAgIGNhc2UgS2luZC5PQkpFQ1RfVFlQRV9ERUZJTklUSU9OOlxuICAgIGNhc2UgS2luZC5PQkpFQ1RfVFlQRV9FWFRFTlNJT046XG4gICAgICByZXR1cm4gRGlyZWN0aXZlTG9jYXRpb24uT0JKRUNUO1xuICAgIGNhc2UgS2luZC5GSUVMRF9ERUZJTklUSU9OOlxuICAgICAgcmV0dXJuIERpcmVjdGl2ZUxvY2F0aW9uLkZJRUxEX0RFRklOSVRJT047XG4gICAgY2FzZSBLaW5kLklOVEVSRkFDRV9UWVBFX0RFRklOSVRJT046XG4gICAgY2FzZSBLaW5kLklOVEVSRkFDRV9UWVBFX0VYVEVOU0lPTjpcbiAgICAgIHJldHVybiBEaXJlY3RpdmVMb2NhdGlvbi5JTlRFUkZBQ0U7XG4gICAgY2FzZSBLaW5kLlVOSU9OX1RZUEVfREVGSU5JVElPTjpcbiAgICBjYXNlIEtpbmQuVU5JT05fVFlQRV9FWFRFTlNJT046XG4gICAgICByZXR1cm4gRGlyZWN0aXZlTG9jYXRpb24uVU5JT047XG4gICAgY2FzZSBLaW5kLkVOVU1fVFlQRV9ERUZJTklUSU9OOlxuICAgIGNhc2UgS2luZC5FTlVNX1RZUEVfRVhURU5TSU9OOlxuICAgICAgcmV0dXJuIERpcmVjdGl2ZUxvY2F0aW9uLkVOVU07XG4gICAgY2FzZSBLaW5kLkVOVU1fVkFMVUVfREVGSU5JVElPTjpcbiAgICAgIHJldHVybiBEaXJlY3RpdmVMb2NhdGlvbi5FTlVNX1ZBTFVFO1xuICAgIGNhc2UgS2luZC5JTlBVVF9PQkpFQ1RfVFlQRV9ERUZJTklUSU9OOlxuICAgIGNhc2UgS2luZC5JTlBVVF9PQkpFQ1RfVFlQRV9FWFRFTlNJT046XG4gICAgICByZXR1cm4gRGlyZWN0aXZlTG9jYXRpb24uSU5QVVRfT0JKRUNUO1xuICAgIGNhc2UgS2luZC5JTlBVVF9WQUxVRV9ERUZJTklUSU9OOiB7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gYW5jZXN0b3JzW2FuY2VzdG9ycy5sZW5ndGggLSAzXTtcbiAgICAgIFwia2luZFwiIGluIHBhcmVudE5vZGUgfHwgaW52YXJpYW50KGZhbHNlKTtcbiAgICAgIHJldHVybiBwYXJlbnROb2RlLmtpbmQgPT09IEtpbmQuSU5QVVRfT0JKRUNUX1RZUEVfREVGSU5JVElPTiA/IERpcmVjdGl2ZUxvY2F0aW9uLklOUFVUX0ZJRUxEX0RFRklOSVRJT04gOiBEaXJlY3RpdmVMb2NhdGlvbi5BUkdVTUVOVF9ERUZJTklUSU9OO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgaW52YXJpYW50KGZhbHNlLCBcIlVuZXhwZWN0ZWQga2luZDogXCIgKyBpbnNwZWN0KGFwcGxpZWRUby5raW5kKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERpcmVjdGl2ZUxvY2F0aW9uRm9yT3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgIGNhc2UgT3BlcmF0aW9uVHlwZU5vZGUuUVVFUlk6XG4gICAgICByZXR1cm4gRGlyZWN0aXZlTG9jYXRpb24uUVVFUlk7XG4gICAgY2FzZSBPcGVyYXRpb25UeXBlTm9kZS5NVVRBVElPTjpcbiAgICAgIHJldHVybiBEaXJlY3RpdmVMb2NhdGlvbi5NVVRBVElPTjtcbiAgICBjYXNlIE9wZXJhdGlvblR5cGVOb2RlLlNVQlNDUklQVElPTjpcbiAgICAgIHJldHVybiBEaXJlY3RpdmVMb2NhdGlvbi5TVUJTQ1JJUFRJT047XG4gIH1cbn1cbnZhciBpbml0X0tub3duRGlyZWN0aXZlc1J1bGUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9Lbm93bkRpcmVjdGl2ZXNSdWxlLm1qc1wiKCkge1xuICAgIGluaXRfaW5zcGVjdCgpO1xuICAgIGluaXRfaW52YXJpYW50KCk7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgICBpbml0X2FzdCgpO1xuICAgIGluaXRfZGlyZWN0aXZlTG9jYXRpb24oKTtcbiAgICBpbml0X2tpbmRzKCk7XG4gICAgaW5pdF9kaXJlY3RpdmVzKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL0tub3duRnJhZ21lbnROYW1lc1J1bGUubWpzXG5mdW5jdGlvbiBLbm93bkZyYWdtZW50TmFtZXNSdWxlKGNvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICBGcmFnbWVudFNwcmVhZChub2RlKSB7XG4gICAgICBjb25zdCBmcmFnbWVudE5hbWUgPSBub2RlLm5hbWUudmFsdWU7XG4gICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRleHQuZ2V0RnJhZ21lbnQoZnJhZ21lbnROYW1lKTtcbiAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKGBVbmtub3duIGZyYWdtZW50IFwiJHtmcmFnbWVudE5hbWV9XCIuYCwge1xuICAgICAgICAgICAgbm9kZXM6IG5vZGUubmFtZVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxudmFyIGluaXRfS25vd25GcmFnbWVudE5hbWVzUnVsZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL0tub3duRnJhZ21lbnROYW1lc1J1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvS25vd25UeXBlTmFtZXNSdWxlLm1qc1xuZnVuY3Rpb24gS25vd25UeXBlTmFtZXNSdWxlKGNvbnRleHQpIHtcbiAgY29uc3Qgc2NoZW1hID0gY29udGV4dC5nZXRTY2hlbWEoKTtcbiAgY29uc3QgZXhpc3RpbmdUeXBlc01hcCA9IHNjaGVtYSA/IHNjaGVtYS5nZXRUeXBlTWFwKCkgOiAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgZGVmaW5lZFR5cGVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgZGVmIG9mIGNvbnRleHQuZ2V0RG9jdW1lbnQoKS5kZWZpbml0aW9ucykge1xuICAgIGlmIChpc1R5cGVEZWZpbml0aW9uTm9kZShkZWYpKSB7XG4gICAgICBkZWZpbmVkVHlwZXNbZGVmLm5hbWUudmFsdWVdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdHlwZU5hbWVzID0gW1xuICAgIC4uLk9iamVjdC5rZXlzKGV4aXN0aW5nVHlwZXNNYXApLFxuICAgIC4uLk9iamVjdC5rZXlzKGRlZmluZWRUeXBlcylcbiAgXTtcbiAgcmV0dXJuIHtcbiAgICBOYW1lZFR5cGUobm9kZSwgXzEsIHBhcmVudCwgXzIsIGFuY2VzdG9ycykge1xuICAgICAgY29uc3QgdHlwZU5hbWUgPSBub2RlLm5hbWUudmFsdWU7XG4gICAgICBpZiAoIWV4aXN0aW5nVHlwZXNNYXBbdHlwZU5hbWVdICYmICFkZWZpbmVkVHlwZXNbdHlwZU5hbWVdKSB7XG4gICAgICAgIHZhciBfYW5jZXN0b3JzJDtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbk5vZGUgPSAoX2FuY2VzdG9ycyQgPSBhbmNlc3RvcnNbMl0pICE9PSBudWxsICYmIF9hbmNlc3RvcnMkICE9PSB2b2lkIDAgPyBfYW5jZXN0b3JzJCA6IHBhcmVudDtcbiAgICAgICAgY29uc3QgaXNTREwgPSBkZWZpbml0aW9uTm9kZSAhPSBudWxsICYmIGlzU0RMTm9kZShkZWZpbml0aW9uTm9kZSk7XG4gICAgICAgIGlmIChpc1NETCAmJiBzdGFuZGFyZFR5cGVOYW1lcy5pbmNsdWRlcyh0eXBlTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VnZ2VzdGVkVHlwZXMgPSBzdWdnZXN0aW9uTGlzdChcbiAgICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgICBpc1NETCA/IHN0YW5kYXJkVHlwZU5hbWVzLmNvbmNhdCh0eXBlTmFtZXMpIDogdHlwZU5hbWVzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBVbmtub3duIHR5cGUgXCIke3R5cGVOYW1lfVwiLmAgKyBkaWRZb3VNZWFuKHN1Z2dlc3RlZFR5cGVzKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbm9kZXM6IG5vZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNTRExOb2RlKHZhbHVlKSB7XG4gIHJldHVybiBcImtpbmRcIiBpbiB2YWx1ZSAmJiAoaXNUeXBlU3lzdGVtRGVmaW5pdGlvbk5vZGUodmFsdWUpIHx8IGlzVHlwZVN5c3RlbUV4dGVuc2lvbk5vZGUodmFsdWUpKTtcbn1cbnZhciBzdGFuZGFyZFR5cGVOYW1lcztcbnZhciBpbml0X0tub3duVHlwZU5hbWVzUnVsZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL0tub3duVHlwZU5hbWVzUnVsZS5tanNcIigpIHtcbiAgICBpbml0X2RpZFlvdU1lYW4oKTtcbiAgICBpbml0X3N1Z2dlc3Rpb25MaXN0KCk7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgICBpbml0X3ByZWRpY2F0ZXMoKTtcbiAgICBpbml0X2ludHJvc3BlY3Rpb24oKTtcbiAgICBpbml0X3NjYWxhcnMoKTtcbiAgICBzdGFuZGFyZFR5cGVOYW1lcyA9IFsuLi5zcGVjaWZpZWRTY2FsYXJUeXBlcywgLi4uaW50cm9zcGVjdGlvblR5cGVzXS5tYXAoXG4gICAgICAodHlwZSkgPT4gdHlwZS5uYW1lXG4gICAgKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvTG9uZUFub255bW91c09wZXJhdGlvblJ1bGUubWpzXG5mdW5jdGlvbiBMb25lQW5vbnltb3VzT3BlcmF0aW9uUnVsZShjb250ZXh0KSB7XG4gIGxldCBvcGVyYXRpb25Db3VudCA9IDA7XG4gIHJldHVybiB7XG4gICAgRG9jdW1lbnQobm9kZSkge1xuICAgICAgb3BlcmF0aW9uQ291bnQgPSBub2RlLmRlZmluaXRpb25zLmZpbHRlcihcbiAgICAgICAgKGRlZmluaXRpb24pID0+IGRlZmluaXRpb24ua2luZCA9PT0gS2luZC5PUEVSQVRJT05fREVGSU5JVElPTlxuICAgICAgKS5sZW5ndGg7XG4gICAgfSxcbiAgICBPcGVyYXRpb25EZWZpbml0aW9uKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZS5uYW1lICYmIG9wZXJhdGlvbkNvdW50ID4gMSkge1xuICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBcIlRoaXMgYW5vbnltb3VzIG9wZXJhdGlvbiBtdXN0IGJlIHRoZSBvbmx5IGRlZmluZWQgb3BlcmF0aW9uLlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBub2Rlczogbm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9Mb25lQW5vbnltb3VzT3BlcmF0aW9uUnVsZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL0xvbmVBbm9ueW1vdXNPcGVyYXRpb25SdWxlLm1qc1wiKCkge1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gICAgaW5pdF9raW5kcygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9Mb25lU2NoZW1hRGVmaW5pdGlvblJ1bGUubWpzXG5mdW5jdGlvbiBMb25lU2NoZW1hRGVmaW5pdGlvblJ1bGUoY29udGV4dCkge1xuICB2YXIgX3JlZiwgX3JlZjIsIF9vbGRTY2hlbWEkYXN0Tm9kZTtcbiAgY29uc3Qgb2xkU2NoZW1hID0gY29udGV4dC5nZXRTY2hlbWEoKTtcbiAgY29uc3QgYWxyZWFkeURlZmluZWQgPSAoX3JlZiA9IChfcmVmMiA9IChfb2xkU2NoZW1hJGFzdE5vZGUgPSBvbGRTY2hlbWEgPT09IG51bGwgfHwgb2xkU2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTY2hlbWEuYXN0Tm9kZSkgIT09IG51bGwgJiYgX29sZFNjaGVtYSRhc3ROb2RlICE9PSB2b2lkIDAgPyBfb2xkU2NoZW1hJGFzdE5vZGUgOiBvbGRTY2hlbWEgPT09IG51bGwgfHwgb2xkU2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTY2hlbWEuZ2V0UXVlcnlUeXBlKCkpICE9PSBudWxsICYmIF9yZWYyICE9PSB2b2lkIDAgPyBfcmVmMiA6IG9sZFNjaGVtYSA9PT0gbnVsbCB8fCBvbGRTY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFNjaGVtYS5nZXRNdXRhdGlvblR5cGUoKSkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IG9sZFNjaGVtYSA9PT0gbnVsbCB8fCBvbGRTY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFNjaGVtYS5nZXRTdWJzY3JpcHRpb25UeXBlKCk7XG4gIGxldCBzY2hlbWFEZWZpbml0aW9uc0NvdW50ID0gMDtcbiAgcmV0dXJuIHtcbiAgICBTY2hlbWFEZWZpbml0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChhbHJlYWR5RGVmaW5lZCkge1xuICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBkZWZpbmUgYSBuZXcgc2NoZW1hIHdpdGhpbiBhIHNjaGVtYSBleHRlbnNpb24uXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5vZGVzOiBub2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2NoZW1hRGVmaW5pdGlvbnNDb3VudCA+IDApIHtcbiAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFwiTXVzdCBwcm92aWRlIG9ubHkgb25lIHNjaGVtYSBkZWZpbml0aW9uLlwiLCB7XG4gICAgICAgICAgICBub2Rlczogbm9kZVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICArK3NjaGVtYURlZmluaXRpb25zQ291bnQ7XG4gICAgfVxuICB9O1xufVxudmFyIGluaXRfTG9uZVNjaGVtYURlZmluaXRpb25SdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvTG9uZVNjaGVtYURlZmluaXRpb25SdWxlLm1qc1wiKCkge1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL05vRnJhZ21lbnRDeWNsZXNSdWxlLm1qc1xuZnVuY3Rpb24gTm9GcmFnbWVudEN5Y2xlc1J1bGUoY29udGV4dCkge1xuICBjb25zdCB2aXNpdGVkRnJhZ3MgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgc3ByZWFkUGF0aCA9IFtdO1xuICBjb25zdCBzcHJlYWRQYXRoSW5kZXhCeU5hbWUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIHtcbiAgICBPcGVyYXRpb25EZWZpbml0aW9uOiAoKSA9PiBmYWxzZSxcbiAgICBGcmFnbWVudERlZmluaXRpb24obm9kZSkge1xuICAgICAgZGV0ZWN0Q3ljbGVSZWN1cnNpdmUobm9kZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkZXRlY3RDeWNsZVJlY3Vyc2l2ZShmcmFnbWVudCkge1xuICAgIGlmICh2aXNpdGVkRnJhZ3NbZnJhZ21lbnQubmFtZS52YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZnJhZ21lbnROYW1lID0gZnJhZ21lbnQubmFtZS52YWx1ZTtcbiAgICB2aXNpdGVkRnJhZ3NbZnJhZ21lbnROYW1lXSA9IHRydWU7XG4gICAgY29uc3Qgc3ByZWFkTm9kZXMgPSBjb250ZXh0LmdldEZyYWdtZW50U3ByZWFkcyhmcmFnbWVudC5zZWxlY3Rpb25TZXQpO1xuICAgIGlmIChzcHJlYWROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3ByZWFkUGF0aEluZGV4QnlOYW1lW2ZyYWdtZW50TmFtZV0gPSBzcHJlYWRQYXRoLmxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IHNwcmVhZE5vZGUgb2Ygc3ByZWFkTm9kZXMpIHtcbiAgICAgIGNvbnN0IHNwcmVhZE5hbWUgPSBzcHJlYWROb2RlLm5hbWUudmFsdWU7XG4gICAgICBjb25zdCBjeWNsZUluZGV4ID0gc3ByZWFkUGF0aEluZGV4QnlOYW1lW3NwcmVhZE5hbWVdO1xuICAgICAgc3ByZWFkUGF0aC5wdXNoKHNwcmVhZE5vZGUpO1xuICAgICAgaWYgKGN5Y2xlSW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBzcHJlYWRGcmFnbWVudCA9IGNvbnRleHQuZ2V0RnJhZ21lbnQoc3ByZWFkTmFtZSk7XG4gICAgICAgIGlmIChzcHJlYWRGcmFnbWVudCkge1xuICAgICAgICAgIGRldGVjdEN5Y2xlUmVjdXJzaXZlKHNwcmVhZEZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3ljbGVQYXRoID0gc3ByZWFkUGF0aC5zbGljZShjeWNsZUluZGV4KTtcbiAgICAgICAgY29uc3QgdmlhUGF0aCA9IGN5Y2xlUGF0aC5zbGljZSgwLCAtMSkubWFwKChzKSA9PiAnXCInICsgcy5uYW1lLnZhbHVlICsgJ1wiJykuam9pbihcIiwgXCIpO1xuICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IHNwcmVhZCBmcmFnbWVudCBcIiR7c3ByZWFkTmFtZX1cIiB3aXRoaW4gaXRzZWxmYCArICh2aWFQYXRoICE9PSBcIlwiID8gYCB2aWEgJHt2aWFQYXRofS5gIDogXCIuXCIpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBub2RlczogY3ljbGVQYXRoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc3ByZWFkUGF0aC5wb3AoKTtcbiAgICB9XG4gICAgc3ByZWFkUGF0aEluZGV4QnlOYW1lW2ZyYWdtZW50TmFtZV0gPSB2b2lkIDA7XG4gIH1cbn1cbnZhciBpbml0X05vRnJhZ21lbnRDeWNsZXNSdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvTm9GcmFnbWVudEN5Y2xlc1J1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvTm9VbmRlZmluZWRWYXJpYWJsZXNSdWxlLm1qc1xuZnVuY3Rpb24gTm9VbmRlZmluZWRWYXJpYWJsZXNSdWxlKGNvbnRleHQpIHtcbiAgbGV0IHZhcmlhYmxlTmFtZURlZmluZWQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIHtcbiAgICBPcGVyYXRpb25EZWZpbml0aW9uOiB7XG4gICAgICBlbnRlcigpIHtcbiAgICAgICAgdmFyaWFibGVOYW1lRGVmaW5lZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfSxcbiAgICAgIGxlYXZlKG9wZXJhdGlvbikge1xuICAgICAgICBjb25zdCB1c2FnZXMgPSBjb250ZXh0LmdldFJlY3Vyc2l2ZVZhcmlhYmxlVXNhZ2VzKG9wZXJhdGlvbik7XG4gICAgICAgIGZvciAoY29uc3QgeyBub2RlIH0gb2YgdXNhZ2VzKSB7XG4gICAgICAgICAgY29uc3QgdmFyTmFtZSA9IG5vZGUubmFtZS52YWx1ZTtcbiAgICAgICAgICBpZiAodmFyaWFibGVOYW1lRGVmaW5lZFt2YXJOYW1lXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmFtZSA/IGBWYXJpYWJsZSBcIiQke3Zhck5hbWV9XCIgaXMgbm90IGRlZmluZWQgYnkgb3BlcmF0aW9uIFwiJHtvcGVyYXRpb24ubmFtZS52YWx1ZX1cIi5gIDogYFZhcmlhYmxlIFwiJCR7dmFyTmFtZX1cIiBpcyBub3QgZGVmaW5lZC5gLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIG5vZGVzOiBbbm9kZSwgb3BlcmF0aW9uXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFZhcmlhYmxlRGVmaW5pdGlvbihub2RlKSB7XG4gICAgICB2YXJpYWJsZU5hbWVEZWZpbmVkW25vZGUudmFyaWFibGUubmFtZS52YWx1ZV0gPSB0cnVlO1xuICAgIH1cbiAgfTtcbn1cbnZhciBpbml0X05vVW5kZWZpbmVkVmFyaWFibGVzUnVsZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL05vVW5kZWZpbmVkVmFyaWFibGVzUnVsZS5tanNcIigpIHtcbiAgICBpbml0X0dyYXBoUUxFcnJvcigpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9Ob1VudXNlZEZyYWdtZW50c1J1bGUubWpzXG5mdW5jdGlvbiBOb1VudXNlZEZyYWdtZW50c1J1bGUoY29udGV4dCkge1xuICBjb25zdCBvcGVyYXRpb25EZWZzID0gW107XG4gIGNvbnN0IGZyYWdtZW50RGVmcyA9IFtdO1xuICByZXR1cm4ge1xuICAgIE9wZXJhdGlvbkRlZmluaXRpb24obm9kZSkge1xuICAgICAgb3BlcmF0aW9uRGVmcy5wdXNoKG5vZGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgRnJhZ21lbnREZWZpbml0aW9uKG5vZGUpIHtcbiAgICAgIGZyYWdtZW50RGVmcy5wdXNoKG5vZGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgRG9jdW1lbnQ6IHtcbiAgICAgIGxlYXZlKCkge1xuICAgICAgICBjb25zdCBmcmFnbWVudE5hbWVVc2VkID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIG9wZXJhdGlvbkRlZnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIGNvbnRleHQuZ2V0UmVjdXJzaXZlbHlSZWZlcmVuY2VkRnJhZ21lbnRzKFxuICAgICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgICAgKSkge1xuICAgICAgICAgICAgZnJhZ21lbnROYW1lVXNlZFtmcmFnbWVudC5uYW1lLnZhbHVlXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnREZWYgb2YgZnJhZ21lbnREZWZzKSB7XG4gICAgICAgICAgY29uc3QgZnJhZ05hbWUgPSBmcmFnbWVudERlZi5uYW1lLnZhbHVlO1xuICAgICAgICAgIGlmIChmcmFnbWVudE5hbWVVc2VkW2ZyYWdOYW1lXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihgRnJhZ21lbnQgXCIke2ZyYWdOYW1lfVwiIGlzIG5ldmVyIHVzZWQuYCwge1xuICAgICAgICAgICAgICAgIG5vZGVzOiBmcmFnbWVudERlZlxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9Ob1VudXNlZEZyYWdtZW50c1J1bGUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9Ob1VudXNlZEZyYWdtZW50c1J1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvTm9VbnVzZWRWYXJpYWJsZXNSdWxlLm1qc1xuZnVuY3Rpb24gTm9VbnVzZWRWYXJpYWJsZXNSdWxlKGNvbnRleHQpIHtcbiAgbGV0IHZhcmlhYmxlRGVmcyA9IFtdO1xuICByZXR1cm4ge1xuICAgIE9wZXJhdGlvbkRlZmluaXRpb246IHtcbiAgICAgIGVudGVyKCkge1xuICAgICAgICB2YXJpYWJsZURlZnMgPSBbXTtcbiAgICAgIH0sXG4gICAgICBsZWF2ZShvcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgdmFyaWFibGVOYW1lVXNlZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjb25zdCB1c2FnZXMgPSBjb250ZXh0LmdldFJlY3Vyc2l2ZVZhcmlhYmxlVXNhZ2VzKG9wZXJhdGlvbik7XG4gICAgICAgIGZvciAoY29uc3QgeyBub2RlIH0gb2YgdXNhZ2VzKSB7XG4gICAgICAgICAgdmFyaWFibGVOYW1lVXNlZFtub2RlLm5hbWUudmFsdWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHZhcmlhYmxlRGVmIG9mIHZhcmlhYmxlRGVmcykge1xuICAgICAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IHZhcmlhYmxlRGVmLnZhcmlhYmxlLm5hbWUudmFsdWU7XG4gICAgICAgICAgaWYgKHZhcmlhYmxlTmFtZVVzZWRbdmFyaWFibGVOYW1lXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmFtZSA/IGBWYXJpYWJsZSBcIiQke3ZhcmlhYmxlTmFtZX1cIiBpcyBuZXZlciB1c2VkIGluIG9wZXJhdGlvbiBcIiR7b3BlcmF0aW9uLm5hbWUudmFsdWV9XCIuYCA6IGBWYXJpYWJsZSBcIiQke3ZhcmlhYmxlTmFtZX1cIiBpcyBuZXZlciB1c2VkLmAsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbm9kZXM6IHZhcmlhYmxlRGVmXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgVmFyaWFibGVEZWZpbml0aW9uKGRlZikge1xuICAgICAgdmFyaWFibGVEZWZzLnB1c2goZGVmKTtcbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9Ob1VudXNlZFZhcmlhYmxlc1J1bGUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9Ob1VudXNlZFZhcmlhYmxlc1J1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9zb3J0VmFsdWVOb2RlLm1qc1xuZnVuY3Rpb24gc29ydFZhbHVlTm9kZSh2YWx1ZU5vZGUpIHtcbiAgc3dpdGNoICh2YWx1ZU5vZGUua2luZCkge1xuICAgIGNhc2UgS2luZC5PQkpFQ1Q6XG4gICAgICByZXR1cm4geyAuLi52YWx1ZU5vZGUsIGZpZWxkczogc29ydEZpZWxkcyh2YWx1ZU5vZGUuZmllbGRzKSB9O1xuICAgIGNhc2UgS2luZC5MSVNUOlxuICAgICAgcmV0dXJuIHsgLi4udmFsdWVOb2RlLCB2YWx1ZXM6IHZhbHVlTm9kZS52YWx1ZXMubWFwKHNvcnRWYWx1ZU5vZGUpIH07XG4gICAgY2FzZSBLaW5kLklOVDpcbiAgICBjYXNlIEtpbmQuRkxPQVQ6XG4gICAgY2FzZSBLaW5kLlNUUklORzpcbiAgICBjYXNlIEtpbmQuQk9PTEVBTjpcbiAgICBjYXNlIEtpbmQuTlVMTDpcbiAgICBjYXNlIEtpbmQuRU5VTTpcbiAgICBjYXNlIEtpbmQuVkFSSUFCTEU6XG4gICAgICByZXR1cm4gdmFsdWVOb2RlO1xuICB9XG59XG5mdW5jdGlvbiBzb3J0RmllbGRzKGZpZWxkcykge1xuICByZXR1cm4gZmllbGRzLm1hcCgoZmllbGROb2RlKSA9PiAoe1xuICAgIC4uLmZpZWxkTm9kZSxcbiAgICB2YWx1ZTogc29ydFZhbHVlTm9kZShmaWVsZE5vZGUudmFsdWUpXG4gIH0pKS5zb3J0KFxuICAgIChmaWVsZEEsIGZpZWxkQikgPT4gbmF0dXJhbENvbXBhcmUoZmllbGRBLm5hbWUudmFsdWUsIGZpZWxkQi5uYW1lLnZhbHVlKVxuICApO1xufVxudmFyIGluaXRfc29ydFZhbHVlTm9kZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvc29ydFZhbHVlTm9kZS5tanNcIigpIHtcbiAgICBpbml0X25hdHVyYWxDb21wYXJlKCk7XG4gICAgaW5pdF9raW5kcygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9PdmVybGFwcGluZ0ZpZWxkc0NhbkJlTWVyZ2VkUnVsZS5tanNcbmZ1bmN0aW9uIHJlYXNvbk1lc3NhZ2UocmVhc29uKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHJlYXNvbikpIHtcbiAgICByZXR1cm4gcmVhc29uLm1hcChcbiAgICAgIChbcmVzcG9uc2VOYW1lLCBzdWJSZWFzb25dKSA9PiBgc3ViZmllbGRzIFwiJHtyZXNwb25zZU5hbWV9XCIgY29uZmxpY3QgYmVjYXVzZSBgICsgcmVhc29uTWVzc2FnZShzdWJSZWFzb24pXG4gICAgKS5qb2luKFwiIGFuZCBcIik7XG4gIH1cbiAgcmV0dXJuIHJlYXNvbjtcbn1cbmZ1bmN0aW9uIE92ZXJsYXBwaW5nRmllbGRzQ2FuQmVNZXJnZWRSdWxlKGNvbnRleHQpIHtcbiAgY29uc3QgY29tcGFyZWRGcmFnbWVudFBhaXJzID0gbmV3IFBhaXJTZXQoKTtcbiAgY29uc3QgY2FjaGVkRmllbGRzQW5kRnJhZ21lbnROYW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiB7XG4gICAgU2VsZWN0aW9uU2V0KHNlbGVjdGlvblNldCkge1xuICAgICAgY29uc3QgY29uZmxpY3RzID0gZmluZENvbmZsaWN0c1dpdGhpblNlbGVjdGlvblNldChcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2FjaGVkRmllbGRzQW5kRnJhZ21lbnROYW1lcyxcbiAgICAgICAgY29tcGFyZWRGcmFnbWVudFBhaXJzLFxuICAgICAgICBjb250ZXh0LmdldFBhcmVudFR5cGUoKSxcbiAgICAgICAgc2VsZWN0aW9uU2V0XG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCBbW3Jlc3BvbnNlTmFtZSwgcmVhc29uXSwgZmllbGRzMSwgZmllbGRzMl0gb2YgY29uZmxpY3RzKSB7XG4gICAgICAgIGNvbnN0IHJlYXNvbk1zZyA9IHJlYXNvbk1lc3NhZ2UocmVhc29uKTtcbiAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYEZpZWxkcyBcIiR7cmVzcG9uc2VOYW1lfVwiIGNvbmZsaWN0IGJlY2F1c2UgJHtyZWFzb25Nc2d9LiBVc2UgZGlmZmVyZW50IGFsaWFzZXMgb24gdGhlIGZpZWxkcyB0byBmZXRjaCBib3RoIGlmIHRoaXMgd2FzIGludGVudGlvbmFsLmAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5vZGVzOiBmaWVsZHMxLmNvbmNhdChmaWVsZHMyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmaW5kQ29uZmxpY3RzV2l0aGluU2VsZWN0aW9uU2V0KGNvbnRleHQsIGNhY2hlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMsIGNvbXBhcmVkRnJhZ21lbnRQYWlycywgcGFyZW50VHlwZSwgc2VsZWN0aW9uU2V0KSB7XG4gIGNvbnN0IGNvbmZsaWN0cyA9IFtdO1xuICBjb25zdCBbZmllbGRNYXAsIGZyYWdtZW50TmFtZXNdID0gZ2V0RmllbGRzQW5kRnJhZ21lbnROYW1lcyhcbiAgICBjb250ZXh0LFxuICAgIGNhY2hlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMsXG4gICAgcGFyZW50VHlwZSxcbiAgICBzZWxlY3Rpb25TZXRcbiAgKTtcbiAgY29sbGVjdENvbmZsaWN0c1dpdGhpbihcbiAgICBjb250ZXh0LFxuICAgIGNvbmZsaWN0cyxcbiAgICBjYWNoZWRGaWVsZHNBbmRGcmFnbWVudE5hbWVzLFxuICAgIGNvbXBhcmVkRnJhZ21lbnRQYWlycyxcbiAgICBmaWVsZE1hcFxuICApO1xuICBpZiAoZnJhZ21lbnROYW1lcy5sZW5ndGggIT09IDApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYWdtZW50TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbGxlY3RDb25mbGljdHNCZXR3ZWVuRmllbGRzQW5kRnJhZ21lbnQoXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNvbmZsaWN0cyxcbiAgICAgICAgY2FjaGVkRmllbGRzQW5kRnJhZ21lbnROYW1lcyxcbiAgICAgICAgY29tcGFyZWRGcmFnbWVudFBhaXJzLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmllbGRNYXAsXG4gICAgICAgIGZyYWdtZW50TmFtZXNbaV1cbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBmcmFnbWVudE5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbGxlY3RDb25mbGljdHNCZXR3ZWVuRnJhZ21lbnRzKFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgY29uZmxpY3RzLFxuICAgICAgICAgIGNhY2hlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMsXG4gICAgICAgICAgY29tcGFyZWRGcmFnbWVudFBhaXJzLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGZyYWdtZW50TmFtZXNbaV0sXG4gICAgICAgICAgZnJhZ21lbnROYW1lc1tqXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmxpY3RzO1xufVxuZnVuY3Rpb24gY29sbGVjdENvbmZsaWN0c0JldHdlZW5GaWVsZHNBbmRGcmFnbWVudChjb250ZXh0LCBjb25mbGljdHMsIGNhY2hlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMsIGNvbXBhcmVkRnJhZ21lbnRQYWlycywgYXJlTXV0dWFsbHlFeGNsdXNpdmUsIGZpZWxkTWFwLCBmcmFnbWVudE5hbWUpIHtcbiAgY29uc3QgZnJhZ21lbnQgPSBjb250ZXh0LmdldEZyYWdtZW50KGZyYWdtZW50TmFtZSk7XG4gIGlmICghZnJhZ21lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW2ZpZWxkTWFwMiwgcmVmZXJlbmNlZEZyYWdtZW50TmFtZXNdID0gZ2V0UmVmZXJlbmNlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMoXG4gICAgY29udGV4dCxcbiAgICBjYWNoZWRGaWVsZHNBbmRGcmFnbWVudE5hbWVzLFxuICAgIGZyYWdtZW50XG4gICk7XG4gIGlmIChmaWVsZE1hcCA9PT0gZmllbGRNYXAyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbGxlY3RDb25mbGljdHNCZXR3ZWVuKFxuICAgIGNvbnRleHQsXG4gICAgY29uZmxpY3RzLFxuICAgIGNhY2hlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMsXG4gICAgY29tcGFyZWRGcmFnbWVudFBhaXJzLFxuICAgIGFyZU11dHVhbGx5RXhjbHVzaXZlLFxuICAgIGZpZWxkTWFwLFxuICAgIGZpZWxkTWFwMlxuICApO1xuICBmb3IgKGNvbnN0IHJlZmVyZW5jZWRGcmFnbWVudE5hbWUgb2YgcmVmZXJlbmNlZEZyYWdtZW50TmFtZXMpIHtcbiAgICBpZiAoY29tcGFyZWRGcmFnbWVudFBhaXJzLmhhcyhcbiAgICAgIHJlZmVyZW5jZWRGcmFnbWVudE5hbWUsXG4gICAgICBmcmFnbWVudE5hbWUsXG4gICAgICBhcmVNdXR1YWxseUV4Y2x1c2l2ZVxuICAgICkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb21wYXJlZEZyYWdtZW50UGFpcnMuYWRkKFxuICAgICAgcmVmZXJlbmNlZEZyYWdtZW50TmFtZSxcbiAgICAgIGZyYWdtZW50TmFtZSxcbiAgICAgIGFyZU11dHVhbGx5RXhjbHVzaXZlXG4gICAgKTtcbiAgICBjb2xsZWN0Q29uZmxpY3RzQmV0d2VlbkZpZWxkc0FuZEZyYWdtZW50KFxuICAgICAgY29udGV4dCxcbiAgICAgIGNvbmZsaWN0cyxcbiAgICAgIGNhY2hlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMsXG4gICAgICBjb21wYXJlZEZyYWdtZW50UGFpcnMsXG4gICAgICBhcmVNdXR1YWxseUV4Y2x1c2l2ZSxcbiAgICAgIGZpZWxkTWFwLFxuICAgICAgcmVmZXJlbmNlZEZyYWdtZW50TmFtZVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RDb25mbGljdHNCZXR3ZWVuRnJhZ21lbnRzKGNvbnRleHQsIGNvbmZsaWN0cywgY2FjaGVkRmllbGRzQW5kRnJhZ21lbnROYW1lcywgY29tcGFyZWRGcmFnbWVudFBhaXJzLCBhcmVNdXR1YWxseUV4Y2x1c2l2ZSwgZnJhZ21lbnROYW1lMSwgZnJhZ21lbnROYW1lMikge1xuICBpZiAoZnJhZ21lbnROYW1lMSA9PT0gZnJhZ21lbnROYW1lMikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY29tcGFyZWRGcmFnbWVudFBhaXJzLmhhcyhcbiAgICBmcmFnbWVudE5hbWUxLFxuICAgIGZyYWdtZW50TmFtZTIsXG4gICAgYXJlTXV0dWFsbHlFeGNsdXNpdmVcbiAgKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb21wYXJlZEZyYWdtZW50UGFpcnMuYWRkKGZyYWdtZW50TmFtZTEsIGZyYWdtZW50TmFtZTIsIGFyZU11dHVhbGx5RXhjbHVzaXZlKTtcbiAgY29uc3QgZnJhZ21lbnQxID0gY29udGV4dC5nZXRGcmFnbWVudChmcmFnbWVudE5hbWUxKTtcbiAgY29uc3QgZnJhZ21lbnQyID0gY29udGV4dC5nZXRGcmFnbWVudChmcmFnbWVudE5hbWUyKTtcbiAgaWYgKCFmcmFnbWVudDEgfHwgIWZyYWdtZW50Mikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbZmllbGRNYXAxLCByZWZlcmVuY2VkRnJhZ21lbnROYW1lczFdID0gZ2V0UmVmZXJlbmNlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMoXG4gICAgY29udGV4dCxcbiAgICBjYWNoZWRGaWVsZHNBbmRGcmFnbWVudE5hbWVzLFxuICAgIGZyYWdtZW50MVxuICApO1xuICBjb25zdCBbZmllbGRNYXAyLCByZWZlcmVuY2VkRnJhZ21lbnROYW1lczJdID0gZ2V0UmVmZXJlbmNlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMoXG4gICAgY29udGV4dCxcbiAgICBjYWNoZWRGaWVsZHNBbmRGcmFnbWVudE5hbWVzLFxuICAgIGZyYWdtZW50MlxuICApO1xuICBjb2xsZWN0Q29uZmxpY3RzQmV0d2VlbihcbiAgICBjb250ZXh0LFxuICAgIGNvbmZsaWN0cyxcbiAgICBjYWNoZWRGaWVsZHNBbmRGcmFnbWVudE5hbWVzLFxuICAgIGNvbXBhcmVkRnJhZ21lbnRQYWlycyxcbiAgICBhcmVNdXR1YWxseUV4Y2x1c2l2ZSxcbiAgICBmaWVsZE1hcDEsXG4gICAgZmllbGRNYXAyXG4gICk7XG4gIGZvciAoY29uc3QgcmVmZXJlbmNlZEZyYWdtZW50TmFtZTIgb2YgcmVmZXJlbmNlZEZyYWdtZW50TmFtZXMyKSB7XG4gICAgY29sbGVjdENvbmZsaWN0c0JldHdlZW5GcmFnbWVudHMoXG4gICAgICBjb250ZXh0LFxuICAgICAgY29uZmxpY3RzLFxuICAgICAgY2FjaGVkRmllbGRzQW5kRnJhZ21lbnROYW1lcyxcbiAgICAgIGNvbXBhcmVkRnJhZ21lbnRQYWlycyxcbiAgICAgIGFyZU11dHVhbGx5RXhjbHVzaXZlLFxuICAgICAgZnJhZ21lbnROYW1lMSxcbiAgICAgIHJlZmVyZW5jZWRGcmFnbWVudE5hbWUyXG4gICAgKTtcbiAgfVxuICBmb3IgKGNvbnN0IHJlZmVyZW5jZWRGcmFnbWVudE5hbWUxIG9mIHJlZmVyZW5jZWRGcmFnbWVudE5hbWVzMSkge1xuICAgIGNvbGxlY3RDb25mbGljdHNCZXR3ZWVuRnJhZ21lbnRzKFxuICAgICAgY29udGV4dCxcbiAgICAgIGNvbmZsaWN0cyxcbiAgICAgIGNhY2hlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMsXG4gICAgICBjb21wYXJlZEZyYWdtZW50UGFpcnMsXG4gICAgICBhcmVNdXR1YWxseUV4Y2x1c2l2ZSxcbiAgICAgIHJlZmVyZW5jZWRGcmFnbWVudE5hbWUxLFxuICAgICAgZnJhZ21lbnROYW1lMlxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRDb25mbGljdHNCZXR3ZWVuU3ViU2VsZWN0aW9uU2V0cyhjb250ZXh0LCBjYWNoZWRGaWVsZHNBbmRGcmFnbWVudE5hbWVzLCBjb21wYXJlZEZyYWdtZW50UGFpcnMsIGFyZU11dHVhbGx5RXhjbHVzaXZlLCBwYXJlbnRUeXBlMSwgc2VsZWN0aW9uU2V0MSwgcGFyZW50VHlwZTIsIHNlbGVjdGlvblNldDIpIHtcbiAgY29uc3QgY29uZmxpY3RzID0gW107XG4gIGNvbnN0IFtmaWVsZE1hcDEsIGZyYWdtZW50TmFtZXMxXSA9IGdldEZpZWxkc0FuZEZyYWdtZW50TmFtZXMoXG4gICAgY29udGV4dCxcbiAgICBjYWNoZWRGaWVsZHNBbmRGcmFnbWVudE5hbWVzLFxuICAgIHBhcmVudFR5cGUxLFxuICAgIHNlbGVjdGlvblNldDFcbiAgKTtcbiAgY29uc3QgW2ZpZWxkTWFwMiwgZnJhZ21lbnROYW1lczJdID0gZ2V0RmllbGRzQW5kRnJhZ21lbnROYW1lcyhcbiAgICBjb250ZXh0LFxuICAgIGNhY2hlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMsXG4gICAgcGFyZW50VHlwZTIsXG4gICAgc2VsZWN0aW9uU2V0MlxuICApO1xuICBjb2xsZWN0Q29uZmxpY3RzQmV0d2VlbihcbiAgICBjb250ZXh0LFxuICAgIGNvbmZsaWN0cyxcbiAgICBjYWNoZWRGaWVsZHNBbmRGcmFnbWVudE5hbWVzLFxuICAgIGNvbXBhcmVkRnJhZ21lbnRQYWlycyxcbiAgICBhcmVNdXR1YWxseUV4Y2x1c2l2ZSxcbiAgICBmaWVsZE1hcDEsXG4gICAgZmllbGRNYXAyXG4gICk7XG4gIGZvciAoY29uc3QgZnJhZ21lbnROYW1lMiBvZiBmcmFnbWVudE5hbWVzMikge1xuICAgIGNvbGxlY3RDb25mbGljdHNCZXR3ZWVuRmllbGRzQW5kRnJhZ21lbnQoXG4gICAgICBjb250ZXh0LFxuICAgICAgY29uZmxpY3RzLFxuICAgICAgY2FjaGVkRmllbGRzQW5kRnJhZ21lbnROYW1lcyxcbiAgICAgIGNvbXBhcmVkRnJhZ21lbnRQYWlycyxcbiAgICAgIGFyZU11dHVhbGx5RXhjbHVzaXZlLFxuICAgICAgZmllbGRNYXAxLFxuICAgICAgZnJhZ21lbnROYW1lMlxuICAgICk7XG4gIH1cbiAgZm9yIChjb25zdCBmcmFnbWVudE5hbWUxIG9mIGZyYWdtZW50TmFtZXMxKSB7XG4gICAgY29sbGVjdENvbmZsaWN0c0JldHdlZW5GaWVsZHNBbmRGcmFnbWVudChcbiAgICAgIGNvbnRleHQsXG4gICAgICBjb25mbGljdHMsXG4gICAgICBjYWNoZWRGaWVsZHNBbmRGcmFnbWVudE5hbWVzLFxuICAgICAgY29tcGFyZWRGcmFnbWVudFBhaXJzLFxuICAgICAgYXJlTXV0dWFsbHlFeGNsdXNpdmUsXG4gICAgICBmaWVsZE1hcDIsXG4gICAgICBmcmFnbWVudE5hbWUxXG4gICAgKTtcbiAgfVxuICBmb3IgKGNvbnN0IGZyYWdtZW50TmFtZTEgb2YgZnJhZ21lbnROYW1lczEpIHtcbiAgICBmb3IgKGNvbnN0IGZyYWdtZW50TmFtZTIgb2YgZnJhZ21lbnROYW1lczIpIHtcbiAgICAgIGNvbGxlY3RDb25mbGljdHNCZXR3ZWVuRnJhZ21lbnRzKFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjb25mbGljdHMsXG4gICAgICAgIGNhY2hlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMsXG4gICAgICAgIGNvbXBhcmVkRnJhZ21lbnRQYWlycyxcbiAgICAgICAgYXJlTXV0dWFsbHlFeGNsdXNpdmUsXG4gICAgICAgIGZyYWdtZW50TmFtZTEsXG4gICAgICAgIGZyYWdtZW50TmFtZTJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25mbGljdHM7XG59XG5mdW5jdGlvbiBjb2xsZWN0Q29uZmxpY3RzV2l0aGluKGNvbnRleHQsIGNvbmZsaWN0cywgY2FjaGVkRmllbGRzQW5kRnJhZ21lbnROYW1lcywgY29tcGFyZWRGcmFnbWVudFBhaXJzLCBmaWVsZE1hcCkge1xuICBmb3IgKGNvbnN0IFtyZXNwb25zZU5hbWUsIGZpZWxkc10gb2YgT2JqZWN0LmVudHJpZXMoZmllbGRNYXApKSB7XG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBjb25mbGljdCA9IGZpbmRDb25mbGljdChcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBjYWNoZWRGaWVsZHNBbmRGcmFnbWVudE5hbWVzLFxuICAgICAgICAgICAgY29tcGFyZWRGcmFnbWVudFBhaXJzLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAvLyB3aXRoaW4gb25lIGNvbGxlY3Rpb24gaXMgbmV2ZXIgbXV0dWFsbHkgZXhjbHVzaXZlXG4gICAgICAgICAgICByZXNwb25zZU5hbWUsXG4gICAgICAgICAgICBmaWVsZHNbaV0sXG4gICAgICAgICAgICBmaWVsZHNbal1cbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChjb25mbGljdCkge1xuICAgICAgICAgICAgY29uZmxpY3RzLnB1c2goY29uZmxpY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29sbGVjdENvbmZsaWN0c0JldHdlZW4oY29udGV4dCwgY29uZmxpY3RzLCBjYWNoZWRGaWVsZHNBbmRGcmFnbWVudE5hbWVzLCBjb21wYXJlZEZyYWdtZW50UGFpcnMsIHBhcmVudEZpZWxkc0FyZU11dHVhbGx5RXhjbHVzaXZlLCBmaWVsZE1hcDEsIGZpZWxkTWFwMikge1xuICBmb3IgKGNvbnN0IFtyZXNwb25zZU5hbWUsIGZpZWxkczFdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkTWFwMSkpIHtcbiAgICBjb25zdCBmaWVsZHMyID0gZmllbGRNYXAyW3Jlc3BvbnNlTmFtZV07XG4gICAgaWYgKGZpZWxkczIpIHtcbiAgICAgIGZvciAoY29uc3QgZmllbGQxIG9mIGZpZWxkczEpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZDIgb2YgZmllbGRzMikge1xuICAgICAgICAgIGNvbnN0IGNvbmZsaWN0ID0gZmluZENvbmZsaWN0KFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIGNhY2hlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMsXG4gICAgICAgICAgICBjb21wYXJlZEZyYWdtZW50UGFpcnMsXG4gICAgICAgICAgICBwYXJlbnRGaWVsZHNBcmVNdXR1YWxseUV4Y2x1c2l2ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlTmFtZSxcbiAgICAgICAgICAgIGZpZWxkMSxcbiAgICAgICAgICAgIGZpZWxkMlxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGNvbmZsaWN0KSB7XG4gICAgICAgICAgICBjb25mbGljdHMucHVzaChjb25mbGljdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaW5kQ29uZmxpY3QoY29udGV4dCwgY2FjaGVkRmllbGRzQW5kRnJhZ21lbnROYW1lcywgY29tcGFyZWRGcmFnbWVudFBhaXJzLCBwYXJlbnRGaWVsZHNBcmVNdXR1YWxseUV4Y2x1c2l2ZSwgcmVzcG9uc2VOYW1lLCBmaWVsZDEsIGZpZWxkMikge1xuICBjb25zdCBbcGFyZW50VHlwZTEsIG5vZGUxLCBkZWYxXSA9IGZpZWxkMTtcbiAgY29uc3QgW3BhcmVudFR5cGUyLCBub2RlMiwgZGVmMl0gPSBmaWVsZDI7XG4gIGNvbnN0IGFyZU11dHVhbGx5RXhjbHVzaXZlID0gcGFyZW50RmllbGRzQXJlTXV0dWFsbHlFeGNsdXNpdmUgfHwgcGFyZW50VHlwZTEgIT09IHBhcmVudFR5cGUyICYmIGlzT2JqZWN0VHlwZShwYXJlbnRUeXBlMSkgJiYgaXNPYmplY3RUeXBlKHBhcmVudFR5cGUyKTtcbiAgaWYgKCFhcmVNdXR1YWxseUV4Y2x1c2l2ZSkge1xuICAgIGNvbnN0IG5hbWUxID0gbm9kZTEubmFtZS52YWx1ZTtcbiAgICBjb25zdCBuYW1lMiA9IG5vZGUyLm5hbWUudmFsdWU7XG4gICAgaWYgKG5hbWUxICE9PSBuYW1lMikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgW3Jlc3BvbnNlTmFtZSwgYFwiJHtuYW1lMX1cIiBhbmQgXCIke25hbWUyfVwiIGFyZSBkaWZmZXJlbnQgZmllbGRzYF0sXG4gICAgICAgIFtub2RlMV0sXG4gICAgICAgIFtub2RlMl1cbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChzdHJpbmdpZnlBcmd1bWVudHMobm9kZTEpICE9PSBzdHJpbmdpZnlBcmd1bWVudHMobm9kZTIpKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbcmVzcG9uc2VOYW1lLCBcInRoZXkgaGF2ZSBkaWZmZXJpbmcgYXJndW1lbnRzXCJdLFxuICAgICAgICBbbm9kZTFdLFxuICAgICAgICBbbm9kZTJdXG4gICAgICBdO1xuICAgIH1cbiAgfVxuICBjb25zdCB0eXBlMSA9IGRlZjEgPT09IG51bGwgfHwgZGVmMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmMS50eXBlO1xuICBjb25zdCB0eXBlMiA9IGRlZjIgPT09IG51bGwgfHwgZGVmMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmMi50eXBlO1xuICBpZiAodHlwZTEgJiYgdHlwZTIgJiYgZG9UeXBlc0NvbmZsaWN0KHR5cGUxLCB0eXBlMikpIHtcbiAgICByZXR1cm4gW1xuICAgICAgW1xuICAgICAgICByZXNwb25zZU5hbWUsXG4gICAgICAgIGB0aGV5IHJldHVybiBjb25mbGljdGluZyB0eXBlcyBcIiR7aW5zcGVjdCh0eXBlMSl9XCIgYW5kIFwiJHtpbnNwZWN0KFxuICAgICAgICAgIHR5cGUyXG4gICAgICAgICl9XCJgXG4gICAgICBdLFxuICAgICAgW25vZGUxXSxcbiAgICAgIFtub2RlMl1cbiAgICBdO1xuICB9XG4gIGNvbnN0IHNlbGVjdGlvblNldDEgPSBub2RlMS5zZWxlY3Rpb25TZXQ7XG4gIGNvbnN0IHNlbGVjdGlvblNldDIgPSBub2RlMi5zZWxlY3Rpb25TZXQ7XG4gIGlmIChzZWxlY3Rpb25TZXQxICYmIHNlbGVjdGlvblNldDIpIHtcbiAgICBjb25zdCBjb25mbGljdHMgPSBmaW5kQ29uZmxpY3RzQmV0d2VlblN1YlNlbGVjdGlvblNldHMoXG4gICAgICBjb250ZXh0LFxuICAgICAgY2FjaGVkRmllbGRzQW5kRnJhZ21lbnROYW1lcyxcbiAgICAgIGNvbXBhcmVkRnJhZ21lbnRQYWlycyxcbiAgICAgIGFyZU11dHVhbGx5RXhjbHVzaXZlLFxuICAgICAgZ2V0TmFtZWRUeXBlKHR5cGUxKSxcbiAgICAgIHNlbGVjdGlvblNldDEsXG4gICAgICBnZXROYW1lZFR5cGUodHlwZTIpLFxuICAgICAgc2VsZWN0aW9uU2V0MlxuICAgICk7XG4gICAgcmV0dXJuIHN1YmZpZWxkQ29uZmxpY3RzKGNvbmZsaWN0cywgcmVzcG9uc2VOYW1lLCBub2RlMSwgbm9kZTIpO1xuICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlBcmd1bWVudHMoZmllbGROb2RlKSB7XG4gIHZhciBfZmllbGROb2RlJGFyZ3VtZW50cztcbiAgY29uc3QgYXJncyA9IChcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgIChfZmllbGROb2RlJGFyZ3VtZW50cyA9IGZpZWxkTm9kZS5hcmd1bWVudHMpICE9PSBudWxsICYmIF9maWVsZE5vZGUkYXJndW1lbnRzICE9PSB2b2lkIDAgPyBfZmllbGROb2RlJGFyZ3VtZW50cyA6IFtdXG4gICk7XG4gIGNvbnN0IGlucHV0T2JqZWN0V2l0aEFyZ3MgPSB7XG4gICAga2luZDogS2luZC5PQkpFQ1QsXG4gICAgZmllbGRzOiBhcmdzLm1hcCgoYXJnTm9kZSkgPT4gKHtcbiAgICAgIGtpbmQ6IEtpbmQuT0JKRUNUX0ZJRUxELFxuICAgICAgbmFtZTogYXJnTm9kZS5uYW1lLFxuICAgICAgdmFsdWU6IGFyZ05vZGUudmFsdWVcbiAgICB9KSlcbiAgfTtcbiAgcmV0dXJuIHByaW50KHNvcnRWYWx1ZU5vZGUoaW5wdXRPYmplY3RXaXRoQXJncykpO1xufVxuZnVuY3Rpb24gZG9UeXBlc0NvbmZsaWN0KHR5cGUxLCB0eXBlMikge1xuICBpZiAoaXNMaXN0VHlwZSh0eXBlMSkpIHtcbiAgICByZXR1cm4gaXNMaXN0VHlwZSh0eXBlMikgPyBkb1R5cGVzQ29uZmxpY3QodHlwZTEub2ZUeXBlLCB0eXBlMi5vZlR5cGUpIDogdHJ1ZTtcbiAgfVxuICBpZiAoaXNMaXN0VHlwZSh0eXBlMikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNOb25OdWxsVHlwZSh0eXBlMSkpIHtcbiAgICByZXR1cm4gaXNOb25OdWxsVHlwZSh0eXBlMikgPyBkb1R5cGVzQ29uZmxpY3QodHlwZTEub2ZUeXBlLCB0eXBlMi5vZlR5cGUpIDogdHJ1ZTtcbiAgfVxuICBpZiAoaXNOb25OdWxsVHlwZSh0eXBlMikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNMZWFmVHlwZSh0eXBlMSkgfHwgaXNMZWFmVHlwZSh0eXBlMikpIHtcbiAgICByZXR1cm4gdHlwZTEgIT09IHR5cGUyO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldEZpZWxkc0FuZEZyYWdtZW50TmFtZXMoY29udGV4dCwgY2FjaGVkRmllbGRzQW5kRnJhZ21lbnROYW1lcywgcGFyZW50VHlwZSwgc2VsZWN0aW9uU2V0KSB7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMuZ2V0KHNlbGVjdGlvblNldCk7XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IG5vZGVBbmREZWZzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IGZyYWdtZW50TmFtZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgX2NvbGxlY3RGaWVsZHNBbmRGcmFnbWVudE5hbWVzKFxuICAgIGNvbnRleHQsXG4gICAgcGFyZW50VHlwZSxcbiAgICBzZWxlY3Rpb25TZXQsXG4gICAgbm9kZUFuZERlZnMsXG4gICAgZnJhZ21lbnROYW1lc1xuICApO1xuICBjb25zdCByZXN1bHQgPSBbbm9kZUFuZERlZnMsIE9iamVjdC5rZXlzKGZyYWdtZW50TmFtZXMpXTtcbiAgY2FjaGVkRmllbGRzQW5kRnJhZ21lbnROYW1lcy5zZXQoc2VsZWN0aW9uU2V0LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlZEZpZWxkc0FuZEZyYWdtZW50TmFtZXMoY29udGV4dCwgY2FjaGVkRmllbGRzQW5kRnJhZ21lbnROYW1lcywgZnJhZ21lbnQpIHtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGVkRmllbGRzQW5kRnJhZ21lbnROYW1lcy5nZXQoZnJhZ21lbnQuc2VsZWN0aW9uU2V0KTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgZnJhZ21lbnRUeXBlID0gdHlwZUZyb21BU1QoY29udGV4dC5nZXRTY2hlbWEoKSwgZnJhZ21lbnQudHlwZUNvbmRpdGlvbik7XG4gIHJldHVybiBnZXRGaWVsZHNBbmRGcmFnbWVudE5hbWVzKFxuICAgIGNvbnRleHQsXG4gICAgY2FjaGVkRmllbGRzQW5kRnJhZ21lbnROYW1lcyxcbiAgICBmcmFnbWVudFR5cGUsXG4gICAgZnJhZ21lbnQuc2VsZWN0aW9uU2V0XG4gICk7XG59XG5mdW5jdGlvbiBfY29sbGVjdEZpZWxkc0FuZEZyYWdtZW50TmFtZXMoY29udGV4dCwgcGFyZW50VHlwZSwgc2VsZWN0aW9uU2V0LCBub2RlQW5kRGVmcywgZnJhZ21lbnROYW1lcykge1xuICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucykge1xuICAgIHN3aXRjaCAoc2VsZWN0aW9uLmtpbmQpIHtcbiAgICAgIGNhc2UgS2luZC5GSUVMRDoge1xuICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBzZWxlY3Rpb24ubmFtZS52YWx1ZTtcbiAgICAgICAgbGV0IGZpZWxkRGVmO1xuICAgICAgICBpZiAoaXNPYmplY3RUeXBlKHBhcmVudFR5cGUpIHx8IGlzSW50ZXJmYWNlVHlwZShwYXJlbnRUeXBlKSkge1xuICAgICAgICAgIGZpZWxkRGVmID0gcGFyZW50VHlwZS5nZXRGaWVsZHMoKVtmaWVsZE5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlTmFtZSA9IHNlbGVjdGlvbi5hbGlhcyA/IHNlbGVjdGlvbi5hbGlhcy52YWx1ZSA6IGZpZWxkTmFtZTtcbiAgICAgICAgaWYgKCFub2RlQW5kRGVmc1tyZXNwb25zZU5hbWVdKSB7XG4gICAgICAgICAgbm9kZUFuZERlZnNbcmVzcG9uc2VOYW1lXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVBbmREZWZzW3Jlc3BvbnNlTmFtZV0ucHVzaChbcGFyZW50VHlwZSwgc2VsZWN0aW9uLCBmaWVsZERlZl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgS2luZC5GUkFHTUVOVF9TUFJFQUQ6XG4gICAgICAgIGZyYWdtZW50TmFtZXNbc2VsZWN0aW9uLm5hbWUudmFsdWVdID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtpbmQuSU5MSU5FX0ZSQUdNRU5UOiB7XG4gICAgICAgIGNvbnN0IHR5cGVDb25kaXRpb24gPSBzZWxlY3Rpb24udHlwZUNvbmRpdGlvbjtcbiAgICAgICAgY29uc3QgaW5saW5lRnJhZ21lbnRUeXBlID0gdHlwZUNvbmRpdGlvbiA/IHR5cGVGcm9tQVNUKGNvbnRleHQuZ2V0U2NoZW1hKCksIHR5cGVDb25kaXRpb24pIDogcGFyZW50VHlwZTtcbiAgICAgICAgX2NvbGxlY3RGaWVsZHNBbmRGcmFnbWVudE5hbWVzKFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgaW5saW5lRnJhZ21lbnRUeXBlLFxuICAgICAgICAgIHNlbGVjdGlvbi5zZWxlY3Rpb25TZXQsXG4gICAgICAgICAgbm9kZUFuZERlZnMsXG4gICAgICAgICAgZnJhZ21lbnROYW1lc1xuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN1YmZpZWxkQ29uZmxpY3RzKGNvbmZsaWN0cywgcmVzcG9uc2VOYW1lLCBub2RlMSwgbm9kZTIpIHtcbiAgaWYgKGNvbmZsaWN0cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFtyZXNwb25zZU5hbWUsIGNvbmZsaWN0cy5tYXAoKFtyZWFzb25dKSA9PiByZWFzb24pXSxcbiAgICAgIFtub2RlMSwgLi4uY29uZmxpY3RzLm1hcCgoWywgZmllbGRzMV0pID0+IGZpZWxkczEpLmZsYXQoKV0sXG4gICAgICBbbm9kZTIsIC4uLmNvbmZsaWN0cy5tYXAoKFssICwgZmllbGRzMl0pID0+IGZpZWxkczIpLmZsYXQoKV1cbiAgICBdO1xuICB9XG59XG52YXIgUGFpclNldDtcbnZhciBpbml0X092ZXJsYXBwaW5nRmllbGRzQ2FuQmVNZXJnZWRSdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvT3ZlcmxhcHBpbmdGaWVsZHNDYW5CZU1lcmdlZFJ1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9pbnNwZWN0KCk7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgICBpbml0X2tpbmRzKCk7XG4gICAgaW5pdF9wcmludGVyKCk7XG4gICAgaW5pdF9kZWZpbml0aW9uKCk7XG4gICAgaW5pdF9zb3J0VmFsdWVOb2RlKCk7XG4gICAgaW5pdF90eXBlRnJvbUFTVCgpO1xuICAgIFBhaXJTZXQgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgICBoYXMoYSwgYiwgYXJlTXV0dWFsbHlFeGNsdXNpdmUpIHtcbiAgICAgICAgdmFyIF90aGlzJF9kYXRhJGdldDtcbiAgICAgICAgY29uc3QgW2tleTEsIGtleTJdID0gYSA8IGIgPyBbYSwgYl0gOiBbYiwgYV07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IChfdGhpcyRfZGF0YSRnZXQgPSB0aGlzLl9kYXRhLmdldChrZXkxKSkgPT09IG51bGwgfHwgX3RoaXMkX2RhdGEkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfZGF0YSRnZXQuZ2V0KGtleTIpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZU11dHVhbGx5RXhjbHVzaXZlID8gdHJ1ZSA6IGFyZU11dHVhbGx5RXhjbHVzaXZlID09PSByZXN1bHQ7XG4gICAgICB9XG4gICAgICBhZGQoYSwgYiwgYXJlTXV0dWFsbHlFeGNsdXNpdmUpIHtcbiAgICAgICAgY29uc3QgW2tleTEsIGtleTJdID0gYSA8IGIgPyBbYSwgYl0gOiBbYiwgYV07XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuX2RhdGEuZ2V0KGtleTEpO1xuICAgICAgICBpZiAobWFwID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aGlzLl9kYXRhLnNldChrZXkxLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW2tleTIsIGFyZU11dHVhbGx5RXhjbHVzaXZlXV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXAuc2V0KGtleTIsIGFyZU11dHVhbGx5RXhjbHVzaXZlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL1Bvc3NpYmxlRnJhZ21lbnRTcHJlYWRzUnVsZS5tanNcbmZ1bmN0aW9uIFBvc3NpYmxlRnJhZ21lbnRTcHJlYWRzUnVsZShjb250ZXh0KSB7XG4gIHJldHVybiB7XG4gICAgSW5saW5lRnJhZ21lbnQobm9kZSkge1xuICAgICAgY29uc3QgZnJhZ1R5cGUgPSBjb250ZXh0LmdldFR5cGUoKTtcbiAgICAgIGNvbnN0IHBhcmVudFR5cGUgPSBjb250ZXh0LmdldFBhcmVudFR5cGUoKTtcbiAgICAgIGlmIChpc0NvbXBvc2l0ZVR5cGUoZnJhZ1R5cGUpICYmIGlzQ29tcG9zaXRlVHlwZShwYXJlbnRUeXBlKSAmJiAhZG9UeXBlc092ZXJsYXAoY29udGV4dC5nZXRTY2hlbWEoKSwgZnJhZ1R5cGUsIHBhcmVudFR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFR5cGVTdHIgPSBpbnNwZWN0KHBhcmVudFR5cGUpO1xuICAgICAgICBjb25zdCBmcmFnVHlwZVN0ciA9IGluc3BlY3QoZnJhZ1R5cGUpO1xuICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBgRnJhZ21lbnQgY2Fubm90IGJlIHNwcmVhZCBoZXJlIGFzIG9iamVjdHMgb2YgdHlwZSBcIiR7cGFyZW50VHlwZVN0cn1cIiBjYW4gbmV2ZXIgYmUgb2YgdHlwZSBcIiR7ZnJhZ1R5cGVTdHJ9XCIuYCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbm9kZXM6IG5vZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICBGcmFnbWVudFNwcmVhZChub2RlKSB7XG4gICAgICBjb25zdCBmcmFnTmFtZSA9IG5vZGUubmFtZS52YWx1ZTtcbiAgICAgIGNvbnN0IGZyYWdUeXBlID0gZ2V0RnJhZ21lbnRUeXBlKGNvbnRleHQsIGZyYWdOYW1lKTtcbiAgICAgIGNvbnN0IHBhcmVudFR5cGUgPSBjb250ZXh0LmdldFBhcmVudFR5cGUoKTtcbiAgICAgIGlmIChmcmFnVHlwZSAmJiBwYXJlbnRUeXBlICYmICFkb1R5cGVzT3ZlcmxhcChjb250ZXh0LmdldFNjaGVtYSgpLCBmcmFnVHlwZSwgcGFyZW50VHlwZSkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50VHlwZVN0ciA9IGluc3BlY3QocGFyZW50VHlwZSk7XG4gICAgICAgIGNvbnN0IGZyYWdUeXBlU3RyID0gaW5zcGVjdChmcmFnVHlwZSk7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBGcmFnbWVudCBcIiR7ZnJhZ05hbWV9XCIgY2Fubm90IGJlIHNwcmVhZCBoZXJlIGFzIG9iamVjdHMgb2YgdHlwZSBcIiR7cGFyZW50VHlwZVN0cn1cIiBjYW4gbmV2ZXIgYmUgb2YgdHlwZSBcIiR7ZnJhZ1R5cGVTdHJ9XCIuYCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbm9kZXM6IG5vZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRUeXBlKGNvbnRleHQsIG5hbWUpIHtcbiAgY29uc3QgZnJhZyA9IGNvbnRleHQuZ2V0RnJhZ21lbnQobmFtZSk7XG4gIGlmIChmcmFnKSB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVGcm9tQVNUKGNvbnRleHQuZ2V0U2NoZW1hKCksIGZyYWcudHlwZUNvbmRpdGlvbik7XG4gICAgaWYgKGlzQ29tcG9zaXRlVHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG59XG52YXIgaW5pdF9Qb3NzaWJsZUZyYWdtZW50U3ByZWFkc1J1bGUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9Qb3NzaWJsZUZyYWdtZW50U3ByZWFkc1J1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9pbnNwZWN0KCk7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgICBpbml0X2RlZmluaXRpb24oKTtcbiAgICBpbml0X3R5cGVDb21wYXJhdG9ycygpO1xuICAgIGluaXRfdHlwZUZyb21BU1QoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvUG9zc2libGVUeXBlRXh0ZW5zaW9uc1J1bGUubWpzXG5mdW5jdGlvbiBQb3NzaWJsZVR5cGVFeHRlbnNpb25zUnVsZShjb250ZXh0KSB7XG4gIGNvbnN0IHNjaGVtYSA9IGNvbnRleHQuZ2V0U2NoZW1hKCk7XG4gIGNvbnN0IGRlZmluZWRUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IGRlZiBvZiBjb250ZXh0LmdldERvY3VtZW50KCkuZGVmaW5pdGlvbnMpIHtcbiAgICBpZiAoaXNUeXBlRGVmaW5pdGlvbk5vZGUoZGVmKSkge1xuICAgICAgZGVmaW5lZFR5cGVzW2RlZi5uYW1lLnZhbHVlXSA9IGRlZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBTY2FsYXJUeXBlRXh0ZW5zaW9uOiBjaGVja0V4dGVuc2lvbixcbiAgICBPYmplY3RUeXBlRXh0ZW5zaW9uOiBjaGVja0V4dGVuc2lvbixcbiAgICBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uOiBjaGVja0V4dGVuc2lvbixcbiAgICBVbmlvblR5cGVFeHRlbnNpb246IGNoZWNrRXh0ZW5zaW9uLFxuICAgIEVudW1UeXBlRXh0ZW5zaW9uOiBjaGVja0V4dGVuc2lvbixcbiAgICBJbnB1dE9iamVjdFR5cGVFeHRlbnNpb246IGNoZWNrRXh0ZW5zaW9uXG4gIH07XG4gIGZ1bmN0aW9uIGNoZWNrRXh0ZW5zaW9uKG5vZGUpIHtcbiAgICBjb25zdCB0eXBlTmFtZSA9IG5vZGUubmFtZS52YWx1ZTtcbiAgICBjb25zdCBkZWZOb2RlID0gZGVmaW5lZFR5cGVzW3R5cGVOYW1lXTtcbiAgICBjb25zdCBleGlzdGluZ1R5cGUgPSBzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWEuZ2V0VHlwZSh0eXBlTmFtZSk7XG4gICAgbGV0IGV4cGVjdGVkS2luZDtcbiAgICBpZiAoZGVmTm9kZSkge1xuICAgICAgZXhwZWN0ZWRLaW5kID0gZGVmS2luZFRvRXh0S2luZFtkZWZOb2RlLmtpbmRdO1xuICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdUeXBlKSB7XG4gICAgICBleHBlY3RlZEtpbmQgPSB0eXBlVG9FeHRLaW5kKGV4aXN0aW5nVHlwZSk7XG4gICAgfVxuICAgIGlmIChleHBlY3RlZEtpbmQpIHtcbiAgICAgIGlmIChleHBlY3RlZEtpbmQgIT09IG5vZGUua2luZCkge1xuICAgICAgICBjb25zdCBraW5kU3RyID0gZXh0ZW5zaW9uS2luZFRvVHlwZU5hbWUobm9kZS5raW5kKTtcbiAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKGBDYW5ub3QgZXh0ZW5kIG5vbi0ke2tpbmRTdHJ9IHR5cGUgXCIke3R5cGVOYW1lfVwiLmAsIHtcbiAgICAgICAgICAgIG5vZGVzOiBkZWZOb2RlID8gW2RlZk5vZGUsIG5vZGVdIDogbm9kZVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFsbFR5cGVOYW1lcyA9IE9iamVjdC5rZXlzKHtcbiAgICAgICAgLi4uZGVmaW5lZFR5cGVzLFxuICAgICAgICAuLi5zY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWEuZ2V0VHlwZU1hcCgpXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN1Z2dlc3RlZFR5cGVzID0gc3VnZ2VzdGlvbkxpc3QodHlwZU5hbWUsIGFsbFR5cGVOYW1lcyk7XG4gICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgIGBDYW5ub3QgZXh0ZW5kIHR5cGUgXCIke3R5cGVOYW1lfVwiIGJlY2F1c2UgaXQgaXMgbm90IGRlZmluZWQuYCArIGRpZFlvdU1lYW4oc3VnZ2VzdGVkVHlwZXMpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5vZGVzOiBub2RlLm5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0eXBlVG9FeHRLaW5kKHR5cGUpIHtcbiAgaWYgKGlzU2NhbGFyVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiBLaW5kLlNDQUxBUl9UWVBFX0VYVEVOU0lPTjtcbiAgfVxuICBpZiAoaXNPYmplY3RUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIEtpbmQuT0JKRUNUX1RZUEVfRVhURU5TSU9OO1xuICB9XG4gIGlmIChpc0ludGVyZmFjZVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gS2luZC5JTlRFUkZBQ0VfVFlQRV9FWFRFTlNJT047XG4gIH1cbiAgaWYgKGlzVW5pb25UeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIEtpbmQuVU5JT05fVFlQRV9FWFRFTlNJT047XG4gIH1cbiAgaWYgKGlzRW51bVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gS2luZC5FTlVNX1RZUEVfRVhURU5TSU9OO1xuICB9XG4gIGlmIChpc0lucHV0T2JqZWN0VHlwZSh0eXBlKSkge1xuICAgIHJldHVybiBLaW5kLklOUFVUX09CSkVDVF9UWVBFX0VYVEVOU0lPTjtcbiAgfVxuICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5leHBlY3RlZCB0eXBlOiBcIiArIGluc3BlY3QodHlwZSkpO1xufVxuZnVuY3Rpb24gZXh0ZW5zaW9uS2luZFRvVHlwZU5hbWUoa2luZCkge1xuICBzd2l0Y2ggKGtpbmQpIHtcbiAgICBjYXNlIEtpbmQuU0NBTEFSX1RZUEVfRVhURU5TSU9OOlxuICAgICAgcmV0dXJuIFwic2NhbGFyXCI7XG4gICAgY2FzZSBLaW5kLk9CSkVDVF9UWVBFX0VYVEVOU0lPTjpcbiAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgIGNhc2UgS2luZC5JTlRFUkZBQ0VfVFlQRV9FWFRFTlNJT046XG4gICAgICByZXR1cm4gXCJpbnRlcmZhY2VcIjtcbiAgICBjYXNlIEtpbmQuVU5JT05fVFlQRV9FWFRFTlNJT046XG4gICAgICByZXR1cm4gXCJ1bmlvblwiO1xuICAgIGNhc2UgS2luZC5FTlVNX1RZUEVfRVhURU5TSU9OOlxuICAgICAgcmV0dXJuIFwiZW51bVwiO1xuICAgIGNhc2UgS2luZC5JTlBVVF9PQkpFQ1RfVFlQRV9FWFRFTlNJT046XG4gICAgICByZXR1cm4gXCJpbnB1dCBvYmplY3RcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgaW52YXJpYW50KGZhbHNlLCBcIlVuZXhwZWN0ZWQga2luZDogXCIgKyBpbnNwZWN0KGtpbmQpKTtcbiAgfVxufVxudmFyIGRlZktpbmRUb0V4dEtpbmQ7XG52YXIgaW5pdF9Qb3NzaWJsZVR5cGVFeHRlbnNpb25zUnVsZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL1Bvc3NpYmxlVHlwZUV4dGVuc2lvbnNSdWxlLm1qc1wiKCkge1xuICAgIGluaXRfZGlkWW91TWVhbigpO1xuICAgIGluaXRfaW5zcGVjdCgpO1xuICAgIGluaXRfaW52YXJpYW50KCk7XG4gICAgaW5pdF9zdWdnZXN0aW9uTGlzdCgpO1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gICAgaW5pdF9raW5kcygpO1xuICAgIGluaXRfcHJlZGljYXRlcygpO1xuICAgIGluaXRfZGVmaW5pdGlvbigpO1xuICAgIGRlZktpbmRUb0V4dEtpbmQgPSB7XG4gICAgICBbS2luZC5TQ0FMQVJfVFlQRV9ERUZJTklUSU9OXTogS2luZC5TQ0FMQVJfVFlQRV9FWFRFTlNJT04sXG4gICAgICBbS2luZC5PQkpFQ1RfVFlQRV9ERUZJTklUSU9OXTogS2luZC5PQkpFQ1RfVFlQRV9FWFRFTlNJT04sXG4gICAgICBbS2luZC5JTlRFUkZBQ0VfVFlQRV9ERUZJTklUSU9OXTogS2luZC5JTlRFUkZBQ0VfVFlQRV9FWFRFTlNJT04sXG4gICAgICBbS2luZC5VTklPTl9UWVBFX0RFRklOSVRJT05dOiBLaW5kLlVOSU9OX1RZUEVfRVhURU5TSU9OLFxuICAgICAgW0tpbmQuRU5VTV9UWVBFX0RFRklOSVRJT05dOiBLaW5kLkVOVU1fVFlQRV9FWFRFTlNJT04sXG4gICAgICBbS2luZC5JTlBVVF9PQkpFQ1RfVFlQRV9ERUZJTklUSU9OXTogS2luZC5JTlBVVF9PQkpFQ1RfVFlQRV9FWFRFTlNJT05cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9Qcm92aWRlZFJlcXVpcmVkQXJndW1lbnRzUnVsZS5tanNcbmZ1bmN0aW9uIFByb3ZpZGVkUmVxdWlyZWRBcmd1bWVudHNSdWxlKGNvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICAgIC4uLlByb3ZpZGVkUmVxdWlyZWRBcmd1bWVudHNPbkRpcmVjdGl2ZXNSdWxlKGNvbnRleHQpLFxuICAgIEZpZWxkOiB7XG4gICAgICAvLyBWYWxpZGF0ZSBvbiBsZWF2ZSB0byBhbGxvdyBmb3IgZGVlcGVyIGVycm9ycyB0byBhcHBlYXIgZmlyc3QuXG4gICAgICBsZWF2ZShmaWVsZE5vZGUpIHtcbiAgICAgICAgdmFyIF9maWVsZE5vZGUkYXJndW1lbnRzO1xuICAgICAgICBjb25zdCBmaWVsZERlZiA9IGNvbnRleHQuZ2V0RmllbGREZWYoKTtcbiAgICAgICAgaWYgKCFmaWVsZERlZikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm92aWRlZEFyZ3MgPSBuZXcgU2V0KFxuICAgICAgICAgIC8vIEZJWE1FOiBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLWpzL2lzc3Vlcy8yMjAzXG4gICAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAoX2ZpZWxkTm9kZSRhcmd1bWVudHMgPSBmaWVsZE5vZGUuYXJndW1lbnRzKSA9PT0gbnVsbCB8fCBfZmllbGROb2RlJGFyZ3VtZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZpZWxkTm9kZSRhcmd1bWVudHMubWFwKChhcmcpID0+IGFyZy5uYW1lLnZhbHVlKVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IGFyZ0RlZiBvZiBmaWVsZERlZi5hcmdzKSB7XG4gICAgICAgICAgaWYgKCFwcm92aWRlZEFyZ3MuaGFzKGFyZ0RlZi5uYW1lKSAmJiBpc1JlcXVpcmVkQXJndW1lbnQoYXJnRGVmKSkge1xuICAgICAgICAgICAgY29uc3QgYXJnVHlwZVN0ciA9IGluc3BlY3QoYXJnRGVmLnR5cGUpO1xuICAgICAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgICAgICBgRmllbGQgXCIke2ZpZWxkRGVmLm5hbWV9XCIgYXJndW1lbnQgXCIke2FyZ0RlZi5uYW1lfVwiIG9mIHR5cGUgXCIke2FyZ1R5cGVTdHJ9XCIgaXMgcmVxdWlyZWQsIGJ1dCBpdCB3YXMgbm90IHByb3ZpZGVkLmAsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbm9kZXM6IGZpZWxkTm9kZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBQcm92aWRlZFJlcXVpcmVkQXJndW1lbnRzT25EaXJlY3RpdmVzUnVsZShjb250ZXh0KSB7XG4gIHZhciBfc2NoZW1hJGdldERpcmVjdGl2ZXM7XG4gIGNvbnN0IHJlcXVpcmVkQXJnc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBzY2hlbWEgPSBjb250ZXh0LmdldFNjaGVtYSgpO1xuICBjb25zdCBkZWZpbmVkRGlyZWN0aXZlcyA9IChfc2NoZW1hJGdldERpcmVjdGl2ZXMgPSBzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWEuZ2V0RGlyZWN0aXZlcygpKSAhPT0gbnVsbCAmJiBfc2NoZW1hJGdldERpcmVjdGl2ZXMgIT09IHZvaWQgMCA/IF9zY2hlbWEkZ2V0RGlyZWN0aXZlcyA6IHNwZWNpZmllZERpcmVjdGl2ZXM7XG4gIGZvciAoY29uc3QgZGlyZWN0aXZlIG9mIGRlZmluZWREaXJlY3RpdmVzKSB7XG4gICAgcmVxdWlyZWRBcmdzTWFwW2RpcmVjdGl2ZS5uYW1lXSA9IGtleU1hcChcbiAgICAgIGRpcmVjdGl2ZS5hcmdzLmZpbHRlcihpc1JlcXVpcmVkQXJndW1lbnQpLFxuICAgICAgKGFyZykgPT4gYXJnLm5hbWVcbiAgICApO1xuICB9XG4gIGNvbnN0IGFzdERlZmluaXRpb25zID0gY29udGV4dC5nZXREb2N1bWVudCgpLmRlZmluaXRpb25zO1xuICBmb3IgKGNvbnN0IGRlZiBvZiBhc3REZWZpbml0aW9ucykge1xuICAgIGlmIChkZWYua2luZCA9PT0gS2luZC5ESVJFQ1RJVkVfREVGSU5JVElPTikge1xuICAgICAgdmFyIF9kZWYkYXJndW1lbnRzO1xuICAgICAgY29uc3QgYXJnTm9kZXMgPSAoX2RlZiRhcmd1bWVudHMgPSBkZWYuYXJndW1lbnRzKSAhPT0gbnVsbCAmJiBfZGVmJGFyZ3VtZW50cyAhPT0gdm9pZCAwID8gX2RlZiRhcmd1bWVudHMgOiBbXTtcbiAgICAgIHJlcXVpcmVkQXJnc01hcFtkZWYubmFtZS52YWx1ZV0gPSBrZXlNYXAoXG4gICAgICAgIGFyZ05vZGVzLmZpbHRlcihpc1JlcXVpcmVkQXJndW1lbnROb2RlKSxcbiAgICAgICAgKGFyZykgPT4gYXJnLm5hbWUudmFsdWVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgRGlyZWN0aXZlOiB7XG4gICAgICAvLyBWYWxpZGF0ZSBvbiBsZWF2ZSB0byBhbGxvdyBmb3IgZGVlcGVyIGVycm9ycyB0byBhcHBlYXIgZmlyc3QuXG4gICAgICBsZWF2ZShkaXJlY3RpdmVOb2RlKSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVOb2RlLm5hbWUudmFsdWU7XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkQXJncyA9IHJlcXVpcmVkQXJnc01hcFtkaXJlY3RpdmVOYW1lXTtcbiAgICAgICAgaWYgKHJlcXVpcmVkQXJncykge1xuICAgICAgICAgIHZhciBfZGlyZWN0aXZlTm9kZSRhcmd1bWU7XG4gICAgICAgICAgY29uc3QgYXJnTm9kZXMgPSAoX2RpcmVjdGl2ZU5vZGUkYXJndW1lID0gZGlyZWN0aXZlTm9kZS5hcmd1bWVudHMpICE9PSBudWxsICYmIF9kaXJlY3RpdmVOb2RlJGFyZ3VtZSAhPT0gdm9pZCAwID8gX2RpcmVjdGl2ZU5vZGUkYXJndW1lIDogW107XG4gICAgICAgICAgY29uc3QgYXJnTm9kZU1hcCA9IG5ldyBTZXQoYXJnTm9kZXMubWFwKChhcmcpID0+IGFyZy5uYW1lLnZhbHVlKSk7XG4gICAgICAgICAgZm9yIChjb25zdCBbYXJnTmFtZSwgYXJnRGVmXSBvZiBPYmplY3QuZW50cmllcyhyZXF1aXJlZEFyZ3MpKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ05vZGVNYXAuaGFzKGFyZ05hbWUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFyZ1R5cGUgPSBpc1R5cGUoYXJnRGVmLnR5cGUpID8gaW5zcGVjdChhcmdEZWYudHlwZSkgOiBwcmludChhcmdEZWYudHlwZSk7XG4gICAgICAgICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgICAgICAgIGBEaXJlY3RpdmUgXCJAJHtkaXJlY3RpdmVOYW1lfVwiIGFyZ3VtZW50IFwiJHthcmdOYW1lfVwiIG9mIHR5cGUgXCIke2FyZ1R5cGV9XCIgaXMgcmVxdWlyZWQsIGJ1dCBpdCB3YXMgbm90IHByb3ZpZGVkLmAsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzOiBkaXJlY3RpdmVOb2RlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUmVxdWlyZWRBcmd1bWVudE5vZGUoYXJnKSB7XG4gIHJldHVybiBhcmcudHlwZS5raW5kID09PSBLaW5kLk5PTl9OVUxMX1RZUEUgJiYgYXJnLmRlZmF1bHRWYWx1ZSA9PSBudWxsO1xufVxudmFyIGluaXRfUHJvdmlkZWRSZXF1aXJlZEFyZ3VtZW50c1J1bGUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9Qcm92aWRlZFJlcXVpcmVkQXJndW1lbnRzUnVsZS5tanNcIigpIHtcbiAgICBpbml0X2luc3BlY3QoKTtcbiAgICBpbml0X2tleU1hcCgpO1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gICAgaW5pdF9raW5kcygpO1xuICAgIGluaXRfcHJpbnRlcigpO1xuICAgIGluaXRfZGVmaW5pdGlvbigpO1xuICAgIGluaXRfZGlyZWN0aXZlcygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9TY2FsYXJMZWFmc1J1bGUubWpzXG5mdW5jdGlvbiBTY2FsYXJMZWFmc1J1bGUoY29udGV4dCkge1xuICByZXR1cm4ge1xuICAgIEZpZWxkKG5vZGUpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBjb250ZXh0LmdldFR5cGUoKTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvblNldCA9IG5vZGUuc2VsZWN0aW9uU2V0O1xuICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgaWYgKGlzTGVhZlR5cGUoZ2V0TmFtZWRUeXBlKHR5cGUpKSkge1xuICAgICAgICAgIGlmIChzZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IG5vZGUubmFtZS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPSBpbnNwZWN0KHR5cGUpO1xuICAgICAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgICAgICBgRmllbGQgXCIke2ZpZWxkTmFtZX1cIiBtdXN0IG5vdCBoYXZlIGEgc2VsZWN0aW9uIHNpbmNlIHR5cGUgXCIke3R5cGVTdHJ9XCIgaGFzIG5vIHN1YmZpZWxkcy5gLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIG5vZGVzOiBzZWxlY3Rpb25TZXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFzZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBub2RlLm5hbWUudmFsdWU7XG4gICAgICAgICAgY29uc3QgdHlwZVN0ciA9IGluc3BlY3QodHlwZSk7XG4gICAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICAgIGBGaWVsZCBcIiR7ZmllbGROYW1lfVwiIG9mIHR5cGUgXCIke3R5cGVTdHJ9XCIgbXVzdCBoYXZlIGEgc2VsZWN0aW9uIG9mIHN1YmZpZWxkcy4gRGlkIHlvdSBtZWFuIFwiJHtmaWVsZE5hbWV9IHsgLi4uIH1cIj9gLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm9kZXM6IG5vZGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9TY2FsYXJMZWFmc1J1bGUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9TY2FsYXJMZWFmc1J1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9pbnNwZWN0KCk7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgICBpbml0X2RlZmluaXRpb24oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvcHJpbnRQYXRoQXJyYXkubWpzXG5mdW5jdGlvbiBwcmludFBhdGhBcnJheShwYXRoKSB7XG4gIHJldHVybiBwYXRoLm1hcChcbiAgICAoa2V5KSA9PiB0eXBlb2Yga2V5ID09PSBcIm51bWJlclwiID8gXCJbXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiXVwiIDogXCIuXCIgKyBrZXlcbiAgKS5qb2luKFwiXCIpO1xufVxudmFyIGluaXRfcHJpbnRQYXRoQXJyYXkgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9wcmludFBhdGhBcnJheS5tanNcIigpIHtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvUGF0aC5tanNcbmZ1bmN0aW9uIGFkZFBhdGgocHJldiwga2V5LCB0eXBlbmFtZSkge1xuICByZXR1cm4ge1xuICAgIHByZXYsXG4gICAga2V5LFxuICAgIHR5cGVuYW1lXG4gIH07XG59XG5mdW5jdGlvbiBwYXRoVG9BcnJheShwYXRoKSB7XG4gIGNvbnN0IGZsYXR0ZW5lZCA9IFtdO1xuICBsZXQgY3VyciA9IHBhdGg7XG4gIHdoaWxlIChjdXJyKSB7XG4gICAgZmxhdHRlbmVkLnB1c2goY3Vyci5rZXkpO1xuICAgIGN1cnIgPSBjdXJyLnByZXY7XG4gIH1cbiAgcmV0dXJuIGZsYXR0ZW5lZC5yZXZlcnNlKCk7XG59XG52YXIgaW5pdF9QYXRoID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvUGF0aC5tanNcIigpIHtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9jb2VyY2VJbnB1dFZhbHVlLm1qc1xuZnVuY3Rpb24gY29lcmNlSW5wdXRWYWx1ZShpbnB1dFZhbHVlLCB0eXBlLCBvbkVycm9yID0gZGVmYXVsdE9uRXJyb3IpIHtcbiAgcmV0dXJuIGNvZXJjZUlucHV0VmFsdWVJbXBsKGlucHV0VmFsdWUsIHR5cGUsIG9uRXJyb3IsIHZvaWQgMCk7XG59XG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihwYXRoLCBpbnZhbGlkVmFsdWUsIGVycm9yKSB7XG4gIGxldCBlcnJvclByZWZpeCA9IFwiSW52YWxpZCB2YWx1ZSBcIiArIGluc3BlY3QoaW52YWxpZFZhbHVlKTtcbiAgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgIGVycm9yUHJlZml4ICs9IGAgYXQgXCJ2YWx1ZSR7cHJpbnRQYXRoQXJyYXkocGF0aCl9XCJgO1xuICB9XG4gIGVycm9yLm1lc3NhZ2UgPSBlcnJvclByZWZpeCArIFwiOiBcIiArIGVycm9yLm1lc3NhZ2U7XG4gIHRocm93IGVycm9yO1xufVxuZnVuY3Rpb24gY29lcmNlSW5wdXRWYWx1ZUltcGwoaW5wdXRWYWx1ZSwgdHlwZSwgb25FcnJvciwgcGF0aCkge1xuICBpZiAoaXNOb25OdWxsVHlwZSh0eXBlKSkge1xuICAgIGlmIChpbnB1dFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2VyY2VJbnB1dFZhbHVlSW1wbChpbnB1dFZhbHVlLCB0eXBlLm9mVHlwZSwgb25FcnJvciwgcGF0aCk7XG4gICAgfVxuICAgIG9uRXJyb3IoXG4gICAgICBwYXRoVG9BcnJheShwYXRoKSxcbiAgICAgIGlucHV0VmFsdWUsXG4gICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgbm9uLW51bGxhYmxlIHR5cGUgXCIke2luc3BlY3QodHlwZSl9XCIgbm90IHRvIGJlIG51bGwuYFxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbnB1dFZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNMaXN0VHlwZSh0eXBlKSkge1xuICAgIGNvbnN0IGl0ZW1UeXBlID0gdHlwZS5vZlR5cGU7XG4gICAgaWYgKGlzSXRlcmFibGVPYmplY3QoaW5wdXRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGlucHV0VmFsdWUsIChpdGVtVmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW1QYXRoID0gYWRkUGF0aChwYXRoLCBpbmRleCwgdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuIGNvZXJjZUlucHV0VmFsdWVJbXBsKGl0ZW1WYWx1ZSwgaXRlbVR5cGUsIG9uRXJyb3IsIGl0ZW1QYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW2NvZXJjZUlucHV0VmFsdWVJbXBsKGlucHV0VmFsdWUsIGl0ZW1UeXBlLCBvbkVycm9yLCBwYXRoKV07XG4gIH1cbiAgaWYgKGlzSW5wdXRPYmplY3RUeXBlKHR5cGUpKSB7XG4gICAgaWYgKCFpc09iamVjdExpa2UoaW5wdXRWYWx1ZSkpIHtcbiAgICAgIG9uRXJyb3IoXG4gICAgICAgIHBhdGhUb0FycmF5KHBhdGgpLFxuICAgICAgICBpbnB1dFZhbHVlLFxuICAgICAgICBuZXcgR3JhcGhRTEVycm9yKGBFeHBlY3RlZCB0eXBlIFwiJHt0eXBlLm5hbWV9XCIgdG8gYmUgYW4gb2JqZWN0LmApXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb2VyY2VkVmFsdWUgPSB7fTtcbiAgICBjb25zdCBmaWVsZERlZnMgPSB0eXBlLmdldEZpZWxkcygpO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgT2JqZWN0LnZhbHVlcyhmaWVsZERlZnMpKSB7XG4gICAgICBjb25zdCBmaWVsZFZhbHVlID0gaW5wdXRWYWx1ZVtmaWVsZC5uYW1lXTtcbiAgICAgIGlmIChmaWVsZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKGZpZWxkLmRlZmF1bHRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29lcmNlZFZhbHVlW2ZpZWxkLm5hbWVdID0gZmllbGQuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTm9uTnVsbFR5cGUoZmllbGQudHlwZSkpIHtcbiAgICAgICAgICBjb25zdCB0eXBlU3RyID0gaW5zcGVjdChmaWVsZC50eXBlKTtcbiAgICAgICAgICBvbkVycm9yKFxuICAgICAgICAgICAgcGF0aFRvQXJyYXkocGF0aCksXG4gICAgICAgICAgICBpbnB1dFZhbHVlLFxuICAgICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgICAgYEZpZWxkIFwiJHtmaWVsZC5uYW1lfVwiIG9mIHJlcXVpcmVkIHR5cGUgXCIke3R5cGVTdHJ9XCIgd2FzIG5vdCBwcm92aWRlZC5gXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvZXJjZWRWYWx1ZVtmaWVsZC5uYW1lXSA9IGNvZXJjZUlucHV0VmFsdWVJbXBsKFxuICAgICAgICBmaWVsZFZhbHVlLFxuICAgICAgICBmaWVsZC50eXBlLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBhZGRQYXRoKHBhdGgsIGZpZWxkLm5hbWUsIHR5cGUubmFtZSlcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIE9iamVjdC5rZXlzKGlucHV0VmFsdWUpKSB7XG4gICAgICBpZiAoIWZpZWxkRGVmc1tmaWVsZE5hbWVdKSB7XG4gICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbkxpc3QoXG4gICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICAgIE9iamVjdC5rZXlzKHR5cGUuZ2V0RmllbGRzKCkpXG4gICAgICAgICk7XG4gICAgICAgIG9uRXJyb3IoXG4gICAgICAgICAgcGF0aFRvQXJyYXkocGF0aCksXG4gICAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYEZpZWxkIFwiJHtmaWVsZE5hbWV9XCIgaXMgbm90IGRlZmluZWQgYnkgdHlwZSBcIiR7dHlwZS5uYW1lfVwiLmAgKyBkaWRZb3VNZWFuKHN1Z2dlc3Rpb25zKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvZXJjZWRWYWx1ZTtcbiAgfVxuICBpZiAoaXNMZWFmVHlwZSh0eXBlKSkge1xuICAgIGxldCBwYXJzZVJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgcGFyc2VSZXN1bHQgPSB0eXBlLnBhcnNlVmFsdWUoaW5wdXRWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEdyYXBoUUxFcnJvcikge1xuICAgICAgICBvbkVycm9yKHBhdGhUb0FycmF5KHBhdGgpLCBpbnB1dFZhbHVlLCBlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkVycm9yKFxuICAgICAgICAgIHBhdGhUb0FycmF5KHBhdGgpLFxuICAgICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihgRXhwZWN0ZWQgdHlwZSBcIiR7dHlwZS5uYW1lfVwiLiBgICsgZXJyb3IubWVzc2FnZSwge1xuICAgICAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyb3JcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGFyc2VSZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgb25FcnJvcihcbiAgICAgICAgcGF0aFRvQXJyYXkocGF0aCksXG4gICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoYEV4cGVjdGVkIHR5cGUgXCIke3R5cGUubmFtZX1cIi5gKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlUmVzdWx0O1xuICB9XG4gIGludmFyaWFudChmYWxzZSwgXCJVbmV4cGVjdGVkIGlucHV0IHR5cGU6IFwiICsgaW5zcGVjdCh0eXBlKSk7XG59XG52YXIgaW5pdF9jb2VyY2VJbnB1dFZhbHVlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9jb2VyY2VJbnB1dFZhbHVlLm1qc1wiKCkge1xuICAgIGluaXRfZGlkWW91TWVhbigpO1xuICAgIGluaXRfaW5zcGVjdCgpO1xuICAgIGluaXRfaW52YXJpYW50KCk7XG4gICAgaW5pdF9pc0l0ZXJhYmxlT2JqZWN0KCk7XG4gICAgaW5pdF9pc09iamVjdExpa2UoKTtcbiAgICBpbml0X1BhdGgoKTtcbiAgICBpbml0X3ByaW50UGF0aEFycmF5KCk7XG4gICAgaW5pdF9zdWdnZXN0aW9uTGlzdCgpO1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gICAgaW5pdF9kZWZpbml0aW9uKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvdmFsdWVGcm9tQVNULm1qc1xuZnVuY3Rpb24gdmFsdWVGcm9tQVNUKHZhbHVlTm9kZSwgdHlwZSwgdmFyaWFibGVzKSB7XG4gIGlmICghdmFsdWVOb2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZU5vZGUua2luZCA9PT0gS2luZC5WQVJJQUJMRSkge1xuICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IHZhbHVlTm9kZS5uYW1lLnZhbHVlO1xuICAgIGlmICh2YXJpYWJsZXMgPT0gbnVsbCB8fCB2YXJpYWJsZXNbdmFyaWFibGVOYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZhcmlhYmxlVmFsdWUgPSB2YXJpYWJsZXNbdmFyaWFibGVOYW1lXTtcbiAgICBpZiAodmFyaWFibGVWYWx1ZSA9PT0gbnVsbCAmJiBpc05vbk51bGxUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB2YXJpYWJsZVZhbHVlO1xuICB9XG4gIGlmIChpc05vbk51bGxUeXBlKHR5cGUpKSB7XG4gICAgaWYgKHZhbHVlTm9kZS5raW5kID09PSBLaW5kLk5VTEwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlRnJvbUFTVCh2YWx1ZU5vZGUsIHR5cGUub2ZUeXBlLCB2YXJpYWJsZXMpO1xuICB9XG4gIGlmICh2YWx1ZU5vZGUua2luZCA9PT0gS2luZC5OVUxMKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzTGlzdFR5cGUodHlwZSkpIHtcbiAgICBjb25zdCBpdGVtVHlwZSA9IHR5cGUub2ZUeXBlO1xuICAgIGlmICh2YWx1ZU5vZGUua2luZCA9PT0gS2luZC5MSVNUKSB7XG4gICAgICBjb25zdCBjb2VyY2VkVmFsdWVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGl0ZW1Ob2RlIG9mIHZhbHVlTm9kZS52YWx1ZXMpIHtcbiAgICAgICAgaWYgKGlzTWlzc2luZ1ZhcmlhYmxlKGl0ZW1Ob2RlLCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgaWYgKGlzTm9uTnVsbFR5cGUoaXRlbVR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvZXJjZWRWYWx1ZXMucHVzaChudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBpdGVtVmFsdWUgPSB2YWx1ZUZyb21BU1QoaXRlbU5vZGUsIGl0ZW1UeXBlLCB2YXJpYWJsZXMpO1xuICAgICAgICAgIGlmIChpdGVtVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb2VyY2VkVmFsdWVzLnB1c2goaXRlbVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZXJjZWRWYWx1ZXM7XG4gICAgfVxuICAgIGNvbnN0IGNvZXJjZWRWYWx1ZSA9IHZhbHVlRnJvbUFTVCh2YWx1ZU5vZGUsIGl0ZW1UeXBlLCB2YXJpYWJsZXMpO1xuICAgIGlmIChjb2VyY2VkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gW2NvZXJjZWRWYWx1ZV07XG4gIH1cbiAgaWYgKGlzSW5wdXRPYmplY3RUeXBlKHR5cGUpKSB7XG4gICAgaWYgKHZhbHVlTm9kZS5raW5kICE9PSBLaW5kLk9CSkVDVCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb2VyY2VkT2JqID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgZmllbGROb2RlcyA9IGtleU1hcCh2YWx1ZU5vZGUuZmllbGRzLCAoZmllbGQpID0+IGZpZWxkLm5hbWUudmFsdWUpO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgT2JqZWN0LnZhbHVlcyh0eXBlLmdldEZpZWxkcygpKSkge1xuICAgICAgY29uc3QgZmllbGROb2RlID0gZmllbGROb2Rlc1tmaWVsZC5uYW1lXTtcbiAgICAgIGlmICghZmllbGROb2RlIHx8IGlzTWlzc2luZ1ZhcmlhYmxlKGZpZWxkTm9kZS52YWx1ZSwgdmFyaWFibGVzKSkge1xuICAgICAgICBpZiAoZmllbGQuZGVmYXVsdFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb2VyY2VkT2JqW2ZpZWxkLm5hbWVdID0gZmllbGQuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTm9uTnVsbFR5cGUoZmllbGQudHlwZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBmaWVsZFZhbHVlID0gdmFsdWVGcm9tQVNUKGZpZWxkTm9kZS52YWx1ZSwgZmllbGQudHlwZSwgdmFyaWFibGVzKTtcbiAgICAgIGlmIChmaWVsZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29lcmNlZE9ialtmaWVsZC5uYW1lXSA9IGZpZWxkVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBjb2VyY2VkT2JqO1xuICB9XG4gIGlmIChpc0xlYWZUeXBlKHR5cGUpKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gdHlwZS5wYXJzZUxpdGVyYWwodmFsdWVOb2RlLCB2YXJpYWJsZXMpO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5leHBlY3RlZCBpbnB1dCB0eXBlOiBcIiArIGluc3BlY3QodHlwZSkpO1xufVxuZnVuY3Rpb24gaXNNaXNzaW5nVmFyaWFibGUodmFsdWVOb2RlLCB2YXJpYWJsZXMpIHtcbiAgcmV0dXJuIHZhbHVlTm9kZS5raW5kID09PSBLaW5kLlZBUklBQkxFICYmICh2YXJpYWJsZXMgPT0gbnVsbCB8fCB2YXJpYWJsZXNbdmFsdWVOb2RlLm5hbWUudmFsdWVdID09PSB2b2lkIDApO1xufVxudmFyIGluaXRfdmFsdWVGcm9tQVNUID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy92YWx1ZUZyb21BU1QubWpzXCIoKSB7XG4gICAgaW5pdF9pbnNwZWN0KCk7XG4gICAgaW5pdF9pbnZhcmlhbnQoKTtcbiAgICBpbml0X2tleU1hcCgpO1xuICAgIGluaXRfa2luZHMoKTtcbiAgICBpbml0X2RlZmluaXRpb24oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2V4ZWN1dGlvbi92YWx1ZXMubWpzXG5mdW5jdGlvbiBnZXRWYXJpYWJsZVZhbHVlcyhzY2hlbWEsIHZhckRlZk5vZGVzLCBpbnB1dHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgZXJyb3JzID0gW107XG4gIGNvbnN0IG1heEVycm9ycyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXhFcnJvcnM7XG4gIHRyeSB7XG4gICAgY29uc3QgY29lcmNlZCA9IGNvZXJjZVZhcmlhYmxlVmFsdWVzKFxuICAgICAgc2NoZW1hLFxuICAgICAgdmFyRGVmTm9kZXMsXG4gICAgICBpbnB1dHMsXG4gICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKG1heEVycm9ycyAhPSBudWxsICYmIGVycm9ycy5sZW5ndGggPj0gbWF4RXJyb3JzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIFwiVG9vIG1hbnkgZXJyb3JzIHByb2Nlc3NpbmcgdmFyaWFibGVzLCBlcnJvciBsaW1pdCByZWFjaGVkLiBFeGVjdXRpb24gYWJvcnRlZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgfVxuICAgICk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvZXJjZWRcbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVycm9yc1xuICB9O1xufVxuZnVuY3Rpb24gY29lcmNlVmFyaWFibGVWYWx1ZXMoc2NoZW1hLCB2YXJEZWZOb2RlcywgaW5wdXRzLCBvbkVycm9yKSB7XG4gIGNvbnN0IGNvZXJjZWRWYWx1ZXMgPSB7fTtcbiAgZm9yIChjb25zdCB2YXJEZWZOb2RlIG9mIHZhckRlZk5vZGVzKSB7XG4gICAgY29uc3QgdmFyTmFtZSA9IHZhckRlZk5vZGUudmFyaWFibGUubmFtZS52YWx1ZTtcbiAgICBjb25zdCB2YXJUeXBlID0gdHlwZUZyb21BU1Qoc2NoZW1hLCB2YXJEZWZOb2RlLnR5cGUpO1xuICAgIGlmICghaXNJbnB1dFR5cGUodmFyVHlwZSkpIHtcbiAgICAgIGNvbnN0IHZhclR5cGVTdHIgPSBwcmludCh2YXJEZWZOb2RlLnR5cGUpO1xuICAgICAgb25FcnJvcihcbiAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICBgVmFyaWFibGUgXCIkJHt2YXJOYW1lfVwiIGV4cGVjdGVkIHZhbHVlIG9mIHR5cGUgXCIke3ZhclR5cGVTdHJ9XCIgd2hpY2ggY2Fubm90IGJlIHVzZWQgYXMgYW4gaW5wdXQgdHlwZS5gLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5vZGVzOiB2YXJEZWZOb2RlLnR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShpbnB1dHMsIHZhck5hbWUpKSB7XG4gICAgICBpZiAodmFyRGVmTm9kZS5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgY29lcmNlZFZhbHVlc1t2YXJOYW1lXSA9IHZhbHVlRnJvbUFTVCh2YXJEZWZOb2RlLmRlZmF1bHRWYWx1ZSwgdmFyVHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTm9uTnVsbFR5cGUodmFyVHlwZSkpIHtcbiAgICAgICAgY29uc3QgdmFyVHlwZVN0ciA9IGluc3BlY3QodmFyVHlwZSk7XG4gICAgICAgIG9uRXJyb3IoXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBWYXJpYWJsZSBcIiQke3Zhck5hbWV9XCIgb2YgcmVxdWlyZWQgdHlwZSBcIiR7dmFyVHlwZVN0cn1cIiB3YXMgbm90IHByb3ZpZGVkLmAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5vZGVzOiB2YXJEZWZOb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gaW5wdXRzW3Zhck5hbWVdO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBpc05vbk51bGxUeXBlKHZhclR5cGUpKSB7XG4gICAgICBjb25zdCB2YXJUeXBlU3RyID0gaW5zcGVjdCh2YXJUeXBlKTtcbiAgICAgIG9uRXJyb3IoXG4gICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgYFZhcmlhYmxlIFwiJCR7dmFyTmFtZX1cIiBvZiBub24tbnVsbCB0eXBlIFwiJHt2YXJUeXBlU3RyfVwiIG11c3Qgbm90IGJlIG51bGwuYCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBub2RlczogdmFyRGVmTm9kZVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb2VyY2VkVmFsdWVzW3Zhck5hbWVdID0gY29lcmNlSW5wdXRWYWx1ZShcbiAgICAgIHZhbHVlLFxuICAgICAgdmFyVHlwZSxcbiAgICAgIChwYXRoLCBpbnZhbGlkVmFsdWUsIGVycm9yKSA9PiB7XG4gICAgICAgIGxldCBwcmVmaXggPSBgVmFyaWFibGUgXCIkJHt2YXJOYW1lfVwiIGdvdCBpbnZhbGlkIHZhbHVlIGAgKyBpbnNwZWN0KGludmFsaWRWYWx1ZSk7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwcmVmaXggKz0gYCBhdCBcIiR7dmFyTmFtZX0ke3ByaW50UGF0aEFycmF5KHBhdGgpfVwiYDtcbiAgICAgICAgfVxuICAgICAgICBvbkVycm9yKFxuICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IocHJlZml4ICsgXCI7IFwiICsgZXJyb3IubWVzc2FnZSwge1xuICAgICAgICAgICAgbm9kZXM6IHZhckRlZk5vZGUsXG4gICAgICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvclxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29lcmNlZFZhbHVlcztcbn1cbmZ1bmN0aW9uIGdldEFyZ3VtZW50VmFsdWVzKGRlZiwgbm9kZSwgdmFyaWFibGVWYWx1ZXMpIHtcbiAgdmFyIF9ub2RlJGFyZ3VtZW50cztcbiAgY29uc3QgY29lcmNlZFZhbHVlcyA9IHt9O1xuICBjb25zdCBhcmd1bWVudE5vZGVzID0gKF9ub2RlJGFyZ3VtZW50cyA9IG5vZGUuYXJndW1lbnRzKSAhPT0gbnVsbCAmJiBfbm9kZSRhcmd1bWVudHMgIT09IHZvaWQgMCA/IF9ub2RlJGFyZ3VtZW50cyA6IFtdO1xuICBjb25zdCBhcmdOb2RlTWFwID0ga2V5TWFwKGFyZ3VtZW50Tm9kZXMsIChhcmcpID0+IGFyZy5uYW1lLnZhbHVlKTtcbiAgZm9yIChjb25zdCBhcmdEZWYgb2YgZGVmLmFyZ3MpIHtcbiAgICBjb25zdCBuYW1lID0gYXJnRGVmLm5hbWU7XG4gICAgY29uc3QgYXJnVHlwZSA9IGFyZ0RlZi50eXBlO1xuICAgIGNvbnN0IGFyZ3VtZW50Tm9kZSA9IGFyZ05vZGVNYXBbbmFtZV07XG4gICAgaWYgKCFhcmd1bWVudE5vZGUpIHtcbiAgICAgIGlmIChhcmdEZWYuZGVmYXVsdFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29lcmNlZFZhbHVlc1tuYW1lXSA9IGFyZ0RlZi5kZWZhdWx0VmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlzTm9uTnVsbFR5cGUoYXJnVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICBgQXJndW1lbnQgXCIke25hbWV9XCIgb2YgcmVxdWlyZWQgdHlwZSBcIiR7aW5zcGVjdChhcmdUeXBlKX1cIiB3YXMgbm90IHByb3ZpZGVkLmAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbm9kZXM6IG5vZGVcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVOb2RlID0gYXJndW1lbnROb2RlLnZhbHVlO1xuICAgIGxldCBpc051bGwgPSB2YWx1ZU5vZGUua2luZCA9PT0gS2luZC5OVUxMO1xuICAgIGlmICh2YWx1ZU5vZGUua2luZCA9PT0gS2luZC5WQVJJQUJMRSkge1xuICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gdmFsdWVOb2RlLm5hbWUudmFsdWU7XG4gICAgICBpZiAodmFyaWFibGVWYWx1ZXMgPT0gbnVsbCB8fCAhaGFzT3duUHJvcGVydHkodmFyaWFibGVWYWx1ZXMsIHZhcmlhYmxlTmFtZSkpIHtcbiAgICAgICAgaWYgKGFyZ0RlZi5kZWZhdWx0VmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvZXJjZWRWYWx1ZXNbbmFtZV0gPSBhcmdEZWYuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTm9uTnVsbFR5cGUoYXJnVHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYEFyZ3VtZW50IFwiJHtuYW1lfVwiIG9mIHJlcXVpcmVkIHR5cGUgXCIke2luc3BlY3QoYXJnVHlwZSl9XCIgd2FzIHByb3ZpZGVkIHRoZSB2YXJpYWJsZSBcIiQke3ZhcmlhYmxlTmFtZX1cIiB3aGljaCB3YXMgbm90IHByb3ZpZGVkIGEgcnVudGltZSB2YWx1ZS5gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBub2RlczogdmFsdWVOb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlzTnVsbCA9IHZhcmlhYmxlVmFsdWVzW3ZhcmlhYmxlTmFtZV0gPT0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlzTnVsbCAmJiBpc05vbk51bGxUeXBlKGFyZ1R5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICBgQXJndW1lbnQgXCIke25hbWV9XCIgb2Ygbm9uLW51bGwgdHlwZSBcIiR7aW5zcGVjdChhcmdUeXBlKX1cIiBtdXN0IG5vdCBiZSBudWxsLmAsXG4gICAgICAgIHtcbiAgICAgICAgICBub2RlczogdmFsdWVOb2RlXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGNvZXJjZWRWYWx1ZSA9IHZhbHVlRnJvbUFTVCh2YWx1ZU5vZGUsIGFyZ1R5cGUsIHZhcmlhYmxlVmFsdWVzKTtcbiAgICBpZiAoY29lcmNlZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgIGBBcmd1bWVudCBcIiR7bmFtZX1cIiBoYXMgaW52YWxpZCB2YWx1ZSAke3ByaW50KHZhbHVlTm9kZSl9LmAsXG4gICAgICAgIHtcbiAgICAgICAgICBub2RlczogdmFsdWVOb2RlXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGNvZXJjZWRWYWx1ZXNbbmFtZV0gPSBjb2VyY2VkVmFsdWU7XG4gIH1cbiAgcmV0dXJuIGNvZXJjZWRWYWx1ZXM7XG59XG5mdW5jdGlvbiBnZXREaXJlY3RpdmVWYWx1ZXMoZGlyZWN0aXZlRGVmLCBub2RlLCB2YXJpYWJsZVZhbHVlcykge1xuICB2YXIgX25vZGUkZGlyZWN0aXZlcztcbiAgY29uc3QgZGlyZWN0aXZlTm9kZSA9IChfbm9kZSRkaXJlY3RpdmVzID0gbm9kZS5kaXJlY3RpdmVzKSA9PT0gbnVsbCB8fCBfbm9kZSRkaXJlY3RpdmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRkaXJlY3RpdmVzLmZpbmQoXG4gICAgKGRpcmVjdGl2ZSkgPT4gZGlyZWN0aXZlLm5hbWUudmFsdWUgPT09IGRpcmVjdGl2ZURlZi5uYW1lXG4gICk7XG4gIGlmIChkaXJlY3RpdmVOb2RlKSB7XG4gICAgcmV0dXJuIGdldEFyZ3VtZW50VmFsdWVzKGRpcmVjdGl2ZURlZiwgZGlyZWN0aXZlTm9kZSwgdmFyaWFibGVWYWx1ZXMpO1xuICB9XG59XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxudmFyIGluaXRfdmFsdWVzID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2V4ZWN1dGlvbi92YWx1ZXMubWpzXCIoKSB7XG4gICAgaW5pdF9pbnNwZWN0KCk7XG4gICAgaW5pdF9rZXlNYXAoKTtcbiAgICBpbml0X3ByaW50UGF0aEFycmF5KCk7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgICBpbml0X2tpbmRzKCk7XG4gICAgaW5pdF9wcmludGVyKCk7XG4gICAgaW5pdF9kZWZpbml0aW9uKCk7XG4gICAgaW5pdF9jb2VyY2VJbnB1dFZhbHVlKCk7XG4gICAgaW5pdF90eXBlRnJvbUFTVCgpO1xuICAgIGluaXRfdmFsdWVGcm9tQVNUKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9leGVjdXRpb24vY29sbGVjdEZpZWxkcy5tanNcbmZ1bmN0aW9uIGNvbGxlY3RGaWVsZHMoc2NoZW1hLCBmcmFnbWVudHMsIHZhcmlhYmxlVmFsdWVzLCBydW50aW1lVHlwZSwgc2VsZWN0aW9uU2V0KSB7XG4gIGNvbnN0IGZpZWxkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbGxlY3RGaWVsZHNJbXBsKFxuICAgIHNjaGVtYSxcbiAgICBmcmFnbWVudHMsXG4gICAgdmFyaWFibGVWYWx1ZXMsXG4gICAgcnVudGltZVR5cGUsXG4gICAgc2VsZWN0aW9uU2V0LFxuICAgIGZpZWxkcyxcbiAgICAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICk7XG4gIHJldHVybiBmaWVsZHM7XG59XG5mdW5jdGlvbiBjb2xsZWN0U3ViZmllbGRzKHNjaGVtYSwgZnJhZ21lbnRzLCB2YXJpYWJsZVZhbHVlcywgcmV0dXJuVHlwZSwgZmllbGROb2Rlcykge1xuICBjb25zdCBzdWJGaWVsZE5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgdmlzaXRlZEZyYWdtZW50TmFtZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgZmllbGROb2Rlcykge1xuICAgIGlmIChub2RlLnNlbGVjdGlvblNldCkge1xuICAgICAgY29sbGVjdEZpZWxkc0ltcGwoXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgZnJhZ21lbnRzLFxuICAgICAgICB2YXJpYWJsZVZhbHVlcyxcbiAgICAgICAgcmV0dXJuVHlwZSxcbiAgICAgICAgbm9kZS5zZWxlY3Rpb25TZXQsXG4gICAgICAgIHN1YkZpZWxkTm9kZXMsXG4gICAgICAgIHZpc2l0ZWRGcmFnbWVudE5hbWVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3ViRmllbGROb2Rlcztcbn1cbmZ1bmN0aW9uIGNvbGxlY3RGaWVsZHNJbXBsKHNjaGVtYSwgZnJhZ21lbnRzLCB2YXJpYWJsZVZhbHVlcywgcnVudGltZVR5cGUsIHNlbGVjdGlvblNldCwgZmllbGRzLCB2aXNpdGVkRnJhZ21lbnROYW1lcykge1xuICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucykge1xuICAgIHN3aXRjaCAoc2VsZWN0aW9uLmtpbmQpIHtcbiAgICAgIGNhc2UgS2luZC5GSUVMRDoge1xuICAgICAgICBpZiAoIXNob3VsZEluY2x1ZGVOb2RlKHZhcmlhYmxlVmFsdWVzLCBzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IGdldEZpZWxkRW50cnlLZXkoc2VsZWN0aW9uKTtcbiAgICAgICAgY29uc3QgZmllbGRMaXN0ID0gZmllbGRzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkTGlzdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZmllbGRMaXN0LnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZHMuc2V0KG5hbWUsIFtzZWxlY3Rpb25dKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgS2luZC5JTkxJTkVfRlJBR01FTlQ6IHtcbiAgICAgICAgaWYgKCFzaG91bGRJbmNsdWRlTm9kZSh2YXJpYWJsZVZhbHVlcywgc2VsZWN0aW9uKSB8fCAhZG9lc0ZyYWdtZW50Q29uZGl0aW9uTWF0Y2goc2NoZW1hLCBzZWxlY3Rpb24sIHJ1bnRpbWVUeXBlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbGxlY3RGaWVsZHNJbXBsKFxuICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICBmcmFnbWVudHMsXG4gICAgICAgICAgdmFyaWFibGVWYWx1ZXMsXG4gICAgICAgICAgcnVudGltZVR5cGUsXG4gICAgICAgICAgc2VsZWN0aW9uLnNlbGVjdGlvblNldCxcbiAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgdmlzaXRlZEZyYWdtZW50TmFtZXNcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEtpbmQuRlJBR01FTlRfU1BSRUFEOiB7XG4gICAgICAgIGNvbnN0IGZyYWdOYW1lID0gc2VsZWN0aW9uLm5hbWUudmFsdWU7XG4gICAgICAgIGlmICh2aXNpdGVkRnJhZ21lbnROYW1lcy5oYXMoZnJhZ05hbWUpIHx8ICFzaG91bGRJbmNsdWRlTm9kZSh2YXJpYWJsZVZhbHVlcywgc2VsZWN0aW9uKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWRGcmFnbWVudE5hbWVzLmFkZChmcmFnTmFtZSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZnJhZ21lbnRzW2ZyYWdOYW1lXTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCB8fCAhZG9lc0ZyYWdtZW50Q29uZGl0aW9uTWF0Y2goc2NoZW1hLCBmcmFnbWVudCwgcnVudGltZVR5cGUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29sbGVjdEZpZWxkc0ltcGwoXG4gICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgIGZyYWdtZW50cyxcbiAgICAgICAgICB2YXJpYWJsZVZhbHVlcyxcbiAgICAgICAgICBydW50aW1lVHlwZSxcbiAgICAgICAgICBmcmFnbWVudC5zZWxlY3Rpb25TZXQsXG4gICAgICAgICAgZmllbGRzLFxuICAgICAgICAgIHZpc2l0ZWRGcmFnbWVudE5hbWVzXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkSW5jbHVkZU5vZGUodmFyaWFibGVWYWx1ZXMsIG5vZGUpIHtcbiAgY29uc3Qgc2tpcCA9IGdldERpcmVjdGl2ZVZhbHVlcyhHcmFwaFFMU2tpcERpcmVjdGl2ZSwgbm9kZSwgdmFyaWFibGVWYWx1ZXMpO1xuICBpZiAoKHNraXAgPT09IG51bGwgfHwgc2tpcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2tpcC5pZikgPT09IHRydWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaW5jbHVkZSA9IGdldERpcmVjdGl2ZVZhbHVlcyhcbiAgICBHcmFwaFFMSW5jbHVkZURpcmVjdGl2ZSxcbiAgICBub2RlLFxuICAgIHZhcmlhYmxlVmFsdWVzXG4gICk7XG4gIGlmICgoaW5jbHVkZSA9PT0gbnVsbCB8fCBpbmNsdWRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmNsdWRlLmlmKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkb2VzRnJhZ21lbnRDb25kaXRpb25NYXRjaChzY2hlbWEsIGZyYWdtZW50LCB0eXBlKSB7XG4gIGNvbnN0IHR5cGVDb25kaXRpb25Ob2RlID0gZnJhZ21lbnQudHlwZUNvbmRpdGlvbjtcbiAgaWYgKCF0eXBlQ29uZGl0aW9uTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGNvbmRpdGlvbmFsVHlwZSA9IHR5cGVGcm9tQVNUKHNjaGVtYSwgdHlwZUNvbmRpdGlvbk5vZGUpO1xuICBpZiAoY29uZGl0aW9uYWxUeXBlID09PSB0eXBlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQWJzdHJhY3RUeXBlKGNvbmRpdGlvbmFsVHlwZSkpIHtcbiAgICByZXR1cm4gc2NoZW1hLmlzU3ViVHlwZShjb25kaXRpb25hbFR5cGUsIHR5cGUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldEZpZWxkRW50cnlLZXkobm9kZSkge1xuICByZXR1cm4gbm9kZS5hbGlhcyA/IG5vZGUuYWxpYXMudmFsdWUgOiBub2RlLm5hbWUudmFsdWU7XG59XG52YXIgaW5pdF9jb2xsZWN0RmllbGRzID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2V4ZWN1dGlvbi9jb2xsZWN0RmllbGRzLm1qc1wiKCkge1xuICAgIGluaXRfa2luZHMoKTtcbiAgICBpbml0X2RlZmluaXRpb24oKTtcbiAgICBpbml0X2RpcmVjdGl2ZXMoKTtcbiAgICBpbml0X3R5cGVGcm9tQVNUKCk7XG4gICAgaW5pdF92YWx1ZXMoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvU2luZ2xlRmllbGRTdWJzY3JpcHRpb25zUnVsZS5tanNcbmZ1bmN0aW9uIFNpbmdsZUZpZWxkU3Vic2NyaXB0aW9uc1J1bGUoY29udGV4dCkge1xuICByZXR1cm4ge1xuICAgIE9wZXJhdGlvbkRlZmluaXRpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUub3BlcmF0aW9uID09PSBcInN1YnNjcmlwdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IGNvbnRleHQuZ2V0U2NoZW1hKCk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblR5cGUgPSBzY2hlbWEuZ2V0U3Vic2NyaXB0aW9uVHlwZSgpO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uVHlwZSkge1xuICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbk5hbWUgPSBub2RlLm5hbWUgPyBub2RlLm5hbWUudmFsdWUgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IHZhcmlhYmxlVmFsdWVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBjb250ZXh0LmdldERvY3VtZW50KCk7XG4gICAgICAgICAgY29uc3QgZnJhZ21lbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZm9yIChjb25zdCBkZWZpbml0aW9uIG9mIGRvY3VtZW50LmRlZmluaXRpb25zKSB7XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kID09PSBLaW5kLkZSQUdNRU5UX0RFRklOSVRJT04pIHtcbiAgICAgICAgICAgICAgZnJhZ21lbnRzW2RlZmluaXRpb24ubmFtZS52YWx1ZV0gPSBkZWZpbml0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmaWVsZHMgPSBjb2xsZWN0RmllbGRzKFxuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgZnJhZ21lbnRzLFxuICAgICAgICAgICAgdmFyaWFibGVWYWx1ZXMsXG4gICAgICAgICAgICBzdWJzY3JpcHRpb25UeXBlLFxuICAgICAgICAgICAgbm9kZS5zZWxlY3Rpb25TZXRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChmaWVsZHMuc2l6ZSA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2VsZWN0aW9uTGlzdHMgPSBbLi4uZmllbGRzLnZhbHVlcygpXTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhRmllbGRTZWxlY3Rpb25MaXN0cyA9IGZpZWxkU2VsZWN0aW9uTGlzdHMuc2xpY2UoMSk7XG4gICAgICAgICAgICBjb25zdCBleHRyYUZpZWxkU2VsZWN0aW9ucyA9IGV4dHJhRmllbGRTZWxlY3Rpb25MaXN0cy5mbGF0KCk7XG4gICAgICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWUgIT0gbnVsbCA/IGBTdWJzY3JpcHRpb24gXCIke29wZXJhdGlvbk5hbWV9XCIgbXVzdCBzZWxlY3Qgb25seSBvbmUgdG9wIGxldmVsIGZpZWxkLmAgOiBcIkFub255bW91cyBTdWJzY3JpcHRpb24gbXVzdCBzZWxlY3Qgb25seSBvbmUgdG9wIGxldmVsIGZpZWxkLlwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIG5vZGVzOiBleHRyYUZpZWxkU2VsZWN0aW9uc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBmaWVsZE5vZGVzIG9mIGZpZWxkcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBmaWVsZE5vZGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gZmllbGQubmFtZS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUuc3RhcnRzV2l0aChcIl9fXCIpKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWUgIT0gbnVsbCA/IGBTdWJzY3JpcHRpb24gXCIke29wZXJhdGlvbk5hbWV9XCIgbXVzdCBub3Qgc2VsZWN0IGFuIGludHJvc3BlY3Rpb24gdG9wIGxldmVsIGZpZWxkLmAgOiBcIkFub255bW91cyBTdWJzY3JpcHRpb24gbXVzdCBub3Qgc2VsZWN0IGFuIGludHJvc3BlY3Rpb24gdG9wIGxldmVsIGZpZWxkLlwiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBub2RlczogZmllbGROb2Rlc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9TaW5nbGVGaWVsZFN1YnNjcmlwdGlvbnNSdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvU2luZ2xlRmllbGRTdWJzY3JpcHRpb25zUnVsZS5tanNcIigpIHtcbiAgICBpbml0X0dyYXBoUUxFcnJvcigpO1xuICAgIGluaXRfa2luZHMoKTtcbiAgICBpbml0X2NvbGxlY3RGaWVsZHMoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvZ3JvdXBCeS5tanNcbmZ1bmN0aW9uIGdyb3VwQnkobGlzdCwga2V5Rm4pIHtcbiAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIGxpc3QpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlGbihpdGVtKTtcbiAgICBjb25zdCBncm91cCA9IHJlc3VsdC5nZXQoa2V5KTtcbiAgICBpZiAoZ3JvdXAgPT09IHZvaWQgMCkge1xuICAgICAgcmVzdWx0LnNldChrZXksIFtpdGVtXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgaW5pdF9ncm91cEJ5ID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvZ3JvdXBCeS5tanNcIigpIHtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVW5pcXVlQXJndW1lbnREZWZpbml0aW9uTmFtZXNSdWxlLm1qc1xuZnVuY3Rpb24gVW5pcXVlQXJndW1lbnREZWZpbml0aW9uTmFtZXNSdWxlKGNvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICBEaXJlY3RpdmVEZWZpbml0aW9uKGRpcmVjdGl2ZU5vZGUpIHtcbiAgICAgIHZhciBfZGlyZWN0aXZlTm9kZSRhcmd1bWU7XG4gICAgICBjb25zdCBhcmd1bWVudE5vZGVzID0gKF9kaXJlY3RpdmVOb2RlJGFyZ3VtZSA9IGRpcmVjdGl2ZU5vZGUuYXJndW1lbnRzKSAhPT0gbnVsbCAmJiBfZGlyZWN0aXZlTm9kZSRhcmd1bWUgIT09IHZvaWQgMCA/IF9kaXJlY3RpdmVOb2RlJGFyZ3VtZSA6IFtdO1xuICAgICAgcmV0dXJuIGNoZWNrQXJnVW5pcXVlbmVzcyhgQCR7ZGlyZWN0aXZlTm9kZS5uYW1lLnZhbHVlfWAsIGFyZ3VtZW50Tm9kZXMpO1xuICAgIH0sXG4gICAgSW50ZXJmYWNlVHlwZURlZmluaXRpb246IGNoZWNrQXJnVW5pcXVlbmVzc1BlckZpZWxkLFxuICAgIEludGVyZmFjZVR5cGVFeHRlbnNpb246IGNoZWNrQXJnVW5pcXVlbmVzc1BlckZpZWxkLFxuICAgIE9iamVjdFR5cGVEZWZpbml0aW9uOiBjaGVja0FyZ1VuaXF1ZW5lc3NQZXJGaWVsZCxcbiAgICBPYmplY3RUeXBlRXh0ZW5zaW9uOiBjaGVja0FyZ1VuaXF1ZW5lc3NQZXJGaWVsZFxuICB9O1xuICBmdW5jdGlvbiBjaGVja0FyZ1VuaXF1ZW5lc3NQZXJGaWVsZCh0eXBlTm9kZSkge1xuICAgIHZhciBfdHlwZU5vZGUkZmllbGRzO1xuICAgIGNvbnN0IHR5cGVOYW1lID0gdHlwZU5vZGUubmFtZS52YWx1ZTtcbiAgICBjb25zdCBmaWVsZE5vZGVzID0gKF90eXBlTm9kZSRmaWVsZHMgPSB0eXBlTm9kZS5maWVsZHMpICE9PSBudWxsICYmIF90eXBlTm9kZSRmaWVsZHMgIT09IHZvaWQgMCA/IF90eXBlTm9kZSRmaWVsZHMgOiBbXTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkRGVmIG9mIGZpZWxkTm9kZXMpIHtcbiAgICAgIHZhciBfZmllbGREZWYkYXJndW1lbnRzO1xuICAgICAgY29uc3QgZmllbGROYW1lID0gZmllbGREZWYubmFtZS52YWx1ZTtcbiAgICAgIGNvbnN0IGFyZ3VtZW50Tm9kZXMgPSAoX2ZpZWxkRGVmJGFyZ3VtZW50cyA9IGZpZWxkRGVmLmFyZ3VtZW50cykgIT09IG51bGwgJiYgX2ZpZWxkRGVmJGFyZ3VtZW50cyAhPT0gdm9pZCAwID8gX2ZpZWxkRGVmJGFyZ3VtZW50cyA6IFtdO1xuICAgICAgY2hlY2tBcmdVbmlxdWVuZXNzKGAke3R5cGVOYW1lfS4ke2ZpZWxkTmFtZX1gLCBhcmd1bWVudE5vZGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrQXJnVW5pcXVlbmVzcyhwYXJlbnROYW1lLCBhcmd1bWVudE5vZGVzKSB7XG4gICAgY29uc3Qgc2VlbkFyZ3MgPSBncm91cEJ5KGFyZ3VtZW50Tm9kZXMsIChhcmcpID0+IGFyZy5uYW1lLnZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IFthcmdOYW1lLCBhcmdOb2Rlc10gb2Ygc2VlbkFyZ3MpIHtcbiAgICAgIGlmIChhcmdOb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBBcmd1bWVudCBcIiR7cGFyZW50TmFtZX0oJHthcmdOYW1lfTopXCIgY2FuIG9ubHkgYmUgZGVmaW5lZCBvbmNlLmAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5vZGVzOiBhcmdOb2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUubmFtZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxudmFyIGluaXRfVW5pcXVlQXJndW1lbnREZWZpbml0aW9uTmFtZXNSdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVW5pcXVlQXJndW1lbnREZWZpbml0aW9uTmFtZXNSdWxlLm1qc1wiKCkge1xuICAgIGluaXRfZ3JvdXBCeSgpO1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL1VuaXF1ZUFyZ3VtZW50TmFtZXNSdWxlLm1qc1xuZnVuY3Rpb24gVW5pcXVlQXJndW1lbnROYW1lc1J1bGUoY29udGV4dCkge1xuICByZXR1cm4ge1xuICAgIEZpZWxkOiBjaGVja0FyZ1VuaXF1ZW5lc3MsXG4gICAgRGlyZWN0aXZlOiBjaGVja0FyZ1VuaXF1ZW5lc3NcbiAgfTtcbiAgZnVuY3Rpb24gY2hlY2tBcmdVbmlxdWVuZXNzKHBhcmVudE5vZGUpIHtcbiAgICB2YXIgX3BhcmVudE5vZGUkYXJndW1lbnRzO1xuICAgIGNvbnN0IGFyZ3VtZW50Tm9kZXMgPSAoX3BhcmVudE5vZGUkYXJndW1lbnRzID0gcGFyZW50Tm9kZS5hcmd1bWVudHMpICE9PSBudWxsICYmIF9wYXJlbnROb2RlJGFyZ3VtZW50cyAhPT0gdm9pZCAwID8gX3BhcmVudE5vZGUkYXJndW1lbnRzIDogW107XG4gICAgY29uc3Qgc2VlbkFyZ3MgPSBncm91cEJ5KGFyZ3VtZW50Tm9kZXMsIChhcmcpID0+IGFyZy5uYW1lLnZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IFthcmdOYW1lLCBhcmdOb2Rlc10gb2Ygc2VlbkFyZ3MpIHtcbiAgICAgIGlmIChhcmdOb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBUaGVyZSBjYW4gYmUgb25seSBvbmUgYXJndW1lbnQgbmFtZWQgXCIke2FyZ05hbWV9XCIuYCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbm9kZXM6IGFyZ05vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5uYW1lKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnZhciBpbml0X1VuaXF1ZUFyZ3VtZW50TmFtZXNSdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVW5pcXVlQXJndW1lbnROYW1lc1J1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9ncm91cEJ5KCk7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVW5pcXVlRGlyZWN0aXZlTmFtZXNSdWxlLm1qc1xuZnVuY3Rpb24gVW5pcXVlRGlyZWN0aXZlTmFtZXNSdWxlKGNvbnRleHQpIHtcbiAgY29uc3Qga25vd25EaXJlY3RpdmVOYW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBzY2hlbWEgPSBjb250ZXh0LmdldFNjaGVtYSgpO1xuICByZXR1cm4ge1xuICAgIERpcmVjdGl2ZURlZmluaXRpb24obm9kZSkge1xuICAgICAgY29uc3QgZGlyZWN0aXZlTmFtZSA9IG5vZGUubmFtZS52YWx1ZTtcbiAgICAgIGlmIChzY2hlbWEgIT09IG51bGwgJiYgc2NoZW1hICE9PSB2b2lkIDAgJiYgc2NoZW1hLmdldERpcmVjdGl2ZShkaXJlY3RpdmVOYW1lKSkge1xuICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBgRGlyZWN0aXZlIFwiQCR7ZGlyZWN0aXZlTmFtZX1cIiBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgc2NoZW1hLiBJdCBjYW5ub3QgYmUgcmVkZWZpbmVkLmAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5vZGVzOiBub2RlLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrbm93bkRpcmVjdGl2ZU5hbWVzW2RpcmVjdGl2ZU5hbWVdKSB7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBUaGVyZSBjYW4gYmUgb25seSBvbmUgZGlyZWN0aXZlIG5hbWVkIFwiQCR7ZGlyZWN0aXZlTmFtZX1cIi5gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBub2RlczogW2tub3duRGlyZWN0aXZlTmFtZXNbZGlyZWN0aXZlTmFtZV0sIG5vZGUubmFtZV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrbm93bkRpcmVjdGl2ZU5hbWVzW2RpcmVjdGl2ZU5hbWVdID0gbm9kZS5uYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cbnZhciBpbml0X1VuaXF1ZURpcmVjdGl2ZU5hbWVzUnVsZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL1VuaXF1ZURpcmVjdGl2ZU5hbWVzUnVsZS5tanNcIigpIHtcbiAgICBpbml0X0dyYXBoUUxFcnJvcigpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9VbmlxdWVEaXJlY3RpdmVzUGVyTG9jYXRpb25SdWxlLm1qc1xuZnVuY3Rpb24gVW5pcXVlRGlyZWN0aXZlc1BlckxvY2F0aW9uUnVsZShjb250ZXh0KSB7XG4gIGNvbnN0IHVuaXF1ZURpcmVjdGl2ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBzY2hlbWEgPSBjb250ZXh0LmdldFNjaGVtYSgpO1xuICBjb25zdCBkZWZpbmVkRGlyZWN0aXZlcyA9IHNjaGVtYSA/IHNjaGVtYS5nZXREaXJlY3RpdmVzKCkgOiBzcGVjaWZpZWREaXJlY3RpdmVzO1xuICBmb3IgKGNvbnN0IGRpcmVjdGl2ZSBvZiBkZWZpbmVkRGlyZWN0aXZlcykge1xuICAgIHVuaXF1ZURpcmVjdGl2ZU1hcFtkaXJlY3RpdmUubmFtZV0gPSAhZGlyZWN0aXZlLmlzUmVwZWF0YWJsZTtcbiAgfVxuICBjb25zdCBhc3REZWZpbml0aW9ucyA9IGNvbnRleHQuZ2V0RG9jdW1lbnQoKS5kZWZpbml0aW9ucztcbiAgZm9yIChjb25zdCBkZWYgb2YgYXN0RGVmaW5pdGlvbnMpIHtcbiAgICBpZiAoZGVmLmtpbmQgPT09IEtpbmQuRElSRUNUSVZFX0RFRklOSVRJT04pIHtcbiAgICAgIHVuaXF1ZURpcmVjdGl2ZU1hcFtkZWYubmFtZS52YWx1ZV0gPSAhZGVmLnJlcGVhdGFibGU7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNjaGVtYURpcmVjdGl2ZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgdHlwZURpcmVjdGl2ZXNNYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBNYW55IGRpZmZlcmVudCBBU1Qgbm9kZXMgbWF5IGNvbnRhaW4gZGlyZWN0aXZlcy4gUmF0aGVyIHRoYW4gbGlzdGluZ1xuICAgIC8vIHRoZW0gYWxsLCBqdXN0IGxpc3RlbiBmb3IgZW50ZXJpbmcgYW55IG5vZGUsIGFuZCBjaGVjayB0byBzZWUgaWYgaXRcbiAgICAvLyBkZWZpbmVzIGFueSBkaXJlY3RpdmVzLlxuICAgIGVudGVyKG5vZGUpIHtcbiAgICAgIGlmICghKFwiZGlyZWN0aXZlc1wiIGluIG5vZGUpIHx8ICFub2RlLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHNlZW5EaXJlY3RpdmVzO1xuICAgICAgaWYgKG5vZGUua2luZCA9PT0gS2luZC5TQ0hFTUFfREVGSU5JVElPTiB8fCBub2RlLmtpbmQgPT09IEtpbmQuU0NIRU1BX0VYVEVOU0lPTikge1xuICAgICAgICBzZWVuRGlyZWN0aXZlcyA9IHNjaGVtYURpcmVjdGl2ZXM7XG4gICAgICB9IGVsc2UgaWYgKGlzVHlwZURlZmluaXRpb25Ob2RlKG5vZGUpIHx8IGlzVHlwZUV4dGVuc2lvbk5vZGUobm9kZSkpIHtcbiAgICAgICAgY29uc3QgdHlwZU5hbWUgPSBub2RlLm5hbWUudmFsdWU7XG4gICAgICAgIHNlZW5EaXJlY3RpdmVzID0gdHlwZURpcmVjdGl2ZXNNYXBbdHlwZU5hbWVdO1xuICAgICAgICBpZiAoc2VlbkRpcmVjdGl2ZXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHR5cGVEaXJlY3RpdmVzTWFwW3R5cGVOYW1lXSA9IHNlZW5EaXJlY3RpdmVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW5EaXJlY3RpdmVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGRpcmVjdGl2ZSBvZiBub2RlLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgY29uc3QgZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZS5uYW1lLnZhbHVlO1xuICAgICAgICBpZiAodW5pcXVlRGlyZWN0aXZlTWFwW2RpcmVjdGl2ZU5hbWVdKSB7XG4gICAgICAgICAgaWYgKHNlZW5EaXJlY3RpdmVzW2RpcmVjdGl2ZU5hbWVdKSB7XG4gICAgICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgICAgIGBUaGUgZGlyZWN0aXZlIFwiQCR7ZGlyZWN0aXZlTmFtZX1cIiBjYW4gb25seSBiZSB1c2VkIG9uY2UgYXQgdGhpcyBsb2NhdGlvbi5gLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIG5vZGVzOiBbc2VlbkRpcmVjdGl2ZXNbZGlyZWN0aXZlTmFtZV0sIGRpcmVjdGl2ZV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZW5EaXJlY3RpdmVzW2RpcmVjdGl2ZU5hbWVdID0gZGlyZWN0aXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbnZhciBpbml0X1VuaXF1ZURpcmVjdGl2ZXNQZXJMb2NhdGlvblJ1bGUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9VbmlxdWVEaXJlY3RpdmVzUGVyTG9jYXRpb25SdWxlLm1qc1wiKCkge1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gICAgaW5pdF9raW5kcygpO1xuICAgIGluaXRfcHJlZGljYXRlcygpO1xuICAgIGluaXRfZGlyZWN0aXZlcygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9VbmlxdWVFbnVtVmFsdWVOYW1lc1J1bGUubWpzXG5mdW5jdGlvbiBVbmlxdWVFbnVtVmFsdWVOYW1lc1J1bGUoY29udGV4dCkge1xuICBjb25zdCBzY2hlbWEgPSBjb250ZXh0LmdldFNjaGVtYSgpO1xuICBjb25zdCBleGlzdGluZ1R5cGVNYXAgPSBzY2hlbWEgPyBzY2hlbWEuZ2V0VHlwZU1hcCgpIDogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IGtub3duVmFsdWVOYW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4ge1xuICAgIEVudW1UeXBlRGVmaW5pdGlvbjogY2hlY2tWYWx1ZVVuaXF1ZW5lc3MsXG4gICAgRW51bVR5cGVFeHRlbnNpb246IGNoZWNrVmFsdWVVbmlxdWVuZXNzXG4gIH07XG4gIGZ1bmN0aW9uIGNoZWNrVmFsdWVVbmlxdWVuZXNzKG5vZGUpIHtcbiAgICB2YXIgX25vZGUkdmFsdWVzO1xuICAgIGNvbnN0IHR5cGVOYW1lID0gbm9kZS5uYW1lLnZhbHVlO1xuICAgIGlmICgha25vd25WYWx1ZU5hbWVzW3R5cGVOYW1lXSkge1xuICAgICAga25vd25WYWx1ZU5hbWVzW3R5cGVOYW1lXSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZU5vZGVzID0gKF9ub2RlJHZhbHVlcyA9IG5vZGUudmFsdWVzKSAhPT0gbnVsbCAmJiBfbm9kZSR2YWx1ZXMgIT09IHZvaWQgMCA/IF9ub2RlJHZhbHVlcyA6IFtdO1xuICAgIGNvbnN0IHZhbHVlTmFtZXMgPSBrbm93blZhbHVlTmFtZXNbdHlwZU5hbWVdO1xuICAgIGZvciAoY29uc3QgdmFsdWVEZWYgb2YgdmFsdWVOb2Rlcykge1xuICAgICAgY29uc3QgdmFsdWVOYW1lID0gdmFsdWVEZWYubmFtZS52YWx1ZTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nVHlwZSA9IGV4aXN0aW5nVHlwZU1hcFt0eXBlTmFtZV07XG4gICAgICBpZiAoaXNFbnVtVHlwZShleGlzdGluZ1R5cGUpICYmIGV4aXN0aW5nVHlwZS5nZXRWYWx1ZSh2YWx1ZU5hbWUpKSB7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBFbnVtIHZhbHVlIFwiJHt0eXBlTmFtZX0uJHt2YWx1ZU5hbWV9XCIgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHNjaGVtYS4gSXQgY2Fubm90IGFsc28gYmUgZGVmaW5lZCBpbiB0aGlzIHR5cGUgZXh0ZW5zaW9uLmAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5vZGVzOiB2YWx1ZURlZi5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZU5hbWVzW3ZhbHVlTmFtZV0pIHtcbiAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYEVudW0gdmFsdWUgXCIke3R5cGVOYW1lfS4ke3ZhbHVlTmFtZX1cIiBjYW4gb25seSBiZSBkZWZpbmVkIG9uY2UuYCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbm9kZXM6IFt2YWx1ZU5hbWVzW3ZhbHVlTmFtZV0sIHZhbHVlRGVmLm5hbWVdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVOYW1lc1t2YWx1ZU5hbWVdID0gdmFsdWVEZWYubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG52YXIgaW5pdF9VbmlxdWVFbnVtVmFsdWVOYW1lc1J1bGUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9VbmlxdWVFbnVtVmFsdWVOYW1lc1J1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgICBpbml0X2RlZmluaXRpb24oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVW5pcXVlRmllbGREZWZpbml0aW9uTmFtZXNSdWxlLm1qc1xuZnVuY3Rpb24gVW5pcXVlRmllbGREZWZpbml0aW9uTmFtZXNSdWxlKGNvbnRleHQpIHtcbiAgY29uc3Qgc2NoZW1hID0gY29udGV4dC5nZXRTY2hlbWEoKTtcbiAgY29uc3QgZXhpc3RpbmdUeXBlTWFwID0gc2NoZW1hID8gc2NoZW1hLmdldFR5cGVNYXAoKSA6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBrbm93bkZpZWxkTmFtZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIHtcbiAgICBJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uOiBjaGVja0ZpZWxkVW5pcXVlbmVzcyxcbiAgICBJbnB1dE9iamVjdFR5cGVFeHRlbnNpb246IGNoZWNrRmllbGRVbmlxdWVuZXNzLFxuICAgIEludGVyZmFjZVR5cGVEZWZpbml0aW9uOiBjaGVja0ZpZWxkVW5pcXVlbmVzcyxcbiAgICBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uOiBjaGVja0ZpZWxkVW5pcXVlbmVzcyxcbiAgICBPYmplY3RUeXBlRGVmaW5pdGlvbjogY2hlY2tGaWVsZFVuaXF1ZW5lc3MsXG4gICAgT2JqZWN0VHlwZUV4dGVuc2lvbjogY2hlY2tGaWVsZFVuaXF1ZW5lc3NcbiAgfTtcbiAgZnVuY3Rpb24gY2hlY2tGaWVsZFVuaXF1ZW5lc3Mobm9kZSkge1xuICAgIHZhciBfbm9kZSRmaWVsZHM7XG4gICAgY29uc3QgdHlwZU5hbWUgPSBub2RlLm5hbWUudmFsdWU7XG4gICAgaWYgKCFrbm93bkZpZWxkTmFtZXNbdHlwZU5hbWVdKSB7XG4gICAgICBrbm93bkZpZWxkTmFtZXNbdHlwZU5hbWVdID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkTm9kZXMgPSAoX25vZGUkZmllbGRzID0gbm9kZS5maWVsZHMpICE9PSBudWxsICYmIF9ub2RlJGZpZWxkcyAhPT0gdm9pZCAwID8gX25vZGUkZmllbGRzIDogW107XG4gICAgY29uc3QgZmllbGROYW1lcyA9IGtub3duRmllbGROYW1lc1t0eXBlTmFtZV07XG4gICAgZm9yIChjb25zdCBmaWVsZERlZiBvZiBmaWVsZE5vZGVzKSB7XG4gICAgICBjb25zdCBmaWVsZE5hbWUgPSBmaWVsZERlZi5uYW1lLnZhbHVlO1xuICAgICAgaWYgKGhhc0ZpZWxkKGV4aXN0aW5nVHlwZU1hcFt0eXBlTmFtZV0sIGZpZWxkTmFtZSkpIHtcbiAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYEZpZWxkIFwiJHt0eXBlTmFtZX0uJHtmaWVsZE5hbWV9XCIgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHNjaGVtYS4gSXQgY2Fubm90IGFsc28gYmUgZGVmaW5lZCBpbiB0aGlzIHR5cGUgZXh0ZW5zaW9uLmAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5vZGVzOiBmaWVsZERlZi5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChmaWVsZE5hbWVzW2ZpZWxkTmFtZV0pIHtcbiAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYEZpZWxkIFwiJHt0eXBlTmFtZX0uJHtmaWVsZE5hbWV9XCIgY2FuIG9ubHkgYmUgZGVmaW5lZCBvbmNlLmAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5vZGVzOiBbZmllbGROYW1lc1tmaWVsZE5hbWVdLCBmaWVsZERlZi5uYW1lXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpZWxkTmFtZXNbZmllbGROYW1lXSA9IGZpZWxkRGVmLm5hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzRmllbGQodHlwZSwgZmllbGROYW1lKSB7XG4gIGlmIChpc09iamVjdFR5cGUodHlwZSkgfHwgaXNJbnRlcmZhY2VUeXBlKHR5cGUpIHx8IGlzSW5wdXRPYmplY3RUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIHR5cGUuZ2V0RmllbGRzKClbZmllbGROYW1lXSAhPSBudWxsO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBpbml0X1VuaXF1ZUZpZWxkRGVmaW5pdGlvbk5hbWVzUnVsZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL1VuaXF1ZUZpZWxkRGVmaW5pdGlvbk5hbWVzUnVsZS5tanNcIigpIHtcbiAgICBpbml0X0dyYXBoUUxFcnJvcigpO1xuICAgIGluaXRfZGVmaW5pdGlvbigpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9VbmlxdWVGcmFnbWVudE5hbWVzUnVsZS5tanNcbmZ1bmN0aW9uIFVuaXF1ZUZyYWdtZW50TmFtZXNSdWxlKGNvbnRleHQpIHtcbiAgY29uc3Qga25vd25GcmFnbWVudE5hbWVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiB7XG4gICAgT3BlcmF0aW9uRGVmaW5pdGlvbjogKCkgPT4gZmFsc2UsXG4gICAgRnJhZ21lbnREZWZpbml0aW9uKG5vZGUpIHtcbiAgICAgIGNvbnN0IGZyYWdtZW50TmFtZSA9IG5vZGUubmFtZS52YWx1ZTtcbiAgICAgIGlmIChrbm93bkZyYWdtZW50TmFtZXNbZnJhZ21lbnROYW1lXSkge1xuICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBgVGhlcmUgY2FuIGJlIG9ubHkgb25lIGZyYWdtZW50IG5hbWVkIFwiJHtmcmFnbWVudE5hbWV9XCIuYCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbm9kZXM6IFtrbm93bkZyYWdtZW50TmFtZXNbZnJhZ21lbnROYW1lXSwgbm9kZS5uYW1lXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtub3duRnJhZ21lbnROYW1lc1tmcmFnbWVudE5hbWVdID0gbm9kZS5uYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cbnZhciBpbml0X1VuaXF1ZUZyYWdtZW50TmFtZXNSdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVW5pcXVlRnJhZ21lbnROYW1lc1J1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVW5pcXVlSW5wdXRGaWVsZE5hbWVzUnVsZS5tanNcbmZ1bmN0aW9uIFVuaXF1ZUlucHV0RmllbGROYW1lc1J1bGUoY29udGV4dCkge1xuICBjb25zdCBrbm93bk5hbWVTdGFjayA9IFtdO1xuICBsZXQga25vd25OYW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4ge1xuICAgIE9iamVjdFZhbHVlOiB7XG4gICAgICBlbnRlcigpIHtcbiAgICAgICAga25vd25OYW1lU3RhY2sucHVzaChrbm93bk5hbWVzKTtcbiAgICAgICAga25vd25OYW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfSxcbiAgICAgIGxlYXZlKCkge1xuICAgICAgICBjb25zdCBwcmV2S25vd25OYW1lcyA9IGtub3duTmFtZVN0YWNrLnBvcCgpO1xuICAgICAgICBwcmV2S25vd25OYW1lcyB8fCBpbnZhcmlhbnQoZmFsc2UpO1xuICAgICAgICBrbm93bk5hbWVzID0gcHJldktub3duTmFtZXM7XG4gICAgICB9XG4gICAgfSxcbiAgICBPYmplY3RGaWVsZChub2RlKSB7XG4gICAgICBjb25zdCBmaWVsZE5hbWUgPSBub2RlLm5hbWUudmFsdWU7XG4gICAgICBpZiAoa25vd25OYW1lc1tmaWVsZE5hbWVdKSB7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBUaGVyZSBjYW4gYmUgb25seSBvbmUgaW5wdXQgZmllbGQgbmFtZWQgXCIke2ZpZWxkTmFtZX1cIi5gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBub2RlczogW2tub3duTmFtZXNbZmllbGROYW1lXSwgbm9kZS5uYW1lXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtub3duTmFtZXNbZmllbGROYW1lXSA9IG5vZGUubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9VbmlxdWVJbnB1dEZpZWxkTmFtZXNSdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVW5pcXVlSW5wdXRGaWVsZE5hbWVzUnVsZS5tanNcIigpIHtcbiAgICBpbml0X2ludmFyaWFudCgpO1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL1VuaXF1ZU9wZXJhdGlvbk5hbWVzUnVsZS5tanNcbmZ1bmN0aW9uIFVuaXF1ZU9wZXJhdGlvbk5hbWVzUnVsZShjb250ZXh0KSB7XG4gIGNvbnN0IGtub3duT3BlcmF0aW9uTmFtZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIHtcbiAgICBPcGVyYXRpb25EZWZpbml0aW9uKG5vZGUpIHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbk5hbWUgPSBub2RlLm5hbWU7XG4gICAgICBpZiAob3BlcmF0aW9uTmFtZSkge1xuICAgICAgICBpZiAoa25vd25PcGVyYXRpb25OYW1lc1tvcGVyYXRpb25OYW1lLnZhbHVlXSkge1xuICAgICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgICBgVGhlcmUgY2FuIGJlIG9ubHkgb25lIG9wZXJhdGlvbiBuYW1lZCBcIiR7b3BlcmF0aW9uTmFtZS52YWx1ZX1cIi5gLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm9kZXM6IFtcbiAgICAgICAgICAgICAgICAgIGtub3duT3BlcmF0aW9uTmFtZXNbb3BlcmF0aW9uTmFtZS52YWx1ZV0sXG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrbm93bk9wZXJhdGlvbk5hbWVzW29wZXJhdGlvbk5hbWUudmFsdWVdID0gb3BlcmF0aW9uTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgRnJhZ21lbnREZWZpbml0aW9uOiAoKSA9PiBmYWxzZVxuICB9O1xufVxudmFyIGluaXRfVW5pcXVlT3BlcmF0aW9uTmFtZXNSdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVW5pcXVlT3BlcmF0aW9uTmFtZXNSdWxlLm1qc1wiKCkge1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL1VuaXF1ZU9wZXJhdGlvblR5cGVzUnVsZS5tanNcbmZ1bmN0aW9uIFVuaXF1ZU9wZXJhdGlvblR5cGVzUnVsZShjb250ZXh0KSB7XG4gIGNvbnN0IHNjaGVtYSA9IGNvbnRleHQuZ2V0U2NoZW1hKCk7XG4gIGNvbnN0IGRlZmluZWRPcGVyYXRpb25UeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBleGlzdGluZ09wZXJhdGlvblR5cGVzID0gc2NoZW1hID8ge1xuICAgIHF1ZXJ5OiBzY2hlbWEuZ2V0UXVlcnlUeXBlKCksXG4gICAgbXV0YXRpb246IHNjaGVtYS5nZXRNdXRhdGlvblR5cGUoKSxcbiAgICBzdWJzY3JpcHRpb246IHNjaGVtYS5nZXRTdWJzY3JpcHRpb25UeXBlKClcbiAgfSA6IHt9O1xuICByZXR1cm4ge1xuICAgIFNjaGVtYURlZmluaXRpb246IGNoZWNrT3BlcmF0aW9uVHlwZXMsXG4gICAgU2NoZW1hRXh0ZW5zaW9uOiBjaGVja09wZXJhdGlvblR5cGVzXG4gIH07XG4gIGZ1bmN0aW9uIGNoZWNrT3BlcmF0aW9uVHlwZXMobm9kZSkge1xuICAgIHZhciBfbm9kZSRvcGVyYXRpb25UeXBlcztcbiAgICBjb25zdCBvcGVyYXRpb25UeXBlc05vZGVzID0gKF9ub2RlJG9wZXJhdGlvblR5cGVzID0gbm9kZS5vcGVyYXRpb25UeXBlcykgIT09IG51bGwgJiYgX25vZGUkb3BlcmF0aW9uVHlwZXMgIT09IHZvaWQgMCA/IF9ub2RlJG9wZXJhdGlvblR5cGVzIDogW107XG4gICAgZm9yIChjb25zdCBvcGVyYXRpb25UeXBlIG9mIG9wZXJhdGlvblR5cGVzTm9kZXMpIHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG9wZXJhdGlvblR5cGUub3BlcmF0aW9uO1xuICAgICAgY29uc3QgYWxyZWFkeURlZmluZWRPcGVyYXRpb25UeXBlID0gZGVmaW5lZE9wZXJhdGlvblR5cGVzW29wZXJhdGlvbl07XG4gICAgICBpZiAoZXhpc3RpbmdPcGVyYXRpb25UeXBlc1tvcGVyYXRpb25dKSB7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBUeXBlIGZvciAke29wZXJhdGlvbn0gYWxyZWFkeSBkZWZpbmVkIGluIHRoZSBzY2hlbWEuIEl0IGNhbm5vdCBiZSByZWRlZmluZWQuYCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbm9kZXM6IG9wZXJhdGlvblR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGFscmVhZHlEZWZpbmVkT3BlcmF0aW9uVHlwZSkge1xuICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBgVGhlcmUgY2FuIGJlIG9ubHkgb25lICR7b3BlcmF0aW9ufSB0eXBlIGluIHNjaGVtYS5gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBub2RlczogW2FscmVhZHlEZWZpbmVkT3BlcmF0aW9uVHlwZSwgb3BlcmF0aW9uVHlwZV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVkT3BlcmF0aW9uVHlwZXNbb3BlcmF0aW9uXSA9IG9wZXJhdGlvblR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxudmFyIGluaXRfVW5pcXVlT3BlcmF0aW9uVHlwZXNSdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVW5pcXVlT3BlcmF0aW9uVHlwZXNSdWxlLm1qc1wiKCkge1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL1VuaXF1ZVR5cGVOYW1lc1J1bGUubWpzXG5mdW5jdGlvbiBVbmlxdWVUeXBlTmFtZXNSdWxlKGNvbnRleHQpIHtcbiAgY29uc3Qga25vd25UeXBlTmFtZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgc2NoZW1hID0gY29udGV4dC5nZXRTY2hlbWEoKTtcbiAgcmV0dXJuIHtcbiAgICBTY2FsYXJUeXBlRGVmaW5pdGlvbjogY2hlY2tUeXBlTmFtZSxcbiAgICBPYmplY3RUeXBlRGVmaW5pdGlvbjogY2hlY2tUeXBlTmFtZSxcbiAgICBJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbjogY2hlY2tUeXBlTmFtZSxcbiAgICBVbmlvblR5cGVEZWZpbml0aW9uOiBjaGVja1R5cGVOYW1lLFxuICAgIEVudW1UeXBlRGVmaW5pdGlvbjogY2hlY2tUeXBlTmFtZSxcbiAgICBJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uOiBjaGVja1R5cGVOYW1lXG4gIH07XG4gIGZ1bmN0aW9uIGNoZWNrVHlwZU5hbWUobm9kZSkge1xuICAgIGNvbnN0IHR5cGVOYW1lID0gbm9kZS5uYW1lLnZhbHVlO1xuICAgIGlmIChzY2hlbWEgIT09IG51bGwgJiYgc2NoZW1hICE9PSB2b2lkIDAgJiYgc2NoZW1hLmdldFR5cGUodHlwZU5hbWUpKSB7XG4gICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgIGBUeXBlIFwiJHt0eXBlTmFtZX1cIiBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgc2NoZW1hLiBJdCBjYW5ub3QgYWxzbyBiZSBkZWZpbmVkIGluIHRoaXMgdHlwZSBkZWZpbml0aW9uLmAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbm9kZXM6IG5vZGUubmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGtub3duVHlwZU5hbWVzW3R5cGVOYW1lXSkge1xuICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihgVGhlcmUgY2FuIGJlIG9ubHkgb25lIHR5cGUgbmFtZWQgXCIke3R5cGVOYW1lfVwiLmAsIHtcbiAgICAgICAgICBub2RlczogW2tub3duVHlwZU5hbWVzW3R5cGVOYW1lXSwgbm9kZS5uYW1lXVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAga25vd25UeXBlTmFtZXNbdHlwZU5hbWVdID0gbm9kZS5uYW1lO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbnZhciBpbml0X1VuaXF1ZVR5cGVOYW1lc1J1bGUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9VbmlxdWVUeXBlTmFtZXNSdWxlLm1qc1wiKCkge1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL1VuaXF1ZVZhcmlhYmxlTmFtZXNSdWxlLm1qc1xuZnVuY3Rpb24gVW5pcXVlVmFyaWFibGVOYW1lc1J1bGUoY29udGV4dCkge1xuICByZXR1cm4ge1xuICAgIE9wZXJhdGlvbkRlZmluaXRpb24ob3BlcmF0aW9uTm9kZSkge1xuICAgICAgdmFyIF9vcGVyYXRpb25Ob2RlJHZhcmlhYjtcbiAgICAgIGNvbnN0IHZhcmlhYmxlRGVmaW5pdGlvbnMgPSAoX29wZXJhdGlvbk5vZGUkdmFyaWFiID0gb3BlcmF0aW9uTm9kZS52YXJpYWJsZURlZmluaXRpb25zKSAhPT0gbnVsbCAmJiBfb3BlcmF0aW9uTm9kZSR2YXJpYWIgIT09IHZvaWQgMCA/IF9vcGVyYXRpb25Ob2RlJHZhcmlhYiA6IFtdO1xuICAgICAgY29uc3Qgc2VlblZhcmlhYmxlRGVmaW5pdGlvbnMgPSBncm91cEJ5KFxuICAgICAgICB2YXJpYWJsZURlZmluaXRpb25zLFxuICAgICAgICAobm9kZSkgPT4gbm9kZS52YXJpYWJsZS5uYW1lLnZhbHVlXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCBbdmFyaWFibGVOYW1lLCB2YXJpYWJsZU5vZGVzXSBvZiBzZWVuVmFyaWFibGVEZWZpbml0aW9ucykge1xuICAgICAgICBpZiAodmFyaWFibGVOb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICAgIGBUaGVyZSBjYW4gYmUgb25seSBvbmUgdmFyaWFibGUgbmFtZWQgXCIkJHt2YXJpYWJsZU5hbWV9XCIuYCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vZGVzOiB2YXJpYWJsZU5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS52YXJpYWJsZS5uYW1lKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbnZhciBpbml0X1VuaXF1ZVZhcmlhYmxlTmFtZXNSdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVW5pcXVlVmFyaWFibGVOYW1lc1J1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9ncm91cEJ5KCk7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVmFsdWVzT2ZDb3JyZWN0VHlwZVJ1bGUubWpzXG5mdW5jdGlvbiBWYWx1ZXNPZkNvcnJlY3RUeXBlUnVsZShjb250ZXh0KSB7XG4gIHJldHVybiB7XG4gICAgTGlzdFZhbHVlKG5vZGUpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBnZXROdWxsYWJsZVR5cGUoY29udGV4dC5nZXRQYXJlbnRJbnB1dFR5cGUoKSk7XG4gICAgICBpZiAoIWlzTGlzdFR5cGUodHlwZSkpIHtcbiAgICAgICAgaXNWYWxpZFZhbHVlTm9kZShjb250ZXh0LCBub2RlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgT2JqZWN0VmFsdWUobm9kZSkge1xuICAgICAgY29uc3QgdHlwZSA9IGdldE5hbWVkVHlwZShjb250ZXh0LmdldElucHV0VHlwZSgpKTtcbiAgICAgIGlmICghaXNJbnB1dE9iamVjdFR5cGUodHlwZSkpIHtcbiAgICAgICAgaXNWYWxpZFZhbHVlTm9kZShjb250ZXh0LCBub2RlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgZmllbGROb2RlTWFwID0ga2V5TWFwKG5vZGUuZmllbGRzLCAoZmllbGQpID0+IGZpZWxkLm5hbWUudmFsdWUpO1xuICAgICAgZm9yIChjb25zdCBmaWVsZERlZiBvZiBPYmplY3QudmFsdWVzKHR5cGUuZ2V0RmllbGRzKCkpKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkTm9kZSA9IGZpZWxkTm9kZU1hcFtmaWVsZERlZi5uYW1lXTtcbiAgICAgICAgaWYgKCFmaWVsZE5vZGUgJiYgaXNSZXF1aXJlZElucHV0RmllbGQoZmllbGREZWYpKSB7XG4gICAgICAgICAgY29uc3QgdHlwZVN0ciA9IGluc3BlY3QoZmllbGREZWYudHlwZSk7XG4gICAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICAgIGBGaWVsZCBcIiR7dHlwZS5uYW1lfS4ke2ZpZWxkRGVmLm5hbWV9XCIgb2YgcmVxdWlyZWQgdHlwZSBcIiR7dHlwZVN0cn1cIiB3YXMgbm90IHByb3ZpZGVkLmAsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBub2Rlczogbm9kZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgT2JqZWN0RmllbGQobm9kZSkge1xuICAgICAgY29uc3QgcGFyZW50VHlwZSA9IGdldE5hbWVkVHlwZShjb250ZXh0LmdldFBhcmVudElucHV0VHlwZSgpKTtcbiAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IGNvbnRleHQuZ2V0SW5wdXRUeXBlKCk7XG4gICAgICBpZiAoIWZpZWxkVHlwZSAmJiBpc0lucHV0T2JqZWN0VHlwZShwYXJlbnRUeXBlKSkge1xuICAgICAgICBjb25zdCBzdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25MaXN0KFxuICAgICAgICAgIG5vZGUubmFtZS52YWx1ZSxcbiAgICAgICAgICBPYmplY3Qua2V5cyhwYXJlbnRUeXBlLmdldEZpZWxkcygpKVxuICAgICAgICApO1xuICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBgRmllbGQgXCIke25vZGUubmFtZS52YWx1ZX1cIiBpcyBub3QgZGVmaW5lZCBieSB0eXBlIFwiJHtwYXJlbnRUeXBlLm5hbWV9XCIuYCArIGRpZFlvdU1lYW4oc3VnZ2VzdGlvbnMpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBub2Rlczogbm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIE51bGxWYWx1ZShub2RlKSB7XG4gICAgICBjb25zdCB0eXBlID0gY29udGV4dC5nZXRJbnB1dFR5cGUoKTtcbiAgICAgIGlmIChpc05vbk51bGxUeXBlKHR5cGUpKSB7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBFeHBlY3RlZCB2YWx1ZSBvZiB0eXBlIFwiJHtpbnNwZWN0KHR5cGUpfVwiLCBmb3VuZCAke3ByaW50KG5vZGUpfS5gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBub2Rlczogbm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIEVudW1WYWx1ZTogKG5vZGUpID0+IGlzVmFsaWRWYWx1ZU5vZGUoY29udGV4dCwgbm9kZSksXG4gICAgSW50VmFsdWU6IChub2RlKSA9PiBpc1ZhbGlkVmFsdWVOb2RlKGNvbnRleHQsIG5vZGUpLFxuICAgIEZsb2F0VmFsdWU6IChub2RlKSA9PiBpc1ZhbGlkVmFsdWVOb2RlKGNvbnRleHQsIG5vZGUpLFxuICAgIFN0cmluZ1ZhbHVlOiAobm9kZSkgPT4gaXNWYWxpZFZhbHVlTm9kZShjb250ZXh0LCBub2RlKSxcbiAgICBCb29sZWFuVmFsdWU6IChub2RlKSA9PiBpc1ZhbGlkVmFsdWVOb2RlKGNvbnRleHQsIG5vZGUpXG4gIH07XG59XG5mdW5jdGlvbiBpc1ZhbGlkVmFsdWVOb2RlKGNvbnRleHQsIG5vZGUpIHtcbiAgY29uc3QgbG9jYXRpb25UeXBlID0gY29udGV4dC5nZXRJbnB1dFR5cGUoKTtcbiAgaWYgKCFsb2NhdGlvblR5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdHlwZSA9IGdldE5hbWVkVHlwZShsb2NhdGlvblR5cGUpO1xuICBpZiAoIWlzTGVhZlR5cGUodHlwZSkpIHtcbiAgICBjb25zdCB0eXBlU3RyID0gaW5zcGVjdChsb2NhdGlvblR5cGUpO1xuICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgdmFsdWUgb2YgdHlwZSBcIiR7dHlwZVN0cn1cIiwgZm91bmQgJHtwcmludChub2RlKX0uYCxcbiAgICAgICAge1xuICAgICAgICAgIG5vZGVzOiBub2RlXG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gdHlwZS5wYXJzZUxpdGVyYWwoXG4gICAgICBub2RlLFxuICAgICAgdm9pZCAwXG4gICAgICAvKiB2YXJpYWJsZXMgKi9cbiAgICApO1xuICAgIGlmIChwYXJzZVJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCB0eXBlU3RyID0gaW5zcGVjdChsb2NhdGlvblR5cGUpO1xuICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgdmFsdWUgb2YgdHlwZSBcIiR7dHlwZVN0cn1cIiwgZm91bmQgJHtwcmludChub2RlKX0uYCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBub2Rlczogbm9kZVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgdHlwZVN0ciA9IGluc3BlY3QobG9jYXRpb25UeXBlKTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBHcmFwaFFMRXJyb3IpIHtcbiAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnJlcG9ydEVycm9yKFxuICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCB2YWx1ZSBvZiB0eXBlIFwiJHt0eXBlU3RyfVwiLCBmb3VuZCAke3ByaW50KG5vZGUpfTsgYCArIGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbm9kZXM6IG5vZGUsXG4gICAgICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbnZhciBpbml0X1ZhbHVlc09mQ29ycmVjdFR5cGVSdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVmFsdWVzT2ZDb3JyZWN0VHlwZVJ1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9kaWRZb3VNZWFuKCk7XG4gICAgaW5pdF9pbnNwZWN0KCk7XG4gICAgaW5pdF9rZXlNYXAoKTtcbiAgICBpbml0X3N1Z2dlc3Rpb25MaXN0KCk7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgICBpbml0X3ByaW50ZXIoKTtcbiAgICBpbml0X2RlZmluaXRpb24oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVmFyaWFibGVzQXJlSW5wdXRUeXBlc1J1bGUubWpzXG5mdW5jdGlvbiBWYXJpYWJsZXNBcmVJbnB1dFR5cGVzUnVsZShjb250ZXh0KSB7XG4gIHJldHVybiB7XG4gICAgVmFyaWFibGVEZWZpbml0aW9uKG5vZGUpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlRnJvbUFTVChjb250ZXh0LmdldFNjaGVtYSgpLCBub2RlLnR5cGUpO1xuICAgICAgaWYgKHR5cGUgIT09IHZvaWQgMCAmJiAhaXNJbnB1dFR5cGUodHlwZSkpIHtcbiAgICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gbm9kZS52YXJpYWJsZS5uYW1lLnZhbHVlO1xuICAgICAgICBjb25zdCB0eXBlTmFtZSA9IHByaW50KG5vZGUudHlwZSk7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBWYXJpYWJsZSBcIiQke3ZhcmlhYmxlTmFtZX1cIiBjYW5ub3QgYmUgbm9uLWlucHV0IHR5cGUgXCIke3R5cGVOYW1lfVwiLmAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5vZGVzOiBub2RlLnR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxudmFyIGluaXRfVmFyaWFibGVzQXJlSW5wdXRUeXBlc1J1bGUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9WYXJpYWJsZXNBcmVJbnB1dFR5cGVzUnVsZS5tanNcIigpIHtcbiAgICBpbml0X0dyYXBoUUxFcnJvcigpO1xuICAgIGluaXRfcHJpbnRlcigpO1xuICAgIGluaXRfZGVmaW5pdGlvbigpO1xuICAgIGluaXRfdHlwZUZyb21BU1QoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvVmFyaWFibGVzSW5BbGxvd2VkUG9zaXRpb25SdWxlLm1qc1xuZnVuY3Rpb24gVmFyaWFibGVzSW5BbGxvd2VkUG9zaXRpb25SdWxlKGNvbnRleHQpIHtcbiAgbGV0IHZhckRlZk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4ge1xuICAgIE9wZXJhdGlvbkRlZmluaXRpb246IHtcbiAgICAgIGVudGVyKCkge1xuICAgICAgICB2YXJEZWZNYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH0sXG4gICAgICBsZWF2ZShvcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgdXNhZ2VzID0gY29udGV4dC5nZXRSZWN1cnNpdmVWYXJpYWJsZVVzYWdlcyhvcGVyYXRpb24pO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbm9kZSwgdHlwZSwgZGVmYXVsdFZhbHVlIH0gb2YgdXNhZ2VzKSB7XG4gICAgICAgICAgY29uc3QgdmFyTmFtZSA9IG5vZGUubmFtZS52YWx1ZTtcbiAgICAgICAgICBjb25zdCB2YXJEZWYgPSB2YXJEZWZNYXBbdmFyTmFtZV07XG4gICAgICAgICAgaWYgKHZhckRlZiAmJiB0eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBjb250ZXh0LmdldFNjaGVtYSgpO1xuICAgICAgICAgICAgY29uc3QgdmFyVHlwZSA9IHR5cGVGcm9tQVNUKHNjaGVtYSwgdmFyRGVmLnR5cGUpO1xuICAgICAgICAgICAgaWYgKHZhclR5cGUgJiYgIWFsbG93ZWRWYXJpYWJsZVVzYWdlKFxuICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgIHZhclR5cGUsXG4gICAgICAgICAgICAgIHZhckRlZi5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICBjb25zdCB2YXJUeXBlU3RyID0gaW5zcGVjdCh2YXJUeXBlKTtcbiAgICAgICAgICAgICAgY29uc3QgdHlwZVN0ciA9IGluc3BlY3QodHlwZSk7XG4gICAgICAgICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgICAgICAgIGBWYXJpYWJsZSBcIiQke3Zhck5hbWV9XCIgb2YgdHlwZSBcIiR7dmFyVHlwZVN0cn1cIiB1c2VkIGluIHBvc2l0aW9uIGV4cGVjdGluZyB0eXBlIFwiJHt0eXBlU3RyfVwiLmAsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzOiBbdmFyRGVmLCBub2RlXVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFZhcmlhYmxlRGVmaW5pdGlvbihub2RlKSB7XG4gICAgICB2YXJEZWZNYXBbbm9kZS52YXJpYWJsZS5uYW1lLnZhbHVlXSA9IG5vZGU7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYWxsb3dlZFZhcmlhYmxlVXNhZ2Uoc2NoZW1hLCB2YXJUeXBlLCB2YXJEZWZhdWx0VmFsdWUsIGxvY2F0aW9uVHlwZSwgbG9jYXRpb25EZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGlzTm9uTnVsbFR5cGUobG9jYXRpb25UeXBlKSAmJiAhaXNOb25OdWxsVHlwZSh2YXJUeXBlKSkge1xuICAgIGNvbnN0IGhhc05vbk51bGxWYXJpYWJsZURlZmF1bHRWYWx1ZSA9IHZhckRlZmF1bHRWYWx1ZSAhPSBudWxsICYmIHZhckRlZmF1bHRWYWx1ZS5raW5kICE9PSBLaW5kLk5VTEw7XG4gICAgY29uc3QgaGFzTG9jYXRpb25EZWZhdWx0VmFsdWUgPSBsb2NhdGlvbkRlZmF1bHRWYWx1ZSAhPT0gdm9pZCAwO1xuICAgIGlmICghaGFzTm9uTnVsbFZhcmlhYmxlRGVmYXVsdFZhbHVlICYmICFoYXNMb2NhdGlvbkRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBudWxsYWJsZUxvY2F0aW9uVHlwZSA9IGxvY2F0aW9uVHlwZS5vZlR5cGU7XG4gICAgcmV0dXJuIGlzVHlwZVN1YlR5cGVPZihzY2hlbWEsIHZhclR5cGUsIG51bGxhYmxlTG9jYXRpb25UeXBlKTtcbiAgfVxuICByZXR1cm4gaXNUeXBlU3ViVHlwZU9mKHNjaGVtYSwgdmFyVHlwZSwgbG9jYXRpb25UeXBlKTtcbn1cbnZhciBpbml0X1ZhcmlhYmxlc0luQWxsb3dlZFBvc2l0aW9uUnVsZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL1ZhcmlhYmxlc0luQWxsb3dlZFBvc2l0aW9uUnVsZS5tanNcIigpIHtcbiAgICBpbml0X2luc3BlY3QoKTtcbiAgICBpbml0X0dyYXBoUUxFcnJvcigpO1xuICAgIGluaXRfa2luZHMoKTtcbiAgICBpbml0X2RlZmluaXRpb24oKTtcbiAgICBpbml0X3R5cGVDb21wYXJhdG9ycygpO1xuICAgIGluaXRfdHlwZUZyb21BU1QoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vc3BlY2lmaWVkUnVsZXMubWpzXG52YXIgc3BlY2lmaWVkUnVsZXMsIHNwZWNpZmllZFNETFJ1bGVzO1xudmFyIGluaXRfc3BlY2lmaWVkUnVsZXMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9zcGVjaWZpZWRSdWxlcy5tanNcIigpIHtcbiAgICBpbml0X0V4ZWN1dGFibGVEZWZpbml0aW9uc1J1bGUoKTtcbiAgICBpbml0X0ZpZWxkc09uQ29ycmVjdFR5cGVSdWxlKCk7XG4gICAgaW5pdF9GcmFnbWVudHNPbkNvbXBvc2l0ZVR5cGVzUnVsZSgpO1xuICAgIGluaXRfS25vd25Bcmd1bWVudE5hbWVzUnVsZSgpO1xuICAgIGluaXRfS25vd25EaXJlY3RpdmVzUnVsZSgpO1xuICAgIGluaXRfS25vd25GcmFnbWVudE5hbWVzUnVsZSgpO1xuICAgIGluaXRfS25vd25UeXBlTmFtZXNSdWxlKCk7XG4gICAgaW5pdF9Mb25lQW5vbnltb3VzT3BlcmF0aW9uUnVsZSgpO1xuICAgIGluaXRfTG9uZVNjaGVtYURlZmluaXRpb25SdWxlKCk7XG4gICAgaW5pdF9Ob0ZyYWdtZW50Q3ljbGVzUnVsZSgpO1xuICAgIGluaXRfTm9VbmRlZmluZWRWYXJpYWJsZXNSdWxlKCk7XG4gICAgaW5pdF9Ob1VudXNlZEZyYWdtZW50c1J1bGUoKTtcbiAgICBpbml0X05vVW51c2VkVmFyaWFibGVzUnVsZSgpO1xuICAgIGluaXRfT3ZlcmxhcHBpbmdGaWVsZHNDYW5CZU1lcmdlZFJ1bGUoKTtcbiAgICBpbml0X1Bvc3NpYmxlRnJhZ21lbnRTcHJlYWRzUnVsZSgpO1xuICAgIGluaXRfUG9zc2libGVUeXBlRXh0ZW5zaW9uc1J1bGUoKTtcbiAgICBpbml0X1Byb3ZpZGVkUmVxdWlyZWRBcmd1bWVudHNSdWxlKCk7XG4gICAgaW5pdF9TY2FsYXJMZWFmc1J1bGUoKTtcbiAgICBpbml0X1NpbmdsZUZpZWxkU3Vic2NyaXB0aW9uc1J1bGUoKTtcbiAgICBpbml0X1VuaXF1ZUFyZ3VtZW50RGVmaW5pdGlvbk5hbWVzUnVsZSgpO1xuICAgIGluaXRfVW5pcXVlQXJndW1lbnROYW1lc1J1bGUoKTtcbiAgICBpbml0X1VuaXF1ZURpcmVjdGl2ZU5hbWVzUnVsZSgpO1xuICAgIGluaXRfVW5pcXVlRGlyZWN0aXZlc1BlckxvY2F0aW9uUnVsZSgpO1xuICAgIGluaXRfVW5pcXVlRW51bVZhbHVlTmFtZXNSdWxlKCk7XG4gICAgaW5pdF9VbmlxdWVGaWVsZERlZmluaXRpb25OYW1lc1J1bGUoKTtcbiAgICBpbml0X1VuaXF1ZUZyYWdtZW50TmFtZXNSdWxlKCk7XG4gICAgaW5pdF9VbmlxdWVJbnB1dEZpZWxkTmFtZXNSdWxlKCk7XG4gICAgaW5pdF9VbmlxdWVPcGVyYXRpb25OYW1lc1J1bGUoKTtcbiAgICBpbml0X1VuaXF1ZU9wZXJhdGlvblR5cGVzUnVsZSgpO1xuICAgIGluaXRfVW5pcXVlVHlwZU5hbWVzUnVsZSgpO1xuICAgIGluaXRfVW5pcXVlVmFyaWFibGVOYW1lc1J1bGUoKTtcbiAgICBpbml0X1ZhbHVlc09mQ29ycmVjdFR5cGVSdWxlKCk7XG4gICAgaW5pdF9WYXJpYWJsZXNBcmVJbnB1dFR5cGVzUnVsZSgpO1xuICAgIGluaXRfVmFyaWFibGVzSW5BbGxvd2VkUG9zaXRpb25SdWxlKCk7XG4gICAgc3BlY2lmaWVkUnVsZXMgPSBPYmplY3QuZnJlZXplKFtcbiAgICAgIEV4ZWN1dGFibGVEZWZpbml0aW9uc1J1bGUsXG4gICAgICBVbmlxdWVPcGVyYXRpb25OYW1lc1J1bGUsXG4gICAgICBMb25lQW5vbnltb3VzT3BlcmF0aW9uUnVsZSxcbiAgICAgIFNpbmdsZUZpZWxkU3Vic2NyaXB0aW9uc1J1bGUsXG4gICAgICBLbm93blR5cGVOYW1lc1J1bGUsXG4gICAgICBGcmFnbWVudHNPbkNvbXBvc2l0ZVR5cGVzUnVsZSxcbiAgICAgIFZhcmlhYmxlc0FyZUlucHV0VHlwZXNSdWxlLFxuICAgICAgU2NhbGFyTGVhZnNSdWxlLFxuICAgICAgRmllbGRzT25Db3JyZWN0VHlwZVJ1bGUsXG4gICAgICBVbmlxdWVGcmFnbWVudE5hbWVzUnVsZSxcbiAgICAgIEtub3duRnJhZ21lbnROYW1lc1J1bGUsXG4gICAgICBOb1VudXNlZEZyYWdtZW50c1J1bGUsXG4gICAgICBQb3NzaWJsZUZyYWdtZW50U3ByZWFkc1J1bGUsXG4gICAgICBOb0ZyYWdtZW50Q3ljbGVzUnVsZSxcbiAgICAgIFVuaXF1ZVZhcmlhYmxlTmFtZXNSdWxlLFxuICAgICAgTm9VbmRlZmluZWRWYXJpYWJsZXNSdWxlLFxuICAgICAgTm9VbnVzZWRWYXJpYWJsZXNSdWxlLFxuICAgICAgS25vd25EaXJlY3RpdmVzUnVsZSxcbiAgICAgIFVuaXF1ZURpcmVjdGl2ZXNQZXJMb2NhdGlvblJ1bGUsXG4gICAgICBLbm93bkFyZ3VtZW50TmFtZXNSdWxlLFxuICAgICAgVW5pcXVlQXJndW1lbnROYW1lc1J1bGUsXG4gICAgICBWYWx1ZXNPZkNvcnJlY3RUeXBlUnVsZSxcbiAgICAgIFByb3ZpZGVkUmVxdWlyZWRBcmd1bWVudHNSdWxlLFxuICAgICAgVmFyaWFibGVzSW5BbGxvd2VkUG9zaXRpb25SdWxlLFxuICAgICAgT3ZlcmxhcHBpbmdGaWVsZHNDYW5CZU1lcmdlZFJ1bGUsXG4gICAgICBVbmlxdWVJbnB1dEZpZWxkTmFtZXNSdWxlXG4gICAgXSk7XG4gICAgc3BlY2lmaWVkU0RMUnVsZXMgPSBPYmplY3QuZnJlZXplKFtcbiAgICAgIExvbmVTY2hlbWFEZWZpbml0aW9uUnVsZSxcbiAgICAgIFVuaXF1ZU9wZXJhdGlvblR5cGVzUnVsZSxcbiAgICAgIFVuaXF1ZVR5cGVOYW1lc1J1bGUsXG4gICAgICBVbmlxdWVFbnVtVmFsdWVOYW1lc1J1bGUsXG4gICAgICBVbmlxdWVGaWVsZERlZmluaXRpb25OYW1lc1J1bGUsXG4gICAgICBVbmlxdWVBcmd1bWVudERlZmluaXRpb25OYW1lc1J1bGUsXG4gICAgICBVbmlxdWVEaXJlY3RpdmVOYW1lc1J1bGUsXG4gICAgICBLbm93blR5cGVOYW1lc1J1bGUsXG4gICAgICBLbm93bkRpcmVjdGl2ZXNSdWxlLFxuICAgICAgVW5pcXVlRGlyZWN0aXZlc1BlckxvY2F0aW9uUnVsZSxcbiAgICAgIFBvc3NpYmxlVHlwZUV4dGVuc2lvbnNSdWxlLFxuICAgICAgS25vd25Bcmd1bWVudE5hbWVzT25EaXJlY3RpdmVzUnVsZSxcbiAgICAgIFVuaXF1ZUFyZ3VtZW50TmFtZXNSdWxlLFxuICAgICAgVW5pcXVlSW5wdXRGaWVsZE5hbWVzUnVsZSxcbiAgICAgIFByb3ZpZGVkUmVxdWlyZWRBcmd1bWVudHNPbkRpcmVjdGl2ZXNSdWxlXG4gICAgXSk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL1ZhbGlkYXRpb25Db250ZXh0Lm1qc1xudmFyIEFTVFZhbGlkYXRpb25Db250ZXh0LCBTRExWYWxpZGF0aW9uQ29udGV4dCwgVmFsaWRhdGlvbkNvbnRleHQ7XG52YXIgaW5pdF9WYWxpZGF0aW9uQ29udGV4dCA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL1ZhbGlkYXRpb25Db250ZXh0Lm1qc1wiKCkge1xuICAgIGluaXRfa2luZHMoKTtcbiAgICBpbml0X3Zpc2l0b3IoKTtcbiAgICBpbml0X1R5cGVJbmZvKCk7XG4gICAgQVNUVmFsaWRhdGlvbkNvbnRleHQgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcihhc3QsIG9uRXJyb3IpIHtcbiAgICAgICAgdGhpcy5fYXN0ID0gYXN0O1xuICAgICAgICB0aGlzLl9mcmFnbWVudHMgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX2ZyYWdtZW50U3ByZWFkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZWx5UmVmZXJlbmNlZEZyYWdtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX29uRXJyb3IgPSBvbkVycm9yO1xuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJBU1RWYWxpZGF0aW9uQ29udGV4dFwiO1xuICAgICAgfVxuICAgICAgcmVwb3J0RXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb25FcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgICBnZXREb2N1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FzdDtcbiAgICAgIH1cbiAgICAgIGdldEZyYWdtZW50KG5hbWUpIHtcbiAgICAgICAgbGV0IGZyYWdtZW50cztcbiAgICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50cykge1xuICAgICAgICAgIGZyYWdtZW50cyA9IHRoaXMuX2ZyYWdtZW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnbWVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGRlZk5vZGUgb2YgdGhpcy5nZXREb2N1bWVudCgpLmRlZmluaXRpb25zKSB7XG4gICAgICAgICAgICBpZiAoZGVmTm9kZS5raW5kID09PSBLaW5kLkZSQUdNRU5UX0RFRklOSVRJT04pIHtcbiAgICAgICAgICAgICAgZnJhZ21lbnRzW2RlZk5vZGUubmFtZS52YWx1ZV0gPSBkZWZOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyYWdtZW50c1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIGdldEZyYWdtZW50U3ByZWFkcyhub2RlKSB7XG4gICAgICAgIGxldCBzcHJlYWRzID0gdGhpcy5fZnJhZ21lbnRTcHJlYWRzLmdldChub2RlKTtcbiAgICAgICAgaWYgKCFzcHJlYWRzKSB7XG4gICAgICAgICAgc3ByZWFkcyA9IFtdO1xuICAgICAgICAgIGNvbnN0IHNldHNUb1Zpc2l0ID0gW25vZGVdO1xuICAgICAgICAgIGxldCBzZXQ7XG4gICAgICAgICAgd2hpbGUgKHNldCA9IHNldHNUb1Zpc2l0LnBvcCgpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZXQuc2VsZWN0aW9ucykge1xuICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmtpbmQgPT09IEtpbmQuRlJBR01FTlRfU1BSRUFEKSB7XG4gICAgICAgICAgICAgICAgc3ByZWFkcy5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgICAgIHNldHNUb1Zpc2l0LnB1c2goc2VsZWN0aW9uLnNlbGVjdGlvblNldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZnJhZ21lbnRTcHJlYWRzLnNldChub2RlLCBzcHJlYWRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ByZWFkcztcbiAgICAgIH1cbiAgICAgIGdldFJlY3Vyc2l2ZWx5UmVmZXJlbmNlZEZyYWdtZW50cyhvcGVyYXRpb24pIHtcbiAgICAgICAgbGV0IGZyYWdtZW50cyA9IHRoaXMuX3JlY3Vyc2l2ZWx5UmVmZXJlbmNlZEZyYWdtZW50cy5nZXQob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudHMpIHtcbiAgICAgICAgICBmcmFnbWVudHMgPSBbXTtcbiAgICAgICAgICBjb25zdCBjb2xsZWN0ZWROYW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGNvbnN0IG5vZGVzVG9WaXNpdCA9IFtvcGVyYXRpb24uc2VsZWN0aW9uU2V0XTtcbiAgICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgICB3aGlsZSAobm9kZSA9IG5vZGVzVG9WaXNpdC5wb3AoKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzcHJlYWQgb2YgdGhpcy5nZXRGcmFnbWVudFNwcmVhZHMobm9kZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgZnJhZ05hbWUgPSBzcHJlYWQubmFtZS52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGNvbGxlY3RlZE5hbWVzW2ZyYWdOYW1lXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3RlZE5hbWVzW2ZyYWdOYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KGZyYWdOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgIG5vZGVzVG9WaXNpdC5wdXNoKGZyYWdtZW50LnNlbGVjdGlvblNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZWx5UmVmZXJlbmNlZEZyYWdtZW50cy5zZXQob3BlcmF0aW9uLCBmcmFnbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgICB9XG4gICAgfTtcbiAgICBTRExWYWxpZGF0aW9uQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgQVNUVmFsaWRhdGlvbkNvbnRleHQge1xuICAgICAgY29uc3RydWN0b3IoYXN0LCBzY2hlbWEsIG9uRXJyb3IpIHtcbiAgICAgICAgc3VwZXIoYXN0LCBvbkVycm9yKTtcbiAgICAgICAgdGhpcy5fc2NoZW1hID0gc2NoZW1hO1xuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJTRExWYWxpZGF0aW9uQ29udGV4dFwiO1xuICAgICAgfVxuICAgICAgZ2V0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NoZW1hO1xuICAgICAgfVxuICAgIH07XG4gICAgVmFsaWRhdGlvbkNvbnRleHQgPSBjbGFzcyBleHRlbmRzIEFTVFZhbGlkYXRpb25Db250ZXh0IHtcbiAgICAgIGNvbnN0cnVjdG9yKHNjaGVtYSwgYXN0LCB0eXBlSW5mbywgb25FcnJvcikge1xuICAgICAgICBzdXBlcihhc3QsIG9uRXJyb3IpO1xuICAgICAgICB0aGlzLl9zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuX3R5cGVJbmZvID0gdHlwZUluZm87XG4gICAgICAgIHRoaXMuX3ZhcmlhYmxlVXNhZ2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlVmFyaWFibGVVc2FnZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJWYWxpZGF0aW9uQ29udGV4dFwiO1xuICAgICAgfVxuICAgICAgZ2V0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NoZW1hO1xuICAgICAgfVxuICAgICAgZ2V0VmFyaWFibGVVc2FnZXMobm9kZSkge1xuICAgICAgICBsZXQgdXNhZ2VzID0gdGhpcy5fdmFyaWFibGVVc2FnZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoIXVzYWdlcykge1xuICAgICAgICAgIGNvbnN0IG5ld1VzYWdlcyA9IFtdO1xuICAgICAgICAgIGNvbnN0IHR5cGVJbmZvID0gbmV3IFR5cGVJbmZvKHRoaXMuX3NjaGVtYSk7XG4gICAgICAgICAgdmlzaXQoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgdmlzaXRXaXRoVHlwZUluZm8odHlwZUluZm8sIHtcbiAgICAgICAgICAgICAgVmFyaWFibGVEZWZpbml0aW9uOiAoKSA9PiBmYWxzZSxcbiAgICAgICAgICAgICAgVmFyaWFibGUodmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICBuZXdVc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBub2RlOiB2YXJpYWJsZSxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVJbmZvLmdldElucHV0VHlwZSgpLFxuICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiB0eXBlSW5mby5nZXREZWZhdWx0VmFsdWUoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgdXNhZ2VzID0gbmV3VXNhZ2VzO1xuICAgICAgICAgIHRoaXMuX3ZhcmlhYmxlVXNhZ2VzLnNldChub2RlLCB1c2FnZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1c2FnZXM7XG4gICAgICB9XG4gICAgICBnZXRSZWN1cnNpdmVWYXJpYWJsZVVzYWdlcyhvcGVyYXRpb24pIHtcbiAgICAgICAgbGV0IHVzYWdlcyA9IHRoaXMuX3JlY3Vyc2l2ZVZhcmlhYmxlVXNhZ2VzLmdldChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoIXVzYWdlcykge1xuICAgICAgICAgIHVzYWdlcyA9IHRoaXMuZ2V0VmFyaWFibGVVc2FnZXMob3BlcmF0aW9uKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGZyYWcgb2YgdGhpcy5nZXRSZWN1cnNpdmVseVJlZmVyZW5jZWRGcmFnbWVudHMob3BlcmF0aW9uKSkge1xuICAgICAgICAgICAgdXNhZ2VzID0gdXNhZ2VzLmNvbmNhdCh0aGlzLmdldFZhcmlhYmxlVXNhZ2VzKGZyYWcpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcmVjdXJzaXZlVmFyaWFibGVVc2FnZXMuc2V0KG9wZXJhdGlvbiwgdXNhZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXNhZ2VzO1xuICAgICAgfVxuICAgICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGVJbmZvLmdldFR5cGUoKTtcbiAgICAgIH1cbiAgICAgIGdldFBhcmVudFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlSW5mby5nZXRQYXJlbnRUeXBlKCk7XG4gICAgICB9XG4gICAgICBnZXRJbnB1dFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlSW5mby5nZXRJbnB1dFR5cGUoKTtcbiAgICAgIH1cbiAgICAgIGdldFBhcmVudElucHV0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGVJbmZvLmdldFBhcmVudElucHV0VHlwZSgpO1xuICAgICAgfVxuICAgICAgZ2V0RmllbGREZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlSW5mby5nZXRGaWVsZERlZigpO1xuICAgICAgfVxuICAgICAgZ2V0RGlyZWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZUluZm8uZ2V0RGlyZWN0aXZlKCk7XG4gICAgICB9XG4gICAgICBnZXRBcmd1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGVJbmZvLmdldEFyZ3VtZW50KCk7XG4gICAgICB9XG4gICAgICBnZXRFbnVtVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlSW5mby5nZXRFbnVtVmFsdWUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi92YWxpZGF0ZS5tanNcbmZ1bmN0aW9uIHZhbGlkYXRlKHNjaGVtYSwgZG9jdW1lbnRBU1QsIHJ1bGVzID0gc3BlY2lmaWVkUnVsZXMsIG9wdGlvbnMsIHR5cGVJbmZvID0gbmV3IFR5cGVJbmZvKHNjaGVtYSkpIHtcbiAgdmFyIF9vcHRpb25zJG1heEVycm9ycztcbiAgY29uc3QgbWF4RXJyb3JzID0gKF9vcHRpb25zJG1heEVycm9ycyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXhFcnJvcnMpICE9PSBudWxsICYmIF9vcHRpb25zJG1heEVycm9ycyAhPT0gdm9pZCAwID8gX29wdGlvbnMkbWF4RXJyb3JzIDogMTAwO1xuICBkb2N1bWVudEFTVCB8fCBkZXZBc3NlcnQoZmFsc2UsIFwiTXVzdCBwcm92aWRlIGRvY3VtZW50LlwiKTtcbiAgYXNzZXJ0VmFsaWRTY2hlbWEoc2NoZW1hKTtcbiAgY29uc3QgYWJvcnRPYmogPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgY29uc3QgZXJyb3JzID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgVmFsaWRhdGlvbkNvbnRleHQoXG4gICAgc2NoZW1hLFxuICAgIGRvY3VtZW50QVNULFxuICAgIHR5cGVJbmZvLFxuICAgIChlcnJvcikgPT4ge1xuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPj0gbWF4RXJyb3JzKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICBcIlRvbyBtYW55IHZhbGlkYXRpb24gZXJyb3JzLCBlcnJvciBsaW1pdCByZWFjaGVkLiBWYWxpZGF0aW9uIGFib3J0ZWQuXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIHRocm93IGFib3J0T2JqO1xuICAgICAgfVxuICAgICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgIH1cbiAgKTtcbiAgY29uc3QgdmlzaXRvciA9IHZpc2l0SW5QYXJhbGxlbChydWxlcy5tYXAoKHJ1bGUpID0+IHJ1bGUoY29udGV4dCkpKTtcbiAgdHJ5IHtcbiAgICB2aXNpdChkb2N1bWVudEFTVCwgdmlzaXRXaXRoVHlwZUluZm8odHlwZUluZm8sIHZpc2l0b3IpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlICE9PSBhYm9ydE9iaikge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU0RMKGRvY3VtZW50QVNULCBzY2hlbWFUb0V4dGVuZCwgcnVsZXMgPSBzcGVjaWZpZWRTRExSdWxlcykge1xuICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgY29uc3QgY29udGV4dCA9IG5ldyBTRExWYWxpZGF0aW9uQ29udGV4dChcbiAgICBkb2N1bWVudEFTVCxcbiAgICBzY2hlbWFUb0V4dGVuZCxcbiAgICAoZXJyb3IpID0+IHtcbiAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICB9XG4gICk7XG4gIGNvbnN0IHZpc2l0b3JzID0gcnVsZXMubWFwKChydWxlKSA9PiBydWxlKGNvbnRleHQpKTtcbiAgdmlzaXQoZG9jdW1lbnRBU1QsIHZpc2l0SW5QYXJhbGxlbCh2aXNpdG9ycykpO1xuICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRTREwoZG9jdW1lbnRBU1QpIHtcbiAgY29uc3QgZXJyb3JzID0gdmFsaWRhdGVTREwoZG9jdW1lbnRBU1QpO1xuICBpZiAoZXJyb3JzLmxlbmd0aCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMubWFwKChlcnJvcikgPT4gZXJyb3IubWVzc2FnZSkuam9pbihcIlxcblxcblwiKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydFZhbGlkU0RMRXh0ZW5zaW9uKGRvY3VtZW50QVNULCBzY2hlbWEpIHtcbiAgY29uc3QgZXJyb3JzID0gdmFsaWRhdGVTREwoZG9jdW1lbnRBU1QsIHNjaGVtYSk7XG4gIGlmIChlcnJvcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5tYXAoKGVycm9yKSA9PiBlcnJvci5tZXNzYWdlKS5qb2luKFwiXFxuXFxuXCIpKTtcbiAgfVxufVxudmFyIGluaXRfdmFsaWRhdGUyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vdmFsaWRhdGUubWpzXCIoKSB7XG4gICAgaW5pdF9kZXZBc3NlcnQoKTtcbiAgICBpbml0X0dyYXBoUUxFcnJvcigpO1xuICAgIGluaXRfdmlzaXRvcigpO1xuICAgIGluaXRfdmFsaWRhdGUoKTtcbiAgICBpbml0X1R5cGVJbmZvKCk7XG4gICAgaW5pdF9zcGVjaWZpZWRSdWxlcygpO1xuICAgIGluaXRfVmFsaWRhdGlvbkNvbnRleHQoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvbWVtb2l6ZTMubWpzXG5mdW5jdGlvbiBtZW1vaXplMyhmbikge1xuICBsZXQgY2FjaGUwO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb2l6ZWQoYTEsIGEyLCBhMykge1xuICAgIGlmIChjYWNoZTAgPT09IHZvaWQgMCkge1xuICAgICAgY2FjaGUwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgfVxuICAgIGxldCBjYWNoZTEgPSBjYWNoZTAuZ2V0KGExKTtcbiAgICBpZiAoY2FjaGUxID09PSB2b2lkIDApIHtcbiAgICAgIGNhY2hlMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgY2FjaGUwLnNldChhMSwgY2FjaGUxKTtcbiAgICB9XG4gICAgbGV0IGNhY2hlMiA9IGNhY2hlMS5nZXQoYTIpO1xuICAgIGlmIChjYWNoZTIgPT09IHZvaWQgMCkge1xuICAgICAgY2FjaGUyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICBjYWNoZTEuc2V0KGEyLCBjYWNoZTIpO1xuICAgIH1cbiAgICBsZXQgZm5SZXN1bHQgPSBjYWNoZTIuZ2V0KGEzKTtcbiAgICBpZiAoZm5SZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgZm5SZXN1bHQgPSBmbihhMSwgYTIsIGEzKTtcbiAgICAgIGNhY2hlMi5zZXQoYTMsIGZuUmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZuUmVzdWx0O1xuICB9O1xufVxudmFyIGluaXRfbWVtb2l6ZTMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9tZW1vaXplMy5tanNcIigpIHtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvcHJvbWlzZUZvck9iamVjdC5tanNcbmZ1bmN0aW9uIHByb21pc2VGb3JPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChPYmplY3QudmFsdWVzKG9iamVjdCkpLnRoZW4oKHJlc29sdmVkVmFsdWVzKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRPYmplY3QgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGNvbnN0IFtpLCBrZXldIG9mIE9iamVjdC5rZXlzKG9iamVjdCkuZW50cmllcygpKSB7XG4gICAgICByZXNvbHZlZE9iamVjdFtrZXldID0gcmVzb2x2ZWRWYWx1ZXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZE9iamVjdDtcbiAgfSk7XG59XG52YXIgaW5pdF9wcm9taXNlRm9yT2JqZWN0ID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvcHJvbWlzZUZvck9iamVjdC5tanNcIigpIHtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvcHJvbWlzZVJlZHVjZS5tanNcbmZ1bmN0aW9uIHByb21pc2VSZWR1Y2UodmFsdWVzLCBjYWxsYmFja0ZuLCBpbml0aWFsVmFsdWUpIHtcbiAgbGV0IGFjY3VtdWxhdG9yID0gaW5pdGlhbFZhbHVlO1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIGFjY3VtdWxhdG9yID0gaXNQcm9taXNlKGFjY3VtdWxhdG9yKSA/IGFjY3VtdWxhdG9yLnRoZW4oKHJlc29sdmVkKSA9PiBjYWxsYmFja0ZuKHJlc29sdmVkLCB2YWx1ZSkpIDogY2FsbGJhY2tGbihhY2N1bXVsYXRvciwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cbnZhciBpbml0X3Byb21pc2VSZWR1Y2UgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9wcm9taXNlUmVkdWNlLm1qc1wiKCkge1xuICAgIGluaXRfaXNQcm9taXNlKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL3RvRXJyb3IubWpzXG5mdW5jdGlvbiB0b0Vycm9yKHRocm93blZhbHVlKSB7XG4gIHJldHVybiB0aHJvd25WYWx1ZSBpbnN0YW5jZW9mIEVycm9yID8gdGhyb3duVmFsdWUgOiBuZXcgTm9uRXJyb3JUaHJvd24odGhyb3duVmFsdWUpO1xufVxudmFyIE5vbkVycm9yVGhyb3duO1xudmFyIGluaXRfdG9FcnJvciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL3RvRXJyb3IubWpzXCIoKSB7XG4gICAgaW5pdF9pbnNwZWN0KCk7XG4gICAgTm9uRXJyb3JUaHJvd24gPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKHRocm93blZhbHVlKSB7XG4gICAgICAgIHN1cGVyKFwiVW5leHBlY3RlZCBlcnJvciB2YWx1ZTogXCIgKyBpbnNwZWN0KHRocm93blZhbHVlKSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTm9uRXJyb3JUaHJvd25cIjtcbiAgICAgICAgdGhpcy50aHJvd25WYWx1ZSA9IHRocm93blZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9lcnJvci9sb2NhdGVkRXJyb3IubWpzXG5mdW5jdGlvbiBsb2NhdGVkRXJyb3IocmF3T3JpZ2luYWxFcnJvciwgbm9kZXMsIHBhdGgpIHtcbiAgdmFyIF9ub2RlcztcbiAgY29uc3Qgb3JpZ2luYWxFcnJvciA9IHRvRXJyb3IocmF3T3JpZ2luYWxFcnJvcik7XG4gIGlmIChpc0xvY2F0ZWRHcmFwaFFMRXJyb3Iob3JpZ2luYWxFcnJvcikpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxFcnJvcjtcbiAgfVxuICByZXR1cm4gbmV3IEdyYXBoUUxFcnJvcihvcmlnaW5hbEVycm9yLm1lc3NhZ2UsIHtcbiAgICBub2RlczogKF9ub2RlcyA9IG9yaWdpbmFsRXJyb3Iubm9kZXMpICE9PSBudWxsICYmIF9ub2RlcyAhPT0gdm9pZCAwID8gX25vZGVzIDogbm9kZXMsXG4gICAgc291cmNlOiBvcmlnaW5hbEVycm9yLnNvdXJjZSxcbiAgICBwb3NpdGlvbnM6IG9yaWdpbmFsRXJyb3IucG9zaXRpb25zLFxuICAgIHBhdGgsXG4gICAgb3JpZ2luYWxFcnJvclxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzTG9jYXRlZEdyYXBoUUxFcnJvcihlcnJvcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShlcnJvci5wYXRoKTtcbn1cbnZhciBpbml0X2xvY2F0ZWRFcnJvciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC9lcnJvci9sb2NhdGVkRXJyb3IubWpzXCIoKSB7XG4gICAgaW5pdF90b0Vycm9yKCk7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2V4ZWN1dGlvbi9leGVjdXRlLm1qc1xuZnVuY3Rpb24gZXhlY3V0ZShhcmdzKSB7XG4gIGFyZ3VtZW50cy5sZW5ndGggPCAyIHx8IGRldkFzc2VydChcbiAgICBmYWxzZSxcbiAgICBcImdyYXBocWxAMTYgZHJvcHBlZCBsb25nLWRlcHJlY2F0ZWQgc3VwcG9ydCBmb3IgcG9zaXRpb25hbCBhcmd1bWVudHMsIHBsZWFzZSBwYXNzIGFuIG9iamVjdCBpbnN0ZWFkLlwiXG4gICk7XG4gIGNvbnN0IHsgc2NoZW1hLCBkb2N1bWVudCwgdmFyaWFibGVWYWx1ZXMsIHJvb3RWYWx1ZSB9ID0gYXJncztcbiAgYXNzZXJ0VmFsaWRFeGVjdXRpb25Bcmd1bWVudHMoc2NoZW1hLCBkb2N1bWVudCwgdmFyaWFibGVWYWx1ZXMpO1xuICBjb25zdCBleGVDb250ZXh0ID0gYnVpbGRFeGVjdXRpb25Db250ZXh0KGFyZ3MpO1xuICBpZiAoIShcInNjaGVtYVwiIGluIGV4ZUNvbnRleHQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yczogZXhlQ29udGV4dFxuICAgIH07XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCB7IG9wZXJhdGlvbiB9ID0gZXhlQ29udGV4dDtcbiAgICBjb25zdCByZXN1bHQgPSBleGVjdXRlT3BlcmF0aW9uKGV4ZUNvbnRleHQsIG9wZXJhdGlvbiwgcm9vdFZhbHVlKTtcbiAgICBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQudGhlbihcbiAgICAgICAgKGRhdGEpID0+IGJ1aWxkUmVzcG9uc2UoZGF0YSwgZXhlQ29udGV4dC5lcnJvcnMpLFxuICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICBleGVDb250ZXh0LmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICByZXR1cm4gYnVpbGRSZXNwb25zZShudWxsLCBleGVDb250ZXh0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBidWlsZFJlc3BvbnNlKHJlc3VsdCwgZXhlQ29udGV4dC5lcnJvcnMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGV4ZUNvbnRleHQuZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgIHJldHVybiBidWlsZFJlc3BvbnNlKG51bGwsIGV4ZUNvbnRleHQuZXJyb3JzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXhlY3V0ZVN5bmMoYXJncykge1xuICBjb25zdCByZXN1bHQgPSBleGVjdXRlKGFyZ3MpO1xuICBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJHcmFwaFFMIGV4ZWN1dGlvbiBmYWlsZWQgdG8gY29tcGxldGUgc3luY2hyb25vdXNseS5cIik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGJ1aWxkUmVzcG9uc2UoZGF0YSwgZXJyb3JzKSB7XG4gIHJldHVybiBlcnJvcnMubGVuZ3RoID09PSAwID8ge1xuICAgIGRhdGFcbiAgfSA6IHtcbiAgICBlcnJvcnMsXG4gICAgZGF0YVxuICB9O1xufVxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRFeGVjdXRpb25Bcmd1bWVudHMoc2NoZW1hLCBkb2N1bWVudCwgcmF3VmFyaWFibGVWYWx1ZXMpIHtcbiAgZG9jdW1lbnQgfHwgZGV2QXNzZXJ0KGZhbHNlLCBcIk11c3QgcHJvdmlkZSBkb2N1bWVudC5cIik7XG4gIGFzc2VydFZhbGlkU2NoZW1hKHNjaGVtYSk7XG4gIHJhd1ZhcmlhYmxlVmFsdWVzID09IG51bGwgfHwgaXNPYmplY3RMaWtlKHJhd1ZhcmlhYmxlVmFsdWVzKSB8fCBkZXZBc3NlcnQoXG4gICAgZmFsc2UsXG4gICAgXCJWYXJpYWJsZXMgbXVzdCBiZSBwcm92aWRlZCBhcyBhbiBPYmplY3Qgd2hlcmUgZWFjaCBwcm9wZXJ0eSBpcyBhIHZhcmlhYmxlIHZhbHVlLiBQZXJoYXBzIGxvb2sgdG8gc2VlIGlmIGFuIHVucGFyc2VkIEpTT04gc3RyaW5nIHdhcyBwcm92aWRlZC5cIlxuICApO1xufVxuZnVuY3Rpb24gYnVpbGRFeGVjdXRpb25Db250ZXh0KGFyZ3MpIHtcbiAgdmFyIF9kZWZpbml0aW9uJG5hbWUsIF9vcGVyYXRpb24kdmFyaWFibGVEZTtcbiAgY29uc3Qge1xuICAgIHNjaGVtYSxcbiAgICBkb2N1bWVudCxcbiAgICByb290VmFsdWUsXG4gICAgY29udGV4dFZhbHVlLFxuICAgIHZhcmlhYmxlVmFsdWVzOiByYXdWYXJpYWJsZVZhbHVlcyxcbiAgICBvcGVyYXRpb25OYW1lLFxuICAgIGZpZWxkUmVzb2x2ZXIsXG4gICAgdHlwZVJlc29sdmVyLFxuICAgIHN1YnNjcmliZUZpZWxkUmVzb2x2ZXJcbiAgfSA9IGFyZ3M7XG4gIGxldCBvcGVyYXRpb247XG4gIGNvbnN0IGZyYWdtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IGRlZmluaXRpb24gb2YgZG9jdW1lbnQuZGVmaW5pdGlvbnMpIHtcbiAgICBzd2l0Y2ggKGRlZmluaXRpb24ua2luZCkge1xuICAgICAgY2FzZSBLaW5kLk9QRVJBVElPTl9ERUZJTklUSU9OOlxuICAgICAgICBpZiAob3BlcmF0aW9uTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKG9wZXJhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgICAgIFwiTXVzdCBwcm92aWRlIG9wZXJhdGlvbiBuYW1lIGlmIHF1ZXJ5IGNvbnRhaW5zIG11bHRpcGxlIG9wZXJhdGlvbnMuXCJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BlcmF0aW9uID0gZGVmaW5pdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICgoKF9kZWZpbml0aW9uJG5hbWUgPSBkZWZpbml0aW9uLm5hbWUpID09PSBudWxsIHx8IF9kZWZpbml0aW9uJG5hbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kZWZpbml0aW9uJG5hbWUudmFsdWUpID09PSBvcGVyYXRpb25OYW1lKSB7XG4gICAgICAgICAgb3BlcmF0aW9uID0gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS2luZC5GUkFHTUVOVF9ERUZJTklUSU9OOlxuICAgICAgICBmcmFnbWVudHNbZGVmaW5pdGlvbi5uYW1lLnZhbHVlXSA9IGRlZmluaXRpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cbiAgaWYgKCFvcGVyYXRpb24pIHtcbiAgICBpZiAob3BlcmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gW25ldyBHcmFwaFFMRXJyb3IoYFVua25vd24gb3BlcmF0aW9uIG5hbWVkIFwiJHtvcGVyYXRpb25OYW1lfVwiLmApXTtcbiAgICB9XG4gICAgcmV0dXJuIFtuZXcgR3JhcGhRTEVycm9yKFwiTXVzdCBwcm92aWRlIGFuIG9wZXJhdGlvbi5cIildO1xuICB9XG4gIGNvbnN0IHZhcmlhYmxlRGVmaW5pdGlvbnMgPSAoX29wZXJhdGlvbiR2YXJpYWJsZURlID0gb3BlcmF0aW9uLnZhcmlhYmxlRGVmaW5pdGlvbnMpICE9PSBudWxsICYmIF9vcGVyYXRpb24kdmFyaWFibGVEZSAhPT0gdm9pZCAwID8gX29wZXJhdGlvbiR2YXJpYWJsZURlIDogW107XG4gIGNvbnN0IGNvZXJjZWRWYXJpYWJsZVZhbHVlcyA9IGdldFZhcmlhYmxlVmFsdWVzKFxuICAgIHNjaGVtYSxcbiAgICB2YXJpYWJsZURlZmluaXRpb25zLFxuICAgIHJhd1ZhcmlhYmxlVmFsdWVzICE9PSBudWxsICYmIHJhd1ZhcmlhYmxlVmFsdWVzICE9PSB2b2lkIDAgPyByYXdWYXJpYWJsZVZhbHVlcyA6IHt9LFxuICAgIHtcbiAgICAgIG1heEVycm9yczogNTBcbiAgICB9XG4gICk7XG4gIGlmIChjb2VyY2VkVmFyaWFibGVWYWx1ZXMuZXJyb3JzKSB7XG4gICAgcmV0dXJuIGNvZXJjZWRWYXJpYWJsZVZhbHVlcy5lcnJvcnM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWEsXG4gICAgZnJhZ21lbnRzLFxuICAgIHJvb3RWYWx1ZSxcbiAgICBjb250ZXh0VmFsdWUsXG4gICAgb3BlcmF0aW9uLFxuICAgIHZhcmlhYmxlVmFsdWVzOiBjb2VyY2VkVmFyaWFibGVWYWx1ZXMuY29lcmNlZCxcbiAgICBmaWVsZFJlc29sdmVyOiBmaWVsZFJlc29sdmVyICE9PSBudWxsICYmIGZpZWxkUmVzb2x2ZXIgIT09IHZvaWQgMCA/IGZpZWxkUmVzb2x2ZXIgOiBkZWZhdWx0RmllbGRSZXNvbHZlcixcbiAgICB0eXBlUmVzb2x2ZXI6IHR5cGVSZXNvbHZlciAhPT0gbnVsbCAmJiB0eXBlUmVzb2x2ZXIgIT09IHZvaWQgMCA/IHR5cGVSZXNvbHZlciA6IGRlZmF1bHRUeXBlUmVzb2x2ZXIsXG4gICAgc3Vic2NyaWJlRmllbGRSZXNvbHZlcjogc3Vic2NyaWJlRmllbGRSZXNvbHZlciAhPT0gbnVsbCAmJiBzdWJzY3JpYmVGaWVsZFJlc29sdmVyICE9PSB2b2lkIDAgPyBzdWJzY3JpYmVGaWVsZFJlc29sdmVyIDogZGVmYXVsdEZpZWxkUmVzb2x2ZXIsXG4gICAgZXJyb3JzOiBbXVxuICB9O1xufVxuZnVuY3Rpb24gZXhlY3V0ZU9wZXJhdGlvbihleGVDb250ZXh0LCBvcGVyYXRpb24sIHJvb3RWYWx1ZSkge1xuICBjb25zdCByb290VHlwZSA9IGV4ZUNvbnRleHQuc2NoZW1hLmdldFJvb3RUeXBlKG9wZXJhdGlvbi5vcGVyYXRpb24pO1xuICBpZiAocm9vdFR5cGUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICBgU2NoZW1hIGlzIG5vdCBjb25maWd1cmVkIHRvIGV4ZWN1dGUgJHtvcGVyYXRpb24ub3BlcmF0aW9ufSBvcGVyYXRpb24uYCxcbiAgICAgIHtcbiAgICAgICAgbm9kZXM6IG9wZXJhdGlvblxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgY29uc3Qgcm9vdEZpZWxkcyA9IGNvbGxlY3RGaWVsZHMoXG4gICAgZXhlQ29udGV4dC5zY2hlbWEsXG4gICAgZXhlQ29udGV4dC5mcmFnbWVudHMsXG4gICAgZXhlQ29udGV4dC52YXJpYWJsZVZhbHVlcyxcbiAgICByb290VHlwZSxcbiAgICBvcGVyYXRpb24uc2VsZWN0aW9uU2V0XG4gICk7XG4gIGNvbnN0IHBhdGggPSB2b2lkIDA7XG4gIHN3aXRjaCAob3BlcmF0aW9uLm9wZXJhdGlvbikge1xuICAgIGNhc2UgT3BlcmF0aW9uVHlwZU5vZGUuUVVFUlk6XG4gICAgICByZXR1cm4gZXhlY3V0ZUZpZWxkcyhleGVDb250ZXh0LCByb290VHlwZSwgcm9vdFZhbHVlLCBwYXRoLCByb290RmllbGRzKTtcbiAgICBjYXNlIE9wZXJhdGlvblR5cGVOb2RlLk1VVEFUSU9OOlxuICAgICAgcmV0dXJuIGV4ZWN1dGVGaWVsZHNTZXJpYWxseShcbiAgICAgICAgZXhlQ29udGV4dCxcbiAgICAgICAgcm9vdFR5cGUsXG4gICAgICAgIHJvb3RWYWx1ZSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgcm9vdEZpZWxkc1xuICAgICAgKTtcbiAgICBjYXNlIE9wZXJhdGlvblR5cGVOb2RlLlNVQlNDUklQVElPTjpcbiAgICAgIHJldHVybiBleGVjdXRlRmllbGRzKGV4ZUNvbnRleHQsIHJvb3RUeXBlLCByb290VmFsdWUsIHBhdGgsIHJvb3RGaWVsZHMpO1xuICB9XG59XG5mdW5jdGlvbiBleGVjdXRlRmllbGRzU2VyaWFsbHkoZXhlQ29udGV4dCwgcGFyZW50VHlwZSwgc291cmNlVmFsdWUsIHBhdGgsIGZpZWxkcykge1xuICByZXR1cm4gcHJvbWlzZVJlZHVjZShcbiAgICBmaWVsZHMuZW50cmllcygpLFxuICAgIChyZXN1bHRzLCBbcmVzcG9uc2VOYW1lLCBmaWVsZE5vZGVzXSkgPT4ge1xuICAgICAgY29uc3QgZmllbGRQYXRoID0gYWRkUGF0aChwYXRoLCByZXNwb25zZU5hbWUsIHBhcmVudFR5cGUubmFtZSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBleGVjdXRlRmllbGQoXG4gICAgICAgIGV4ZUNvbnRleHQsXG4gICAgICAgIHBhcmVudFR5cGUsXG4gICAgICAgIHNvdXJjZVZhbHVlLFxuICAgICAgICBmaWVsZE5vZGVzLFxuICAgICAgICBmaWVsZFBhdGhcbiAgICAgICk7XG4gICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXNvbHZlZFJlc3VsdCkgPT4ge1xuICAgICAgICAgIHJlc3VsdHNbcmVzcG9uc2VOYW1lXSA9IHJlc29sdmVkUmVzdWx0O1xuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdHNbcmVzcG9uc2VOYW1lXSA9IHJlc3VsdDtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbClcbiAgKTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVGaWVsZHMoZXhlQ29udGV4dCwgcGFyZW50VHlwZSwgc291cmNlVmFsdWUsIHBhdGgsIGZpZWxkcykge1xuICBjb25zdCByZXN1bHRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBjb250YWluc1Byb21pc2UgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBmb3IgKGNvbnN0IFtyZXNwb25zZU5hbWUsIGZpZWxkTm9kZXNdIG9mIGZpZWxkcy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IGZpZWxkUGF0aCA9IGFkZFBhdGgocGF0aCwgcmVzcG9uc2VOYW1lLCBwYXJlbnRUeXBlLm5hbWUpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXhlY3V0ZUZpZWxkKFxuICAgICAgICBleGVDb250ZXh0LFxuICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICBzb3VyY2VWYWx1ZSxcbiAgICAgICAgZmllbGROb2RlcyxcbiAgICAgICAgZmllbGRQYXRoXG4gICAgICApO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJlc3VsdHNbcmVzcG9uc2VOYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgY29udGFpbnNQcm9taXNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoY29udGFpbnNQcm9taXNlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZUZvck9iamVjdChyZXN1bHRzKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYgKCFjb250YWluc1Byb21pc2UpIHtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICByZXR1cm4gcHJvbWlzZUZvck9iamVjdChyZXN1bHRzKTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVGaWVsZChleGVDb250ZXh0LCBwYXJlbnRUeXBlLCBzb3VyY2UsIGZpZWxkTm9kZXMsIHBhdGgpIHtcbiAgdmFyIF9maWVsZERlZiRyZXNvbHZlO1xuICBjb25zdCBmaWVsZERlZiA9IGdldEZpZWxkRGVmMihleGVDb250ZXh0LnNjaGVtYSwgcGFyZW50VHlwZSwgZmllbGROb2Rlc1swXSk7XG4gIGlmICghZmllbGREZWYpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmV0dXJuVHlwZSA9IGZpZWxkRGVmLnR5cGU7XG4gIGNvbnN0IHJlc29sdmVGbiA9IChfZmllbGREZWYkcmVzb2x2ZSA9IGZpZWxkRGVmLnJlc29sdmUpICE9PSBudWxsICYmIF9maWVsZERlZiRyZXNvbHZlICE9PSB2b2lkIDAgPyBfZmllbGREZWYkcmVzb2x2ZSA6IGV4ZUNvbnRleHQuZmllbGRSZXNvbHZlcjtcbiAgY29uc3QgaW5mbyA9IGJ1aWxkUmVzb2x2ZUluZm8oXG4gICAgZXhlQ29udGV4dCxcbiAgICBmaWVsZERlZixcbiAgICBmaWVsZE5vZGVzLFxuICAgIHBhcmVudFR5cGUsXG4gICAgcGF0aFxuICApO1xuICB0cnkge1xuICAgIGNvbnN0IGFyZ3MgPSBnZXRBcmd1bWVudFZhbHVlcyhcbiAgICAgIGZpZWxkRGVmLFxuICAgICAgZmllbGROb2Rlc1swXSxcbiAgICAgIGV4ZUNvbnRleHQudmFyaWFibGVWYWx1ZXNcbiAgICApO1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IGV4ZUNvbnRleHQuY29udGV4dFZhbHVlO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJlc29sdmVGbihzb3VyY2UsIGFyZ3MsIGNvbnRleHRWYWx1ZSwgaW5mbyk7XG4gICAgbGV0IGNvbXBsZXRlZDtcbiAgICBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgIGNvbXBsZXRlZCA9IHJlc3VsdC50aGVuKFxuICAgICAgICAocmVzb2x2ZWQpID0+IGNvbXBsZXRlVmFsdWUoZXhlQ29udGV4dCwgcmV0dXJuVHlwZSwgZmllbGROb2RlcywgaW5mbywgcGF0aCwgcmVzb2x2ZWQpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wbGV0ZWQgPSBjb21wbGV0ZVZhbHVlKFxuICAgICAgICBleGVDb250ZXh0LFxuICAgICAgICByZXR1cm5UeXBlLFxuICAgICAgICBmaWVsZE5vZGVzLFxuICAgICAgICBpbmZvLFxuICAgICAgICBwYXRoLFxuICAgICAgICByZXN1bHRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc1Byb21pc2UoY29tcGxldGVkKSkge1xuICAgICAgcmV0dXJuIGNvbXBsZXRlZC50aGVuKHZvaWQgMCwgKHJhd0Vycm9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbG9jYXRlZEVycm9yKHJhd0Vycm9yLCBmaWVsZE5vZGVzLCBwYXRoVG9BcnJheShwYXRoKSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVGaWVsZEVycm9yKGVycm9yLCByZXR1cm5UeXBlLCBleGVDb250ZXh0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGxldGVkO1xuICB9IGNhdGNoIChyYXdFcnJvcikge1xuICAgIGNvbnN0IGVycm9yID0gbG9jYXRlZEVycm9yKHJhd0Vycm9yLCBmaWVsZE5vZGVzLCBwYXRoVG9BcnJheShwYXRoKSk7XG4gICAgcmV0dXJuIGhhbmRsZUZpZWxkRXJyb3IoZXJyb3IsIHJldHVyblR5cGUsIGV4ZUNvbnRleHQpO1xuICB9XG59XG5mdW5jdGlvbiBidWlsZFJlc29sdmVJbmZvKGV4ZUNvbnRleHQsIGZpZWxkRGVmLCBmaWVsZE5vZGVzLCBwYXJlbnRUeXBlLCBwYXRoKSB7XG4gIHJldHVybiB7XG4gICAgZmllbGROYW1lOiBmaWVsZERlZi5uYW1lLFxuICAgIGZpZWxkTm9kZXMsXG4gICAgcmV0dXJuVHlwZTogZmllbGREZWYudHlwZSxcbiAgICBwYXJlbnRUeXBlLFxuICAgIHBhdGgsXG4gICAgc2NoZW1hOiBleGVDb250ZXh0LnNjaGVtYSxcbiAgICBmcmFnbWVudHM6IGV4ZUNvbnRleHQuZnJhZ21lbnRzLFxuICAgIHJvb3RWYWx1ZTogZXhlQ29udGV4dC5yb290VmFsdWUsXG4gICAgb3BlcmF0aW9uOiBleGVDb250ZXh0Lm9wZXJhdGlvbixcbiAgICB2YXJpYWJsZVZhbHVlczogZXhlQ29udGV4dC52YXJpYWJsZVZhbHVlc1xuICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlRmllbGRFcnJvcihlcnJvciwgcmV0dXJuVHlwZSwgZXhlQ29udGV4dCkge1xuICBpZiAoaXNOb25OdWxsVHlwZShyZXR1cm5UeXBlKSkge1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGV4ZUNvbnRleHQuZXJyb3JzLnB1c2goZXJyb3IpO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlVmFsdWUoZXhlQ29udGV4dCwgcmV0dXJuVHlwZSwgZmllbGROb2RlcywgaW5mbywgcGF0aCwgcmVzdWx0KSB7XG4gIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHRocm93IHJlc3VsdDtcbiAgfVxuICBpZiAoaXNOb25OdWxsVHlwZShyZXR1cm5UeXBlKSkge1xuICAgIGNvbnN0IGNvbXBsZXRlZCA9IGNvbXBsZXRlVmFsdWUoXG4gICAgICBleGVDb250ZXh0LFxuICAgICAgcmV0dXJuVHlwZS5vZlR5cGUsXG4gICAgICBmaWVsZE5vZGVzLFxuICAgICAgaW5mbyxcbiAgICAgIHBhdGgsXG4gICAgICByZXN1bHRcbiAgICApO1xuICAgIGlmIChjb21wbGV0ZWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCByZXR1cm4gbnVsbCBmb3Igbm9uLW51bGxhYmxlIGZpZWxkICR7aW5mby5wYXJlbnRUeXBlLm5hbWV9LiR7aW5mby5maWVsZE5hbWV9LmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb21wbGV0ZWQ7XG4gIH1cbiAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzTGlzdFR5cGUocmV0dXJuVHlwZSkpIHtcbiAgICByZXR1cm4gY29tcGxldGVMaXN0VmFsdWUoXG4gICAgICBleGVDb250ZXh0LFxuICAgICAgcmV0dXJuVHlwZSxcbiAgICAgIGZpZWxkTm9kZXMsXG4gICAgICBpbmZvLFxuICAgICAgcGF0aCxcbiAgICAgIHJlc3VsdFxuICAgICk7XG4gIH1cbiAgaWYgKGlzTGVhZlR5cGUocmV0dXJuVHlwZSkpIHtcbiAgICByZXR1cm4gY29tcGxldGVMZWFmVmFsdWUocmV0dXJuVHlwZSwgcmVzdWx0KTtcbiAgfVxuICBpZiAoaXNBYnN0cmFjdFR5cGUocmV0dXJuVHlwZSkpIHtcbiAgICByZXR1cm4gY29tcGxldGVBYnN0cmFjdFZhbHVlKFxuICAgICAgZXhlQ29udGV4dCxcbiAgICAgIHJldHVyblR5cGUsXG4gICAgICBmaWVsZE5vZGVzLFxuICAgICAgaW5mbyxcbiAgICAgIHBhdGgsXG4gICAgICByZXN1bHRcbiAgICApO1xuICB9XG4gIGlmIChpc09iamVjdFR5cGUocmV0dXJuVHlwZSkpIHtcbiAgICByZXR1cm4gY29tcGxldGVPYmplY3RWYWx1ZShcbiAgICAgIGV4ZUNvbnRleHQsXG4gICAgICByZXR1cm5UeXBlLFxuICAgICAgZmllbGROb2RlcyxcbiAgICAgIGluZm8sXG4gICAgICBwYXRoLFxuICAgICAgcmVzdWx0XG4gICAgKTtcbiAgfVxuICBpbnZhcmlhbnQoXG4gICAgZmFsc2UsXG4gICAgXCJDYW5ub3QgY29tcGxldGUgdmFsdWUgb2YgdW5leHBlY3RlZCBvdXRwdXQgdHlwZTogXCIgKyBpbnNwZWN0KHJldHVyblR5cGUpXG4gICk7XG59XG5mdW5jdGlvbiBjb21wbGV0ZUxpc3RWYWx1ZShleGVDb250ZXh0LCByZXR1cm5UeXBlLCBmaWVsZE5vZGVzLCBpbmZvLCBwYXRoLCByZXN1bHQpIHtcbiAgaWYgKCFpc0l0ZXJhYmxlT2JqZWN0KHJlc3VsdCkpIHtcbiAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgYEV4cGVjdGVkIEl0ZXJhYmxlLCBidXQgZGlkIG5vdCBmaW5kIG9uZSBmb3IgZmllbGQgXCIke2luZm8ucGFyZW50VHlwZS5uYW1lfS4ke2luZm8uZmllbGROYW1lfVwiLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IGl0ZW1UeXBlID0gcmV0dXJuVHlwZS5vZlR5cGU7XG4gIGxldCBjb250YWluc1Byb21pc2UgPSBmYWxzZTtcbiAgY29uc3QgY29tcGxldGVkUmVzdWx0cyA9IEFycmF5LmZyb20ocmVzdWx0LCAoaXRlbSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBpdGVtUGF0aCA9IGFkZFBhdGgocGF0aCwgaW5kZXgsIHZvaWQgMCk7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb21wbGV0ZWRJdGVtO1xuICAgICAgaWYgKGlzUHJvbWlzZShpdGVtKSkge1xuICAgICAgICBjb21wbGV0ZWRJdGVtID0gaXRlbS50aGVuKFxuICAgICAgICAgIChyZXNvbHZlZCkgPT4gY29tcGxldGVWYWx1ZShcbiAgICAgICAgICAgIGV4ZUNvbnRleHQsXG4gICAgICAgICAgICBpdGVtVHlwZSxcbiAgICAgICAgICAgIGZpZWxkTm9kZXMsXG4gICAgICAgICAgICBpbmZvLFxuICAgICAgICAgICAgaXRlbVBhdGgsXG4gICAgICAgICAgICByZXNvbHZlZFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBsZXRlZEl0ZW0gPSBjb21wbGV0ZVZhbHVlKFxuICAgICAgICAgIGV4ZUNvbnRleHQsXG4gICAgICAgICAgaXRlbVR5cGUsXG4gICAgICAgICAgZmllbGROb2RlcyxcbiAgICAgICAgICBpbmZvLFxuICAgICAgICAgIGl0ZW1QYXRoLFxuICAgICAgICAgIGl0ZW1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Byb21pc2UoY29tcGxldGVkSXRlbSkpIHtcbiAgICAgICAgY29udGFpbnNQcm9taXNlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlZEl0ZW0udGhlbih2b2lkIDAsIChyYXdFcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbG9jYXRlZEVycm9yKFxuICAgICAgICAgICAgcmF3RXJyb3IsXG4gICAgICAgICAgICBmaWVsZE5vZGVzLFxuICAgICAgICAgICAgcGF0aFRvQXJyYXkoaXRlbVBhdGgpXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRmllbGRFcnJvcihlcnJvciwgaXRlbVR5cGUsIGV4ZUNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wbGV0ZWRJdGVtO1xuICAgIH0gY2F0Y2ggKHJhd0Vycm9yKSB7XG4gICAgICBjb25zdCBlcnJvciA9IGxvY2F0ZWRFcnJvcihyYXdFcnJvciwgZmllbGROb2RlcywgcGF0aFRvQXJyYXkoaXRlbVBhdGgpKTtcbiAgICAgIHJldHVybiBoYW5kbGVGaWVsZEVycm9yKGVycm9yLCBpdGVtVHlwZSwgZXhlQ29udGV4dCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNvbnRhaW5zUHJvbWlzZSA/IFByb21pc2UuYWxsKGNvbXBsZXRlZFJlc3VsdHMpIDogY29tcGxldGVkUmVzdWx0cztcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlTGVhZlZhbHVlKHJldHVyblR5cGUsIHJlc3VsdCkge1xuICBjb25zdCBzZXJpYWxpemVkUmVzdWx0ID0gcmV0dXJuVHlwZS5zZXJpYWxpemUocmVzdWx0KTtcbiAgaWYgKHNlcmlhbGl6ZWRSZXN1bHQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBcXGAke2luc3BlY3QocmV0dXJuVHlwZSl9LnNlcmlhbGl6ZSgke2luc3BlY3QocmVzdWx0KX0pXFxgIHRvIHJldHVybiBub24tbnVsbGFibGUgdmFsdWUsIHJldHVybmVkOiAke2luc3BlY3Qoc2VyaWFsaXplZFJlc3VsdCl9YFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWRSZXN1bHQ7XG59XG5mdW5jdGlvbiBjb21wbGV0ZUFic3RyYWN0VmFsdWUoZXhlQ29udGV4dCwgcmV0dXJuVHlwZSwgZmllbGROb2RlcywgaW5mbywgcGF0aCwgcmVzdWx0KSB7XG4gIHZhciBfcmV0dXJuVHlwZSRyZXNvbHZlVHk7XG4gIGNvbnN0IHJlc29sdmVUeXBlRm4gPSAoX3JldHVyblR5cGUkcmVzb2x2ZVR5ID0gcmV0dXJuVHlwZS5yZXNvbHZlVHlwZSkgIT09IG51bGwgJiYgX3JldHVyblR5cGUkcmVzb2x2ZVR5ICE9PSB2b2lkIDAgPyBfcmV0dXJuVHlwZSRyZXNvbHZlVHkgOiBleGVDb250ZXh0LnR5cGVSZXNvbHZlcjtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gZXhlQ29udGV4dC5jb250ZXh0VmFsdWU7XG4gIGNvbnN0IHJ1bnRpbWVUeXBlID0gcmVzb2x2ZVR5cGVGbihyZXN1bHQsIGNvbnRleHRWYWx1ZSwgaW5mbywgcmV0dXJuVHlwZSk7XG4gIGlmIChpc1Byb21pc2UocnVudGltZVR5cGUpKSB7XG4gICAgcmV0dXJuIHJ1bnRpbWVUeXBlLnRoZW4oXG4gICAgICAocmVzb2x2ZWRSdW50aW1lVHlwZSkgPT4gY29tcGxldGVPYmplY3RWYWx1ZShcbiAgICAgICAgZXhlQ29udGV4dCxcbiAgICAgICAgZW5zdXJlVmFsaWRSdW50aW1lVHlwZShcbiAgICAgICAgICByZXNvbHZlZFJ1bnRpbWVUeXBlLFxuICAgICAgICAgIGV4ZUNvbnRleHQsXG4gICAgICAgICAgcmV0dXJuVHlwZSxcbiAgICAgICAgICBmaWVsZE5vZGVzLFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgcmVzdWx0XG4gICAgICAgICksXG4gICAgICAgIGZpZWxkTm9kZXMsXG4gICAgICAgIGluZm8sXG4gICAgICAgIHBhdGgsXG4gICAgICAgIHJlc3VsdFxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbXBsZXRlT2JqZWN0VmFsdWUoXG4gICAgZXhlQ29udGV4dCxcbiAgICBlbnN1cmVWYWxpZFJ1bnRpbWVUeXBlKFxuICAgICAgcnVudGltZVR5cGUsXG4gICAgICBleGVDb250ZXh0LFxuICAgICAgcmV0dXJuVHlwZSxcbiAgICAgIGZpZWxkTm9kZXMsXG4gICAgICBpbmZvLFxuICAgICAgcmVzdWx0XG4gICAgKSxcbiAgICBmaWVsZE5vZGVzLFxuICAgIGluZm8sXG4gICAgcGF0aCxcbiAgICByZXN1bHRcbiAgKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZhbGlkUnVudGltZVR5cGUocnVudGltZVR5cGVOYW1lLCBleGVDb250ZXh0LCByZXR1cm5UeXBlLCBmaWVsZE5vZGVzLCBpbmZvLCByZXN1bHQpIHtcbiAgaWYgKHJ1bnRpbWVUeXBlTmFtZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgIGBBYnN0cmFjdCB0eXBlIFwiJHtyZXR1cm5UeXBlLm5hbWV9XCIgbXVzdCByZXNvbHZlIHRvIGFuIE9iamVjdCB0eXBlIGF0IHJ1bnRpbWUgZm9yIGZpZWxkIFwiJHtpbmZvLnBhcmVudFR5cGUubmFtZX0uJHtpbmZvLmZpZWxkTmFtZX1cIi4gRWl0aGVyIHRoZSBcIiR7cmV0dXJuVHlwZS5uYW1lfVwiIHR5cGUgc2hvdWxkIHByb3ZpZGUgYSBcInJlc29sdmVUeXBlXCIgZnVuY3Rpb24gb3IgZWFjaCBwb3NzaWJsZSB0eXBlIHNob3VsZCBwcm92aWRlIGFuIFwiaXNUeXBlT2ZcIiBmdW5jdGlvbi5gLFxuICAgICAgZmllbGROb2Rlc1xuICAgICk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0VHlwZShydW50aW1lVHlwZU5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgIFwiU3VwcG9ydCBmb3IgcmV0dXJuaW5nIEdyYXBoUUxPYmplY3RUeXBlIGZyb20gcmVzb2x2ZVR5cGUgd2FzIHJlbW92ZWQgaW4gZ3JhcGhxbC1qc0AxNi4wLjAgcGxlYXNlIHJldHVybiB0eXBlIG5hbWUgaW5zdGVhZC5cIlxuICAgICk7XG4gIH1cbiAgaWYgKHR5cGVvZiBydW50aW1lVHlwZU5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgYEFic3RyYWN0IHR5cGUgXCIke3JldHVyblR5cGUubmFtZX1cIiBtdXN0IHJlc29sdmUgdG8gYW4gT2JqZWN0IHR5cGUgYXQgcnVudGltZSBmb3IgZmllbGQgXCIke2luZm8ucGFyZW50VHlwZS5uYW1lfS4ke2luZm8uZmllbGROYW1lfVwiIHdpdGggdmFsdWUgJHtpbnNwZWN0KHJlc3VsdCl9LCByZWNlaXZlZCBcIiR7aW5zcGVjdChydW50aW1lVHlwZU5hbWUpfVwiLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IHJ1bnRpbWVUeXBlID0gZXhlQ29udGV4dC5zY2hlbWEuZ2V0VHlwZShydW50aW1lVHlwZU5hbWUpO1xuICBpZiAocnVudGltZVR5cGUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICBgQWJzdHJhY3QgdHlwZSBcIiR7cmV0dXJuVHlwZS5uYW1lfVwiIHdhcyByZXNvbHZlZCB0byBhIHR5cGUgXCIke3J1bnRpbWVUeXBlTmFtZX1cIiB0aGF0IGRvZXMgbm90IGV4aXN0IGluc2lkZSB0aGUgc2NoZW1hLmAsXG4gICAgICB7XG4gICAgICAgIG5vZGVzOiBmaWVsZE5vZGVzXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBpZiAoIWlzT2JqZWN0VHlwZShydW50aW1lVHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgYEFic3RyYWN0IHR5cGUgXCIke3JldHVyblR5cGUubmFtZX1cIiB3YXMgcmVzb2x2ZWQgdG8gYSBub24tb2JqZWN0IHR5cGUgXCIke3J1bnRpbWVUeXBlTmFtZX1cIi5gLFxuICAgICAge1xuICAgICAgICBub2RlczogZmllbGROb2Rlc1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgaWYgKCFleGVDb250ZXh0LnNjaGVtYS5pc1N1YlR5cGUocmV0dXJuVHlwZSwgcnVudGltZVR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgIGBSdW50aW1lIE9iamVjdCB0eXBlIFwiJHtydW50aW1lVHlwZS5uYW1lfVwiIGlzIG5vdCBhIHBvc3NpYmxlIHR5cGUgZm9yIFwiJHtyZXR1cm5UeXBlLm5hbWV9XCIuYCxcbiAgICAgIHtcbiAgICAgICAgbm9kZXM6IGZpZWxkTm9kZXNcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHJldHVybiBydW50aW1lVHlwZTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlT2JqZWN0VmFsdWUoZXhlQ29udGV4dCwgcmV0dXJuVHlwZSwgZmllbGROb2RlcywgaW5mbywgcGF0aCwgcmVzdWx0KSB7XG4gIGNvbnN0IHN1YkZpZWxkTm9kZXMgPSBjb2xsZWN0U3ViZmllbGRzMihleGVDb250ZXh0LCByZXR1cm5UeXBlLCBmaWVsZE5vZGVzKTtcbiAgaWYgKHJldHVyblR5cGUuaXNUeXBlT2YpIHtcbiAgICBjb25zdCBpc1R5cGVPZiA9IHJldHVyblR5cGUuaXNUeXBlT2YocmVzdWx0LCBleGVDb250ZXh0LmNvbnRleHRWYWx1ZSwgaW5mbyk7XG4gICAgaWYgKGlzUHJvbWlzZShpc1R5cGVPZikpIHtcbiAgICAgIHJldHVybiBpc1R5cGVPZi50aGVuKChyZXNvbHZlZElzVHlwZU9mKSA9PiB7XG4gICAgICAgIGlmICghcmVzb2x2ZWRJc1R5cGVPZikge1xuICAgICAgICAgIHRocm93IGludmFsaWRSZXR1cm5UeXBlRXJyb3IocmV0dXJuVHlwZSwgcmVzdWx0LCBmaWVsZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhlY3V0ZUZpZWxkcyhcbiAgICAgICAgICBleGVDb250ZXh0LFxuICAgICAgICAgIHJldHVyblR5cGUsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgc3ViRmllbGROb2Rlc1xuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghaXNUeXBlT2YpIHtcbiAgICAgIHRocm93IGludmFsaWRSZXR1cm5UeXBlRXJyb3IocmV0dXJuVHlwZSwgcmVzdWx0LCBmaWVsZE5vZGVzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV4ZWN1dGVGaWVsZHMoZXhlQ29udGV4dCwgcmV0dXJuVHlwZSwgcmVzdWx0LCBwYXRoLCBzdWJGaWVsZE5vZGVzKTtcbn1cbmZ1bmN0aW9uIGludmFsaWRSZXR1cm5UeXBlRXJyb3IocmV0dXJuVHlwZSwgcmVzdWx0LCBmaWVsZE5vZGVzKSB7XG4gIHJldHVybiBuZXcgR3JhcGhRTEVycm9yKFxuICAgIGBFeHBlY3RlZCB2YWx1ZSBvZiB0eXBlIFwiJHtyZXR1cm5UeXBlLm5hbWV9XCIgYnV0IGdvdDogJHtpbnNwZWN0KHJlc3VsdCl9LmAsXG4gICAge1xuICAgICAgbm9kZXM6IGZpZWxkTm9kZXNcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBnZXRGaWVsZERlZjIoc2NoZW1hLCBwYXJlbnRUeXBlLCBmaWVsZE5vZGUpIHtcbiAgY29uc3QgZmllbGROYW1lID0gZmllbGROb2RlLm5hbWUudmFsdWU7XG4gIGlmIChmaWVsZE5hbWUgPT09IFNjaGVtYU1ldGFGaWVsZERlZi5uYW1lICYmIHNjaGVtYS5nZXRRdWVyeVR5cGUoKSA9PT0gcGFyZW50VHlwZSkge1xuICAgIHJldHVybiBTY2hlbWFNZXRhRmllbGREZWY7XG4gIH0gZWxzZSBpZiAoZmllbGROYW1lID09PSBUeXBlTWV0YUZpZWxkRGVmLm5hbWUgJiYgc2NoZW1hLmdldFF1ZXJ5VHlwZSgpID09PSBwYXJlbnRUeXBlKSB7XG4gICAgcmV0dXJuIFR5cGVNZXRhRmllbGREZWY7XG4gIH0gZWxzZSBpZiAoZmllbGROYW1lID09PSBUeXBlTmFtZU1ldGFGaWVsZERlZi5uYW1lKSB7XG4gICAgcmV0dXJuIFR5cGVOYW1lTWV0YUZpZWxkRGVmO1xuICB9XG4gIHJldHVybiBwYXJlbnRUeXBlLmdldEZpZWxkcygpW2ZpZWxkTmFtZV07XG59XG52YXIgY29sbGVjdFN1YmZpZWxkczIsIGRlZmF1bHRUeXBlUmVzb2x2ZXIsIGRlZmF1bHRGaWVsZFJlc29sdmVyO1xudmFyIGluaXRfZXhlY3V0ZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC9leGVjdXRpb24vZXhlY3V0ZS5tanNcIigpIHtcbiAgICBpbml0X2RldkFzc2VydCgpO1xuICAgIGluaXRfaW5zcGVjdCgpO1xuICAgIGluaXRfaW52YXJpYW50KCk7XG4gICAgaW5pdF9pc0l0ZXJhYmxlT2JqZWN0KCk7XG4gICAgaW5pdF9pc09iamVjdExpa2UoKTtcbiAgICBpbml0X2lzUHJvbWlzZSgpO1xuICAgIGluaXRfbWVtb2l6ZTMoKTtcbiAgICBpbml0X1BhdGgoKTtcbiAgICBpbml0X3Byb21pc2VGb3JPYmplY3QoKTtcbiAgICBpbml0X3Byb21pc2VSZWR1Y2UoKTtcbiAgICBpbml0X0dyYXBoUUxFcnJvcigpO1xuICAgIGluaXRfbG9jYXRlZEVycm9yKCk7XG4gICAgaW5pdF9hc3QoKTtcbiAgICBpbml0X2tpbmRzKCk7XG4gICAgaW5pdF9kZWZpbml0aW9uKCk7XG4gICAgaW5pdF9pbnRyb3NwZWN0aW9uKCk7XG4gICAgaW5pdF92YWxpZGF0ZSgpO1xuICAgIGluaXRfY29sbGVjdEZpZWxkcygpO1xuICAgIGluaXRfdmFsdWVzKCk7XG4gICAgY29sbGVjdFN1YmZpZWxkczIgPSBtZW1vaXplMyhcbiAgICAgIChleGVDb250ZXh0LCByZXR1cm5UeXBlLCBmaWVsZE5vZGVzKSA9PiBjb2xsZWN0U3ViZmllbGRzKFxuICAgICAgICBleGVDb250ZXh0LnNjaGVtYSxcbiAgICAgICAgZXhlQ29udGV4dC5mcmFnbWVudHMsXG4gICAgICAgIGV4ZUNvbnRleHQudmFyaWFibGVWYWx1ZXMsXG4gICAgICAgIHJldHVyblR5cGUsXG4gICAgICAgIGZpZWxkTm9kZXNcbiAgICAgIClcbiAgICApO1xuICAgIGRlZmF1bHRUeXBlUmVzb2x2ZXIgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dFZhbHVlLCBpbmZvLCBhYnN0cmFjdFR5cGUpIHtcbiAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS5fX3R5cGVuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5fX3R5cGVuYW1lO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9zc2libGVUeXBlcyA9IGluZm8uc2NoZW1hLmdldFBvc3NpYmxlVHlwZXMoYWJzdHJhY3RUeXBlKTtcbiAgICAgIGNvbnN0IHByb21pc2VkSXNUeXBlT2ZSZXN1bHRzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc3NpYmxlVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHBvc3NpYmxlVHlwZXNbaV07XG4gICAgICAgIGlmICh0eXBlLmlzVHlwZU9mKSB7XG4gICAgICAgICAgY29uc3QgaXNUeXBlT2ZSZXN1bHQgPSB0eXBlLmlzVHlwZU9mKHZhbHVlLCBjb250ZXh0VmFsdWUsIGluZm8pO1xuICAgICAgICAgIGlmIChpc1Byb21pc2UoaXNUeXBlT2ZSZXN1bHQpKSB7XG4gICAgICAgICAgICBwcm9taXNlZElzVHlwZU9mUmVzdWx0c1tpXSA9IGlzVHlwZU9mUmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNUeXBlT2ZSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvbWlzZWRJc1R5cGVPZlJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlZElzVHlwZU9mUmVzdWx0cykudGhlbigoaXNUeXBlT2ZSZXN1bHRzKSA9PiB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpc1R5cGVPZlJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpc1R5cGVPZlJlc3VsdHNbaV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBvc3NpYmxlVHlwZXNbaV0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgZGVmYXVsdEZpZWxkUmVzb2x2ZXIgPSBmdW5jdGlvbihzb3VyY2UsIGFyZ3MsIGNvbnRleHRWYWx1ZSwgaW5mbykge1xuICAgICAgaWYgKGlzT2JqZWN0TGlrZShzb3VyY2UpIHx8IHR5cGVvZiBzb3VyY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IHNvdXJjZVtpbmZvLmZpZWxkTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBzb3VyY2VbaW5mby5maWVsZE5hbWVdKGFyZ3MsIGNvbnRleHRWYWx1ZSwgaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BlcnR5O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9ncmFwaHFsLm1qc1xuZnVuY3Rpb24gZ3JhcGhxbChhcmdzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZShncmFwaHFsSW1wbChhcmdzKSkpO1xufVxuZnVuY3Rpb24gZ3JhcGhxbFN5bmMoYXJncykge1xuICBjb25zdCByZXN1bHQgPSBncmFwaHFsSW1wbChhcmdzKTtcbiAgaWYgKGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiR3JhcGhRTCBleGVjdXRpb24gZmFpbGVkIHRvIGNvbXBsZXRlIHN5bmNocm9ub3VzbHkuXCIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBncmFwaHFsSW1wbChhcmdzKSB7XG4gIGFyZ3VtZW50cy5sZW5ndGggPCAyIHx8IGRldkFzc2VydChcbiAgICBmYWxzZSxcbiAgICBcImdyYXBocWxAMTYgZHJvcHBlZCBsb25nLWRlcHJlY2F0ZWQgc3VwcG9ydCBmb3IgcG9zaXRpb25hbCBhcmd1bWVudHMsIHBsZWFzZSBwYXNzIGFuIG9iamVjdCBpbnN0ZWFkLlwiXG4gICk7XG4gIGNvbnN0IHtcbiAgICBzY2hlbWEsXG4gICAgc291cmNlLFxuICAgIHJvb3RWYWx1ZSxcbiAgICBjb250ZXh0VmFsdWUsXG4gICAgdmFyaWFibGVWYWx1ZXMsXG4gICAgb3BlcmF0aW9uTmFtZSxcbiAgICBmaWVsZFJlc29sdmVyLFxuICAgIHR5cGVSZXNvbHZlclxuICB9ID0gYXJncztcbiAgY29uc3Qgc2NoZW1hVmFsaWRhdGlvbkVycm9ycyA9IHZhbGlkYXRlU2NoZW1hKHNjaGVtYSk7XG4gIGlmIChzY2hlbWFWYWxpZGF0aW9uRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3JzOiBzY2hlbWFWYWxpZGF0aW9uRXJyb3JzXG4gICAgfTtcbiAgfVxuICBsZXQgZG9jdW1lbnQ7XG4gIHRyeSB7XG4gICAgZG9jdW1lbnQgPSBwYXJzZShzb3VyY2UpO1xuICB9IGNhdGNoIChzeW50YXhFcnJvcjIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3JzOiBbc3ludGF4RXJyb3IyXVxuICAgIH07XG4gIH1cbiAgY29uc3QgdmFsaWRhdGlvbkVycm9ycyA9IHZhbGlkYXRlKHNjaGVtYSwgZG9jdW1lbnQpO1xuICBpZiAodmFsaWRhdGlvbkVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yczogdmFsaWRhdGlvbkVycm9yc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGV4ZWN1dGUoe1xuICAgIHNjaGVtYSxcbiAgICBkb2N1bWVudCxcbiAgICByb290VmFsdWUsXG4gICAgY29udGV4dFZhbHVlLFxuICAgIHZhcmlhYmxlVmFsdWVzLFxuICAgIG9wZXJhdGlvbk5hbWUsXG4gICAgZmllbGRSZXNvbHZlcixcbiAgICB0eXBlUmVzb2x2ZXJcbiAgfSk7XG59XG52YXIgaW5pdF9ncmFwaHFsID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2dyYXBocWwubWpzXCIoKSB7XG4gICAgaW5pdF9kZXZBc3NlcnQoKTtcbiAgICBpbml0X2lzUHJvbWlzZSgpO1xuICAgIGluaXRfcGFyc2VyKCk7XG4gICAgaW5pdF92YWxpZGF0ZSgpO1xuICAgIGluaXRfdmFsaWRhdGUyKCk7XG4gICAgaW5pdF9leGVjdXRlKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2lzQXN5bmNJdGVyYWJsZS5tanNcbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZShtYXliZUFzeW5jSXRlcmFibGUpIHtcbiAgcmV0dXJuIHR5cGVvZiAobWF5YmVBc3luY0l0ZXJhYmxlID09PSBudWxsIHx8IG1heWJlQXN5bmNJdGVyYWJsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF5YmVBc3luY0l0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkgPT09IFwiZnVuY3Rpb25cIjtcbn1cbnZhciBpbml0X2lzQXN5bmNJdGVyYWJsZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2lzQXN5bmNJdGVyYWJsZS5tanNcIigpIHtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2V4ZWN1dGlvbi9tYXBBc3luY0l0ZXJhdG9yLm1qc1xuZnVuY3Rpb24gbWFwQXN5bmNJdGVyYXRvcihpdGVyYWJsZSwgY2FsbGJhY2spIHtcbiAgY29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgYXN5bmMgZnVuY3Rpb24gbWFwUmVzdWx0KHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBhd2FpdCBjYWxsYmFjayhyZXN1bHQudmFsdWUpLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci5yZXR1cm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhc3luYyBuZXh0KCkge1xuICAgICAgcmV0dXJuIG1hcFJlc3VsdChhd2FpdCBpdGVyYXRvci5uZXh0KCkpO1xuICAgIH0sXG4gICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBpdGVyYXRvci5yZXR1cm4gPT09IFwiZnVuY3Rpb25cIiA/IG1hcFJlc3VsdChhd2FpdCBpdGVyYXRvci5yZXR1cm4oKSkgOiB7XG4gICAgICAgIHZhbHVlOiB2b2lkIDAsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBhc3luYyB0aHJvdyhlcnJvcikge1xuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci50aHJvdyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBtYXBSZXN1bHQoYXdhaXQgaXRlcmF0b3IudGhyb3coZXJyb3IpKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0sXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn1cbnZhciBpbml0X21hcEFzeW5jSXRlcmF0b3IgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvZXhlY3V0aW9uL21hcEFzeW5jSXRlcmF0b3IubWpzXCIoKSB7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9leGVjdXRpb24vc3Vic2NyaWJlLm1qc1xuYXN5bmMgZnVuY3Rpb24gc3Vic2NyaWJlKGFyZ3MpIHtcbiAgYXJndW1lbnRzLmxlbmd0aCA8IDIgfHwgZGV2QXNzZXJ0KFxuICAgIGZhbHNlLFxuICAgIFwiZ3JhcGhxbEAxNiBkcm9wcGVkIGxvbmctZGVwcmVjYXRlZCBzdXBwb3J0IGZvciBwb3NpdGlvbmFsIGFyZ3VtZW50cywgcGxlYXNlIHBhc3MgYW4gb2JqZWN0IGluc3RlYWQuXCJcbiAgKTtcbiAgY29uc3QgcmVzdWx0T3JTdHJlYW0gPSBhd2FpdCBjcmVhdGVTb3VyY2VFdmVudFN0cmVhbShhcmdzKTtcbiAgaWYgKCFpc0FzeW5jSXRlcmFibGUocmVzdWx0T3JTdHJlYW0pKSB7XG4gICAgcmV0dXJuIHJlc3VsdE9yU3RyZWFtO1xuICB9XG4gIGNvbnN0IG1hcFNvdXJjZVRvUmVzcG9uc2UgPSAocGF5bG9hZCkgPT4gZXhlY3V0ZSh7IC4uLmFyZ3MsIHJvb3RWYWx1ZTogcGF5bG9hZCB9KTtcbiAgcmV0dXJuIG1hcEFzeW5jSXRlcmF0b3IocmVzdWx0T3JTdHJlYW0sIG1hcFNvdXJjZVRvUmVzcG9uc2UpO1xufVxuZnVuY3Rpb24gdG9Ob3JtYWxpemVkQXJncyhhcmdzKSB7XG4gIGNvbnN0IGZpcnN0QXJnID0gYXJnc1swXTtcbiAgaWYgKGZpcnN0QXJnICYmIFwiZG9jdW1lbnRcIiBpbiBmaXJzdEFyZykge1xuICAgIHJldHVybiBmaXJzdEFyZztcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjaGVtYTogZmlyc3RBcmcsXG4gICAgLy8gRklYTUU6IHdoZW4gdW5kZXJseWluZyBUUyBidWcgZml4ZWQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzMxNjEzXG4gICAgZG9jdW1lbnQ6IGFyZ3NbMV0sXG4gICAgcm9vdFZhbHVlOiBhcmdzWzJdLFxuICAgIGNvbnRleHRWYWx1ZTogYXJnc1szXSxcbiAgICB2YXJpYWJsZVZhbHVlczogYXJnc1s0XSxcbiAgICBvcGVyYXRpb25OYW1lOiBhcmdzWzVdLFxuICAgIHN1YnNjcmliZUZpZWxkUmVzb2x2ZXI6IGFyZ3NbNl1cbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNvdXJjZUV2ZW50U3RyZWFtKC4uLnJhd0FyZ3MpIHtcbiAgY29uc3QgYXJncyA9IHRvTm9ybWFsaXplZEFyZ3MocmF3QXJncyk7XG4gIGNvbnN0IHsgc2NoZW1hLCBkb2N1bWVudCwgdmFyaWFibGVWYWx1ZXMgfSA9IGFyZ3M7XG4gIGFzc2VydFZhbGlkRXhlY3V0aW9uQXJndW1lbnRzKHNjaGVtYSwgZG9jdW1lbnQsIHZhcmlhYmxlVmFsdWVzKTtcbiAgY29uc3QgZXhlQ29udGV4dCA9IGJ1aWxkRXhlY3V0aW9uQ29udGV4dChhcmdzKTtcbiAgaWYgKCEoXCJzY2hlbWFcIiBpbiBleGVDb250ZXh0KSkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcnM6IGV4ZUNvbnRleHRcbiAgICB9O1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgZXZlbnRTdHJlYW0gPSBhd2FpdCBleGVjdXRlU3Vic2NyaXB0aW9uKGV4ZUNvbnRleHQpO1xuICAgIGlmICghaXNBc3luY0l0ZXJhYmxlKGV2ZW50U3RyZWFtKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgU3Vic2NyaXB0aW9uIGZpZWxkIG11c3QgcmV0dXJuIEFzeW5jIEl0ZXJhYmxlLiBSZWNlaXZlZDogJHtpbnNwZWN0KGV2ZW50U3RyZWFtKX0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RyZWFtO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEdyYXBoUUxFcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3JzOiBbZXJyb3JdXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVN1YnNjcmlwdGlvbihleGVDb250ZXh0KSB7XG4gIGNvbnN0IHsgc2NoZW1hLCBmcmFnbWVudHMsIG9wZXJhdGlvbiwgdmFyaWFibGVWYWx1ZXMsIHJvb3RWYWx1ZSB9ID0gZXhlQ29udGV4dDtcbiAgY29uc3Qgcm9vdFR5cGUgPSBzY2hlbWEuZ2V0U3Vic2NyaXB0aW9uVHlwZSgpO1xuICBpZiAocm9vdFR5cGUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICBcIlNjaGVtYSBpcyBub3QgY29uZmlndXJlZCB0byBleGVjdXRlIHN1YnNjcmlwdGlvbiBvcGVyYXRpb24uXCIsXG4gICAgICB7XG4gICAgICAgIG5vZGVzOiBvcGVyYXRpb25cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGNvbnN0IHJvb3RGaWVsZHMgPSBjb2xsZWN0RmllbGRzKFxuICAgIHNjaGVtYSxcbiAgICBmcmFnbWVudHMsXG4gICAgdmFyaWFibGVWYWx1ZXMsXG4gICAgcm9vdFR5cGUsXG4gICAgb3BlcmF0aW9uLnNlbGVjdGlvblNldFxuICApO1xuICBjb25zdCBbcmVzcG9uc2VOYW1lLCBmaWVsZE5vZGVzXSA9IFsuLi5yb290RmllbGRzLmVudHJpZXMoKV1bMF07XG4gIGNvbnN0IGZpZWxkRGVmID0gZ2V0RmllbGREZWYyKHNjaGVtYSwgcm9vdFR5cGUsIGZpZWxkTm9kZXNbMF0pO1xuICBpZiAoIWZpZWxkRGVmKSB7XG4gICAgY29uc3QgZmllbGROYW1lID0gZmllbGROb2Rlc1swXS5uYW1lLnZhbHVlO1xuICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICBgVGhlIHN1YnNjcmlwdGlvbiBmaWVsZCBcIiR7ZmllbGROYW1lfVwiIGlzIG5vdCBkZWZpbmVkLmAsXG4gICAgICB7XG4gICAgICAgIG5vZGVzOiBmaWVsZE5vZGVzXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBjb25zdCBwYXRoID0gYWRkUGF0aCh2b2lkIDAsIHJlc3BvbnNlTmFtZSwgcm9vdFR5cGUubmFtZSk7XG4gIGNvbnN0IGluZm8gPSBidWlsZFJlc29sdmVJbmZvKFxuICAgIGV4ZUNvbnRleHQsXG4gICAgZmllbGREZWYsXG4gICAgZmllbGROb2RlcyxcbiAgICByb290VHlwZSxcbiAgICBwYXRoXG4gICk7XG4gIHRyeSB7XG4gICAgdmFyIF9maWVsZERlZiRzdWJzY3JpYmU7XG4gICAgY29uc3QgYXJncyA9IGdldEFyZ3VtZW50VmFsdWVzKGZpZWxkRGVmLCBmaWVsZE5vZGVzWzBdLCB2YXJpYWJsZVZhbHVlcyk7XG4gICAgY29uc3QgY29udGV4dFZhbHVlID0gZXhlQ29udGV4dC5jb250ZXh0VmFsdWU7XG4gICAgY29uc3QgcmVzb2x2ZUZuID0gKF9maWVsZERlZiRzdWJzY3JpYmUgPSBmaWVsZERlZi5zdWJzY3JpYmUpICE9PSBudWxsICYmIF9maWVsZERlZiRzdWJzY3JpYmUgIT09IHZvaWQgMCA/IF9maWVsZERlZiRzdWJzY3JpYmUgOiBleGVDb250ZXh0LnN1YnNjcmliZUZpZWxkUmVzb2x2ZXI7XG4gICAgY29uc3QgZXZlbnRTdHJlYW0gPSBhd2FpdCByZXNvbHZlRm4ocm9vdFZhbHVlLCBhcmdzLCBjb250ZXh0VmFsdWUsIGluZm8pO1xuICAgIGlmIChldmVudFN0cmVhbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBldmVudFN0cmVhbTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RyZWFtO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGxvY2F0ZWRFcnJvcihlcnJvciwgZmllbGROb2RlcywgcGF0aFRvQXJyYXkocGF0aCkpO1xuICB9XG59XG52YXIgaW5pdF9zdWJzY3JpYmUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvZXhlY3V0aW9uL3N1YnNjcmliZS5tanNcIigpIHtcbiAgICBpbml0X2RldkFzc2VydCgpO1xuICAgIGluaXRfaW5zcGVjdCgpO1xuICAgIGluaXRfaXNBc3luY0l0ZXJhYmxlKCk7XG4gICAgaW5pdF9QYXRoKCk7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgICBpbml0X2xvY2F0ZWRFcnJvcigpO1xuICAgIGluaXRfY29sbGVjdEZpZWxkcygpO1xuICAgIGluaXRfZXhlY3V0ZSgpO1xuICAgIGluaXRfbWFwQXN5bmNJdGVyYXRvcigpO1xuICAgIGluaXRfdmFsdWVzKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC9leGVjdXRpb24vaW5kZXgubWpzXG52YXIgaW5pdF9leGVjdXRpb24gPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvZXhlY3V0aW9uL2luZGV4Lm1qc1wiKCkge1xuICAgIGluaXRfUGF0aCgpO1xuICAgIGluaXRfZXhlY3V0ZSgpO1xuICAgIGluaXRfc3Vic2NyaWJlKCk7XG4gICAgaW5pdF92YWx1ZXMoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvY3VzdG9tL05vRGVwcmVjYXRlZEN1c3RvbVJ1bGUubWpzXG5mdW5jdGlvbiBOb0RlcHJlY2F0ZWRDdXN0b21SdWxlKGNvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICBGaWVsZChub2RlKSB7XG4gICAgICBjb25zdCBmaWVsZERlZiA9IGNvbnRleHQuZ2V0RmllbGREZWYoKTtcbiAgICAgIGNvbnN0IGRlcHJlY2F0aW9uUmVhc29uID0gZmllbGREZWYgPT09IG51bGwgfHwgZmllbGREZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkRGVmLmRlcHJlY2F0aW9uUmVhc29uO1xuICAgICAgaWYgKGZpZWxkRGVmICYmIGRlcHJlY2F0aW9uUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcGFyZW50VHlwZSA9IGNvbnRleHQuZ2V0UGFyZW50VHlwZSgpO1xuICAgICAgICBwYXJlbnRUeXBlICE9IG51bGwgfHwgaW52YXJpYW50KGZhbHNlKTtcbiAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgYFRoZSBmaWVsZCAke3BhcmVudFR5cGUubmFtZX0uJHtmaWVsZERlZi5uYW1lfSBpcyBkZXByZWNhdGVkLiAke2RlcHJlY2F0aW9uUmVhc29ufWAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5vZGVzOiBub2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAgQXJndW1lbnQobm9kZSkge1xuICAgICAgY29uc3QgYXJnRGVmID0gY29udGV4dC5nZXRBcmd1bWVudCgpO1xuICAgICAgY29uc3QgZGVwcmVjYXRpb25SZWFzb24gPSBhcmdEZWYgPT09IG51bGwgfHwgYXJnRGVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdEZWYuZGVwcmVjYXRpb25SZWFzb247XG4gICAgICBpZiAoYXJnRGVmICYmIGRlcHJlY2F0aW9uUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgZGlyZWN0aXZlRGVmID0gY29udGV4dC5nZXREaXJlY3RpdmUoKTtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZURlZiAhPSBudWxsKSB7XG4gICAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICAgIGBEaXJlY3RpdmUgXCJAJHtkaXJlY3RpdmVEZWYubmFtZX1cIiBhcmd1bWVudCBcIiR7YXJnRGVmLm5hbWV9XCIgaXMgZGVwcmVjYXRlZC4gJHtkZXByZWNhdGlvblJlYXNvbn1gLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm9kZXM6IG5vZGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcGFyZW50VHlwZSA9IGNvbnRleHQuZ2V0UGFyZW50VHlwZSgpO1xuICAgICAgICAgIGNvbnN0IGZpZWxkRGVmID0gY29udGV4dC5nZXRGaWVsZERlZigpO1xuICAgICAgICAgIHBhcmVudFR5cGUgIT0gbnVsbCAmJiBmaWVsZERlZiAhPSBudWxsIHx8IGludmFyaWFudChmYWxzZSk7XG4gICAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvcihcbiAgICAgICAgICAgIG5ldyBHcmFwaFFMRXJyb3IoXG4gICAgICAgICAgICAgIGBGaWVsZCBcIiR7cGFyZW50VHlwZS5uYW1lfS4ke2ZpZWxkRGVmLm5hbWV9XCIgYXJndW1lbnQgXCIke2FyZ0RlZi5uYW1lfVwiIGlzIGRlcHJlY2F0ZWQuICR7ZGVwcmVjYXRpb25SZWFzb259YCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vZGVzOiBub2RlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBPYmplY3RGaWVsZChub2RlKSB7XG4gICAgICBjb25zdCBpbnB1dE9iamVjdERlZiA9IGdldE5hbWVkVHlwZShjb250ZXh0LmdldFBhcmVudElucHV0VHlwZSgpKTtcbiAgICAgIGlmIChpc0lucHV0T2JqZWN0VHlwZShpbnB1dE9iamVjdERlZikpIHtcbiAgICAgICAgY29uc3QgaW5wdXRGaWVsZERlZiA9IGlucHV0T2JqZWN0RGVmLmdldEZpZWxkcygpW25vZGUubmFtZS52YWx1ZV07XG4gICAgICAgIGNvbnN0IGRlcHJlY2F0aW9uUmVhc29uID0gaW5wdXRGaWVsZERlZiA9PT0gbnVsbCB8fCBpbnB1dEZpZWxkRGVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnB1dEZpZWxkRGVmLmRlcHJlY2F0aW9uUmVhc29uO1xuICAgICAgICBpZiAoZGVwcmVjYXRpb25SZWFzb24gIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgICBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgICBgVGhlIGlucHV0IGZpZWxkICR7aW5wdXRPYmplY3REZWYubmFtZX0uJHtpbnB1dEZpZWxkRGVmLm5hbWV9IGlzIGRlcHJlY2F0ZWQuICR7ZGVwcmVjYXRpb25SZWFzb259YCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vZGVzOiBub2RlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBFbnVtVmFsdWUobm9kZSkge1xuICAgICAgY29uc3QgZW51bVZhbHVlRGVmID0gY29udGV4dC5nZXRFbnVtVmFsdWUoKTtcbiAgICAgIGNvbnN0IGRlcHJlY2F0aW9uUmVhc29uID0gZW51bVZhbHVlRGVmID09PSBudWxsIHx8IGVudW1WYWx1ZURlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW51bVZhbHVlRGVmLmRlcHJlY2F0aW9uUmVhc29uO1xuICAgICAgaWYgKGVudW1WYWx1ZURlZiAmJiBkZXByZWNhdGlvblJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGVudW1UeXBlRGVmID0gZ2V0TmFtZWRUeXBlKGNvbnRleHQuZ2V0SW5wdXRUeXBlKCkpO1xuICAgICAgICBlbnVtVHlwZURlZiAhPSBudWxsIHx8IGludmFyaWFudChmYWxzZSk7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBUaGUgZW51bSB2YWx1ZSBcIiR7ZW51bVR5cGVEZWYubmFtZX0uJHtlbnVtVmFsdWVEZWYubmFtZX1cIiBpcyBkZXByZWNhdGVkLiAke2RlcHJlY2F0aW9uUmVhc29ufWAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5vZGVzOiBub2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbnZhciBpbml0X05vRGVwcmVjYXRlZEN1c3RvbVJ1bGUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdmFsaWRhdGlvbi9ydWxlcy9jdXN0b20vTm9EZXByZWNhdGVkQ3VzdG9tUnVsZS5tanNcIigpIHtcbiAgICBpbml0X2ludmFyaWFudCgpO1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gICAgaW5pdF9kZWZpbml0aW9uKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC92YWxpZGF0aW9uL3J1bGVzL2N1c3RvbS9Ob1NjaGVtYUludHJvc3BlY3Rpb25DdXN0b21SdWxlLm1qc1xuZnVuY3Rpb24gTm9TY2hlbWFJbnRyb3NwZWN0aW9uQ3VzdG9tUnVsZShjb250ZXh0KSB7XG4gIHJldHVybiB7XG4gICAgRmllbGQobm9kZSkge1xuICAgICAgY29uc3QgdHlwZSA9IGdldE5hbWVkVHlwZShjb250ZXh0LmdldFR5cGUoKSk7XG4gICAgICBpZiAodHlwZSAmJiBpc0ludHJvc3BlY3Rpb25UeXBlKHR5cGUpKSB7XG4gICAgICAgIGNvbnRleHQucmVwb3J0RXJyb3IoXG4gICAgICAgICAgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBHcmFwaFFMIGludHJvc3BlY3Rpb24gaGFzIGJlZW4gZGlzYWJsZWQsIGJ1dCB0aGUgcmVxdWVzdGVkIHF1ZXJ5IGNvbnRhaW5lZCB0aGUgZmllbGQgXCIke25vZGUubmFtZS52YWx1ZX1cIi5gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBub2Rlczogbm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9Ob1NjaGVtYUludHJvc3BlY3Rpb25DdXN0b21SdWxlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vcnVsZXMvY3VzdG9tL05vU2NoZW1hSW50cm9zcGVjdGlvbkN1c3RvbVJ1bGUubWpzXCIoKSB7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgICBpbml0X2RlZmluaXRpb24oKTtcbiAgICBpbml0X2ludHJvc3BlY3Rpb24oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vaW5kZXgubWpzXG52YXIgaW5pdF92YWxpZGF0aW9uID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3ZhbGlkYXRpb24vaW5kZXgubWpzXCIoKSB7XG4gICAgaW5pdF92YWxpZGF0ZTIoKTtcbiAgICBpbml0X1ZhbGlkYXRpb25Db250ZXh0KCk7XG4gICAgaW5pdF9zcGVjaWZpZWRSdWxlcygpO1xuICAgIGluaXRfRXhlY3V0YWJsZURlZmluaXRpb25zUnVsZSgpO1xuICAgIGluaXRfRmllbGRzT25Db3JyZWN0VHlwZVJ1bGUoKTtcbiAgICBpbml0X0ZyYWdtZW50c09uQ29tcG9zaXRlVHlwZXNSdWxlKCk7XG4gICAgaW5pdF9Lbm93bkFyZ3VtZW50TmFtZXNSdWxlKCk7XG4gICAgaW5pdF9Lbm93bkRpcmVjdGl2ZXNSdWxlKCk7XG4gICAgaW5pdF9Lbm93bkZyYWdtZW50TmFtZXNSdWxlKCk7XG4gICAgaW5pdF9Lbm93blR5cGVOYW1lc1J1bGUoKTtcbiAgICBpbml0X0xvbmVBbm9ueW1vdXNPcGVyYXRpb25SdWxlKCk7XG4gICAgaW5pdF9Ob0ZyYWdtZW50Q3ljbGVzUnVsZSgpO1xuICAgIGluaXRfTm9VbmRlZmluZWRWYXJpYWJsZXNSdWxlKCk7XG4gICAgaW5pdF9Ob1VudXNlZEZyYWdtZW50c1J1bGUoKTtcbiAgICBpbml0X05vVW51c2VkVmFyaWFibGVzUnVsZSgpO1xuICAgIGluaXRfT3ZlcmxhcHBpbmdGaWVsZHNDYW5CZU1lcmdlZFJ1bGUoKTtcbiAgICBpbml0X1Bvc3NpYmxlRnJhZ21lbnRTcHJlYWRzUnVsZSgpO1xuICAgIGluaXRfUHJvdmlkZWRSZXF1aXJlZEFyZ3VtZW50c1J1bGUoKTtcbiAgICBpbml0X1NjYWxhckxlYWZzUnVsZSgpO1xuICAgIGluaXRfU2luZ2xlRmllbGRTdWJzY3JpcHRpb25zUnVsZSgpO1xuICAgIGluaXRfVW5pcXVlQXJndW1lbnROYW1lc1J1bGUoKTtcbiAgICBpbml0X1VuaXF1ZURpcmVjdGl2ZXNQZXJMb2NhdGlvblJ1bGUoKTtcbiAgICBpbml0X1VuaXF1ZUZyYWdtZW50TmFtZXNSdWxlKCk7XG4gICAgaW5pdF9VbmlxdWVJbnB1dEZpZWxkTmFtZXNSdWxlKCk7XG4gICAgaW5pdF9VbmlxdWVPcGVyYXRpb25OYW1lc1J1bGUoKTtcbiAgICBpbml0X1VuaXF1ZVZhcmlhYmxlTmFtZXNSdWxlKCk7XG4gICAgaW5pdF9WYWx1ZXNPZkNvcnJlY3RUeXBlUnVsZSgpO1xuICAgIGluaXRfVmFyaWFibGVzQXJlSW5wdXRUeXBlc1J1bGUoKTtcbiAgICBpbml0X1ZhcmlhYmxlc0luQWxsb3dlZFBvc2l0aW9uUnVsZSgpO1xuICAgIGluaXRfTG9uZVNjaGVtYURlZmluaXRpb25SdWxlKCk7XG4gICAgaW5pdF9VbmlxdWVPcGVyYXRpb25UeXBlc1J1bGUoKTtcbiAgICBpbml0X1VuaXF1ZVR5cGVOYW1lc1J1bGUoKTtcbiAgICBpbml0X1VuaXF1ZUVudW1WYWx1ZU5hbWVzUnVsZSgpO1xuICAgIGluaXRfVW5pcXVlRmllbGREZWZpbml0aW9uTmFtZXNSdWxlKCk7XG4gICAgaW5pdF9VbmlxdWVBcmd1bWVudERlZmluaXRpb25OYW1lc1J1bGUoKTtcbiAgICBpbml0X1VuaXF1ZURpcmVjdGl2ZU5hbWVzUnVsZSgpO1xuICAgIGluaXRfUG9zc2libGVUeXBlRXh0ZW5zaW9uc1J1bGUoKTtcbiAgICBpbml0X05vRGVwcmVjYXRlZEN1c3RvbVJ1bGUoKTtcbiAgICBpbml0X05vU2NoZW1hSW50cm9zcGVjdGlvbkN1c3RvbVJ1bGUoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2Vycm9yL2luZGV4Lm1qc1xudmFyIGluaXRfZXJyb3IgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvZXJyb3IvaW5kZXgubWpzXCIoKSB7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgICBpbml0X3N5bnRheEVycm9yKCk7XG4gICAgaW5pdF9sb2NhdGVkRXJyb3IoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9nZXRJbnRyb3NwZWN0aW9uUXVlcnkubWpzXG5mdW5jdGlvbiBnZXRJbnRyb3NwZWN0aW9uUXVlcnkob3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zV2l0aERlZmF1bHQgPSB7XG4gICAgZGVzY3JpcHRpb25zOiB0cnVlLFxuICAgIHNwZWNpZmllZEJ5VXJsOiBmYWxzZSxcbiAgICBkaXJlY3RpdmVJc1JlcGVhdGFibGU6IGZhbHNlLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uOiBmYWxzZSxcbiAgICBpbnB1dFZhbHVlRGVwcmVjYXRpb246IGZhbHNlLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3QgZGVzY3JpcHRpb25zID0gb3B0aW9uc1dpdGhEZWZhdWx0LmRlc2NyaXB0aW9ucyA/IFwiZGVzY3JpcHRpb25cIiA6IFwiXCI7XG4gIGNvbnN0IHNwZWNpZmllZEJ5VXJsID0gb3B0aW9uc1dpdGhEZWZhdWx0LnNwZWNpZmllZEJ5VXJsID8gXCJzcGVjaWZpZWRCeVVSTFwiIDogXCJcIjtcbiAgY29uc3QgZGlyZWN0aXZlSXNSZXBlYXRhYmxlID0gb3B0aW9uc1dpdGhEZWZhdWx0LmRpcmVjdGl2ZUlzUmVwZWF0YWJsZSA/IFwiaXNSZXBlYXRhYmxlXCIgOiBcIlwiO1xuICBjb25zdCBzY2hlbWFEZXNjcmlwdGlvbiA9IG9wdGlvbnNXaXRoRGVmYXVsdC5zY2hlbWFEZXNjcmlwdGlvbiA/IGRlc2NyaXB0aW9ucyA6IFwiXCI7XG4gIGZ1bmN0aW9uIGlucHV0RGVwcmVjYXRpb24oc3RyKSB7XG4gICAgcmV0dXJuIG9wdGlvbnNXaXRoRGVmYXVsdC5pbnB1dFZhbHVlRGVwcmVjYXRpb24gPyBzdHIgOiBcIlwiO1xuICB9XG4gIHJldHVybiBgXG4gICAgcXVlcnkgSW50cm9zcGVjdGlvblF1ZXJ5IHtcbiAgICAgIF9fc2NoZW1hIHtcbiAgICAgICAgJHtzY2hlbWFEZXNjcmlwdGlvbn1cbiAgICAgICAgcXVlcnlUeXBlIHsgbmFtZSB9XG4gICAgICAgIG11dGF0aW9uVHlwZSB7IG5hbWUgfVxuICAgICAgICBzdWJzY3JpcHRpb25UeXBlIHsgbmFtZSB9XG4gICAgICAgIHR5cGVzIHtcbiAgICAgICAgICAuLi5GdWxsVHlwZVxuICAgICAgICB9XG4gICAgICAgIGRpcmVjdGl2ZXMge1xuICAgICAgICAgIG5hbWVcbiAgICAgICAgICAke2Rlc2NyaXB0aW9uc31cbiAgICAgICAgICAke2RpcmVjdGl2ZUlzUmVwZWF0YWJsZX1cbiAgICAgICAgICBsb2NhdGlvbnNcbiAgICAgICAgICBhcmdzJHtpbnB1dERlcHJlY2F0aW9uKFwiKGluY2x1ZGVEZXByZWNhdGVkOiB0cnVlKVwiKX0ge1xuICAgICAgICAgICAgLi4uSW5wdXRWYWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZyYWdtZW50IEZ1bGxUeXBlIG9uIF9fVHlwZSB7XG4gICAgICBraW5kXG4gICAgICBuYW1lXG4gICAgICAke2Rlc2NyaXB0aW9uc31cbiAgICAgICR7c3BlY2lmaWVkQnlVcmx9XG4gICAgICBmaWVsZHMoaW5jbHVkZURlcHJlY2F0ZWQ6IHRydWUpIHtcbiAgICAgICAgbmFtZVxuICAgICAgICAke2Rlc2NyaXB0aW9uc31cbiAgICAgICAgYXJncyR7aW5wdXREZXByZWNhdGlvbihcIihpbmNsdWRlRGVwcmVjYXRlZDogdHJ1ZSlcIil9IHtcbiAgICAgICAgICAuLi5JbnB1dFZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgdHlwZSB7XG4gICAgICAgICAgLi4uVHlwZVJlZlxuICAgICAgICB9XG4gICAgICAgIGlzRGVwcmVjYXRlZFxuICAgICAgICBkZXByZWNhdGlvblJlYXNvblxuICAgICAgfVxuICAgICAgaW5wdXRGaWVsZHMke2lucHV0RGVwcmVjYXRpb24oXCIoaW5jbHVkZURlcHJlY2F0ZWQ6IHRydWUpXCIpfSB7XG4gICAgICAgIC4uLklucHV0VmFsdWVcbiAgICAgIH1cbiAgICAgIGludGVyZmFjZXMge1xuICAgICAgICAuLi5UeXBlUmVmXG4gICAgICB9XG4gICAgICBlbnVtVmFsdWVzKGluY2x1ZGVEZXByZWNhdGVkOiB0cnVlKSB7XG4gICAgICAgIG5hbWVcbiAgICAgICAgJHtkZXNjcmlwdGlvbnN9XG4gICAgICAgIGlzRGVwcmVjYXRlZFxuICAgICAgICBkZXByZWNhdGlvblJlYXNvblxuICAgICAgfVxuICAgICAgcG9zc2libGVUeXBlcyB7XG4gICAgICAgIC4uLlR5cGVSZWZcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmcmFnbWVudCBJbnB1dFZhbHVlIG9uIF9fSW5wdXRWYWx1ZSB7XG4gICAgICBuYW1lXG4gICAgICAke2Rlc2NyaXB0aW9uc31cbiAgICAgIHR5cGUgeyAuLi5UeXBlUmVmIH1cbiAgICAgIGRlZmF1bHRWYWx1ZVxuICAgICAgJHtpbnB1dERlcHJlY2F0aW9uKFwiaXNEZXByZWNhdGVkXCIpfVxuICAgICAgJHtpbnB1dERlcHJlY2F0aW9uKFwiZGVwcmVjYXRpb25SZWFzb25cIil9XG4gICAgfVxuXG4gICAgZnJhZ21lbnQgVHlwZVJlZiBvbiBfX1R5cGUge1xuICAgICAga2luZFxuICAgICAgbmFtZVxuICAgICAgb2ZUeXBlIHtcbiAgICAgICAga2luZFxuICAgICAgICBuYW1lXG4gICAgICAgIG9mVHlwZSB7XG4gICAgICAgICAga2luZFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgICBvZlR5cGUge1xuICAgICAgICAgICAga2luZFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgb2ZUeXBlIHtcbiAgICAgICAgICAgICAga2luZFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgIG9mVHlwZSB7XG4gICAgICAgICAgICAgICAga2luZFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICBvZlR5cGUge1xuICAgICAgICAgICAgICAgICAga2luZFxuICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgb2ZUeXBlIHtcbiAgICAgICAgICAgICAgICAgICAga2luZFxuICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICAgIG9mVHlwZSB7XG4gICAgICAgICAgICAgICAgICAgICAga2luZFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICBvZlR5cGUge1xuICAgICAgICAgICAgICAgICAgICAgICAga2luZFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgYDtcbn1cbnZhciBpbml0X2dldEludHJvc3BlY3Rpb25RdWVyeSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvZ2V0SW50cm9zcGVjdGlvblF1ZXJ5Lm1qc1wiKCkge1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdXRpbGl0aWVzL2dldE9wZXJhdGlvbkFTVC5tanNcbmZ1bmN0aW9uIGdldE9wZXJhdGlvbkFTVChkb2N1bWVudEFTVCwgb3BlcmF0aW9uTmFtZSkge1xuICBsZXQgb3BlcmF0aW9uID0gbnVsbDtcbiAgZm9yIChjb25zdCBkZWZpbml0aW9uIG9mIGRvY3VtZW50QVNULmRlZmluaXRpb25zKSB7XG4gICAgaWYgKGRlZmluaXRpb24ua2luZCA9PT0gS2luZC5PUEVSQVRJT05fREVGSU5JVElPTikge1xuICAgICAgdmFyIF9kZWZpbml0aW9uJG5hbWU7XG4gICAgICBpZiAob3BlcmF0aW9uTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBvcGVyYXRpb24gPSBkZWZpbml0aW9uO1xuICAgICAgfSBlbHNlIGlmICgoKF9kZWZpbml0aW9uJG5hbWUgPSBkZWZpbml0aW9uLm5hbWUpID09PSBudWxsIHx8IF9kZWZpbml0aW9uJG5hbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kZWZpbml0aW9uJG5hbWUudmFsdWUpID09PSBvcGVyYXRpb25OYW1lKSB7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3BlcmF0aW9uO1xufVxudmFyIGluaXRfZ2V0T3BlcmF0aW9uQVNUID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9nZXRPcGVyYXRpb25BU1QubWpzXCIoKSB7XG4gICAgaW5pdF9raW5kcygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdXRpbGl0aWVzL2dldE9wZXJhdGlvblJvb3RUeXBlLm1qc1xuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uUm9vdFR5cGUoc2NoZW1hLCBvcGVyYXRpb24pIHtcbiAgaWYgKG9wZXJhdGlvbi5vcGVyYXRpb24gPT09IFwicXVlcnlcIikge1xuICAgIGNvbnN0IHF1ZXJ5VHlwZSA9IHNjaGVtYS5nZXRRdWVyeVR5cGUoKTtcbiAgICBpZiAoIXF1ZXJ5VHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgXCJTY2hlbWEgZG9lcyBub3QgZGVmaW5lIHRoZSByZXF1aXJlZCBxdWVyeSByb290IHR5cGUuXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBub2Rlczogb3BlcmF0aW9uXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeVR5cGU7XG4gIH1cbiAgaWYgKG9wZXJhdGlvbi5vcGVyYXRpb24gPT09IFwibXV0YXRpb25cIikge1xuICAgIGNvbnN0IG11dGF0aW9uVHlwZSA9IHNjaGVtYS5nZXRNdXRhdGlvblR5cGUoKTtcbiAgICBpZiAoIW11dGF0aW9uVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihcIlNjaGVtYSBpcyBub3QgY29uZmlndXJlZCBmb3IgbXV0YXRpb25zLlwiLCB7XG4gICAgICAgIG5vZGVzOiBvcGVyYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbXV0YXRpb25UeXBlO1xuICB9XG4gIGlmIChvcGVyYXRpb24ub3BlcmF0aW9uID09PSBcInN1YnNjcmlwdGlvblwiKSB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uVHlwZSA9IHNjaGVtYS5nZXRTdWJzY3JpcHRpb25UeXBlKCk7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25UeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFwiU2NoZW1hIGlzIG5vdCBjb25maWd1cmVkIGZvciBzdWJzY3JpcHRpb25zLlwiLCB7XG4gICAgICAgIG5vZGVzOiBvcGVyYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uVHlwZTtcbiAgfVxuICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgIFwiQ2FuIG9ubHkgaGF2ZSBxdWVyeSwgbXV0YXRpb24gYW5kIHN1YnNjcmlwdGlvbiBvcGVyYXRpb25zLlwiLFxuICAgIHtcbiAgICAgIG5vZGVzOiBvcGVyYXRpb25cbiAgICB9XG4gICk7XG59XG52YXIgaW5pdF9nZXRPcGVyYXRpb25Sb290VHlwZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvZ2V0T3BlcmF0aW9uUm9vdFR5cGUubWpzXCIoKSB7XG4gICAgaW5pdF9HcmFwaFFMRXJyb3IoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9pbnRyb3NwZWN0aW9uRnJvbVNjaGVtYS5tanNcbmZ1bmN0aW9uIGludHJvc3BlY3Rpb25Gcm9tU2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zV2l0aERlZmF1bHRzID0ge1xuICAgIHNwZWNpZmllZEJ5VXJsOiB0cnVlLFxuICAgIGRpcmVjdGl2ZUlzUmVwZWF0YWJsZTogdHJ1ZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbjogdHJ1ZSxcbiAgICBpbnB1dFZhbHVlRGVwcmVjYXRpb246IHRydWUsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBkb2N1bWVudCA9IHBhcnNlKGdldEludHJvc3BlY3Rpb25RdWVyeShvcHRpb25zV2l0aERlZmF1bHRzKSk7XG4gIGNvbnN0IHJlc3VsdCA9IGV4ZWN1dGVTeW5jKHtcbiAgICBzY2hlbWEsXG4gICAgZG9jdW1lbnRcbiAgfSk7XG4gICFyZXN1bHQuZXJyb3JzICYmIHJlc3VsdC5kYXRhIHx8IGludmFyaWFudChmYWxzZSk7XG4gIHJldHVybiByZXN1bHQuZGF0YTtcbn1cbnZhciBpbml0X2ludHJvc3BlY3Rpb25Gcm9tU2NoZW1hID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9pbnRyb3NwZWN0aW9uRnJvbVNjaGVtYS5tanNcIigpIHtcbiAgICBpbml0X2ludmFyaWFudCgpO1xuICAgIGluaXRfcGFyc2VyKCk7XG4gICAgaW5pdF9leGVjdXRlKCk7XG4gICAgaW5pdF9nZXRJbnRyb3NwZWN0aW9uUXVlcnkoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9idWlsZENsaWVudFNjaGVtYS5tanNcbmZ1bmN0aW9uIGJ1aWxkQ2xpZW50U2NoZW1hKGludHJvc3BlY3Rpb24sIG9wdGlvbnMpIHtcbiAgaXNPYmplY3RMaWtlKGludHJvc3BlY3Rpb24pICYmIGlzT2JqZWN0TGlrZShpbnRyb3NwZWN0aW9uLl9fc2NoZW1hKSB8fCBkZXZBc3NlcnQoXG4gICAgZmFsc2UsXG4gICAgYEludmFsaWQgb3IgaW5jb21wbGV0ZSBpbnRyb3NwZWN0aW9uIHJlc3VsdC4gRW5zdXJlIHRoYXQgeW91IGFyZSBwYXNzaW5nIFwiZGF0YVwiIHByb3BlcnR5IG9mIGludHJvc3BlY3Rpb24gcmVzcG9uc2UgYW5kIG5vIFwiZXJyb3JzXCIgd2FzIHJldHVybmVkIGFsb25nc2lkZTogJHtpbnNwZWN0KFxuICAgICAgaW50cm9zcGVjdGlvblxuICAgICl9LmBcbiAgKTtcbiAgY29uc3Qgc2NoZW1hSW50cm9zcGVjdGlvbiA9IGludHJvc3BlY3Rpb24uX19zY2hlbWE7XG4gIGNvbnN0IHR5cGVNYXAgPSBrZXlWYWxNYXAoXG4gICAgc2NoZW1hSW50cm9zcGVjdGlvbi50eXBlcyxcbiAgICAodHlwZUludHJvc3BlY3Rpb24pID0+IHR5cGVJbnRyb3NwZWN0aW9uLm5hbWUsXG4gICAgKHR5cGVJbnRyb3NwZWN0aW9uKSA9PiBidWlsZFR5cGUodHlwZUludHJvc3BlY3Rpb24pXG4gICk7XG4gIGZvciAoY29uc3Qgc3RkVHlwZSBvZiBbLi4uc3BlY2lmaWVkU2NhbGFyVHlwZXMsIC4uLmludHJvc3BlY3Rpb25UeXBlc10pIHtcbiAgICBpZiAodHlwZU1hcFtzdGRUeXBlLm5hbWVdKSB7XG4gICAgICB0eXBlTWFwW3N0ZFR5cGUubmFtZV0gPSBzdGRUeXBlO1xuICAgIH1cbiAgfVxuICBjb25zdCBxdWVyeVR5cGUgPSBzY2hlbWFJbnRyb3NwZWN0aW9uLnF1ZXJ5VHlwZSA/IGdldE9iamVjdFR5cGUoc2NoZW1hSW50cm9zcGVjdGlvbi5xdWVyeVR5cGUpIDogbnVsbDtcbiAgY29uc3QgbXV0YXRpb25UeXBlID0gc2NoZW1hSW50cm9zcGVjdGlvbi5tdXRhdGlvblR5cGUgPyBnZXRPYmplY3RUeXBlKHNjaGVtYUludHJvc3BlY3Rpb24ubXV0YXRpb25UeXBlKSA6IG51bGw7XG4gIGNvbnN0IHN1YnNjcmlwdGlvblR5cGUgPSBzY2hlbWFJbnRyb3NwZWN0aW9uLnN1YnNjcmlwdGlvblR5cGUgPyBnZXRPYmplY3RUeXBlKHNjaGVtYUludHJvc3BlY3Rpb24uc3Vic2NyaXB0aW9uVHlwZSkgOiBudWxsO1xuICBjb25zdCBkaXJlY3RpdmVzID0gc2NoZW1hSW50cm9zcGVjdGlvbi5kaXJlY3RpdmVzID8gc2NoZW1hSW50cm9zcGVjdGlvbi5kaXJlY3RpdmVzLm1hcChidWlsZERpcmVjdGl2ZSkgOiBbXTtcbiAgcmV0dXJuIG5ldyBHcmFwaFFMU2NoZW1hKHtcbiAgICBkZXNjcmlwdGlvbjogc2NoZW1hSW50cm9zcGVjdGlvbi5kZXNjcmlwdGlvbixcbiAgICBxdWVyeTogcXVlcnlUeXBlLFxuICAgIG11dGF0aW9uOiBtdXRhdGlvblR5cGUsXG4gICAgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb25UeXBlLFxuICAgIHR5cGVzOiBPYmplY3QudmFsdWVzKHR5cGVNYXApLFxuICAgIGRpcmVjdGl2ZXMsXG4gICAgYXNzdW1lVmFsaWQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hc3N1bWVWYWxpZFxuICB9KTtcbiAgZnVuY3Rpb24gZ2V0VHlwZSh0eXBlUmVmKSB7XG4gICAgaWYgKHR5cGVSZWYua2luZCA9PT0gVHlwZUtpbmQuTElTVCkge1xuICAgICAgY29uc3QgaXRlbVJlZiA9IHR5cGVSZWYub2ZUeXBlO1xuICAgICAgaWYgKCFpdGVtUmVmKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlY29yYXRlZCB0eXBlIGRlZXBlciB0aGFuIGludHJvc3BlY3Rpb24gcXVlcnkuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBHcmFwaFFMTGlzdChnZXRUeXBlKGl0ZW1SZWYpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVSZWYua2luZCA9PT0gVHlwZUtpbmQuTk9OX05VTEwpIHtcbiAgICAgIGNvbnN0IG51bGxhYmxlUmVmID0gdHlwZVJlZi5vZlR5cGU7XG4gICAgICBpZiAoIW51bGxhYmxlUmVmKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlY29yYXRlZCB0eXBlIGRlZXBlciB0aGFuIGludHJvc3BlY3Rpb24gcXVlcnkuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbnVsbGFibGVUeXBlID0gZ2V0VHlwZShudWxsYWJsZVJlZik7XG4gICAgICByZXR1cm4gbmV3IEdyYXBoUUxOb25OdWxsKGFzc2VydE51bGxhYmxlVHlwZShudWxsYWJsZVR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldE5hbWVkVHlwZTIodHlwZVJlZik7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TmFtZWRUeXBlMih0eXBlUmVmKSB7XG4gICAgY29uc3QgdHlwZU5hbWUgPSB0eXBlUmVmLm5hbWU7XG4gICAgaWYgKCF0eXBlTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHR5cGUgcmVmZXJlbmNlOiAke2luc3BlY3QodHlwZVJlZil9LmApO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdHlwZU1hcFt0eXBlTmFtZV07XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIG9yIGluY29tcGxldGUgc2NoZW1hLCB1bmtub3duIHR5cGU6ICR7dHlwZU5hbWV9LiBFbnN1cmUgdGhhdCBhIGZ1bGwgaW50cm9zcGVjdGlvbiBxdWVyeSBpcyB1c2VkIGluIG9yZGVyIHRvIGJ1aWxkIGEgY2xpZW50IHNjaGVtYS5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRPYmplY3RUeXBlKHR5cGVSZWYpIHtcbiAgICByZXR1cm4gYXNzZXJ0T2JqZWN0VHlwZShnZXROYW1lZFR5cGUyKHR5cGVSZWYpKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRJbnRlcmZhY2VUeXBlKHR5cGVSZWYpIHtcbiAgICByZXR1cm4gYXNzZXJ0SW50ZXJmYWNlVHlwZShnZXROYW1lZFR5cGUyKHR5cGVSZWYpKTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZFR5cGUodHlwZSkge1xuICAgIGlmICh0eXBlICE9IG51bGwgJiYgdHlwZS5uYW1lICE9IG51bGwgJiYgdHlwZS5raW5kICE9IG51bGwpIHtcbiAgICAgIHN3aXRjaCAodHlwZS5raW5kKSB7XG4gICAgICAgIGNhc2UgVHlwZUtpbmQuU0NBTEFSOlxuICAgICAgICAgIHJldHVybiBidWlsZFNjYWxhckRlZih0eXBlKTtcbiAgICAgICAgY2FzZSBUeXBlS2luZC5PQkpFQ1Q6XG4gICAgICAgICAgcmV0dXJuIGJ1aWxkT2JqZWN0RGVmKHR5cGUpO1xuICAgICAgICBjYXNlIFR5cGVLaW5kLklOVEVSRkFDRTpcbiAgICAgICAgICByZXR1cm4gYnVpbGRJbnRlcmZhY2VEZWYodHlwZSk7XG4gICAgICAgIGNhc2UgVHlwZUtpbmQuVU5JT046XG4gICAgICAgICAgcmV0dXJuIGJ1aWxkVW5pb25EZWYodHlwZSk7XG4gICAgICAgIGNhc2UgVHlwZUtpbmQuRU5VTTpcbiAgICAgICAgICByZXR1cm4gYnVpbGRFbnVtRGVmKHR5cGUpO1xuICAgICAgICBjYXNlIFR5cGVLaW5kLklOUFVUX09CSkVDVDpcbiAgICAgICAgICByZXR1cm4gYnVpbGRJbnB1dE9iamVjdERlZih0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHlwZVN0ciA9IGluc3BlY3QodHlwZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgb3IgaW5jb21wbGV0ZSBpbnRyb3NwZWN0aW9uIHJlc3VsdC4gRW5zdXJlIHRoYXQgYSBmdWxsIGludHJvc3BlY3Rpb24gcXVlcnkgaXMgdXNlZCBpbiBvcmRlciB0byBidWlsZCBhIGNsaWVudCBzY2hlbWE6ICR7dHlwZVN0cn0uYFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRTY2FsYXJEZWYoc2NhbGFySW50cm9zcGVjdGlvbikge1xuICAgIHJldHVybiBuZXcgR3JhcGhRTFNjYWxhclR5cGUoe1xuICAgICAgbmFtZTogc2NhbGFySW50cm9zcGVjdGlvbi5uYW1lLFxuICAgICAgZGVzY3JpcHRpb246IHNjYWxhckludHJvc3BlY3Rpb24uZGVzY3JpcHRpb24sXG4gICAgICBzcGVjaWZpZWRCeVVSTDogc2NhbGFySW50cm9zcGVjdGlvbi5zcGVjaWZpZWRCeVVSTFxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkSW1wbGVtZW50YXRpb25zTGlzdChpbXBsZW1lbnRpbmdJbnRyb3NwZWN0aW9uKSB7XG4gICAgaWYgKGltcGxlbWVudGluZ0ludHJvc3BlY3Rpb24uaW50ZXJmYWNlcyA9PT0gbnVsbCAmJiBpbXBsZW1lbnRpbmdJbnRyb3NwZWN0aW9uLmtpbmQgPT09IFR5cGVLaW5kLklOVEVSRkFDRSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoIWltcGxlbWVudGluZ0ludHJvc3BlY3Rpb24uaW50ZXJmYWNlcykge1xuICAgICAgY29uc3QgaW1wbGVtZW50aW5nSW50cm9zcGVjdGlvblN0ciA9IGluc3BlY3QoaW1wbGVtZW50aW5nSW50cm9zcGVjdGlvbik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnRyb3NwZWN0aW9uIHJlc3VsdCBtaXNzaW5nIGludGVyZmFjZXM6ICR7aW1wbGVtZW50aW5nSW50cm9zcGVjdGlvblN0cn0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGltcGxlbWVudGluZ0ludHJvc3BlY3Rpb24uaW50ZXJmYWNlcy5tYXAoZ2V0SW50ZXJmYWNlVHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRPYmplY3REZWYob2JqZWN0SW50cm9zcGVjdGlvbikge1xuICAgIHJldHVybiBuZXcgR3JhcGhRTE9iamVjdFR5cGUoe1xuICAgICAgbmFtZTogb2JqZWN0SW50cm9zcGVjdGlvbi5uYW1lLFxuICAgICAgZGVzY3JpcHRpb246IG9iamVjdEludHJvc3BlY3Rpb24uZGVzY3JpcHRpb24sXG4gICAgICBpbnRlcmZhY2VzOiAoKSA9PiBidWlsZEltcGxlbWVudGF0aW9uc0xpc3Qob2JqZWN0SW50cm9zcGVjdGlvbiksXG4gICAgICBmaWVsZHM6ICgpID0+IGJ1aWxkRmllbGREZWZNYXAob2JqZWN0SW50cm9zcGVjdGlvbilcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZEludGVyZmFjZURlZihpbnRlcmZhY2VJbnRyb3NwZWN0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBHcmFwaFFMSW50ZXJmYWNlVHlwZSh7XG4gICAgICBuYW1lOiBpbnRlcmZhY2VJbnRyb3NwZWN0aW9uLm5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogaW50ZXJmYWNlSW50cm9zcGVjdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgIGludGVyZmFjZXM6ICgpID0+IGJ1aWxkSW1wbGVtZW50YXRpb25zTGlzdChpbnRlcmZhY2VJbnRyb3NwZWN0aW9uKSxcbiAgICAgIGZpZWxkczogKCkgPT4gYnVpbGRGaWVsZERlZk1hcChpbnRlcmZhY2VJbnRyb3NwZWN0aW9uKVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkVW5pb25EZWYodW5pb25JbnRyb3NwZWN0aW9uKSB7XG4gICAgaWYgKCF1bmlvbkludHJvc3BlY3Rpb24ucG9zc2libGVUeXBlcykge1xuICAgICAgY29uc3QgdW5pb25JbnRyb3NwZWN0aW9uU3RyID0gaW5zcGVjdCh1bmlvbkludHJvc3BlY3Rpb24pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW50cm9zcGVjdGlvbiByZXN1bHQgbWlzc2luZyBwb3NzaWJsZVR5cGVzOiAke3VuaW9uSW50cm9zcGVjdGlvblN0cn0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBHcmFwaFFMVW5pb25UeXBlKHtcbiAgICAgIG5hbWU6IHVuaW9uSW50cm9zcGVjdGlvbi5uYW1lLFxuICAgICAgZGVzY3JpcHRpb246IHVuaW9uSW50cm9zcGVjdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgIHR5cGVzOiAoKSA9PiB1bmlvbkludHJvc3BlY3Rpb24ucG9zc2libGVUeXBlcy5tYXAoZ2V0T2JqZWN0VHlwZSlcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZEVudW1EZWYoZW51bUludHJvc3BlY3Rpb24pIHtcbiAgICBpZiAoIWVudW1JbnRyb3NwZWN0aW9uLmVudW1WYWx1ZXMpIHtcbiAgICAgIGNvbnN0IGVudW1JbnRyb3NwZWN0aW9uU3RyID0gaW5zcGVjdChlbnVtSW50cm9zcGVjdGlvbik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnRyb3NwZWN0aW9uIHJlc3VsdCBtaXNzaW5nIGVudW1WYWx1ZXM6ICR7ZW51bUludHJvc3BlY3Rpb25TdHJ9LmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgR3JhcGhRTEVudW1UeXBlKHtcbiAgICAgIG5hbWU6IGVudW1JbnRyb3NwZWN0aW9uLm5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogZW51bUludHJvc3BlY3Rpb24uZGVzY3JpcHRpb24sXG4gICAgICB2YWx1ZXM6IGtleVZhbE1hcChcbiAgICAgICAgZW51bUludHJvc3BlY3Rpb24uZW51bVZhbHVlcyxcbiAgICAgICAgKHZhbHVlSW50cm9zcGVjdGlvbikgPT4gdmFsdWVJbnRyb3NwZWN0aW9uLm5hbWUsXG4gICAgICAgICh2YWx1ZUludHJvc3BlY3Rpb24pID0+ICh7XG4gICAgICAgICAgZGVzY3JpcHRpb246IHZhbHVlSW50cm9zcGVjdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgICAgICBkZXByZWNhdGlvblJlYXNvbjogdmFsdWVJbnRyb3NwZWN0aW9uLmRlcHJlY2F0aW9uUmVhc29uXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRJbnB1dE9iamVjdERlZihpbnB1dE9iamVjdEludHJvc3BlY3Rpb24pIHtcbiAgICBpZiAoIWlucHV0T2JqZWN0SW50cm9zcGVjdGlvbi5pbnB1dEZpZWxkcykge1xuICAgICAgY29uc3QgaW5wdXRPYmplY3RJbnRyb3NwZWN0aW9uU3RyID0gaW5zcGVjdChpbnB1dE9iamVjdEludHJvc3BlY3Rpb24pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW50cm9zcGVjdGlvbiByZXN1bHQgbWlzc2luZyBpbnB1dEZpZWxkczogJHtpbnB1dE9iamVjdEludHJvc3BlY3Rpb25TdHJ9LmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgR3JhcGhRTElucHV0T2JqZWN0VHlwZSh7XG4gICAgICBuYW1lOiBpbnB1dE9iamVjdEludHJvc3BlY3Rpb24ubmFtZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBpbnB1dE9iamVjdEludHJvc3BlY3Rpb24uZGVzY3JpcHRpb24sXG4gICAgICBmaWVsZHM6ICgpID0+IGJ1aWxkSW5wdXRWYWx1ZURlZk1hcChpbnB1dE9iamVjdEludHJvc3BlY3Rpb24uaW5wdXRGaWVsZHMpXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRGaWVsZERlZk1hcCh0eXBlSW50cm9zcGVjdGlvbikge1xuICAgIGlmICghdHlwZUludHJvc3BlY3Rpb24uZmllbGRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnRyb3NwZWN0aW9uIHJlc3VsdCBtaXNzaW5nIGZpZWxkczogJHtpbnNwZWN0KHR5cGVJbnRyb3NwZWN0aW9uKX0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVZhbE1hcChcbiAgICAgIHR5cGVJbnRyb3NwZWN0aW9uLmZpZWxkcyxcbiAgICAgIChmaWVsZEludHJvc3BlY3Rpb24pID0+IGZpZWxkSW50cm9zcGVjdGlvbi5uYW1lLFxuICAgICAgYnVpbGRGaWVsZFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRGaWVsZChmaWVsZEludHJvc3BlY3Rpb24pIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0VHlwZShmaWVsZEludHJvc3BlY3Rpb24udHlwZSk7XG4gICAgaWYgKCFpc091dHB1dFR5cGUodHlwZSkpIHtcbiAgICAgIGNvbnN0IHR5cGVTdHIgPSBpbnNwZWN0KHR5cGUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW50cm9zcGVjdGlvbiBtdXN0IHByb3ZpZGUgb3V0cHV0IHR5cGUgZm9yIGZpZWxkcywgYnV0IHJlY2VpdmVkOiAke3R5cGVTdHJ9LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghZmllbGRJbnRyb3NwZWN0aW9uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IGZpZWxkSW50cm9zcGVjdGlvblN0ciA9IGluc3BlY3QoZmllbGRJbnRyb3NwZWN0aW9uKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludHJvc3BlY3Rpb24gcmVzdWx0IG1pc3NpbmcgZmllbGQgYXJnczogJHtmaWVsZEludHJvc3BlY3Rpb25TdHJ9LmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkZXNjcmlwdGlvbjogZmllbGRJbnRyb3NwZWN0aW9uLmRlc2NyaXB0aW9uLFxuICAgICAgZGVwcmVjYXRpb25SZWFzb246IGZpZWxkSW50cm9zcGVjdGlvbi5kZXByZWNhdGlvblJlYXNvbixcbiAgICAgIHR5cGUsXG4gICAgICBhcmdzOiBidWlsZElucHV0VmFsdWVEZWZNYXAoZmllbGRJbnRyb3NwZWN0aW9uLmFyZ3MpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZElucHV0VmFsdWVEZWZNYXAoaW5wdXRWYWx1ZUludHJvc3BlY3Rpb25zKSB7XG4gICAgcmV0dXJuIGtleVZhbE1hcChcbiAgICAgIGlucHV0VmFsdWVJbnRyb3NwZWN0aW9ucyxcbiAgICAgIChpbnB1dFZhbHVlKSA9PiBpbnB1dFZhbHVlLm5hbWUsXG4gICAgICBidWlsZElucHV0VmFsdWVcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkSW5wdXRWYWx1ZShpbnB1dFZhbHVlSW50cm9zcGVjdGlvbikge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKGlucHV0VmFsdWVJbnRyb3NwZWN0aW9uLnR5cGUpO1xuICAgIGlmICghaXNJbnB1dFR5cGUodHlwZSkpIHtcbiAgICAgIGNvbnN0IHR5cGVTdHIgPSBpbnNwZWN0KHR5cGUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW50cm9zcGVjdGlvbiBtdXN0IHByb3ZpZGUgaW5wdXQgdHlwZSBmb3IgYXJndW1lbnRzLCBidXQgcmVjZWl2ZWQ6ICR7dHlwZVN0cn0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gaW5wdXRWYWx1ZUludHJvc3BlY3Rpb24uZGVmYXVsdFZhbHVlICE9IG51bGwgPyB2YWx1ZUZyb21BU1QocGFyc2VWYWx1ZShpbnB1dFZhbHVlSW50cm9zcGVjdGlvbi5kZWZhdWx0VmFsdWUpLCB0eXBlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4ge1xuICAgICAgZGVzY3JpcHRpb246IGlucHV0VmFsdWVJbnRyb3NwZWN0aW9uLmRlc2NyaXB0aW9uLFxuICAgICAgdHlwZSxcbiAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgIGRlcHJlY2F0aW9uUmVhc29uOiBpbnB1dFZhbHVlSW50cm9zcGVjdGlvbi5kZXByZWNhdGlvblJlYXNvblxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGREaXJlY3RpdmUoZGlyZWN0aXZlSW50cm9zcGVjdGlvbikge1xuICAgIGlmICghZGlyZWN0aXZlSW50cm9zcGVjdGlvbi5hcmdzKSB7XG4gICAgICBjb25zdCBkaXJlY3RpdmVJbnRyb3NwZWN0aW9uU3RyID0gaW5zcGVjdChkaXJlY3RpdmVJbnRyb3NwZWN0aW9uKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludHJvc3BlY3Rpb24gcmVzdWx0IG1pc3NpbmcgZGlyZWN0aXZlIGFyZ3M6ICR7ZGlyZWN0aXZlSW50cm9zcGVjdGlvblN0cn0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFkaXJlY3RpdmVJbnRyb3NwZWN0aW9uLmxvY2F0aW9ucykge1xuICAgICAgY29uc3QgZGlyZWN0aXZlSW50cm9zcGVjdGlvblN0ciA9IGluc3BlY3QoZGlyZWN0aXZlSW50cm9zcGVjdGlvbik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnRyb3NwZWN0aW9uIHJlc3VsdCBtaXNzaW5nIGRpcmVjdGl2ZSBsb2NhdGlvbnM6ICR7ZGlyZWN0aXZlSW50cm9zcGVjdGlvblN0cn0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBHcmFwaFFMRGlyZWN0aXZlKHtcbiAgICAgIG5hbWU6IGRpcmVjdGl2ZUludHJvc3BlY3Rpb24ubmFtZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBkaXJlY3RpdmVJbnRyb3NwZWN0aW9uLmRlc2NyaXB0aW9uLFxuICAgICAgaXNSZXBlYXRhYmxlOiBkaXJlY3RpdmVJbnRyb3NwZWN0aW9uLmlzUmVwZWF0YWJsZSxcbiAgICAgIGxvY2F0aW9uczogZGlyZWN0aXZlSW50cm9zcGVjdGlvbi5sb2NhdGlvbnMuc2xpY2UoKSxcbiAgICAgIGFyZ3M6IGJ1aWxkSW5wdXRWYWx1ZURlZk1hcChkaXJlY3RpdmVJbnRyb3NwZWN0aW9uLmFyZ3MpXG4gICAgfSk7XG4gIH1cbn1cbnZhciBpbml0X2J1aWxkQ2xpZW50U2NoZW1hID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9idWlsZENsaWVudFNjaGVtYS5tanNcIigpIHtcbiAgICBpbml0X2RldkFzc2VydCgpO1xuICAgIGluaXRfaW5zcGVjdCgpO1xuICAgIGluaXRfaXNPYmplY3RMaWtlKCk7XG4gICAgaW5pdF9rZXlWYWxNYXAoKTtcbiAgICBpbml0X3BhcnNlcigpO1xuICAgIGluaXRfZGVmaW5pdGlvbigpO1xuICAgIGluaXRfZGlyZWN0aXZlcygpO1xuICAgIGluaXRfaW50cm9zcGVjdGlvbigpO1xuICAgIGluaXRfc2NhbGFycygpO1xuICAgIGluaXRfc2NoZW1hKCk7XG4gICAgaW5pdF92YWx1ZUZyb21BU1QoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9leHRlbmRTY2hlbWEubWpzXG5mdW5jdGlvbiBleHRlbmRTY2hlbWEoc2NoZW1hLCBkb2N1bWVudEFTVCwgb3B0aW9ucykge1xuICBhc3NlcnRTY2hlbWEoc2NoZW1hKTtcbiAgZG9jdW1lbnRBU1QgIT0gbnVsbCAmJiBkb2N1bWVudEFTVC5raW5kID09PSBLaW5kLkRPQ1VNRU5UIHx8IGRldkFzc2VydChmYWxzZSwgXCJNdXN0IHByb3ZpZGUgdmFsaWQgRG9jdW1lbnQgQVNULlwiKTtcbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXNzdW1lVmFsaWQpICE9PSB0cnVlICYmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXNzdW1lVmFsaWRTREwpICE9PSB0cnVlKSB7XG4gICAgYXNzZXJ0VmFsaWRTRExFeHRlbnNpb24oZG9jdW1lbnRBU1QsIHNjaGVtYSk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hQ29uZmlnID0gc2NoZW1hLnRvQ29uZmlnKCk7XG4gIGNvbnN0IGV4dGVuZGVkQ29uZmlnID0gZXh0ZW5kU2NoZW1hSW1wbChzY2hlbWFDb25maWcsIGRvY3VtZW50QVNULCBvcHRpb25zKTtcbiAgcmV0dXJuIHNjaGVtYUNvbmZpZyA9PT0gZXh0ZW5kZWRDb25maWcgPyBzY2hlbWEgOiBuZXcgR3JhcGhRTFNjaGVtYShleHRlbmRlZENvbmZpZyk7XG59XG5mdW5jdGlvbiBleHRlbmRTY2hlbWFJbXBsKHNjaGVtYUNvbmZpZywgZG9jdW1lbnRBU1QsIG9wdGlvbnMpIHtcbiAgdmFyIF9zY2hlbWFEZWYsIF9zY2hlbWFEZWYkZGVzY3JpcHRpbywgX3NjaGVtYURlZjIsIF9vcHRpb25zJGFzc3VtZVZhbGlkO1xuICBjb25zdCB0eXBlRGVmcyA9IFtdO1xuICBjb25zdCB0eXBlRXh0ZW5zaW9uc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBkaXJlY3RpdmVEZWZzID0gW107XG4gIGxldCBzY2hlbWFEZWY7XG4gIGNvbnN0IHNjaGVtYUV4dGVuc2lvbnMgPSBbXTtcbiAgZm9yIChjb25zdCBkZWYgb2YgZG9jdW1lbnRBU1QuZGVmaW5pdGlvbnMpIHtcbiAgICBpZiAoZGVmLmtpbmQgPT09IEtpbmQuU0NIRU1BX0RFRklOSVRJT04pIHtcbiAgICAgIHNjaGVtYURlZiA9IGRlZjtcbiAgICB9IGVsc2UgaWYgKGRlZi5raW5kID09PSBLaW5kLlNDSEVNQV9FWFRFTlNJT04pIHtcbiAgICAgIHNjaGVtYUV4dGVuc2lvbnMucHVzaChkZWYpO1xuICAgIH0gZWxzZSBpZiAoaXNUeXBlRGVmaW5pdGlvbk5vZGUoZGVmKSkge1xuICAgICAgdHlwZURlZnMucHVzaChkZWYpO1xuICAgIH0gZWxzZSBpZiAoaXNUeXBlRXh0ZW5zaW9uTm9kZShkZWYpKSB7XG4gICAgICBjb25zdCBleHRlbmRlZFR5cGVOYW1lID0gZGVmLm5hbWUudmFsdWU7XG4gICAgICBjb25zdCBleGlzdGluZ1R5cGVFeHRlbnNpb25zID0gdHlwZUV4dGVuc2lvbnNNYXBbZXh0ZW5kZWRUeXBlTmFtZV07XG4gICAgICB0eXBlRXh0ZW5zaW9uc01hcFtleHRlbmRlZFR5cGVOYW1lXSA9IGV4aXN0aW5nVHlwZUV4dGVuc2lvbnMgPyBleGlzdGluZ1R5cGVFeHRlbnNpb25zLmNvbmNhdChbZGVmXSkgOiBbZGVmXTtcbiAgICB9IGVsc2UgaWYgKGRlZi5raW5kID09PSBLaW5kLkRJUkVDVElWRV9ERUZJTklUSU9OKSB7XG4gICAgICBkaXJlY3RpdmVEZWZzLnB1c2goZGVmKTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHR5cGVFeHRlbnNpb25zTWFwKS5sZW5ndGggPT09IDAgJiYgdHlwZURlZnMubGVuZ3RoID09PSAwICYmIGRpcmVjdGl2ZURlZnMubGVuZ3RoID09PSAwICYmIHNjaGVtYUV4dGVuc2lvbnMubGVuZ3RoID09PSAwICYmIHNjaGVtYURlZiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNjaGVtYUNvbmZpZztcbiAgfVxuICBjb25zdCB0eXBlTWFwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgZXhpc3RpbmdUeXBlIG9mIHNjaGVtYUNvbmZpZy50eXBlcykge1xuICAgIHR5cGVNYXBbZXhpc3RpbmdUeXBlLm5hbWVdID0gZXh0ZW5kTmFtZWRUeXBlKGV4aXN0aW5nVHlwZSk7XG4gIH1cbiAgZm9yIChjb25zdCB0eXBlTm9kZSBvZiB0eXBlRGVmcykge1xuICAgIHZhciBfc3RkVHlwZU1hcCRuYW1lO1xuICAgIGNvbnN0IG5hbWUgPSB0eXBlTm9kZS5uYW1lLnZhbHVlO1xuICAgIHR5cGVNYXBbbmFtZV0gPSAoX3N0ZFR5cGVNYXAkbmFtZSA9IHN0ZFR5cGVNYXBbbmFtZV0pICE9PSBudWxsICYmIF9zdGRUeXBlTWFwJG5hbWUgIT09IHZvaWQgMCA/IF9zdGRUeXBlTWFwJG5hbWUgOiBidWlsZFR5cGUodHlwZU5vZGUpO1xuICB9XG4gIGNvbnN0IG9wZXJhdGlvblR5cGVzID0ge1xuICAgIC8vIEdldCB0aGUgZXh0ZW5kZWQgcm9vdCBvcGVyYXRpb24gdHlwZXMuXG4gICAgcXVlcnk6IHNjaGVtYUNvbmZpZy5xdWVyeSAmJiByZXBsYWNlTmFtZWRUeXBlKHNjaGVtYUNvbmZpZy5xdWVyeSksXG4gICAgbXV0YXRpb246IHNjaGVtYUNvbmZpZy5tdXRhdGlvbiAmJiByZXBsYWNlTmFtZWRUeXBlKHNjaGVtYUNvbmZpZy5tdXRhdGlvbiksXG4gICAgc3Vic2NyaXB0aW9uOiBzY2hlbWFDb25maWcuc3Vic2NyaXB0aW9uICYmIHJlcGxhY2VOYW1lZFR5cGUoc2NoZW1hQ29uZmlnLnN1YnNjcmlwdGlvbiksXG4gICAgLy8gVGhlbiwgaW5jb3Jwb3JhdGUgc2NoZW1hIGRlZmluaXRpb24gYW5kIGFsbCBzY2hlbWEgZXh0ZW5zaW9ucy5cbiAgICAuLi5zY2hlbWFEZWYgJiYgZ2V0T3BlcmF0aW9uVHlwZXMoW3NjaGVtYURlZl0pLFxuICAgIC4uLmdldE9wZXJhdGlvblR5cGVzKHNjaGVtYUV4dGVuc2lvbnMpXG4gIH07XG4gIHJldHVybiB7XG4gICAgZGVzY3JpcHRpb246IChfc2NoZW1hRGVmID0gc2NoZW1hRGVmKSA9PT0gbnVsbCB8fCBfc2NoZW1hRGVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NjaGVtYURlZiRkZXNjcmlwdGlvID0gX3NjaGVtYURlZi5kZXNjcmlwdGlvbikgPT09IG51bGwgfHwgX3NjaGVtYURlZiRkZXNjcmlwdGlvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc2NoZW1hRGVmJGRlc2NyaXB0aW8udmFsdWUsXG4gICAgLi4ub3BlcmF0aW9uVHlwZXMsXG4gICAgdHlwZXM6IE9iamVjdC52YWx1ZXModHlwZU1hcCksXG4gICAgZGlyZWN0aXZlczogW1xuICAgICAgLi4uc2NoZW1hQ29uZmlnLmRpcmVjdGl2ZXMubWFwKHJlcGxhY2VEaXJlY3RpdmUpLFxuICAgICAgLi4uZGlyZWN0aXZlRGVmcy5tYXAoYnVpbGREaXJlY3RpdmUpXG4gICAgXSxcbiAgICBleHRlbnNpb25zOiAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBhc3ROb2RlOiAoX3NjaGVtYURlZjIgPSBzY2hlbWFEZWYpICE9PSBudWxsICYmIF9zY2hlbWFEZWYyICE9PSB2b2lkIDAgPyBfc2NoZW1hRGVmMiA6IHNjaGVtYUNvbmZpZy5hc3ROb2RlLFxuICAgIGV4dGVuc2lvbkFTVE5vZGVzOiBzY2hlbWFDb25maWcuZXh0ZW5zaW9uQVNUTm9kZXMuY29uY2F0KHNjaGVtYUV4dGVuc2lvbnMpLFxuICAgIGFzc3VtZVZhbGlkOiAoX29wdGlvbnMkYXNzdW1lVmFsaWQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXNzdW1lVmFsaWQpICE9PSBudWxsICYmIF9vcHRpb25zJGFzc3VtZVZhbGlkICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRhc3N1bWVWYWxpZCA6IGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIHJlcGxhY2VUeXBlKHR5cGUpIHtcbiAgICBpZiAoaXNMaXN0VHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIG5ldyBHcmFwaFFMTGlzdChyZXBsYWNlVHlwZSh0eXBlLm9mVHlwZSkpO1xuICAgIH1cbiAgICBpZiAoaXNOb25OdWxsVHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIG5ldyBHcmFwaFFMTm9uTnVsbChyZXBsYWNlVHlwZSh0eXBlLm9mVHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbGFjZU5hbWVkVHlwZSh0eXBlKTtcbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlTmFtZWRUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZU1hcFt0eXBlLm5hbWVdO1xuICB9XG4gIGZ1bmN0aW9uIHJlcGxhY2VEaXJlY3RpdmUoZGlyZWN0aXZlKSB7XG4gICAgY29uc3QgY29uZmlnID0gZGlyZWN0aXZlLnRvQ29uZmlnKCk7XG4gICAgcmV0dXJuIG5ldyBHcmFwaFFMRGlyZWN0aXZlKHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGFyZ3M6IG1hcFZhbHVlKGNvbmZpZy5hcmdzLCBleHRlbmRBcmcpXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZXh0ZW5kTmFtZWRUeXBlKHR5cGUpIHtcbiAgICBpZiAoaXNJbnRyb3NwZWN0aW9uVHlwZSh0eXBlKSB8fCBpc1NwZWNpZmllZFNjYWxhclR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBpZiAoaXNTY2FsYXJUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kU2NhbGFyVHlwZSh0eXBlKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0VHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIGV4dGVuZE9iamVjdFR5cGUodHlwZSk7XG4gICAgfVxuICAgIGlmIChpc0ludGVyZmFjZVR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiBleHRlbmRJbnRlcmZhY2VUeXBlKHR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNVbmlvblR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiBleHRlbmRVbmlvblR5cGUodHlwZSk7XG4gICAgfVxuICAgIGlmIChpc0VudW1UeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kRW51bVR5cGUodHlwZSk7XG4gICAgfVxuICAgIGlmIChpc0lucHV0T2JqZWN0VHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIGV4dGVuZElucHV0T2JqZWN0VHlwZSh0eXBlKTtcbiAgICB9XG4gICAgaW52YXJpYW50KGZhbHNlLCBcIlVuZXhwZWN0ZWQgdHlwZTogXCIgKyBpbnNwZWN0KHR5cGUpKTtcbiAgfVxuICBmdW5jdGlvbiBleHRlbmRJbnB1dE9iamVjdFR5cGUodHlwZSkge1xuICAgIHZhciBfdHlwZUV4dGVuc2lvbnNNYXAkY287XG4gICAgY29uc3QgY29uZmlnID0gdHlwZS50b0NvbmZpZygpO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSAoX3R5cGVFeHRlbnNpb25zTWFwJGNvID0gdHlwZUV4dGVuc2lvbnNNYXBbY29uZmlnLm5hbWVdKSAhPT0gbnVsbCAmJiBfdHlwZUV4dGVuc2lvbnNNYXAkY28gIT09IHZvaWQgMCA/IF90eXBlRXh0ZW5zaW9uc01hcCRjbyA6IFtdO1xuICAgIHJldHVybiBuZXcgR3JhcGhRTElucHV0T2JqZWN0VHlwZSh7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBmaWVsZHM6ICgpID0+ICh7XG4gICAgICAgIC4uLm1hcFZhbHVlKGNvbmZpZy5maWVsZHMsIChmaWVsZCkgPT4gKHtcbiAgICAgICAgICAuLi5maWVsZCxcbiAgICAgICAgICB0eXBlOiByZXBsYWNlVHlwZShmaWVsZC50eXBlKVxuICAgICAgICB9KSksXG4gICAgICAgIC4uLmJ1aWxkSW5wdXRGaWVsZE1hcChleHRlbnNpb25zKVxuICAgICAgfSksXG4gICAgICBleHRlbnNpb25BU1ROb2RlczogY29uZmlnLmV4dGVuc2lvbkFTVE5vZGVzLmNvbmNhdChleHRlbnNpb25zKVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGV4dGVuZEVudW1UeXBlKHR5cGUpIHtcbiAgICB2YXIgX3R5cGVFeHRlbnNpb25zTWFwJHR5O1xuICAgIGNvbnN0IGNvbmZpZyA9IHR5cGUudG9Db25maWcoKTtcbiAgICBjb25zdCBleHRlbnNpb25zID0gKF90eXBlRXh0ZW5zaW9uc01hcCR0eSA9IHR5cGVFeHRlbnNpb25zTWFwW3R5cGUubmFtZV0pICE9PSBudWxsICYmIF90eXBlRXh0ZW5zaW9uc01hcCR0eSAhPT0gdm9pZCAwID8gX3R5cGVFeHRlbnNpb25zTWFwJHR5IDogW107XG4gICAgcmV0dXJuIG5ldyBHcmFwaFFMRW51bVR5cGUoe1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgdmFsdWVzOiB7IC4uLmNvbmZpZy52YWx1ZXMsIC4uLmJ1aWxkRW51bVZhbHVlTWFwKGV4dGVuc2lvbnMpIH0sXG4gICAgICBleHRlbnNpb25BU1ROb2RlczogY29uZmlnLmV4dGVuc2lvbkFTVE5vZGVzLmNvbmNhdChleHRlbnNpb25zKVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGV4dGVuZFNjYWxhclR5cGUodHlwZSkge1xuICAgIHZhciBfdHlwZUV4dGVuc2lvbnNNYXAkY28yO1xuICAgIGNvbnN0IGNvbmZpZyA9IHR5cGUudG9Db25maWcoKTtcbiAgICBjb25zdCBleHRlbnNpb25zID0gKF90eXBlRXh0ZW5zaW9uc01hcCRjbzIgPSB0eXBlRXh0ZW5zaW9uc01hcFtjb25maWcubmFtZV0pICE9PSBudWxsICYmIF90eXBlRXh0ZW5zaW9uc01hcCRjbzIgIT09IHZvaWQgMCA/IF90eXBlRXh0ZW5zaW9uc01hcCRjbzIgOiBbXTtcbiAgICBsZXQgc3BlY2lmaWVkQnlVUkwgPSBjb25maWcuc3BlY2lmaWVkQnlVUkw7XG4gICAgZm9yIChjb25zdCBleHRlbnNpb25Ob2RlIG9mIGV4dGVuc2lvbnMpIHtcbiAgICAgIHZhciBfZ2V0U3BlY2lmaWVkQnlVUkw7XG4gICAgICBzcGVjaWZpZWRCeVVSTCA9IChfZ2V0U3BlY2lmaWVkQnlVUkwgPSBnZXRTcGVjaWZpZWRCeVVSTChleHRlbnNpb25Ob2RlKSkgIT09IG51bGwgJiYgX2dldFNwZWNpZmllZEJ5VVJMICE9PSB2b2lkIDAgPyBfZ2V0U3BlY2lmaWVkQnlVUkwgOiBzcGVjaWZpZWRCeVVSTDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBHcmFwaFFMU2NhbGFyVHlwZSh7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBzcGVjaWZpZWRCeVVSTCxcbiAgICAgIGV4dGVuc2lvbkFTVE5vZGVzOiBjb25maWcuZXh0ZW5zaW9uQVNUTm9kZXMuY29uY2F0KGV4dGVuc2lvbnMpXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZXh0ZW5kT2JqZWN0VHlwZSh0eXBlKSB7XG4gICAgdmFyIF90eXBlRXh0ZW5zaW9uc01hcCRjbzM7XG4gICAgY29uc3QgY29uZmlnID0gdHlwZS50b0NvbmZpZygpO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSAoX3R5cGVFeHRlbnNpb25zTWFwJGNvMyA9IHR5cGVFeHRlbnNpb25zTWFwW2NvbmZpZy5uYW1lXSkgIT09IG51bGwgJiYgX3R5cGVFeHRlbnNpb25zTWFwJGNvMyAhPT0gdm9pZCAwID8gX3R5cGVFeHRlbnNpb25zTWFwJGNvMyA6IFtdO1xuICAgIHJldHVybiBuZXcgR3JhcGhRTE9iamVjdFR5cGUoe1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgaW50ZXJmYWNlczogKCkgPT4gW1xuICAgICAgICAuLi50eXBlLmdldEludGVyZmFjZXMoKS5tYXAocmVwbGFjZU5hbWVkVHlwZSksXG4gICAgICAgIC4uLmJ1aWxkSW50ZXJmYWNlcyhleHRlbnNpb25zKVxuICAgICAgXSxcbiAgICAgIGZpZWxkczogKCkgPT4gKHtcbiAgICAgICAgLi4ubWFwVmFsdWUoY29uZmlnLmZpZWxkcywgZXh0ZW5kRmllbGQpLFxuICAgICAgICAuLi5idWlsZEZpZWxkTWFwKGV4dGVuc2lvbnMpXG4gICAgICB9KSxcbiAgICAgIGV4dGVuc2lvbkFTVE5vZGVzOiBjb25maWcuZXh0ZW5zaW9uQVNUTm9kZXMuY29uY2F0KGV4dGVuc2lvbnMpXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZXh0ZW5kSW50ZXJmYWNlVHlwZSh0eXBlKSB7XG4gICAgdmFyIF90eXBlRXh0ZW5zaW9uc01hcCRjbzQ7XG4gICAgY29uc3QgY29uZmlnID0gdHlwZS50b0NvbmZpZygpO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSAoX3R5cGVFeHRlbnNpb25zTWFwJGNvNCA9IHR5cGVFeHRlbnNpb25zTWFwW2NvbmZpZy5uYW1lXSkgIT09IG51bGwgJiYgX3R5cGVFeHRlbnNpb25zTWFwJGNvNCAhPT0gdm9pZCAwID8gX3R5cGVFeHRlbnNpb25zTWFwJGNvNCA6IFtdO1xuICAgIHJldHVybiBuZXcgR3JhcGhRTEludGVyZmFjZVR5cGUoe1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgaW50ZXJmYWNlczogKCkgPT4gW1xuICAgICAgICAuLi50eXBlLmdldEludGVyZmFjZXMoKS5tYXAocmVwbGFjZU5hbWVkVHlwZSksXG4gICAgICAgIC4uLmJ1aWxkSW50ZXJmYWNlcyhleHRlbnNpb25zKVxuICAgICAgXSxcbiAgICAgIGZpZWxkczogKCkgPT4gKHtcbiAgICAgICAgLi4ubWFwVmFsdWUoY29uZmlnLmZpZWxkcywgZXh0ZW5kRmllbGQpLFxuICAgICAgICAuLi5idWlsZEZpZWxkTWFwKGV4dGVuc2lvbnMpXG4gICAgICB9KSxcbiAgICAgIGV4dGVuc2lvbkFTVE5vZGVzOiBjb25maWcuZXh0ZW5zaW9uQVNUTm9kZXMuY29uY2F0KGV4dGVuc2lvbnMpXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZXh0ZW5kVW5pb25UeXBlKHR5cGUpIHtcbiAgICB2YXIgX3R5cGVFeHRlbnNpb25zTWFwJGNvNTtcbiAgICBjb25zdCBjb25maWcgPSB0eXBlLnRvQ29uZmlnKCk7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IChfdHlwZUV4dGVuc2lvbnNNYXAkY281ID0gdHlwZUV4dGVuc2lvbnNNYXBbY29uZmlnLm5hbWVdKSAhPT0gbnVsbCAmJiBfdHlwZUV4dGVuc2lvbnNNYXAkY281ICE9PSB2b2lkIDAgPyBfdHlwZUV4dGVuc2lvbnNNYXAkY281IDogW107XG4gICAgcmV0dXJuIG5ldyBHcmFwaFFMVW5pb25UeXBlKHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIHR5cGVzOiAoKSA9PiBbXG4gICAgICAgIC4uLnR5cGUuZ2V0VHlwZXMoKS5tYXAocmVwbGFjZU5hbWVkVHlwZSksXG4gICAgICAgIC4uLmJ1aWxkVW5pb25UeXBlcyhleHRlbnNpb25zKVxuICAgICAgXSxcbiAgICAgIGV4dGVuc2lvbkFTVE5vZGVzOiBjb25maWcuZXh0ZW5zaW9uQVNUTm9kZXMuY29uY2F0KGV4dGVuc2lvbnMpXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZXh0ZW5kRmllbGQoZmllbGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZmllbGQsXG4gICAgICB0eXBlOiByZXBsYWNlVHlwZShmaWVsZC50eXBlKSxcbiAgICAgIGFyZ3M6IGZpZWxkLmFyZ3MgJiYgbWFwVmFsdWUoZmllbGQuYXJncywgZXh0ZW5kQXJnKVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZXh0ZW5kQXJnKGFyZykge1xuICAgIHJldHVybiB7IC4uLmFyZywgdHlwZTogcmVwbGFjZVR5cGUoYXJnLnR5cGUpIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0T3BlcmF0aW9uVHlwZXMobm9kZXMpIHtcbiAgICBjb25zdCBvcFR5cGVzID0ge307XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICB2YXIgX25vZGUkb3BlcmF0aW9uVHlwZXM7XG4gICAgICBjb25zdCBvcGVyYXRpb25UeXBlc05vZGVzID0gKFxuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAoX25vZGUkb3BlcmF0aW9uVHlwZXMgPSBub2RlLm9wZXJhdGlvblR5cGVzKSAhPT0gbnVsbCAmJiBfbm9kZSRvcGVyYXRpb25UeXBlcyAhPT0gdm9pZCAwID8gX25vZGUkb3BlcmF0aW9uVHlwZXMgOiBbXVxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uVHlwZSBvZiBvcGVyYXRpb25UeXBlc05vZGVzKSB7XG4gICAgICAgIG9wVHlwZXNbb3BlcmF0aW9uVHlwZS5vcGVyYXRpb25dID0gZ2V0TmFtZWRUeXBlMihvcGVyYXRpb25UeXBlLnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BUeXBlcztcbiAgfVxuICBmdW5jdGlvbiBnZXROYW1lZFR5cGUyKG5vZGUpIHtcbiAgICB2YXIgX3N0ZFR5cGVNYXAkbmFtZTI7XG4gICAgY29uc3QgbmFtZSA9IG5vZGUubmFtZS52YWx1ZTtcbiAgICBjb25zdCB0eXBlID0gKF9zdGRUeXBlTWFwJG5hbWUyID0gc3RkVHlwZU1hcFtuYW1lXSkgIT09IG51bGwgJiYgX3N0ZFR5cGVNYXAkbmFtZTIgIT09IHZvaWQgMCA/IF9zdGRUeXBlTWFwJG5hbWUyIDogdHlwZU1hcFtuYW1lXTtcbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdHlwZTogXCIke25hbWV9XCIuYCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGZ1bmN0aW9uIGdldFdyYXBwZWRUeXBlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5raW5kID09PSBLaW5kLkxJU1RfVFlQRSkge1xuICAgICAgcmV0dXJuIG5ldyBHcmFwaFFMTGlzdChnZXRXcmFwcGVkVHlwZShub2RlLnR5cGUpKTtcbiAgICB9XG4gICAgaWYgKG5vZGUua2luZCA9PT0gS2luZC5OT05fTlVMTF9UWVBFKSB7XG4gICAgICByZXR1cm4gbmV3IEdyYXBoUUxOb25OdWxsKGdldFdyYXBwZWRUeXBlKG5vZGUudHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0TmFtZWRUeXBlMihub2RlKTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZERpcmVjdGl2ZShub2RlKSB7XG4gICAgdmFyIF9ub2RlJGRlc2NyaXB0aW9uO1xuICAgIHJldHVybiBuZXcgR3JhcGhRTERpcmVjdGl2ZSh7XG4gICAgICBuYW1lOiBub2RlLm5hbWUudmFsdWUsXG4gICAgICBkZXNjcmlwdGlvbjogKF9ub2RlJGRlc2NyaXB0aW9uID0gbm9kZS5kZXNjcmlwdGlvbikgPT09IG51bGwgfHwgX25vZGUkZGVzY3JpcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGRlc2NyaXB0aW9uLnZhbHVlLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgbG9jYXRpb25zOiBub2RlLmxvY2F0aW9ucy5tYXAoKHsgdmFsdWUgfSkgPT4gdmFsdWUpLFxuICAgICAgaXNSZXBlYXRhYmxlOiBub2RlLnJlcGVhdGFibGUsXG4gICAgICBhcmdzOiBidWlsZEFyZ3VtZW50TWFwKG5vZGUuYXJndW1lbnRzKSxcbiAgICAgIGFzdE5vZGU6IG5vZGVcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZEZpZWxkTWFwKG5vZGVzKSB7XG4gICAgY29uc3QgZmllbGRDb25maWdNYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIHZhciBfbm9kZSRmaWVsZHM7XG4gICAgICBjb25zdCBub2RlRmllbGRzID0gKFxuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAoX25vZGUkZmllbGRzID0gbm9kZS5maWVsZHMpICE9PSBudWxsICYmIF9ub2RlJGZpZWxkcyAhPT0gdm9pZCAwID8gX25vZGUkZmllbGRzIDogW11cbiAgICAgICk7XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIG5vZGVGaWVsZHMpIHtcbiAgICAgICAgdmFyIF9maWVsZCRkZXNjcmlwdGlvbjtcbiAgICAgICAgZmllbGRDb25maWdNYXBbZmllbGQubmFtZS52YWx1ZV0gPSB7XG4gICAgICAgICAgLy8gTm90ZTogV2hpbGUgdGhpcyBjb3VsZCBtYWtlIGFzc2VydGlvbnMgdG8gZ2V0IHRoZSBjb3JyZWN0bHkgdHlwZWRcbiAgICAgICAgICAvLyB2YWx1ZSwgdGhhdCB3b3VsZCB0aHJvdyBpbW1lZGlhdGVseSB3aGlsZSB0eXBlIHN5c3RlbSB2YWxpZGF0aW9uXG4gICAgICAgICAgLy8gd2l0aCB2YWxpZGF0ZVNjaGVtYSgpIHdpbGwgcHJvZHVjZSBtb3JlIGFjdGlvbmFibGUgcmVzdWx0cy5cbiAgICAgICAgICB0eXBlOiBnZXRXcmFwcGVkVHlwZShmaWVsZC50eXBlKSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogKF9maWVsZCRkZXNjcmlwdGlvbiA9IGZpZWxkLmRlc2NyaXB0aW9uKSA9PT0gbnVsbCB8fCBfZmllbGQkZGVzY3JpcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9maWVsZCRkZXNjcmlwdGlvbi52YWx1ZSxcbiAgICAgICAgICBhcmdzOiBidWlsZEFyZ3VtZW50TWFwKGZpZWxkLmFyZ3VtZW50cyksXG4gICAgICAgICAgZGVwcmVjYXRpb25SZWFzb246IGdldERlcHJlY2F0aW9uUmVhc29uKGZpZWxkKSxcbiAgICAgICAgICBhc3ROb2RlOiBmaWVsZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRDb25maWdNYXA7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRBcmd1bWVudE1hcChhcmdzKSB7XG4gICAgY29uc3QgYXJnc05vZGVzID0gKFxuICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgIGFyZ3MgIT09IG51bGwgJiYgYXJncyAhPT0gdm9pZCAwID8gYXJncyA6IFtdXG4gICAgKTtcbiAgICBjb25zdCBhcmdDb25maWdNYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzTm9kZXMpIHtcbiAgICAgIHZhciBfYXJnJGRlc2NyaXB0aW9uO1xuICAgICAgY29uc3QgdHlwZSA9IGdldFdyYXBwZWRUeXBlKGFyZy50eXBlKTtcbiAgICAgIGFyZ0NvbmZpZ01hcFthcmcubmFtZS52YWx1ZV0gPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAoX2FyZyRkZXNjcmlwdGlvbiA9IGFyZy5kZXNjcmlwdGlvbikgPT09IG51bGwgfHwgX2FyZyRkZXNjcmlwdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FyZyRkZXNjcmlwdGlvbi52YWx1ZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZUZyb21BU1QoYXJnLmRlZmF1bHRWYWx1ZSwgdHlwZSksXG4gICAgICAgIGRlcHJlY2F0aW9uUmVhc29uOiBnZXREZXByZWNhdGlvblJlYXNvbihhcmcpLFxuICAgICAgICBhc3ROb2RlOiBhcmdcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhcmdDb25maWdNYXA7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRJbnB1dEZpZWxkTWFwKG5vZGVzKSB7XG4gICAgY29uc3QgaW5wdXRGaWVsZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgdmFyIF9ub2RlJGZpZWxkczI7XG4gICAgICBjb25zdCBmaWVsZHNOb2RlcyA9IChcbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgKF9ub2RlJGZpZWxkczIgPSBub2RlLmZpZWxkcykgIT09IG51bGwgJiYgX25vZGUkZmllbGRzMiAhPT0gdm9pZCAwID8gX25vZGUkZmllbGRzMiA6IFtdXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHNOb2Rlcykge1xuICAgICAgICB2YXIgX2ZpZWxkJGRlc2NyaXB0aW9uMjtcbiAgICAgICAgY29uc3QgdHlwZSA9IGdldFdyYXBwZWRUeXBlKGZpZWxkLnR5cGUpO1xuICAgICAgICBpbnB1dEZpZWxkTWFwW2ZpZWxkLm5hbWUudmFsdWVdID0ge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZGVzY3JpcHRpb246IChfZmllbGQkZGVzY3JpcHRpb24yID0gZmllbGQuZGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9maWVsZCRkZXNjcmlwdGlvbjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9maWVsZCRkZXNjcmlwdGlvbjIudmFsdWUsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZUZyb21BU1QoZmllbGQuZGVmYXVsdFZhbHVlLCB0eXBlKSxcbiAgICAgICAgICBkZXByZWNhdGlvblJlYXNvbjogZ2V0RGVwcmVjYXRpb25SZWFzb24oZmllbGQpLFxuICAgICAgICAgIGFzdE5vZGU6IGZpZWxkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnB1dEZpZWxkTWFwO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkRW51bVZhbHVlTWFwKG5vZGVzKSB7XG4gICAgY29uc3QgZW51bVZhbHVlTWFwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICB2YXIgX25vZGUkdmFsdWVzO1xuICAgICAgY29uc3QgdmFsdWVzTm9kZXMgPSAoXG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgIChfbm9kZSR2YWx1ZXMgPSBub2RlLnZhbHVlcykgIT09IG51bGwgJiYgX25vZGUkdmFsdWVzICE9PSB2b2lkIDAgPyBfbm9kZSR2YWx1ZXMgOiBbXVxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzTm9kZXMpIHtcbiAgICAgICAgdmFyIF92YWx1ZSRkZXNjcmlwdGlvbjtcbiAgICAgICAgZW51bVZhbHVlTWFwW3ZhbHVlLm5hbWUudmFsdWVdID0ge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiAoX3ZhbHVlJGRlc2NyaXB0aW9uID0gdmFsdWUuZGVzY3JpcHRpb24pID09PSBudWxsIHx8IF92YWx1ZSRkZXNjcmlwdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZhbHVlJGRlc2NyaXB0aW9uLnZhbHVlLFxuICAgICAgICAgIGRlcHJlY2F0aW9uUmVhc29uOiBnZXREZXByZWNhdGlvblJlYXNvbih2YWx1ZSksXG4gICAgICAgICAgYXN0Tm9kZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVudW1WYWx1ZU1hcDtcbiAgfVxuICBmdW5jdGlvbiBidWlsZEludGVyZmFjZXMobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMuZmxhdE1hcChcbiAgICAgIC8vIEZJWE1FOiBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLWpzL2lzc3Vlcy8yMjAzXG4gICAgICAobm9kZSkgPT4ge1xuICAgICAgICB2YXIgX25vZGUkaW50ZXJmYWNlcyRtYXAsIF9ub2RlJGludGVyZmFjZXM7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAoX25vZGUkaW50ZXJmYWNlcyRtYXAgPSAoX25vZGUkaW50ZXJmYWNlcyA9IG5vZGUuaW50ZXJmYWNlcykgPT09IG51bGwgfHwgX25vZGUkaW50ZXJmYWNlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkaW50ZXJmYWNlcy5tYXAoZ2V0TmFtZWRUeXBlMikpICE9PSBudWxsICYmIF9ub2RlJGludGVyZmFjZXMkbWFwICE9PSB2b2lkIDAgPyBfbm9kZSRpbnRlcmZhY2VzJG1hcCA6IFtdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZFVuaW9uVHlwZXMobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMuZmxhdE1hcChcbiAgICAgIC8vIEZJWE1FOiBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLWpzL2lzc3Vlcy8yMjAzXG4gICAgICAobm9kZSkgPT4ge1xuICAgICAgICB2YXIgX25vZGUkdHlwZXMkbWFwLCBfbm9kZSR0eXBlcztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIChfbm9kZSR0eXBlcyRtYXAgPSAoX25vZGUkdHlwZXMgPSBub2RlLnR5cGVzKSA9PT0gbnVsbCB8fCBfbm9kZSR0eXBlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkdHlwZXMubWFwKGdldE5hbWVkVHlwZTIpKSAhPT0gbnVsbCAmJiBfbm9kZSR0eXBlcyRtYXAgIT09IHZvaWQgMCA/IF9ub2RlJHR5cGVzJG1hcCA6IFtdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZFR5cGUoYXN0Tm9kZSkge1xuICAgIHZhciBfdHlwZUV4dGVuc2lvbnNNYXAkbmE7XG4gICAgY29uc3QgbmFtZSA9IGFzdE5vZGUubmFtZS52YWx1ZTtcbiAgICBjb25zdCBleHRlbnNpb25BU1ROb2RlcyA9IChfdHlwZUV4dGVuc2lvbnNNYXAkbmEgPSB0eXBlRXh0ZW5zaW9uc01hcFtuYW1lXSkgIT09IG51bGwgJiYgX3R5cGVFeHRlbnNpb25zTWFwJG5hICE9PSB2b2lkIDAgPyBfdHlwZUV4dGVuc2lvbnNNYXAkbmEgOiBbXTtcbiAgICBzd2l0Y2ggKGFzdE5vZGUua2luZCkge1xuICAgICAgY2FzZSBLaW5kLk9CSkVDVF9UWVBFX0RFRklOSVRJT046IHtcbiAgICAgICAgdmFyIF9hc3ROb2RlJGRlc2NyaXB0aW9uO1xuICAgICAgICBjb25zdCBhbGxOb2RlcyA9IFthc3ROb2RlLCAuLi5leHRlbnNpb25BU1ROb2Rlc107XG4gICAgICAgIHJldHVybiBuZXcgR3JhcGhRTE9iamVjdFR5cGUoe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZGVzY3JpcHRpb246IChfYXN0Tm9kZSRkZXNjcmlwdGlvbiA9IGFzdE5vZGUuZGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hc3ROb2RlJGRlc2NyaXB0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXN0Tm9kZSRkZXNjcmlwdGlvbi52YWx1ZSxcbiAgICAgICAgICBpbnRlcmZhY2VzOiAoKSA9PiBidWlsZEludGVyZmFjZXMoYWxsTm9kZXMpLFxuICAgICAgICAgIGZpZWxkczogKCkgPT4gYnVpbGRGaWVsZE1hcChhbGxOb2RlcyksXG4gICAgICAgICAgYXN0Tm9kZSxcbiAgICAgICAgICBleHRlbnNpb25BU1ROb2Rlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgS2luZC5JTlRFUkZBQ0VfVFlQRV9ERUZJTklUSU9OOiB7XG4gICAgICAgIHZhciBfYXN0Tm9kZSRkZXNjcmlwdGlvbjI7XG4gICAgICAgIGNvbnN0IGFsbE5vZGVzID0gW2FzdE5vZGUsIC4uLmV4dGVuc2lvbkFTVE5vZGVzXTtcbiAgICAgICAgcmV0dXJuIG5ldyBHcmFwaFFMSW50ZXJmYWNlVHlwZSh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogKF9hc3ROb2RlJGRlc2NyaXB0aW9uMiA9IGFzdE5vZGUuZGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hc3ROb2RlJGRlc2NyaXB0aW9uMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FzdE5vZGUkZGVzY3JpcHRpb24yLnZhbHVlLFxuICAgICAgICAgIGludGVyZmFjZXM6ICgpID0+IGJ1aWxkSW50ZXJmYWNlcyhhbGxOb2RlcyksXG4gICAgICAgICAgZmllbGRzOiAoKSA9PiBidWlsZEZpZWxkTWFwKGFsbE5vZGVzKSxcbiAgICAgICAgICBhc3ROb2RlLFxuICAgICAgICAgIGV4dGVuc2lvbkFTVE5vZGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBLaW5kLkVOVU1fVFlQRV9ERUZJTklUSU9OOiB7XG4gICAgICAgIHZhciBfYXN0Tm9kZSRkZXNjcmlwdGlvbjM7XG4gICAgICAgIGNvbnN0IGFsbE5vZGVzID0gW2FzdE5vZGUsIC4uLmV4dGVuc2lvbkFTVE5vZGVzXTtcbiAgICAgICAgcmV0dXJuIG5ldyBHcmFwaFFMRW51bVR5cGUoe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZGVzY3JpcHRpb246IChfYXN0Tm9kZSRkZXNjcmlwdGlvbjMgPSBhc3ROb2RlLmRlc2NyaXB0aW9uKSA9PT0gbnVsbCB8fCBfYXN0Tm9kZSRkZXNjcmlwdGlvbjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hc3ROb2RlJGRlc2NyaXB0aW9uMy52YWx1ZSxcbiAgICAgICAgICB2YWx1ZXM6IGJ1aWxkRW51bVZhbHVlTWFwKGFsbE5vZGVzKSxcbiAgICAgICAgICBhc3ROb2RlLFxuICAgICAgICAgIGV4dGVuc2lvbkFTVE5vZGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBLaW5kLlVOSU9OX1RZUEVfREVGSU5JVElPTjoge1xuICAgICAgICB2YXIgX2FzdE5vZGUkZGVzY3JpcHRpb240O1xuICAgICAgICBjb25zdCBhbGxOb2RlcyA9IFthc3ROb2RlLCAuLi5leHRlbnNpb25BU1ROb2Rlc107XG4gICAgICAgIHJldHVybiBuZXcgR3JhcGhRTFVuaW9uVHlwZSh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogKF9hc3ROb2RlJGRlc2NyaXB0aW9uNCA9IGFzdE5vZGUuZGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hc3ROb2RlJGRlc2NyaXB0aW9uNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FzdE5vZGUkZGVzY3JpcHRpb240LnZhbHVlLFxuICAgICAgICAgIHR5cGVzOiAoKSA9PiBidWlsZFVuaW9uVHlwZXMoYWxsTm9kZXMpLFxuICAgICAgICAgIGFzdE5vZGUsXG4gICAgICAgICAgZXh0ZW5zaW9uQVNUTm9kZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjYXNlIEtpbmQuU0NBTEFSX1RZUEVfREVGSU5JVElPTjoge1xuICAgICAgICB2YXIgX2FzdE5vZGUkZGVzY3JpcHRpb241O1xuICAgICAgICByZXR1cm4gbmV3IEdyYXBoUUxTY2FsYXJUeXBlKHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAoX2FzdE5vZGUkZGVzY3JpcHRpb241ID0gYXN0Tm9kZS5kZXNjcmlwdGlvbikgPT09IG51bGwgfHwgX2FzdE5vZGUkZGVzY3JpcHRpb241ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXN0Tm9kZSRkZXNjcmlwdGlvbjUudmFsdWUsXG4gICAgICAgICAgc3BlY2lmaWVkQnlVUkw6IGdldFNwZWNpZmllZEJ5VVJMKGFzdE5vZGUpLFxuICAgICAgICAgIGFzdE5vZGUsXG4gICAgICAgICAgZXh0ZW5zaW9uQVNUTm9kZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjYXNlIEtpbmQuSU5QVVRfT0JKRUNUX1RZUEVfREVGSU5JVElPTjoge1xuICAgICAgICB2YXIgX2FzdE5vZGUkZGVzY3JpcHRpb242O1xuICAgICAgICBjb25zdCBhbGxOb2RlcyA9IFthc3ROb2RlLCAuLi5leHRlbnNpb25BU1ROb2Rlc107XG4gICAgICAgIHJldHVybiBuZXcgR3JhcGhRTElucHV0T2JqZWN0VHlwZSh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogKF9hc3ROb2RlJGRlc2NyaXB0aW9uNiA9IGFzdE5vZGUuZGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hc3ROb2RlJGRlc2NyaXB0aW9uNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FzdE5vZGUkZGVzY3JpcHRpb242LnZhbHVlLFxuICAgICAgICAgIGZpZWxkczogKCkgPT4gYnVpbGRJbnB1dEZpZWxkTWFwKGFsbE5vZGVzKSxcbiAgICAgICAgICBhc3ROb2RlLFxuICAgICAgICAgIGV4dGVuc2lvbkFTVE5vZGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGVwcmVjYXRpb25SZWFzb24obm9kZSkge1xuICBjb25zdCBkZXByZWNhdGVkID0gZ2V0RGlyZWN0aXZlVmFsdWVzKEdyYXBoUUxEZXByZWNhdGVkRGlyZWN0aXZlLCBub2RlKTtcbiAgcmV0dXJuIGRlcHJlY2F0ZWQgPT09IG51bGwgfHwgZGVwcmVjYXRlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcmVjYXRlZC5yZWFzb247XG59XG5mdW5jdGlvbiBnZXRTcGVjaWZpZWRCeVVSTChub2RlKSB7XG4gIGNvbnN0IHNwZWNpZmllZEJ5ID0gZ2V0RGlyZWN0aXZlVmFsdWVzKEdyYXBoUUxTcGVjaWZpZWRCeURpcmVjdGl2ZSwgbm9kZSk7XG4gIHJldHVybiBzcGVjaWZpZWRCeSA9PT0gbnVsbCB8fCBzcGVjaWZpZWRCeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3BlY2lmaWVkQnkudXJsO1xufVxudmFyIHN0ZFR5cGVNYXA7XG52YXIgaW5pdF9leHRlbmRTY2hlbWEgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdXRpbGl0aWVzL2V4dGVuZFNjaGVtYS5tanNcIigpIHtcbiAgICBpbml0X2RldkFzc2VydCgpO1xuICAgIGluaXRfaW5zcGVjdCgpO1xuICAgIGluaXRfaW52YXJpYW50KCk7XG4gICAgaW5pdF9rZXlNYXAoKTtcbiAgICBpbml0X21hcFZhbHVlKCk7XG4gICAgaW5pdF9raW5kcygpO1xuICAgIGluaXRfcHJlZGljYXRlcygpO1xuICAgIGluaXRfZGVmaW5pdGlvbigpO1xuICAgIGluaXRfZGlyZWN0aXZlcygpO1xuICAgIGluaXRfaW50cm9zcGVjdGlvbigpO1xuICAgIGluaXRfc2NhbGFycygpO1xuICAgIGluaXRfc2NoZW1hKCk7XG4gICAgaW5pdF92YWxpZGF0ZTIoKTtcbiAgICBpbml0X3ZhbHVlcygpO1xuICAgIGluaXRfdmFsdWVGcm9tQVNUKCk7XG4gICAgc3RkVHlwZU1hcCA9IGtleU1hcChcbiAgICAgIFsuLi5zcGVjaWZpZWRTY2FsYXJUeXBlcywgLi4uaW50cm9zcGVjdGlvblR5cGVzXSxcbiAgICAgICh0eXBlKSA9PiB0eXBlLm5hbWVcbiAgICApO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdXRpbGl0aWVzL2J1aWxkQVNUU2NoZW1hLm1qc1xuZnVuY3Rpb24gYnVpbGRBU1RTY2hlbWEoZG9jdW1lbnRBU1QsIG9wdGlvbnMpIHtcbiAgZG9jdW1lbnRBU1QgIT0gbnVsbCAmJiBkb2N1bWVudEFTVC5raW5kID09PSBLaW5kLkRPQ1VNRU5UIHx8IGRldkFzc2VydChmYWxzZSwgXCJNdXN0IHByb3ZpZGUgdmFsaWQgRG9jdW1lbnQgQVNULlwiKTtcbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXNzdW1lVmFsaWQpICE9PSB0cnVlICYmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXNzdW1lVmFsaWRTREwpICE9PSB0cnVlKSB7XG4gICAgYXNzZXJ0VmFsaWRTREwoZG9jdW1lbnRBU1QpO1xuICB9XG4gIGNvbnN0IGVtcHR5U2NoZW1hQ29uZmlnID0ge1xuICAgIGRlc2NyaXB0aW9uOiB2b2lkIDAsXG4gICAgdHlwZXM6IFtdLFxuICAgIGRpcmVjdGl2ZXM6IFtdLFxuICAgIGV4dGVuc2lvbnM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIGV4dGVuc2lvbkFTVE5vZGVzOiBbXSxcbiAgICBhc3N1bWVWYWxpZDogZmFsc2VcbiAgfTtcbiAgY29uc3QgY29uZmlnID0gZXh0ZW5kU2NoZW1hSW1wbChlbXB0eVNjaGVtYUNvbmZpZywgZG9jdW1lbnRBU1QsIG9wdGlvbnMpO1xuICBpZiAoY29uZmlnLmFzdE5vZGUgPT0gbnVsbCkge1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBjb25maWcudHlwZXMpIHtcbiAgICAgIHN3aXRjaCAodHlwZS5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJRdWVyeVwiOlxuICAgICAgICAgIGNvbmZpZy5xdWVyeSA9IHR5cGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJNdXRhdGlvblwiOlxuICAgICAgICAgIGNvbmZpZy5tdXRhdGlvbiA9IHR5cGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJTdWJzY3JpcHRpb25cIjpcbiAgICAgICAgICBjb25maWcuc3Vic2NyaXB0aW9uID0gdHlwZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgZGlyZWN0aXZlcyA9IFtcbiAgICAuLi5jb25maWcuZGlyZWN0aXZlcyxcbiAgICAvLyBJZiBzcGVjaWZpZWQgZGlyZWN0aXZlcyB3ZXJlIG5vdCBleHBsaWNpdGx5IGRlY2xhcmVkLCBhZGQgdGhlbS5cbiAgICAuLi5zcGVjaWZpZWREaXJlY3RpdmVzLmZpbHRlcihcbiAgICAgIChzdGREaXJlY3RpdmUpID0+IGNvbmZpZy5kaXJlY3RpdmVzLmV2ZXJ5KFxuICAgICAgICAoZGlyZWN0aXZlKSA9PiBkaXJlY3RpdmUubmFtZSAhPT0gc3RkRGlyZWN0aXZlLm5hbWVcbiAgICAgIClcbiAgICApXG4gIF07XG4gIHJldHVybiBuZXcgR3JhcGhRTFNjaGVtYSh7IC4uLmNvbmZpZywgZGlyZWN0aXZlcyB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2NoZW1hKHNvdXJjZSwgb3B0aW9ucykge1xuICBjb25zdCBkb2N1bWVudCA9IHBhcnNlKHNvdXJjZSwge1xuICAgIG5vTG9jYXRpb246IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub0xvY2F0aW9uLFxuICAgIGFsbG93TGVnYWN5RnJhZ21lbnRWYXJpYWJsZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbGxvd0xlZ2FjeUZyYWdtZW50VmFyaWFibGVzXG4gIH0pO1xuICByZXR1cm4gYnVpbGRBU1RTY2hlbWEoZG9jdW1lbnQsIHtcbiAgICBhc3N1bWVWYWxpZFNETDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFzc3VtZVZhbGlkU0RMLFxuICAgIGFzc3VtZVZhbGlkOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXNzdW1lVmFsaWRcbiAgfSk7XG59XG52YXIgaW5pdF9idWlsZEFTVFNjaGVtYSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvYnVpbGRBU1RTY2hlbWEubWpzXCIoKSB7XG4gICAgaW5pdF9kZXZBc3NlcnQoKTtcbiAgICBpbml0X2tpbmRzKCk7XG4gICAgaW5pdF9wYXJzZXIoKTtcbiAgICBpbml0X2RpcmVjdGl2ZXMoKTtcbiAgICBpbml0X3NjaGVtYSgpO1xuICAgIGluaXRfdmFsaWRhdGUyKCk7XG4gICAgaW5pdF9leHRlbmRTY2hlbWEoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9sZXhpY29ncmFwaGljU29ydFNjaGVtYS5tanNcbmZ1bmN0aW9uIGxleGljb2dyYXBoaWNTb3J0U2NoZW1hKHNjaGVtYSkge1xuICBjb25zdCBzY2hlbWFDb25maWcgPSBzY2hlbWEudG9Db25maWcoKTtcbiAgY29uc3QgdHlwZU1hcCA9IGtleVZhbE1hcChcbiAgICBzb3J0QnlOYW1lKHNjaGVtYUNvbmZpZy50eXBlcyksXG4gICAgKHR5cGUpID0+IHR5cGUubmFtZSxcbiAgICBzb3J0TmFtZWRUeXBlXG4gICk7XG4gIHJldHVybiBuZXcgR3JhcGhRTFNjaGVtYSh7XG4gICAgLi4uc2NoZW1hQ29uZmlnLFxuICAgIHR5cGVzOiBPYmplY3QudmFsdWVzKHR5cGVNYXApLFxuICAgIGRpcmVjdGl2ZXM6IHNvcnRCeU5hbWUoc2NoZW1hQ29uZmlnLmRpcmVjdGl2ZXMpLm1hcChzb3J0RGlyZWN0aXZlKSxcbiAgICBxdWVyeTogcmVwbGFjZU1heWJlVHlwZShzY2hlbWFDb25maWcucXVlcnkpLFxuICAgIG11dGF0aW9uOiByZXBsYWNlTWF5YmVUeXBlKHNjaGVtYUNvbmZpZy5tdXRhdGlvbiksXG4gICAgc3Vic2NyaXB0aW9uOiByZXBsYWNlTWF5YmVUeXBlKHNjaGVtYUNvbmZpZy5zdWJzY3JpcHRpb24pXG4gIH0pO1xuICBmdW5jdGlvbiByZXBsYWNlVHlwZSh0eXBlKSB7XG4gICAgaWYgKGlzTGlzdFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiBuZXcgR3JhcGhRTExpc3QocmVwbGFjZVR5cGUodHlwZS5vZlR5cGUpKTtcbiAgICB9IGVsc2UgaWYgKGlzTm9uTnVsbFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiBuZXcgR3JhcGhRTE5vbk51bGwocmVwbGFjZVR5cGUodHlwZS5vZlR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGxhY2VOYW1lZFR5cGUodHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZU5hbWVkVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGVNYXBbdHlwZS5uYW1lXTtcbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlTWF5YmVUeXBlKG1heWJlVHlwZSkge1xuICAgIHJldHVybiBtYXliZVR5cGUgJiYgcmVwbGFjZU5hbWVkVHlwZShtYXliZVR5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIHNvcnREaXJlY3RpdmUoZGlyZWN0aXZlKSB7XG4gICAgY29uc3QgY29uZmlnID0gZGlyZWN0aXZlLnRvQ29uZmlnKCk7XG4gICAgcmV0dXJuIG5ldyBHcmFwaFFMRGlyZWN0aXZlKHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGxvY2F0aW9uczogc29ydEJ5KGNvbmZpZy5sb2NhdGlvbnMsICh4KSA9PiB4KSxcbiAgICAgIGFyZ3M6IHNvcnRBcmdzKGNvbmZpZy5hcmdzKVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNvcnRBcmdzKGFyZ3MpIHtcbiAgICByZXR1cm4gc29ydE9iak1hcChhcmdzLCAoYXJnKSA9PiAoeyAuLi5hcmcsIHR5cGU6IHJlcGxhY2VUeXBlKGFyZy50eXBlKSB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gc29ydEZpZWxkczIoZmllbGRzTWFwKSB7XG4gICAgcmV0dXJuIHNvcnRPYmpNYXAoZmllbGRzTWFwLCAoZmllbGQpID0+ICh7XG4gICAgICAuLi5maWVsZCxcbiAgICAgIHR5cGU6IHJlcGxhY2VUeXBlKGZpZWxkLnR5cGUpLFxuICAgICAgYXJnczogZmllbGQuYXJncyAmJiBzb3J0QXJncyhmaWVsZC5hcmdzKVxuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBzb3J0SW5wdXRGaWVsZHMoZmllbGRzTWFwKSB7XG4gICAgcmV0dXJuIHNvcnRPYmpNYXAoZmllbGRzTWFwLCAoZmllbGQpID0+ICh7XG4gICAgICAuLi5maWVsZCxcbiAgICAgIHR5cGU6IHJlcGxhY2VUeXBlKGZpZWxkLnR5cGUpXG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIHNvcnRUeXBlcyhhcnJheSkge1xuICAgIHJldHVybiBzb3J0QnlOYW1lKGFycmF5KS5tYXAocmVwbGFjZU5hbWVkVHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gc29ydE5hbWVkVHlwZSh0eXBlKSB7XG4gICAgaWYgKGlzU2NhbGFyVHlwZSh0eXBlKSB8fCBpc0ludHJvc3BlY3Rpb25UeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0VHlwZSh0eXBlKSkge1xuICAgICAgY29uc3QgY29uZmlnID0gdHlwZS50b0NvbmZpZygpO1xuICAgICAgcmV0dXJuIG5ldyBHcmFwaFFMT2JqZWN0VHlwZSh7XG4gICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgaW50ZXJmYWNlczogKCkgPT4gc29ydFR5cGVzKGNvbmZpZy5pbnRlcmZhY2VzKSxcbiAgICAgICAgZmllbGRzOiAoKSA9PiBzb3J0RmllbGRzMihjb25maWcuZmllbGRzKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc0ludGVyZmFjZVR5cGUodHlwZSkpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHR5cGUudG9Db25maWcoKTtcbiAgICAgIHJldHVybiBuZXcgR3JhcGhRTEludGVyZmFjZVR5cGUoe1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIGludGVyZmFjZXM6ICgpID0+IHNvcnRUeXBlcyhjb25maWcuaW50ZXJmYWNlcyksXG4gICAgICAgIGZpZWxkczogKCkgPT4gc29ydEZpZWxkczIoY29uZmlnLmZpZWxkcylcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNVbmlvblR5cGUodHlwZSkpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHR5cGUudG9Db25maWcoKTtcbiAgICAgIHJldHVybiBuZXcgR3JhcGhRTFVuaW9uVHlwZSh7XG4gICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgdHlwZXM6ICgpID0+IHNvcnRUeXBlcyhjb25maWcudHlwZXMpXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzRW51bVR5cGUodHlwZSkpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHR5cGUudG9Db25maWcoKTtcbiAgICAgIHJldHVybiBuZXcgR3JhcGhRTEVudW1UeXBlKHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICB2YWx1ZXM6IHNvcnRPYmpNYXAoY29uZmlnLnZhbHVlcywgKHZhbHVlKSA9PiB2YWx1ZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNJbnB1dE9iamVjdFR5cGUodHlwZSkpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHR5cGUudG9Db25maWcoKTtcbiAgICAgIHJldHVybiBuZXcgR3JhcGhRTElucHV0T2JqZWN0VHlwZSh7XG4gICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgZmllbGRzOiAoKSA9PiBzb3J0SW5wdXRGaWVsZHMoY29uZmlnLmZpZWxkcylcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5leHBlY3RlZCB0eXBlOiBcIiArIGluc3BlY3QodHlwZSkpO1xuICB9XG59XG5mdW5jdGlvbiBzb3J0T2JqTWFwKG1hcCwgc29ydFZhbHVlRm4pIHtcbiAgY29uc3Qgc29ydGVkTWFwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG1hcCkuc29ydChuYXR1cmFsQ29tcGFyZSkpIHtcbiAgICBzb3J0ZWRNYXBba2V5XSA9IHNvcnRWYWx1ZUZuKG1hcFtrZXldKTtcbiAgfVxuICByZXR1cm4gc29ydGVkTWFwO1xufVxuZnVuY3Rpb24gc29ydEJ5TmFtZShhcnJheSkge1xuICByZXR1cm4gc29ydEJ5KGFycmF5LCAob2JqKSA9PiBvYmoubmFtZSk7XG59XG5mdW5jdGlvbiBzb3J0QnkoYXJyYXksIG1hcFRvS2V5KSB7XG4gIHJldHVybiBhcnJheS5zbGljZSgpLnNvcnQoKG9iajEsIG9iajIpID0+IHtcbiAgICBjb25zdCBrZXkxID0gbWFwVG9LZXkob2JqMSk7XG4gICAgY29uc3Qga2V5MiA9IG1hcFRvS2V5KG9iajIpO1xuICAgIHJldHVybiBuYXR1cmFsQ29tcGFyZShrZXkxLCBrZXkyKTtcbiAgfSk7XG59XG52YXIgaW5pdF9sZXhpY29ncmFwaGljU29ydFNjaGVtYSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvbGV4aWNvZ3JhcGhpY1NvcnRTY2hlbWEubWpzXCIoKSB7XG4gICAgaW5pdF9pbnNwZWN0KCk7XG4gICAgaW5pdF9pbnZhcmlhbnQoKTtcbiAgICBpbml0X2tleVZhbE1hcCgpO1xuICAgIGluaXRfbmF0dXJhbENvbXBhcmUoKTtcbiAgICBpbml0X2RlZmluaXRpb24oKTtcbiAgICBpbml0X2RpcmVjdGl2ZXMoKTtcbiAgICBpbml0X2ludHJvc3BlY3Rpb24oKTtcbiAgICBpbml0X3NjaGVtYSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2dyYXBocWwvdXRpbGl0aWVzL3ByaW50U2NoZW1hLm1qc1xuZnVuY3Rpb24gcHJpbnRTY2hlbWEoc2NoZW1hKSB7XG4gIHJldHVybiBwcmludEZpbHRlcmVkU2NoZW1hKFxuICAgIHNjaGVtYSxcbiAgICAobikgPT4gIWlzU3BlY2lmaWVkRGlyZWN0aXZlKG4pLFxuICAgIGlzRGVmaW5lZFR5cGVcbiAgKTtcbn1cbmZ1bmN0aW9uIHByaW50SW50cm9zcGVjdGlvblNjaGVtYShzY2hlbWEpIHtcbiAgcmV0dXJuIHByaW50RmlsdGVyZWRTY2hlbWEoc2NoZW1hLCBpc1NwZWNpZmllZERpcmVjdGl2ZSwgaXNJbnRyb3NwZWN0aW9uVHlwZSk7XG59XG5mdW5jdGlvbiBpc0RlZmluZWRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuICFpc1NwZWNpZmllZFNjYWxhclR5cGUodHlwZSkgJiYgIWlzSW50cm9zcGVjdGlvblR5cGUodHlwZSk7XG59XG5mdW5jdGlvbiBwcmludEZpbHRlcmVkU2NoZW1hKHNjaGVtYSwgZGlyZWN0aXZlRmlsdGVyLCB0eXBlRmlsdGVyKSB7XG4gIGNvbnN0IGRpcmVjdGl2ZXMgPSBzY2hlbWEuZ2V0RGlyZWN0aXZlcygpLmZpbHRlcihkaXJlY3RpdmVGaWx0ZXIpO1xuICBjb25zdCB0eXBlcyA9IE9iamVjdC52YWx1ZXMoc2NoZW1hLmdldFR5cGVNYXAoKSkuZmlsdGVyKHR5cGVGaWx0ZXIpO1xuICByZXR1cm4gW1xuICAgIHByaW50U2NoZW1hRGVmaW5pdGlvbihzY2hlbWEpLFxuICAgIC4uLmRpcmVjdGl2ZXMubWFwKChkaXJlY3RpdmUpID0+IHByaW50RGlyZWN0aXZlKGRpcmVjdGl2ZSkpLFxuICAgIC4uLnR5cGVzLm1hcCgodHlwZSkgPT4gcHJpbnRUeXBlKHR5cGUpKVxuICBdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiXFxuXFxuXCIpO1xufVxuZnVuY3Rpb24gcHJpbnRTY2hlbWFEZWZpbml0aW9uKHNjaGVtYSkge1xuICBpZiAoc2NoZW1hLmRlc2NyaXB0aW9uID09IG51bGwgJiYgaXNTY2hlbWFPZkNvbW1vbk5hbWVzKHNjaGVtYSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3BlcmF0aW9uVHlwZXMgPSBbXTtcbiAgY29uc3QgcXVlcnlUeXBlID0gc2NoZW1hLmdldFF1ZXJ5VHlwZSgpO1xuICBpZiAocXVlcnlUeXBlKSB7XG4gICAgb3BlcmF0aW9uVHlwZXMucHVzaChgICBxdWVyeTogJHtxdWVyeVR5cGUubmFtZX1gKTtcbiAgfVxuICBjb25zdCBtdXRhdGlvblR5cGUgPSBzY2hlbWEuZ2V0TXV0YXRpb25UeXBlKCk7XG4gIGlmIChtdXRhdGlvblR5cGUpIHtcbiAgICBvcGVyYXRpb25UeXBlcy5wdXNoKGAgIG11dGF0aW9uOiAke211dGF0aW9uVHlwZS5uYW1lfWApO1xuICB9XG4gIGNvbnN0IHN1YnNjcmlwdGlvblR5cGUgPSBzY2hlbWEuZ2V0U3Vic2NyaXB0aW9uVHlwZSgpO1xuICBpZiAoc3Vic2NyaXB0aW9uVHlwZSkge1xuICAgIG9wZXJhdGlvblR5cGVzLnB1c2goYCAgc3Vic2NyaXB0aW9uOiAke3N1YnNjcmlwdGlvblR5cGUubmFtZX1gKTtcbiAgfVxuICByZXR1cm4gcHJpbnREZXNjcmlwdGlvbihzY2hlbWEpICsgYHNjaGVtYSB7XG4ke29wZXJhdGlvblR5cGVzLmpvaW4oXCJcXG5cIil9XG59YDtcbn1cbmZ1bmN0aW9uIGlzU2NoZW1hT2ZDb21tb25OYW1lcyhzY2hlbWEpIHtcbiAgY29uc3QgcXVlcnlUeXBlID0gc2NoZW1hLmdldFF1ZXJ5VHlwZSgpO1xuICBpZiAocXVlcnlUeXBlICYmIHF1ZXJ5VHlwZS5uYW1lICE9PSBcIlF1ZXJ5XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbXV0YXRpb25UeXBlID0gc2NoZW1hLmdldE11dGF0aW9uVHlwZSgpO1xuICBpZiAobXV0YXRpb25UeXBlICYmIG11dGF0aW9uVHlwZS5uYW1lICE9PSBcIk11dGF0aW9uXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3Vic2NyaXB0aW9uVHlwZSA9IHNjaGVtYS5nZXRTdWJzY3JpcHRpb25UeXBlKCk7XG4gIGlmIChzdWJzY3JpcHRpb25UeXBlICYmIHN1YnNjcmlwdGlvblR5cGUubmFtZSAhPT0gXCJTdWJzY3JpcHRpb25cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHByaW50VHlwZSh0eXBlKSB7XG4gIGlmIChpc1NjYWxhclR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gcHJpbnRTY2FsYXIodHlwZSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0VHlwZSh0eXBlKSkge1xuICAgIHJldHVybiBwcmludE9iamVjdCh0eXBlKTtcbiAgfVxuICBpZiAoaXNJbnRlcmZhY2VUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIHByaW50SW50ZXJmYWNlKHR5cGUpO1xuICB9XG4gIGlmIChpc1VuaW9uVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiBwcmludFVuaW9uKHR5cGUpO1xuICB9XG4gIGlmIChpc0VudW1UeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIHByaW50RW51bSh0eXBlKTtcbiAgfVxuICBpZiAoaXNJbnB1dE9iamVjdFR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gcHJpbnRJbnB1dE9iamVjdCh0eXBlKTtcbiAgfVxuICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5leHBlY3RlZCB0eXBlOiBcIiArIGluc3BlY3QodHlwZSkpO1xufVxuZnVuY3Rpb24gcHJpbnRTY2FsYXIodHlwZSkge1xuICByZXR1cm4gcHJpbnREZXNjcmlwdGlvbih0eXBlKSArIGBzY2FsYXIgJHt0eXBlLm5hbWV9YCArIHByaW50U3BlY2lmaWVkQnlVUkwodHlwZSk7XG59XG5mdW5jdGlvbiBwcmludEltcGxlbWVudGVkSW50ZXJmYWNlcyh0eXBlKSB7XG4gIGNvbnN0IGludGVyZmFjZXMgPSB0eXBlLmdldEludGVyZmFjZXMoKTtcbiAgcmV0dXJuIGludGVyZmFjZXMubGVuZ3RoID8gXCIgaW1wbGVtZW50cyBcIiArIGludGVyZmFjZXMubWFwKChpKSA9PiBpLm5hbWUpLmpvaW4oXCIgJiBcIikgOiBcIlwiO1xufVxuZnVuY3Rpb24gcHJpbnRPYmplY3QodHlwZSkge1xuICByZXR1cm4gcHJpbnREZXNjcmlwdGlvbih0eXBlKSArIGB0eXBlICR7dHlwZS5uYW1lfWAgKyBwcmludEltcGxlbWVudGVkSW50ZXJmYWNlcyh0eXBlKSArIHByaW50RmllbGRzKHR5cGUpO1xufVxuZnVuY3Rpb24gcHJpbnRJbnRlcmZhY2UodHlwZSkge1xuICByZXR1cm4gcHJpbnREZXNjcmlwdGlvbih0eXBlKSArIGBpbnRlcmZhY2UgJHt0eXBlLm5hbWV9YCArIHByaW50SW1wbGVtZW50ZWRJbnRlcmZhY2VzKHR5cGUpICsgcHJpbnRGaWVsZHModHlwZSk7XG59XG5mdW5jdGlvbiBwcmludFVuaW9uKHR5cGUpIHtcbiAgY29uc3QgdHlwZXMgPSB0eXBlLmdldFR5cGVzKCk7XG4gIGNvbnN0IHBvc3NpYmxlVHlwZXMgPSB0eXBlcy5sZW5ndGggPyBcIiA9IFwiICsgdHlwZXMuam9pbihcIiB8IFwiKSA6IFwiXCI7XG4gIHJldHVybiBwcmludERlc2NyaXB0aW9uKHR5cGUpICsgXCJ1bmlvbiBcIiArIHR5cGUubmFtZSArIHBvc3NpYmxlVHlwZXM7XG59XG5mdW5jdGlvbiBwcmludEVudW0odHlwZSkge1xuICBjb25zdCB2YWx1ZXMgPSB0eXBlLmdldFZhbHVlcygpLm1hcChcbiAgICAodmFsdWUsIGkpID0+IHByaW50RGVzY3JpcHRpb24odmFsdWUsIFwiICBcIiwgIWkpICsgXCIgIFwiICsgdmFsdWUubmFtZSArIHByaW50RGVwcmVjYXRlZCh2YWx1ZS5kZXByZWNhdGlvblJlYXNvbilcbiAgKTtcbiAgcmV0dXJuIHByaW50RGVzY3JpcHRpb24odHlwZSkgKyBgZW51bSAke3R5cGUubmFtZX1gICsgcHJpbnRCbG9jayh2YWx1ZXMpO1xufVxuZnVuY3Rpb24gcHJpbnRJbnB1dE9iamVjdCh0eXBlKSB7XG4gIGNvbnN0IGZpZWxkcyA9IE9iamVjdC52YWx1ZXModHlwZS5nZXRGaWVsZHMoKSkubWFwKFxuICAgIChmLCBpKSA9PiBwcmludERlc2NyaXB0aW9uKGYsIFwiICBcIiwgIWkpICsgXCIgIFwiICsgcHJpbnRJbnB1dFZhbHVlKGYpXG4gICk7XG4gIHJldHVybiBwcmludERlc2NyaXB0aW9uKHR5cGUpICsgYGlucHV0ICR7dHlwZS5uYW1lfWAgKyBwcmludEJsb2NrKGZpZWxkcyk7XG59XG5mdW5jdGlvbiBwcmludEZpZWxkcyh0eXBlKSB7XG4gIGNvbnN0IGZpZWxkcyA9IE9iamVjdC52YWx1ZXModHlwZS5nZXRGaWVsZHMoKSkubWFwKFxuICAgIChmLCBpKSA9PiBwcmludERlc2NyaXB0aW9uKGYsIFwiICBcIiwgIWkpICsgXCIgIFwiICsgZi5uYW1lICsgcHJpbnRBcmdzKGYuYXJncywgXCIgIFwiKSArIFwiOiBcIiArIFN0cmluZyhmLnR5cGUpICsgcHJpbnREZXByZWNhdGVkKGYuZGVwcmVjYXRpb25SZWFzb24pXG4gICk7XG4gIHJldHVybiBwcmludEJsb2NrKGZpZWxkcyk7XG59XG5mdW5jdGlvbiBwcmludEJsb2NrKGl0ZW1zKSB7XG4gIHJldHVybiBpdGVtcy5sZW5ndGggIT09IDAgPyBcIiB7XFxuXCIgKyBpdGVtcy5qb2luKFwiXFxuXCIpICsgXCJcXG59XCIgOiBcIlwiO1xufVxuZnVuY3Rpb24gcHJpbnRBcmdzKGFyZ3MsIGluZGVudGF0aW9uID0gXCJcIikge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBpZiAoYXJncy5ldmVyeSgoYXJnKSA9PiAhYXJnLmRlc2NyaXB0aW9uKSkge1xuICAgIHJldHVybiBcIihcIiArIGFyZ3MubWFwKHByaW50SW5wdXRWYWx1ZSkuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gIH1cbiAgcmV0dXJuIFwiKFxcblwiICsgYXJncy5tYXAoXG4gICAgKGFyZywgaSkgPT4gcHJpbnREZXNjcmlwdGlvbihhcmcsIFwiICBcIiArIGluZGVudGF0aW9uLCAhaSkgKyBcIiAgXCIgKyBpbmRlbnRhdGlvbiArIHByaW50SW5wdXRWYWx1ZShhcmcpXG4gICkuam9pbihcIlxcblwiKSArIFwiXFxuXCIgKyBpbmRlbnRhdGlvbiArIFwiKVwiO1xufVxuZnVuY3Rpb24gcHJpbnRJbnB1dFZhbHVlKGFyZykge1xuICBjb25zdCBkZWZhdWx0QVNUID0gYXN0RnJvbVZhbHVlKGFyZy5kZWZhdWx0VmFsdWUsIGFyZy50eXBlKTtcbiAgbGV0IGFyZ0RlY2wgPSBhcmcubmFtZSArIFwiOiBcIiArIFN0cmluZyhhcmcudHlwZSk7XG4gIGlmIChkZWZhdWx0QVNUKSB7XG4gICAgYXJnRGVjbCArPSBgID0gJHtwcmludChkZWZhdWx0QVNUKX1gO1xuICB9XG4gIHJldHVybiBhcmdEZWNsICsgcHJpbnREZXByZWNhdGVkKGFyZy5kZXByZWNhdGlvblJlYXNvbik7XG59XG5mdW5jdGlvbiBwcmludERpcmVjdGl2ZShkaXJlY3RpdmUpIHtcbiAgcmV0dXJuIHByaW50RGVzY3JpcHRpb24oZGlyZWN0aXZlKSArIFwiZGlyZWN0aXZlIEBcIiArIGRpcmVjdGl2ZS5uYW1lICsgcHJpbnRBcmdzKGRpcmVjdGl2ZS5hcmdzKSArIChkaXJlY3RpdmUuaXNSZXBlYXRhYmxlID8gXCIgcmVwZWF0YWJsZVwiIDogXCJcIikgKyBcIiBvbiBcIiArIGRpcmVjdGl2ZS5sb2NhdGlvbnMuam9pbihcIiB8IFwiKTtcbn1cbmZ1bmN0aW9uIHByaW50RGVwcmVjYXRlZChyZWFzb24pIHtcbiAgaWYgKHJlYXNvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgaWYgKHJlYXNvbiAhPT0gREVGQVVMVF9ERVBSRUNBVElPTl9SRUFTT04pIHtcbiAgICBjb25zdCBhc3RWYWx1ZSA9IHByaW50KHtcbiAgICAgIGtpbmQ6IEtpbmQuU1RSSU5HLFxuICAgICAgdmFsdWU6IHJlYXNvblxuICAgIH0pO1xuICAgIHJldHVybiBgIEBkZXByZWNhdGVkKHJlYXNvbjogJHthc3RWYWx1ZX0pYDtcbiAgfVxuICByZXR1cm4gXCIgQGRlcHJlY2F0ZWRcIjtcbn1cbmZ1bmN0aW9uIHByaW50U3BlY2lmaWVkQnlVUkwoc2NhbGFyKSB7XG4gIGlmIChzY2FsYXIuc3BlY2lmaWVkQnlVUkwgPT0gbnVsbCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IGFzdFZhbHVlID0gcHJpbnQoe1xuICAgIGtpbmQ6IEtpbmQuU1RSSU5HLFxuICAgIHZhbHVlOiBzY2FsYXIuc3BlY2lmaWVkQnlVUkxcbiAgfSk7XG4gIHJldHVybiBgIEBzcGVjaWZpZWRCeSh1cmw6ICR7YXN0VmFsdWV9KWA7XG59XG5mdW5jdGlvbiBwcmludERlc2NyaXB0aW9uKGRlZiwgaW5kZW50YXRpb24gPSBcIlwiLCBmaXJzdEluQmxvY2sgPSB0cnVlKSB7XG4gIGNvbnN0IHsgZGVzY3JpcHRpb24gfSA9IGRlZjtcbiAgaWYgKGRlc2NyaXB0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBjb25zdCBibG9ja1N0cmluZyA9IHByaW50KHtcbiAgICBraW5kOiBLaW5kLlNUUklORyxcbiAgICB2YWx1ZTogZGVzY3JpcHRpb24sXG4gICAgYmxvY2s6IGlzUHJpbnRhYmxlQXNCbG9ja1N0cmluZyhkZXNjcmlwdGlvbilcbiAgfSk7XG4gIGNvbnN0IHByZWZpeCA9IGluZGVudGF0aW9uICYmICFmaXJzdEluQmxvY2sgPyBcIlxcblwiICsgaW5kZW50YXRpb24gOiBpbmRlbnRhdGlvbjtcbiAgcmV0dXJuIHByZWZpeCArIGJsb2NrU3RyaW5nLnJlcGxhY2UoL1xcbi9nLCBcIlxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIjtcbn1cbnZhciBpbml0X3ByaW50U2NoZW1hID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9wcmludFNjaGVtYS5tanNcIigpIHtcbiAgICBpbml0X2luc3BlY3QoKTtcbiAgICBpbml0X2ludmFyaWFudCgpO1xuICAgIGluaXRfYmxvY2tTdHJpbmcoKTtcbiAgICBpbml0X2tpbmRzKCk7XG4gICAgaW5pdF9wcmludGVyKCk7XG4gICAgaW5pdF9kZWZpbml0aW9uKCk7XG4gICAgaW5pdF9kaXJlY3RpdmVzKCk7XG4gICAgaW5pdF9pbnRyb3NwZWN0aW9uKCk7XG4gICAgaW5pdF9zY2FsYXJzKCk7XG4gICAgaW5pdF9hc3RGcm9tVmFsdWUoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9jb25jYXRBU1QubWpzXG5mdW5jdGlvbiBjb25jYXRBU1QoZG9jdW1lbnRzKSB7XG4gIGNvbnN0IGRlZmluaXRpb25zID0gW107XG4gIGZvciAoY29uc3QgZG9jIG9mIGRvY3VtZW50cykge1xuICAgIGRlZmluaXRpb25zLnB1c2goLi4uZG9jLmRlZmluaXRpb25zKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGtpbmQ6IEtpbmQuRE9DVU1FTlQsXG4gICAgZGVmaW5pdGlvbnNcbiAgfTtcbn1cbnZhciBpbml0X2NvbmNhdEFTVCA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvY29uY2F0QVNULm1qc1wiKCkge1xuICAgIGluaXRfa2luZHMoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9zZXBhcmF0ZU9wZXJhdGlvbnMubWpzXG5mdW5jdGlvbiBzZXBhcmF0ZU9wZXJhdGlvbnMoZG9jdW1lbnRBU1QpIHtcbiAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdO1xuICBjb25zdCBkZXBHcmFwaCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IGRlZmluaXRpb25Ob2RlIG9mIGRvY3VtZW50QVNULmRlZmluaXRpb25zKSB7XG4gICAgc3dpdGNoIChkZWZpbml0aW9uTm9kZS5raW5kKSB7XG4gICAgICBjYXNlIEtpbmQuT1BFUkFUSU9OX0RFRklOSVRJT046XG4gICAgICAgIG9wZXJhdGlvbnMucHVzaChkZWZpbml0aW9uTm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLaW5kLkZSQUdNRU5UX0RFRklOSVRJT046XG4gICAgICAgIGRlcEdyYXBoW2RlZmluaXRpb25Ob2RlLm5hbWUudmFsdWVdID0gY29sbGVjdERlcGVuZGVuY2llcyhcbiAgICAgICAgICBkZWZpbml0aW9uTm9kZS5zZWxlY3Rpb25TZXRcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuICBjb25zdCBzZXBhcmF0ZWREb2N1bWVudEFTVHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBvcGVyYXRpb24gb2Ygb3BlcmF0aW9ucykge1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBmcmFnbWVudE5hbWUgb2YgY29sbGVjdERlcGVuZGVuY2llcyhvcGVyYXRpb24uc2VsZWN0aW9uU2V0KSkge1xuICAgICAgY29sbGVjdFRyYW5zaXRpdmVEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzLCBkZXBHcmFwaCwgZnJhZ21lbnROYW1lKTtcbiAgICB9XG4gICAgY29uc3Qgb3BlcmF0aW9uTmFtZSA9IG9wZXJhdGlvbi5uYW1lID8gb3BlcmF0aW9uLm5hbWUudmFsdWUgOiBcIlwiO1xuICAgIHNlcGFyYXRlZERvY3VtZW50QVNUc1tvcGVyYXRpb25OYW1lXSA9IHtcbiAgICAgIGtpbmQ6IEtpbmQuRE9DVU1FTlQsXG4gICAgICBkZWZpbml0aW9uczogZG9jdW1lbnRBU1QuZGVmaW5pdGlvbnMuZmlsdGVyKFxuICAgICAgICAobm9kZSkgPT4gbm9kZSA9PT0gb3BlcmF0aW9uIHx8IG5vZGUua2luZCA9PT0gS2luZC5GUkFHTUVOVF9ERUZJTklUSU9OICYmIGRlcGVuZGVuY2llcy5oYXMobm9kZS5uYW1lLnZhbHVlKVxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNlcGFyYXRlZERvY3VtZW50QVNUcztcbn1cbmZ1bmN0aW9uIGNvbGxlY3RUcmFuc2l0aXZlRGVwZW5kZW5jaWVzKGNvbGxlY3RlZCwgZGVwR3JhcGgsIGZyb21OYW1lKSB7XG4gIGlmICghY29sbGVjdGVkLmhhcyhmcm9tTmFtZSkpIHtcbiAgICBjb2xsZWN0ZWQuYWRkKGZyb21OYW1lKTtcbiAgICBjb25zdCBpbW1lZGlhdGVEZXBzID0gZGVwR3JhcGhbZnJvbU5hbWVdO1xuICAgIGlmIChpbW1lZGlhdGVEZXBzICE9PSB2b2lkIDApIHtcbiAgICAgIGZvciAoY29uc3QgdG9OYW1lIG9mIGltbWVkaWF0ZURlcHMpIHtcbiAgICAgICAgY29sbGVjdFRyYW5zaXRpdmVEZXBlbmRlbmNpZXMoY29sbGVjdGVkLCBkZXBHcmFwaCwgdG9OYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3REZXBlbmRlbmNpZXMoc2VsZWN0aW9uU2V0KSB7XG4gIGNvbnN0IGRlcGVuZGVuY2llcyA9IFtdO1xuICB2aXNpdChzZWxlY3Rpb25TZXQsIHtcbiAgICBGcmFnbWVudFNwcmVhZChub2RlKSB7XG4gICAgICBkZXBlbmRlbmNpZXMucHVzaChub2RlLm5hbWUudmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkZXBlbmRlbmNpZXM7XG59XG52YXIgaW5pdF9zZXBhcmF0ZU9wZXJhdGlvbnMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdXRpbGl0aWVzL3NlcGFyYXRlT3BlcmF0aW9ucy5tanNcIigpIHtcbiAgICBpbml0X2tpbmRzKCk7XG4gICAgaW5pdF92aXNpdG9yKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvc3RyaXBJZ25vcmVkQ2hhcmFjdGVycy5tanNcbmZ1bmN0aW9uIHN0cmlwSWdub3JlZENoYXJhY3RlcnMoc291cmNlKSB7XG4gIGNvbnN0IHNvdXJjZU9iaiA9IGlzU291cmNlKHNvdXJjZSkgPyBzb3VyY2UgOiBuZXcgU291cmNlKHNvdXJjZSk7XG4gIGNvbnN0IGJvZHkgPSBzb3VyY2VPYmouYm9keTtcbiAgY29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoc291cmNlT2JqKTtcbiAgbGV0IHN0cmlwcGVkQm9keSA9IFwiXCI7XG4gIGxldCB3YXNMYXN0QWRkZWRUb2tlbk5vblB1bmN0dWF0b3IgPSBmYWxzZTtcbiAgd2hpbGUgKGxleGVyLmFkdmFuY2UoKS5raW5kICE9PSBUb2tlbktpbmQuRU9GKSB7XG4gICAgY29uc3QgY3VycmVudFRva2VuID0gbGV4ZXIudG9rZW47XG4gICAgY29uc3QgdG9rZW5LaW5kID0gY3VycmVudFRva2VuLmtpbmQ7XG4gICAgY29uc3QgaXNOb25QdW5jdHVhdG9yID0gIWlzUHVuY3R1YXRvclRva2VuS2luZChjdXJyZW50VG9rZW4ua2luZCk7XG4gICAgaWYgKHdhc0xhc3RBZGRlZFRva2VuTm9uUHVuY3R1YXRvcikge1xuICAgICAgaWYgKGlzTm9uUHVuY3R1YXRvciB8fCBjdXJyZW50VG9rZW4ua2luZCA9PT0gVG9rZW5LaW5kLlNQUkVBRCkge1xuICAgICAgICBzdHJpcHBlZEJvZHkgKz0gXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRva2VuQm9keSA9IGJvZHkuc2xpY2UoY3VycmVudFRva2VuLnN0YXJ0LCBjdXJyZW50VG9rZW4uZW5kKTtcbiAgICBpZiAodG9rZW5LaW5kID09PSBUb2tlbktpbmQuQkxPQ0tfU1RSSU5HKSB7XG4gICAgICBzdHJpcHBlZEJvZHkgKz0gcHJpbnRCbG9ja1N0cmluZyhjdXJyZW50VG9rZW4udmFsdWUsIHtcbiAgICAgICAgbWluaW1pemU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJpcHBlZEJvZHkgKz0gdG9rZW5Cb2R5O1xuICAgIH1cbiAgICB3YXNMYXN0QWRkZWRUb2tlbk5vblB1bmN0dWF0b3IgPSBpc05vblB1bmN0dWF0b3I7XG4gIH1cbiAgcmV0dXJuIHN0cmlwcGVkQm9keTtcbn1cbnZhciBpbml0X3N0cmlwSWdub3JlZENoYXJhY3RlcnMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdXRpbGl0aWVzL3N0cmlwSWdub3JlZENoYXJhY3RlcnMubWpzXCIoKSB7XG4gICAgaW5pdF9ibG9ja1N0cmluZygpO1xuICAgIGluaXRfbGV4ZXIoKTtcbiAgICBpbml0X3NvdXJjZSgpO1xuICAgIGluaXRfdG9rZW5LaW5kKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvYXNzZXJ0VmFsaWROYW1lLm1qc1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWROYW1lKG5hbWUpIHtcbiAgY29uc3QgZXJyb3IgPSBpc1ZhbGlkTmFtZUVycm9yKG5hbWUpO1xuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWROYW1lRXJyb3IobmFtZSkge1xuICB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiB8fCBkZXZBc3NlcnQoZmFsc2UsIFwiRXhwZWN0ZWQgbmFtZSB0byBiZSBhIHN0cmluZy5cIik7XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJfX1wiKSkge1xuICAgIHJldHVybiBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgYE5hbWUgXCIke25hbWV9XCIgbXVzdCBub3QgYmVnaW4gd2l0aCBcIl9fXCIsIHdoaWNoIGlzIHJlc2VydmVkIGJ5IEdyYXBoUUwgaW50cm9zcGVjdGlvbi5gXG4gICAgKTtcbiAgfVxuICB0cnkge1xuICAgIGFzc2VydE5hbWUobmFtZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG59XG52YXIgaW5pdF9hc3NlcnRWYWxpZE5hbWUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdXRpbGl0aWVzL2Fzc2VydFZhbGlkTmFtZS5tanNcIigpIHtcbiAgICBpbml0X2RldkFzc2VydCgpO1xuICAgIGluaXRfR3JhcGhRTEVycm9yKCk7XG4gICAgaW5pdF9hc3NlcnROYW1lKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvZmluZEJyZWFraW5nQ2hhbmdlcy5tanNcbmZ1bmN0aW9uIGZpbmRCcmVha2luZ0NoYW5nZXMob2xkU2NoZW1hLCBuZXdTY2hlbWEpIHtcbiAgcmV0dXJuIGZpbmRTY2hlbWFDaGFuZ2VzKG9sZFNjaGVtYSwgbmV3U2NoZW1hKS5maWx0ZXIoXG4gICAgKGNoYW5nZSkgPT4gY2hhbmdlLnR5cGUgaW4gQnJlYWtpbmdDaGFuZ2VUeXBlXG4gICk7XG59XG5mdW5jdGlvbiBmaW5kRGFuZ2Vyb3VzQ2hhbmdlcyhvbGRTY2hlbWEsIG5ld1NjaGVtYSkge1xuICByZXR1cm4gZmluZFNjaGVtYUNoYW5nZXMob2xkU2NoZW1hLCBuZXdTY2hlbWEpLmZpbHRlcihcbiAgICAoY2hhbmdlKSA9PiBjaGFuZ2UudHlwZSBpbiBEYW5nZXJvdXNDaGFuZ2VUeXBlXG4gICk7XG59XG5mdW5jdGlvbiBmaW5kU2NoZW1hQ2hhbmdlcyhvbGRTY2hlbWEsIG5ld1NjaGVtYSkge1xuICByZXR1cm4gW1xuICAgIC4uLmZpbmRUeXBlQ2hhbmdlcyhvbGRTY2hlbWEsIG5ld1NjaGVtYSksXG4gICAgLi4uZmluZERpcmVjdGl2ZUNoYW5nZXMob2xkU2NoZW1hLCBuZXdTY2hlbWEpXG4gIF07XG59XG5mdW5jdGlvbiBmaW5kRGlyZWN0aXZlQ2hhbmdlcyhvbGRTY2hlbWEsIG5ld1NjaGVtYSkge1xuICBjb25zdCBzY2hlbWFDaGFuZ2VzID0gW107XG4gIGNvbnN0IGRpcmVjdGl2ZXNEaWZmID0gZGlmZihcbiAgICBvbGRTY2hlbWEuZ2V0RGlyZWN0aXZlcygpLFxuICAgIG5ld1NjaGVtYS5nZXREaXJlY3RpdmVzKClcbiAgKTtcbiAgZm9yIChjb25zdCBvbGREaXJlY3RpdmUgb2YgZGlyZWN0aXZlc0RpZmYucmVtb3ZlZCkge1xuICAgIHNjaGVtYUNoYW5nZXMucHVzaCh7XG4gICAgICB0eXBlOiBCcmVha2luZ0NoYW5nZVR5cGUuRElSRUNUSVZFX1JFTU9WRUQsXG4gICAgICBkZXNjcmlwdGlvbjogYCR7b2xkRGlyZWN0aXZlLm5hbWV9IHdhcyByZW1vdmVkLmBcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IFtvbGREaXJlY3RpdmUsIG5ld0RpcmVjdGl2ZV0gb2YgZGlyZWN0aXZlc0RpZmYucGVyc2lzdGVkKSB7XG4gICAgY29uc3QgYXJnc0RpZmYgPSBkaWZmKG9sZERpcmVjdGl2ZS5hcmdzLCBuZXdEaXJlY3RpdmUuYXJncyk7XG4gICAgZm9yIChjb25zdCBuZXdBcmcgb2YgYXJnc0RpZmYuYWRkZWQpIHtcbiAgICAgIGlmIChpc1JlcXVpcmVkQXJndW1lbnQobmV3QXJnKSkge1xuICAgICAgICBzY2hlbWFDaGFuZ2VzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IEJyZWFraW5nQ2hhbmdlVHlwZS5SRVFVSVJFRF9ESVJFQ1RJVkVfQVJHX0FEREVELFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQSByZXF1aXJlZCBhcmcgJHtuZXdBcmcubmFtZX0gb24gZGlyZWN0aXZlICR7b2xkRGlyZWN0aXZlLm5hbWV9IHdhcyBhZGRlZC5gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9sZEFyZyBvZiBhcmdzRGlmZi5yZW1vdmVkKSB7XG4gICAgICBzY2hlbWFDaGFuZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiBCcmVha2luZ0NoYW5nZVR5cGUuRElSRUNUSVZFX0FSR19SRU1PVkVELFxuICAgICAgICBkZXNjcmlwdGlvbjogYCR7b2xkQXJnLm5hbWV9IHdhcyByZW1vdmVkIGZyb20gJHtvbGREaXJlY3RpdmUubmFtZX0uYFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvbGREaXJlY3RpdmUuaXNSZXBlYXRhYmxlICYmICFuZXdEaXJlY3RpdmUuaXNSZXBlYXRhYmxlKSB7XG4gICAgICBzY2hlbWFDaGFuZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiBCcmVha2luZ0NoYW5nZVR5cGUuRElSRUNUSVZFX1JFUEVBVEFCTEVfUkVNT1ZFRCxcbiAgICAgICAgZGVzY3JpcHRpb246IGBSZXBlYXRhYmxlIGZsYWcgd2FzIHJlbW92ZWQgZnJvbSAke29sZERpcmVjdGl2ZS5uYW1lfS5gXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsb2NhdGlvbiBvZiBvbGREaXJlY3RpdmUubG9jYXRpb25zKSB7XG4gICAgICBpZiAoIW5ld0RpcmVjdGl2ZS5sb2NhdGlvbnMuaW5jbHVkZXMobG9jYXRpb24pKSB7XG4gICAgICAgIHNjaGVtYUNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogQnJlYWtpbmdDaGFuZ2VUeXBlLkRJUkVDVElWRV9MT0NBVElPTl9SRU1PVkVELFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtsb2NhdGlvbn0gd2FzIHJlbW92ZWQgZnJvbSAke29sZERpcmVjdGl2ZS5uYW1lfS5gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2NoZW1hQ2hhbmdlcztcbn1cbmZ1bmN0aW9uIGZpbmRUeXBlQ2hhbmdlcyhvbGRTY2hlbWEsIG5ld1NjaGVtYSkge1xuICBjb25zdCBzY2hlbWFDaGFuZ2VzID0gW107XG4gIGNvbnN0IHR5cGVzRGlmZiA9IGRpZmYoXG4gICAgT2JqZWN0LnZhbHVlcyhvbGRTY2hlbWEuZ2V0VHlwZU1hcCgpKSxcbiAgICBPYmplY3QudmFsdWVzKG5ld1NjaGVtYS5nZXRUeXBlTWFwKCkpXG4gICk7XG4gIGZvciAoY29uc3Qgb2xkVHlwZSBvZiB0eXBlc0RpZmYucmVtb3ZlZCkge1xuICAgIHNjaGVtYUNoYW5nZXMucHVzaCh7XG4gICAgICB0eXBlOiBCcmVha2luZ0NoYW5nZVR5cGUuVFlQRV9SRU1PVkVELFxuICAgICAgZGVzY3JpcHRpb246IGlzU3BlY2lmaWVkU2NhbGFyVHlwZShvbGRUeXBlKSA/IGBTdGFuZGFyZCBzY2FsYXIgJHtvbGRUeXBlLm5hbWV9IHdhcyByZW1vdmVkIGJlY2F1c2UgaXQgaXMgbm90IHJlZmVyZW5jZWQgYW55bW9yZS5gIDogYCR7b2xkVHlwZS5uYW1lfSB3YXMgcmVtb3ZlZC5gXG4gICAgfSk7XG4gIH1cbiAgZm9yIChjb25zdCBbb2xkVHlwZSwgbmV3VHlwZV0gb2YgdHlwZXNEaWZmLnBlcnNpc3RlZCkge1xuICAgIGlmIChpc0VudW1UeXBlKG9sZFR5cGUpICYmIGlzRW51bVR5cGUobmV3VHlwZSkpIHtcbiAgICAgIHNjaGVtYUNoYW5nZXMucHVzaCguLi5maW5kRW51bVR5cGVDaGFuZ2VzKG9sZFR5cGUsIG5ld1R5cGUpKTtcbiAgICB9IGVsc2UgaWYgKGlzVW5pb25UeXBlKG9sZFR5cGUpICYmIGlzVW5pb25UeXBlKG5ld1R5cGUpKSB7XG4gICAgICBzY2hlbWFDaGFuZ2VzLnB1c2goLi4uZmluZFVuaW9uVHlwZUNoYW5nZXMob2xkVHlwZSwgbmV3VHlwZSkpO1xuICAgIH0gZWxzZSBpZiAoaXNJbnB1dE9iamVjdFR5cGUob2xkVHlwZSkgJiYgaXNJbnB1dE9iamVjdFR5cGUobmV3VHlwZSkpIHtcbiAgICAgIHNjaGVtYUNoYW5nZXMucHVzaCguLi5maW5kSW5wdXRPYmplY3RUeXBlQ2hhbmdlcyhvbGRUeXBlLCBuZXdUeXBlKSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdFR5cGUob2xkVHlwZSkgJiYgaXNPYmplY3RUeXBlKG5ld1R5cGUpKSB7XG4gICAgICBzY2hlbWFDaGFuZ2VzLnB1c2goXG4gICAgICAgIC4uLmZpbmRGaWVsZENoYW5nZXMob2xkVHlwZSwgbmV3VHlwZSksXG4gICAgICAgIC4uLmZpbmRJbXBsZW1lbnRlZEludGVyZmFjZXNDaGFuZ2VzKG9sZFR5cGUsIG5ld1R5cGUpXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNJbnRlcmZhY2VUeXBlKG9sZFR5cGUpICYmIGlzSW50ZXJmYWNlVHlwZShuZXdUeXBlKSkge1xuICAgICAgc2NoZW1hQ2hhbmdlcy5wdXNoKFxuICAgICAgICAuLi5maW5kRmllbGRDaGFuZ2VzKG9sZFR5cGUsIG5ld1R5cGUpLFxuICAgICAgICAuLi5maW5kSW1wbGVtZW50ZWRJbnRlcmZhY2VzQ2hhbmdlcyhvbGRUeXBlLCBuZXdUeXBlKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKG9sZFR5cGUuY29uc3RydWN0b3IgIT09IG5ld1R5cGUuY29uc3RydWN0b3IpIHtcbiAgICAgIHNjaGVtYUNoYW5nZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IEJyZWFraW5nQ2hhbmdlVHlwZS5UWVBFX0NIQU5HRURfS0lORCxcbiAgICAgICAgZGVzY3JpcHRpb246IGAke29sZFR5cGUubmFtZX0gY2hhbmdlZCBmcm9tICR7dHlwZUtpbmROYW1lKG9sZFR5cGUpfSB0byAke3R5cGVLaW5kTmFtZShuZXdUeXBlKX0uYFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzY2hlbWFDaGFuZ2VzO1xufVxuZnVuY3Rpb24gZmluZElucHV0T2JqZWN0VHlwZUNoYW5nZXMob2xkVHlwZSwgbmV3VHlwZSkge1xuICBjb25zdCBzY2hlbWFDaGFuZ2VzID0gW107XG4gIGNvbnN0IGZpZWxkc0RpZmYgPSBkaWZmKFxuICAgIE9iamVjdC52YWx1ZXMob2xkVHlwZS5nZXRGaWVsZHMoKSksXG4gICAgT2JqZWN0LnZhbHVlcyhuZXdUeXBlLmdldEZpZWxkcygpKVxuICApO1xuICBmb3IgKGNvbnN0IG5ld0ZpZWxkIG9mIGZpZWxkc0RpZmYuYWRkZWQpIHtcbiAgICBpZiAoaXNSZXF1aXJlZElucHV0RmllbGQobmV3RmllbGQpKSB7XG4gICAgICBzY2hlbWFDaGFuZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiBCcmVha2luZ0NoYW5nZVR5cGUuUkVRVUlSRURfSU5QVVRfRklFTERfQURERUQsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQSByZXF1aXJlZCBmaWVsZCAke25ld0ZpZWxkLm5hbWV9IG9uIGlucHV0IHR5cGUgJHtvbGRUeXBlLm5hbWV9IHdhcyBhZGRlZC5gXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZW1hQ2hhbmdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogRGFuZ2Vyb3VzQ2hhbmdlVHlwZS5PUFRJT05BTF9JTlBVVF9GSUVMRF9BRERFRCxcbiAgICAgICAgZGVzY3JpcHRpb246IGBBbiBvcHRpb25hbCBmaWVsZCAke25ld0ZpZWxkLm5hbWV9IG9uIGlucHV0IHR5cGUgJHtvbGRUeXBlLm5hbWV9IHdhcyBhZGRlZC5gXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBvbGRGaWVsZCBvZiBmaWVsZHNEaWZmLnJlbW92ZWQpIHtcbiAgICBzY2hlbWFDaGFuZ2VzLnB1c2goe1xuICAgICAgdHlwZTogQnJlYWtpbmdDaGFuZ2VUeXBlLkZJRUxEX1JFTU9WRUQsXG4gICAgICBkZXNjcmlwdGlvbjogYCR7b2xkVHlwZS5uYW1lfS4ke29sZEZpZWxkLm5hbWV9IHdhcyByZW1vdmVkLmBcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IFtvbGRGaWVsZCwgbmV3RmllbGRdIG9mIGZpZWxkc0RpZmYucGVyc2lzdGVkKSB7XG4gICAgY29uc3QgaXNTYWZlID0gaXNDaGFuZ2VTYWZlRm9ySW5wdXRPYmplY3RGaWVsZE9yRmllbGRBcmcoXG4gICAgICBvbGRGaWVsZC50eXBlLFxuICAgICAgbmV3RmllbGQudHlwZVxuICAgICk7XG4gICAgaWYgKCFpc1NhZmUpIHtcbiAgICAgIHNjaGVtYUNoYW5nZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IEJyZWFraW5nQ2hhbmdlVHlwZS5GSUVMRF9DSEFOR0VEX0tJTkQsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgJHtvbGRUeXBlLm5hbWV9LiR7b2xkRmllbGQubmFtZX0gY2hhbmdlZCB0eXBlIGZyb20gJHtTdHJpbmcob2xkRmllbGQudHlwZSl9IHRvICR7U3RyaW5nKG5ld0ZpZWxkLnR5cGUpfS5gXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNjaGVtYUNoYW5nZXM7XG59XG5mdW5jdGlvbiBmaW5kVW5pb25UeXBlQ2hhbmdlcyhvbGRUeXBlLCBuZXdUeXBlKSB7XG4gIGNvbnN0IHNjaGVtYUNoYW5nZXMgPSBbXTtcbiAgY29uc3QgcG9zc2libGVUeXBlc0RpZmYgPSBkaWZmKG9sZFR5cGUuZ2V0VHlwZXMoKSwgbmV3VHlwZS5nZXRUeXBlcygpKTtcbiAgZm9yIChjb25zdCBuZXdQb3NzaWJsZVR5cGUgb2YgcG9zc2libGVUeXBlc0RpZmYuYWRkZWQpIHtcbiAgICBzY2hlbWFDaGFuZ2VzLnB1c2goe1xuICAgICAgdHlwZTogRGFuZ2Vyb3VzQ2hhbmdlVHlwZS5UWVBFX0FEREVEX1RPX1VOSU9OLFxuICAgICAgZGVzY3JpcHRpb246IGAke25ld1Bvc3NpYmxlVHlwZS5uYW1lfSB3YXMgYWRkZWQgdG8gdW5pb24gdHlwZSAke29sZFR5cGUubmFtZX0uYFxuICAgIH0pO1xuICB9XG4gIGZvciAoY29uc3Qgb2xkUG9zc2libGVUeXBlIG9mIHBvc3NpYmxlVHlwZXNEaWZmLnJlbW92ZWQpIHtcbiAgICBzY2hlbWFDaGFuZ2VzLnB1c2goe1xuICAgICAgdHlwZTogQnJlYWtpbmdDaGFuZ2VUeXBlLlRZUEVfUkVNT1ZFRF9GUk9NX1VOSU9OLFxuICAgICAgZGVzY3JpcHRpb246IGAke29sZFBvc3NpYmxlVHlwZS5uYW1lfSB3YXMgcmVtb3ZlZCBmcm9tIHVuaW9uIHR5cGUgJHtvbGRUeXBlLm5hbWV9LmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2NoZW1hQ2hhbmdlcztcbn1cbmZ1bmN0aW9uIGZpbmRFbnVtVHlwZUNoYW5nZXMob2xkVHlwZSwgbmV3VHlwZSkge1xuICBjb25zdCBzY2hlbWFDaGFuZ2VzID0gW107XG4gIGNvbnN0IHZhbHVlc0RpZmYgPSBkaWZmKG9sZFR5cGUuZ2V0VmFsdWVzKCksIG5ld1R5cGUuZ2V0VmFsdWVzKCkpO1xuICBmb3IgKGNvbnN0IG5ld1ZhbHVlIG9mIHZhbHVlc0RpZmYuYWRkZWQpIHtcbiAgICBzY2hlbWFDaGFuZ2VzLnB1c2goe1xuICAgICAgdHlwZTogRGFuZ2Vyb3VzQ2hhbmdlVHlwZS5WQUxVRV9BRERFRF9UT19FTlVNLFxuICAgICAgZGVzY3JpcHRpb246IGAke25ld1ZhbHVlLm5hbWV9IHdhcyBhZGRlZCB0byBlbnVtIHR5cGUgJHtvbGRUeXBlLm5hbWV9LmBcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IG9sZFZhbHVlIG9mIHZhbHVlc0RpZmYucmVtb3ZlZCkge1xuICAgIHNjaGVtYUNoYW5nZXMucHVzaCh7XG4gICAgICB0eXBlOiBCcmVha2luZ0NoYW5nZVR5cGUuVkFMVUVfUkVNT1ZFRF9GUk9NX0VOVU0sXG4gICAgICBkZXNjcmlwdGlvbjogYCR7b2xkVmFsdWUubmFtZX0gd2FzIHJlbW92ZWQgZnJvbSBlbnVtIHR5cGUgJHtvbGRUeXBlLm5hbWV9LmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2NoZW1hQ2hhbmdlcztcbn1cbmZ1bmN0aW9uIGZpbmRJbXBsZW1lbnRlZEludGVyZmFjZXNDaGFuZ2VzKG9sZFR5cGUsIG5ld1R5cGUpIHtcbiAgY29uc3Qgc2NoZW1hQ2hhbmdlcyA9IFtdO1xuICBjb25zdCBpbnRlcmZhY2VzRGlmZiA9IGRpZmYob2xkVHlwZS5nZXRJbnRlcmZhY2VzKCksIG5ld1R5cGUuZ2V0SW50ZXJmYWNlcygpKTtcbiAgZm9yIChjb25zdCBuZXdJbnRlcmZhY2Ugb2YgaW50ZXJmYWNlc0RpZmYuYWRkZWQpIHtcbiAgICBzY2hlbWFDaGFuZ2VzLnB1c2goe1xuICAgICAgdHlwZTogRGFuZ2Vyb3VzQ2hhbmdlVHlwZS5JTVBMRU1FTlRFRF9JTlRFUkZBQ0VfQURERUQsXG4gICAgICBkZXNjcmlwdGlvbjogYCR7bmV3SW50ZXJmYWNlLm5hbWV9IGFkZGVkIHRvIGludGVyZmFjZXMgaW1wbGVtZW50ZWQgYnkgJHtvbGRUeXBlLm5hbWV9LmBcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IG9sZEludGVyZmFjZSBvZiBpbnRlcmZhY2VzRGlmZi5yZW1vdmVkKSB7XG4gICAgc2NoZW1hQ2hhbmdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IEJyZWFraW5nQ2hhbmdlVHlwZS5JTVBMRU1FTlRFRF9JTlRFUkZBQ0VfUkVNT1ZFRCxcbiAgICAgIGRlc2NyaXB0aW9uOiBgJHtvbGRUeXBlLm5hbWV9IG5vIGxvbmdlciBpbXBsZW1lbnRzIGludGVyZmFjZSAke29sZEludGVyZmFjZS5uYW1lfS5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYUNoYW5nZXM7XG59XG5mdW5jdGlvbiBmaW5kRmllbGRDaGFuZ2VzKG9sZFR5cGUsIG5ld1R5cGUpIHtcbiAgY29uc3Qgc2NoZW1hQ2hhbmdlcyA9IFtdO1xuICBjb25zdCBmaWVsZHNEaWZmID0gZGlmZihcbiAgICBPYmplY3QudmFsdWVzKG9sZFR5cGUuZ2V0RmllbGRzKCkpLFxuICAgIE9iamVjdC52YWx1ZXMobmV3VHlwZS5nZXRGaWVsZHMoKSlcbiAgKTtcbiAgZm9yIChjb25zdCBvbGRGaWVsZCBvZiBmaWVsZHNEaWZmLnJlbW92ZWQpIHtcbiAgICBzY2hlbWFDaGFuZ2VzLnB1c2goe1xuICAgICAgdHlwZTogQnJlYWtpbmdDaGFuZ2VUeXBlLkZJRUxEX1JFTU9WRUQsXG4gICAgICBkZXNjcmlwdGlvbjogYCR7b2xkVHlwZS5uYW1lfS4ke29sZEZpZWxkLm5hbWV9IHdhcyByZW1vdmVkLmBcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IFtvbGRGaWVsZCwgbmV3RmllbGRdIG9mIGZpZWxkc0RpZmYucGVyc2lzdGVkKSB7XG4gICAgc2NoZW1hQ2hhbmdlcy5wdXNoKC4uLmZpbmRBcmdDaGFuZ2VzKG9sZFR5cGUsIG9sZEZpZWxkLCBuZXdGaWVsZCkpO1xuICAgIGNvbnN0IGlzU2FmZSA9IGlzQ2hhbmdlU2FmZUZvck9iamVjdE9ySW50ZXJmYWNlRmllbGQoXG4gICAgICBvbGRGaWVsZC50eXBlLFxuICAgICAgbmV3RmllbGQudHlwZVxuICAgICk7XG4gICAgaWYgKCFpc1NhZmUpIHtcbiAgICAgIHNjaGVtYUNoYW5nZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IEJyZWFraW5nQ2hhbmdlVHlwZS5GSUVMRF9DSEFOR0VEX0tJTkQsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgJHtvbGRUeXBlLm5hbWV9LiR7b2xkRmllbGQubmFtZX0gY2hhbmdlZCB0eXBlIGZyb20gJHtTdHJpbmcob2xkRmllbGQudHlwZSl9IHRvICR7U3RyaW5nKG5ld0ZpZWxkLnR5cGUpfS5gXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNjaGVtYUNoYW5nZXM7XG59XG5mdW5jdGlvbiBmaW5kQXJnQ2hhbmdlcyhvbGRUeXBlLCBvbGRGaWVsZCwgbmV3RmllbGQpIHtcbiAgY29uc3Qgc2NoZW1hQ2hhbmdlcyA9IFtdO1xuICBjb25zdCBhcmdzRGlmZiA9IGRpZmYob2xkRmllbGQuYXJncywgbmV3RmllbGQuYXJncyk7XG4gIGZvciAoY29uc3Qgb2xkQXJnIG9mIGFyZ3NEaWZmLnJlbW92ZWQpIHtcbiAgICBzY2hlbWFDaGFuZ2VzLnB1c2goe1xuICAgICAgdHlwZTogQnJlYWtpbmdDaGFuZ2VUeXBlLkFSR19SRU1PVkVELFxuICAgICAgZGVzY3JpcHRpb246IGAke29sZFR5cGUubmFtZX0uJHtvbGRGaWVsZC5uYW1lfSBhcmcgJHtvbGRBcmcubmFtZX0gd2FzIHJlbW92ZWQuYFxuICAgIH0pO1xuICB9XG4gIGZvciAoY29uc3QgW29sZEFyZywgbmV3QXJnXSBvZiBhcmdzRGlmZi5wZXJzaXN0ZWQpIHtcbiAgICBjb25zdCBpc1NhZmUgPSBpc0NoYW5nZVNhZmVGb3JJbnB1dE9iamVjdEZpZWxkT3JGaWVsZEFyZyhcbiAgICAgIG9sZEFyZy50eXBlLFxuICAgICAgbmV3QXJnLnR5cGVcbiAgICApO1xuICAgIGlmICghaXNTYWZlKSB7XG4gICAgICBzY2hlbWFDaGFuZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiBCcmVha2luZ0NoYW5nZVR5cGUuQVJHX0NIQU5HRURfS0lORCxcbiAgICAgICAgZGVzY3JpcHRpb246IGAke29sZFR5cGUubmFtZX0uJHtvbGRGaWVsZC5uYW1lfSBhcmcgJHtvbGRBcmcubmFtZX0gaGFzIGNoYW5nZWQgdHlwZSBmcm9tICR7U3RyaW5nKG9sZEFyZy50eXBlKX0gdG8gJHtTdHJpbmcobmV3QXJnLnR5cGUpfS5gXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG9sZEFyZy5kZWZhdWx0VmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKG5ld0FyZy5kZWZhdWx0VmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBzY2hlbWFDaGFuZ2VzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IERhbmdlcm91c0NoYW5nZVR5cGUuQVJHX0RFRkFVTFRfVkFMVUVfQ0hBTkdFLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtvbGRUeXBlLm5hbWV9LiR7b2xkRmllbGQubmFtZX0gYXJnICR7b2xkQXJnLm5hbWV9IGRlZmF1bHRWYWx1ZSB3YXMgcmVtb3ZlZC5gXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWVTdHIgPSBzdHJpbmdpZnlWYWx1ZShvbGRBcmcuZGVmYXVsdFZhbHVlLCBvbGRBcmcudHlwZSk7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlU3RyID0gc3RyaW5naWZ5VmFsdWUobmV3QXJnLmRlZmF1bHRWYWx1ZSwgbmV3QXJnLnR5cGUpO1xuICAgICAgICBpZiAob2xkVmFsdWVTdHIgIT09IG5ld1ZhbHVlU3RyKSB7XG4gICAgICAgICAgc2NoZW1hQ2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IERhbmdlcm91c0NoYW5nZVR5cGUuQVJHX0RFRkFVTFRfVkFMVUVfQ0hBTkdFLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGAke29sZFR5cGUubmFtZX0uJHtvbGRGaWVsZC5uYW1lfSBhcmcgJHtvbGRBcmcubmFtZX0gaGFzIGNoYW5nZWQgZGVmYXVsdFZhbHVlIGZyb20gJHtvbGRWYWx1ZVN0cn0gdG8gJHtuZXdWYWx1ZVN0cn0uYFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgbmV3QXJnIG9mIGFyZ3NEaWZmLmFkZGVkKSB7XG4gICAgaWYgKGlzUmVxdWlyZWRBcmd1bWVudChuZXdBcmcpKSB7XG4gICAgICBzY2hlbWFDaGFuZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiBCcmVha2luZ0NoYW5nZVR5cGUuUkVRVUlSRURfQVJHX0FEREVELFxuICAgICAgICBkZXNjcmlwdGlvbjogYEEgcmVxdWlyZWQgYXJnICR7bmV3QXJnLm5hbWV9IG9uICR7b2xkVHlwZS5uYW1lfS4ke29sZEZpZWxkLm5hbWV9IHdhcyBhZGRlZC5gXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZW1hQ2hhbmdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogRGFuZ2Vyb3VzQ2hhbmdlVHlwZS5PUFRJT05BTF9BUkdfQURERUQsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQW4gb3B0aW9uYWwgYXJnICR7bmV3QXJnLm5hbWV9IG9uICR7b2xkVHlwZS5uYW1lfS4ke29sZEZpZWxkLm5hbWV9IHdhcyBhZGRlZC5gXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNjaGVtYUNoYW5nZXM7XG59XG5mdW5jdGlvbiBpc0NoYW5nZVNhZmVGb3JPYmplY3RPckludGVyZmFjZUZpZWxkKG9sZFR5cGUsIG5ld1R5cGUpIHtcbiAgaWYgKGlzTGlzdFR5cGUob2xkVHlwZSkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gaWYgdGhleSdyZSBib3RoIGxpc3RzLCBtYWtlIHN1cmUgdGhlIHVuZGVybHlpbmcgdHlwZXMgYXJlIGNvbXBhdGlibGVcbiAgICAgIGlzTGlzdFR5cGUobmV3VHlwZSkgJiYgaXNDaGFuZ2VTYWZlRm9yT2JqZWN0T3JJbnRlcmZhY2VGaWVsZChcbiAgICAgICAgb2xkVHlwZS5vZlR5cGUsXG4gICAgICAgIG5ld1R5cGUub2ZUeXBlXG4gICAgICApIHx8IC8vIG1vdmluZyBmcm9tIG51bGxhYmxlIHRvIG5vbi1udWxsIG9mIHRoZSBzYW1lIHVuZGVybHlpbmcgdHlwZSBpcyBzYWZlXG4gICAgICBpc05vbk51bGxUeXBlKG5ld1R5cGUpICYmIGlzQ2hhbmdlU2FmZUZvck9iamVjdE9ySW50ZXJmYWNlRmllbGQob2xkVHlwZSwgbmV3VHlwZS5vZlR5cGUpXG4gICAgKTtcbiAgfVxuICBpZiAoaXNOb25OdWxsVHlwZShvbGRUeXBlKSkge1xuICAgIHJldHVybiBpc05vbk51bGxUeXBlKG5ld1R5cGUpICYmIGlzQ2hhbmdlU2FmZUZvck9iamVjdE9ySW50ZXJmYWNlRmllbGQob2xkVHlwZS5vZlR5cGUsIG5ld1R5cGUub2ZUeXBlKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIC8vIGlmIHRoZXkncmUgYm90aCBuYW1lZCB0eXBlcywgc2VlIGlmIHRoZWlyIG5hbWVzIGFyZSBlcXVpdmFsZW50XG4gICAgaXNOYW1lZFR5cGUobmV3VHlwZSkgJiYgb2xkVHlwZS5uYW1lID09PSBuZXdUeXBlLm5hbWUgfHwgLy8gbW92aW5nIGZyb20gbnVsbGFibGUgdG8gbm9uLW51bGwgb2YgdGhlIHNhbWUgdW5kZXJseWluZyB0eXBlIGlzIHNhZmVcbiAgICBpc05vbk51bGxUeXBlKG5ld1R5cGUpICYmIGlzQ2hhbmdlU2FmZUZvck9iamVjdE9ySW50ZXJmYWNlRmllbGQob2xkVHlwZSwgbmV3VHlwZS5vZlR5cGUpXG4gICk7XG59XG5mdW5jdGlvbiBpc0NoYW5nZVNhZmVGb3JJbnB1dE9iamVjdEZpZWxkT3JGaWVsZEFyZyhvbGRUeXBlLCBuZXdUeXBlKSB7XG4gIGlmIChpc0xpc3RUeXBlKG9sZFR5cGUpKSB7XG4gICAgcmV0dXJuIGlzTGlzdFR5cGUobmV3VHlwZSkgJiYgaXNDaGFuZ2VTYWZlRm9ySW5wdXRPYmplY3RGaWVsZE9yRmllbGRBcmcob2xkVHlwZS5vZlR5cGUsIG5ld1R5cGUub2ZUeXBlKTtcbiAgfVxuICBpZiAoaXNOb25OdWxsVHlwZShvbGRUeXBlKSkge1xuICAgIHJldHVybiAoXG4gICAgICAvLyBpZiB0aGV5J3JlIGJvdGggbm9uLW51bGwsIG1ha2Ugc3VyZSB0aGUgdW5kZXJseWluZyB0eXBlcyBhcmVcbiAgICAgIC8vIGNvbXBhdGlibGVcbiAgICAgIGlzTm9uTnVsbFR5cGUobmV3VHlwZSkgJiYgaXNDaGFuZ2VTYWZlRm9ySW5wdXRPYmplY3RGaWVsZE9yRmllbGRBcmcoXG4gICAgICAgIG9sZFR5cGUub2ZUeXBlLFxuICAgICAgICBuZXdUeXBlLm9mVHlwZVxuICAgICAgKSB8fCAvLyBtb3ZpbmcgZnJvbSBub24tbnVsbCB0byBudWxsYWJsZSBvZiB0aGUgc2FtZSB1bmRlcmx5aW5nIHR5cGUgaXMgc2FmZVxuICAgICAgIWlzTm9uTnVsbFR5cGUobmV3VHlwZSkgJiYgaXNDaGFuZ2VTYWZlRm9ySW5wdXRPYmplY3RGaWVsZE9yRmllbGRBcmcob2xkVHlwZS5vZlR5cGUsIG5ld1R5cGUpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gaXNOYW1lZFR5cGUobmV3VHlwZSkgJiYgb2xkVHlwZS5uYW1lID09PSBuZXdUeXBlLm5hbWU7XG59XG5mdW5jdGlvbiB0eXBlS2luZE5hbWUodHlwZSkge1xuICBpZiAoaXNTY2FsYXJUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIFwiYSBTY2FsYXIgdHlwZVwiO1xuICB9XG4gIGlmIChpc09iamVjdFR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gXCJhbiBPYmplY3QgdHlwZVwiO1xuICB9XG4gIGlmIChpc0ludGVyZmFjZVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gXCJhbiBJbnRlcmZhY2UgdHlwZVwiO1xuICB9XG4gIGlmIChpc1VuaW9uVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiBcImEgVW5pb24gdHlwZVwiO1xuICB9XG4gIGlmIChpc0VudW1UeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIFwiYW4gRW51bSB0eXBlXCI7XG4gIH1cbiAgaWYgKGlzSW5wdXRPYmplY3RUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIFwiYW4gSW5wdXQgdHlwZVwiO1xuICB9XG4gIGludmFyaWFudChmYWxzZSwgXCJVbmV4cGVjdGVkIHR5cGU6IFwiICsgaW5zcGVjdCh0eXBlKSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICBjb25zdCBhc3QgPSBhc3RGcm9tVmFsdWUodmFsdWUsIHR5cGUpO1xuICBhc3QgIT0gbnVsbCB8fCBpbnZhcmlhbnQoZmFsc2UpO1xuICByZXR1cm4gcHJpbnQoc29ydFZhbHVlTm9kZShhc3QpKTtcbn1cbmZ1bmN0aW9uIGRpZmYob2xkQXJyYXksIG5ld0FycmF5KSB7XG4gIGNvbnN0IGFkZGVkID0gW107XG4gIGNvbnN0IHJlbW92ZWQgPSBbXTtcbiAgY29uc3QgcGVyc2lzdGVkID0gW107XG4gIGNvbnN0IG9sZE1hcCA9IGtleU1hcChvbGRBcnJheSwgKHsgbmFtZSB9KSA9PiBuYW1lKTtcbiAgY29uc3QgbmV3TWFwID0ga2V5TWFwKG5ld0FycmF5LCAoeyBuYW1lIH0pID0+IG5hbWUpO1xuICBmb3IgKGNvbnN0IG9sZEl0ZW0gb2Ygb2xkQXJyYXkpIHtcbiAgICBjb25zdCBuZXdJdGVtID0gbmV3TWFwW29sZEl0ZW0ubmFtZV07XG4gICAgaWYgKG5ld0l0ZW0gPT09IHZvaWQgMCkge1xuICAgICAgcmVtb3ZlZC5wdXNoKG9sZEl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZXJzaXN0ZWQucHVzaChbb2xkSXRlbSwgbmV3SXRlbV0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IG5ld0l0ZW0gb2YgbmV3QXJyYXkpIHtcbiAgICBpZiAob2xkTWFwW25ld0l0ZW0ubmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgYWRkZWQucHVzaChuZXdJdGVtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhZGRlZCxcbiAgICBwZXJzaXN0ZWQsXG4gICAgcmVtb3ZlZFxuICB9O1xufVxudmFyIEJyZWFraW5nQ2hhbmdlVHlwZSwgRGFuZ2Vyb3VzQ2hhbmdlVHlwZTtcbnZhciBpbml0X2ZpbmRCcmVha2luZ0NoYW5nZXMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvdXRpbGl0aWVzL2ZpbmRCcmVha2luZ0NoYW5nZXMubWpzXCIoKSB7XG4gICAgaW5pdF9pbnNwZWN0KCk7XG4gICAgaW5pdF9pbnZhcmlhbnQoKTtcbiAgICBpbml0X2tleU1hcCgpO1xuICAgIGluaXRfcHJpbnRlcigpO1xuICAgIGluaXRfZGVmaW5pdGlvbigpO1xuICAgIGluaXRfc2NhbGFycygpO1xuICAgIGluaXRfYXN0RnJvbVZhbHVlKCk7XG4gICAgaW5pdF9zb3J0VmFsdWVOb2RlKCk7XG4gICAgKGZ1bmN0aW9uKEJyZWFraW5nQ2hhbmdlVHlwZTIpIHtcbiAgICAgIEJyZWFraW5nQ2hhbmdlVHlwZTJbXCJUWVBFX1JFTU9WRURcIl0gPSBcIlRZUEVfUkVNT1ZFRFwiO1xuICAgICAgQnJlYWtpbmdDaGFuZ2VUeXBlMltcIlRZUEVfQ0hBTkdFRF9LSU5EXCJdID0gXCJUWVBFX0NIQU5HRURfS0lORFwiO1xuICAgICAgQnJlYWtpbmdDaGFuZ2VUeXBlMltcIlRZUEVfUkVNT1ZFRF9GUk9NX1VOSU9OXCJdID0gXCJUWVBFX1JFTU9WRURfRlJPTV9VTklPTlwiO1xuICAgICAgQnJlYWtpbmdDaGFuZ2VUeXBlMltcIlZBTFVFX1JFTU9WRURfRlJPTV9FTlVNXCJdID0gXCJWQUxVRV9SRU1PVkVEX0ZST01fRU5VTVwiO1xuICAgICAgQnJlYWtpbmdDaGFuZ2VUeXBlMltcIlJFUVVJUkVEX0lOUFVUX0ZJRUxEX0FEREVEXCJdID0gXCJSRVFVSVJFRF9JTlBVVF9GSUVMRF9BRERFRFwiO1xuICAgICAgQnJlYWtpbmdDaGFuZ2VUeXBlMltcIklNUExFTUVOVEVEX0lOVEVSRkFDRV9SRU1PVkVEXCJdID0gXCJJTVBMRU1FTlRFRF9JTlRFUkZBQ0VfUkVNT1ZFRFwiO1xuICAgICAgQnJlYWtpbmdDaGFuZ2VUeXBlMltcIkZJRUxEX1JFTU9WRURcIl0gPSBcIkZJRUxEX1JFTU9WRURcIjtcbiAgICAgIEJyZWFraW5nQ2hhbmdlVHlwZTJbXCJGSUVMRF9DSEFOR0VEX0tJTkRcIl0gPSBcIkZJRUxEX0NIQU5HRURfS0lORFwiO1xuICAgICAgQnJlYWtpbmdDaGFuZ2VUeXBlMltcIlJFUVVJUkVEX0FSR19BRERFRFwiXSA9IFwiUkVRVUlSRURfQVJHX0FEREVEXCI7XG4gICAgICBCcmVha2luZ0NoYW5nZVR5cGUyW1wiQVJHX1JFTU9WRURcIl0gPSBcIkFSR19SRU1PVkVEXCI7XG4gICAgICBCcmVha2luZ0NoYW5nZVR5cGUyW1wiQVJHX0NIQU5HRURfS0lORFwiXSA9IFwiQVJHX0NIQU5HRURfS0lORFwiO1xuICAgICAgQnJlYWtpbmdDaGFuZ2VUeXBlMltcIkRJUkVDVElWRV9SRU1PVkVEXCJdID0gXCJESVJFQ1RJVkVfUkVNT1ZFRFwiO1xuICAgICAgQnJlYWtpbmdDaGFuZ2VUeXBlMltcIkRJUkVDVElWRV9BUkdfUkVNT1ZFRFwiXSA9IFwiRElSRUNUSVZFX0FSR19SRU1PVkVEXCI7XG4gICAgICBCcmVha2luZ0NoYW5nZVR5cGUyW1wiUkVRVUlSRURfRElSRUNUSVZFX0FSR19BRERFRFwiXSA9IFwiUkVRVUlSRURfRElSRUNUSVZFX0FSR19BRERFRFwiO1xuICAgICAgQnJlYWtpbmdDaGFuZ2VUeXBlMltcIkRJUkVDVElWRV9SRVBFQVRBQkxFX1JFTU9WRURcIl0gPSBcIkRJUkVDVElWRV9SRVBFQVRBQkxFX1JFTU9WRURcIjtcbiAgICAgIEJyZWFraW5nQ2hhbmdlVHlwZTJbXCJESVJFQ1RJVkVfTE9DQVRJT05fUkVNT1ZFRFwiXSA9IFwiRElSRUNUSVZFX0xPQ0FUSU9OX1JFTU9WRURcIjtcbiAgICB9KShCcmVha2luZ0NoYW5nZVR5cGUgfHwgKEJyZWFraW5nQ2hhbmdlVHlwZSA9IHt9KSk7XG4gICAgKGZ1bmN0aW9uKERhbmdlcm91c0NoYW5nZVR5cGUyKSB7XG4gICAgICBEYW5nZXJvdXNDaGFuZ2VUeXBlMltcIlZBTFVFX0FEREVEX1RPX0VOVU1cIl0gPSBcIlZBTFVFX0FEREVEX1RPX0VOVU1cIjtcbiAgICAgIERhbmdlcm91c0NoYW5nZVR5cGUyW1wiVFlQRV9BRERFRF9UT19VTklPTlwiXSA9IFwiVFlQRV9BRERFRF9UT19VTklPTlwiO1xuICAgICAgRGFuZ2Vyb3VzQ2hhbmdlVHlwZTJbXCJPUFRJT05BTF9JTlBVVF9GSUVMRF9BRERFRFwiXSA9IFwiT1BUSU9OQUxfSU5QVVRfRklFTERfQURERURcIjtcbiAgICAgIERhbmdlcm91c0NoYW5nZVR5cGUyW1wiT1BUSU9OQUxfQVJHX0FEREVEXCJdID0gXCJPUFRJT05BTF9BUkdfQURERURcIjtcbiAgICAgIERhbmdlcm91c0NoYW5nZVR5cGUyW1wiSU1QTEVNRU5URURfSU5URVJGQUNFX0FEREVEXCJdID0gXCJJTVBMRU1FTlRFRF9JTlRFUkZBQ0VfQURERURcIjtcbiAgICAgIERhbmdlcm91c0NoYW5nZVR5cGUyW1wiQVJHX0RFRkFVTFRfVkFMVUVfQ0hBTkdFXCJdID0gXCJBUkdfREVGQVVMVF9WQUxVRV9DSEFOR0VcIjtcbiAgICB9KShEYW5nZXJvdXNDaGFuZ2VUeXBlIHx8IChEYW5nZXJvdXNDaGFuZ2VUeXBlID0ge30pKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL3V0aWxpdGllcy9pbmRleC5tanNcbnZhciBpbml0X3V0aWxpdGllcyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvaW5kZXgubWpzXCIoKSB7XG4gICAgaW5pdF9nZXRJbnRyb3NwZWN0aW9uUXVlcnkoKTtcbiAgICBpbml0X2dldE9wZXJhdGlvbkFTVCgpO1xuICAgIGluaXRfZ2V0T3BlcmF0aW9uUm9vdFR5cGUoKTtcbiAgICBpbml0X2ludHJvc3BlY3Rpb25Gcm9tU2NoZW1hKCk7XG4gICAgaW5pdF9idWlsZENsaWVudFNjaGVtYSgpO1xuICAgIGluaXRfYnVpbGRBU1RTY2hlbWEoKTtcbiAgICBpbml0X2V4dGVuZFNjaGVtYSgpO1xuICAgIGluaXRfbGV4aWNvZ3JhcGhpY1NvcnRTY2hlbWEoKTtcbiAgICBpbml0X3ByaW50U2NoZW1hKCk7XG4gICAgaW5pdF90eXBlRnJvbUFTVCgpO1xuICAgIGluaXRfdmFsdWVGcm9tQVNUKCk7XG4gICAgaW5pdF92YWx1ZUZyb21BU1RVbnR5cGVkKCk7XG4gICAgaW5pdF9hc3RGcm9tVmFsdWUoKTtcbiAgICBpbml0X1R5cGVJbmZvKCk7XG4gICAgaW5pdF9jb2VyY2VJbnB1dFZhbHVlKCk7XG4gICAgaW5pdF9jb25jYXRBU1QoKTtcbiAgICBpbml0X3NlcGFyYXRlT3BlcmF0aW9ucygpO1xuICAgIGluaXRfc3RyaXBJZ25vcmVkQ2hhcmFjdGVycygpO1xuICAgIGluaXRfdHlwZUNvbXBhcmF0b3JzKCk7XG4gICAgaW5pdF9hc3NlcnRWYWxpZE5hbWUoKTtcbiAgICBpbml0X2ZpbmRCcmVha2luZ0NoYW5nZXMoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ncmFwaHFsL2luZGV4Lm1qc1xudmFyIGdyYXBocWxfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZ3JhcGhxbF9leHBvcnRzLCB7XG4gIEJSRUFLOiAoKSA9PiBCUkVBSyxcbiAgQnJlYWtpbmdDaGFuZ2VUeXBlOiAoKSA9PiBCcmVha2luZ0NoYW5nZVR5cGUsXG4gIERFRkFVTFRfREVQUkVDQVRJT05fUkVBU09OOiAoKSA9PiBERUZBVUxUX0RFUFJFQ0FUSU9OX1JFQVNPTixcbiAgRGFuZ2Vyb3VzQ2hhbmdlVHlwZTogKCkgPT4gRGFuZ2Vyb3VzQ2hhbmdlVHlwZSxcbiAgRGlyZWN0aXZlTG9jYXRpb246ICgpID0+IERpcmVjdGl2ZUxvY2F0aW9uLFxuICBFeGVjdXRhYmxlRGVmaW5pdGlvbnNSdWxlOiAoKSA9PiBFeGVjdXRhYmxlRGVmaW5pdGlvbnNSdWxlLFxuICBGaWVsZHNPbkNvcnJlY3RUeXBlUnVsZTogKCkgPT4gRmllbGRzT25Db3JyZWN0VHlwZVJ1bGUsXG4gIEZyYWdtZW50c09uQ29tcG9zaXRlVHlwZXNSdWxlOiAoKSA9PiBGcmFnbWVudHNPbkNvbXBvc2l0ZVR5cGVzUnVsZSxcbiAgR1JBUEhRTF9NQVhfSU5UOiAoKSA9PiBHUkFQSFFMX01BWF9JTlQsXG4gIEdSQVBIUUxfTUlOX0lOVDogKCkgPT4gR1JBUEhRTF9NSU5fSU5ULFxuICBHcmFwaFFMQm9vbGVhbjogKCkgPT4gR3JhcGhRTEJvb2xlYW4sXG4gIEdyYXBoUUxEZXByZWNhdGVkRGlyZWN0aXZlOiAoKSA9PiBHcmFwaFFMRGVwcmVjYXRlZERpcmVjdGl2ZSxcbiAgR3JhcGhRTERpcmVjdGl2ZTogKCkgPT4gR3JhcGhRTERpcmVjdGl2ZSxcbiAgR3JhcGhRTEVudW1UeXBlOiAoKSA9PiBHcmFwaFFMRW51bVR5cGUsXG4gIEdyYXBoUUxFcnJvcjogKCkgPT4gR3JhcGhRTEVycm9yLFxuICBHcmFwaFFMRmxvYXQ6ICgpID0+IEdyYXBoUUxGbG9hdCxcbiAgR3JhcGhRTElEOiAoKSA9PiBHcmFwaFFMSUQsXG4gIEdyYXBoUUxJbmNsdWRlRGlyZWN0aXZlOiAoKSA9PiBHcmFwaFFMSW5jbHVkZURpcmVjdGl2ZSxcbiAgR3JhcGhRTElucHV0T2JqZWN0VHlwZTogKCkgPT4gR3JhcGhRTElucHV0T2JqZWN0VHlwZSxcbiAgR3JhcGhRTEludDogKCkgPT4gR3JhcGhRTEludCxcbiAgR3JhcGhRTEludGVyZmFjZVR5cGU6ICgpID0+IEdyYXBoUUxJbnRlcmZhY2VUeXBlLFxuICBHcmFwaFFMTGlzdDogKCkgPT4gR3JhcGhRTExpc3QsXG4gIEdyYXBoUUxOb25OdWxsOiAoKSA9PiBHcmFwaFFMTm9uTnVsbCxcbiAgR3JhcGhRTE9iamVjdFR5cGU6ICgpID0+IEdyYXBoUUxPYmplY3RUeXBlLFxuICBHcmFwaFFMU2NhbGFyVHlwZTogKCkgPT4gR3JhcGhRTFNjYWxhclR5cGUsXG4gIEdyYXBoUUxTY2hlbWE6ICgpID0+IEdyYXBoUUxTY2hlbWEsXG4gIEdyYXBoUUxTa2lwRGlyZWN0aXZlOiAoKSA9PiBHcmFwaFFMU2tpcERpcmVjdGl2ZSxcbiAgR3JhcGhRTFNwZWNpZmllZEJ5RGlyZWN0aXZlOiAoKSA9PiBHcmFwaFFMU3BlY2lmaWVkQnlEaXJlY3RpdmUsXG4gIEdyYXBoUUxTdHJpbmc6ICgpID0+IEdyYXBoUUxTdHJpbmcsXG4gIEdyYXBoUUxVbmlvblR5cGU6ICgpID0+IEdyYXBoUUxVbmlvblR5cGUsXG4gIEtpbmQ6ICgpID0+IEtpbmQsXG4gIEtub3duQXJndW1lbnROYW1lc1J1bGU6ICgpID0+IEtub3duQXJndW1lbnROYW1lc1J1bGUsXG4gIEtub3duRGlyZWN0aXZlc1J1bGU6ICgpID0+IEtub3duRGlyZWN0aXZlc1J1bGUsXG4gIEtub3duRnJhZ21lbnROYW1lc1J1bGU6ICgpID0+IEtub3duRnJhZ21lbnROYW1lc1J1bGUsXG4gIEtub3duVHlwZU5hbWVzUnVsZTogKCkgPT4gS25vd25UeXBlTmFtZXNSdWxlLFxuICBMZXhlcjogKCkgPT4gTGV4ZXIsXG4gIExvY2F0aW9uOiAoKSA9PiBMb2NhdGlvbixcbiAgTG9uZUFub255bW91c09wZXJhdGlvblJ1bGU6ICgpID0+IExvbmVBbm9ueW1vdXNPcGVyYXRpb25SdWxlLFxuICBMb25lU2NoZW1hRGVmaW5pdGlvblJ1bGU6ICgpID0+IExvbmVTY2hlbWFEZWZpbml0aW9uUnVsZSxcbiAgTm9EZXByZWNhdGVkQ3VzdG9tUnVsZTogKCkgPT4gTm9EZXByZWNhdGVkQ3VzdG9tUnVsZSxcbiAgTm9GcmFnbWVudEN5Y2xlc1J1bGU6ICgpID0+IE5vRnJhZ21lbnRDeWNsZXNSdWxlLFxuICBOb1NjaGVtYUludHJvc3BlY3Rpb25DdXN0b21SdWxlOiAoKSA9PiBOb1NjaGVtYUludHJvc3BlY3Rpb25DdXN0b21SdWxlLFxuICBOb1VuZGVmaW5lZFZhcmlhYmxlc1J1bGU6ICgpID0+IE5vVW5kZWZpbmVkVmFyaWFibGVzUnVsZSxcbiAgTm9VbnVzZWRGcmFnbWVudHNSdWxlOiAoKSA9PiBOb1VudXNlZEZyYWdtZW50c1J1bGUsXG4gIE5vVW51c2VkVmFyaWFibGVzUnVsZTogKCkgPT4gTm9VbnVzZWRWYXJpYWJsZXNSdWxlLFxuICBPcGVyYXRpb25UeXBlTm9kZTogKCkgPT4gT3BlcmF0aW9uVHlwZU5vZGUsXG4gIE92ZXJsYXBwaW5nRmllbGRzQ2FuQmVNZXJnZWRSdWxlOiAoKSA9PiBPdmVybGFwcGluZ0ZpZWxkc0NhbkJlTWVyZ2VkUnVsZSxcbiAgUG9zc2libGVGcmFnbWVudFNwcmVhZHNSdWxlOiAoKSA9PiBQb3NzaWJsZUZyYWdtZW50U3ByZWFkc1J1bGUsXG4gIFBvc3NpYmxlVHlwZUV4dGVuc2lvbnNSdWxlOiAoKSA9PiBQb3NzaWJsZVR5cGVFeHRlbnNpb25zUnVsZSxcbiAgUHJvdmlkZWRSZXF1aXJlZEFyZ3VtZW50c1J1bGU6ICgpID0+IFByb3ZpZGVkUmVxdWlyZWRBcmd1bWVudHNSdWxlLFxuICBTY2FsYXJMZWFmc1J1bGU6ICgpID0+IFNjYWxhckxlYWZzUnVsZSxcbiAgU2NoZW1hTWV0YUZpZWxkRGVmOiAoKSA9PiBTY2hlbWFNZXRhRmllbGREZWYsXG4gIFNpbmdsZUZpZWxkU3Vic2NyaXB0aW9uc1J1bGU6ICgpID0+IFNpbmdsZUZpZWxkU3Vic2NyaXB0aW9uc1J1bGUsXG4gIFNvdXJjZTogKCkgPT4gU291cmNlLFxuICBUb2tlbjogKCkgPT4gVG9rZW4sXG4gIFRva2VuS2luZDogKCkgPT4gVG9rZW5LaW5kLFxuICBUeXBlSW5mbzogKCkgPT4gVHlwZUluZm8sXG4gIFR5cGVLaW5kOiAoKSA9PiBUeXBlS2luZCxcbiAgVHlwZU1ldGFGaWVsZERlZjogKCkgPT4gVHlwZU1ldGFGaWVsZERlZixcbiAgVHlwZU5hbWVNZXRhRmllbGREZWY6ICgpID0+IFR5cGVOYW1lTWV0YUZpZWxkRGVmLFxuICBVbmlxdWVBcmd1bWVudERlZmluaXRpb25OYW1lc1J1bGU6ICgpID0+IFVuaXF1ZUFyZ3VtZW50RGVmaW5pdGlvbk5hbWVzUnVsZSxcbiAgVW5pcXVlQXJndW1lbnROYW1lc1J1bGU6ICgpID0+IFVuaXF1ZUFyZ3VtZW50TmFtZXNSdWxlLFxuICBVbmlxdWVEaXJlY3RpdmVOYW1lc1J1bGU6ICgpID0+IFVuaXF1ZURpcmVjdGl2ZU5hbWVzUnVsZSxcbiAgVW5pcXVlRGlyZWN0aXZlc1BlckxvY2F0aW9uUnVsZTogKCkgPT4gVW5pcXVlRGlyZWN0aXZlc1BlckxvY2F0aW9uUnVsZSxcbiAgVW5pcXVlRW51bVZhbHVlTmFtZXNSdWxlOiAoKSA9PiBVbmlxdWVFbnVtVmFsdWVOYW1lc1J1bGUsXG4gIFVuaXF1ZUZpZWxkRGVmaW5pdGlvbk5hbWVzUnVsZTogKCkgPT4gVW5pcXVlRmllbGREZWZpbml0aW9uTmFtZXNSdWxlLFxuICBVbmlxdWVGcmFnbWVudE5hbWVzUnVsZTogKCkgPT4gVW5pcXVlRnJhZ21lbnROYW1lc1J1bGUsXG4gIFVuaXF1ZUlucHV0RmllbGROYW1lc1J1bGU6ICgpID0+IFVuaXF1ZUlucHV0RmllbGROYW1lc1J1bGUsXG4gIFVuaXF1ZU9wZXJhdGlvbk5hbWVzUnVsZTogKCkgPT4gVW5pcXVlT3BlcmF0aW9uTmFtZXNSdWxlLFxuICBVbmlxdWVPcGVyYXRpb25UeXBlc1J1bGU6ICgpID0+IFVuaXF1ZU9wZXJhdGlvblR5cGVzUnVsZSxcbiAgVW5pcXVlVHlwZU5hbWVzUnVsZTogKCkgPT4gVW5pcXVlVHlwZU5hbWVzUnVsZSxcbiAgVW5pcXVlVmFyaWFibGVOYW1lc1J1bGU6ICgpID0+IFVuaXF1ZVZhcmlhYmxlTmFtZXNSdWxlLFxuICBWYWxpZGF0aW9uQ29udGV4dDogKCkgPT4gVmFsaWRhdGlvbkNvbnRleHQsXG4gIFZhbHVlc09mQ29ycmVjdFR5cGVSdWxlOiAoKSA9PiBWYWx1ZXNPZkNvcnJlY3RUeXBlUnVsZSxcbiAgVmFyaWFibGVzQXJlSW5wdXRUeXBlc1J1bGU6ICgpID0+IFZhcmlhYmxlc0FyZUlucHV0VHlwZXNSdWxlLFxuICBWYXJpYWJsZXNJbkFsbG93ZWRQb3NpdGlvblJ1bGU6ICgpID0+IFZhcmlhYmxlc0luQWxsb3dlZFBvc2l0aW9uUnVsZSxcbiAgX19EaXJlY3RpdmU6ICgpID0+IF9fRGlyZWN0aXZlLFxuICBfX0RpcmVjdGl2ZUxvY2F0aW9uOiAoKSA9PiBfX0RpcmVjdGl2ZUxvY2F0aW9uLFxuICBfX0VudW1WYWx1ZTogKCkgPT4gX19FbnVtVmFsdWUsXG4gIF9fRmllbGQ6ICgpID0+IF9fRmllbGQsXG4gIF9fSW5wdXRWYWx1ZTogKCkgPT4gX19JbnB1dFZhbHVlLFxuICBfX1NjaGVtYTogKCkgPT4gX19TY2hlbWEsXG4gIF9fVHlwZTogKCkgPT4gX19UeXBlLFxuICBfX1R5cGVLaW5kOiAoKSA9PiBfX1R5cGVLaW5kLFxuICBhc3NlcnRBYnN0cmFjdFR5cGU6ICgpID0+IGFzc2VydEFic3RyYWN0VHlwZSxcbiAgYXNzZXJ0Q29tcG9zaXRlVHlwZTogKCkgPT4gYXNzZXJ0Q29tcG9zaXRlVHlwZSxcbiAgYXNzZXJ0RGlyZWN0aXZlOiAoKSA9PiBhc3NlcnREaXJlY3RpdmUsXG4gIGFzc2VydEVudW1UeXBlOiAoKSA9PiBhc3NlcnRFbnVtVHlwZSxcbiAgYXNzZXJ0RW51bVZhbHVlTmFtZTogKCkgPT4gYXNzZXJ0RW51bVZhbHVlTmFtZSxcbiAgYXNzZXJ0SW5wdXRPYmplY3RUeXBlOiAoKSA9PiBhc3NlcnRJbnB1dE9iamVjdFR5cGUsXG4gIGFzc2VydElucHV0VHlwZTogKCkgPT4gYXNzZXJ0SW5wdXRUeXBlLFxuICBhc3NlcnRJbnRlcmZhY2VUeXBlOiAoKSA9PiBhc3NlcnRJbnRlcmZhY2VUeXBlLFxuICBhc3NlcnRMZWFmVHlwZTogKCkgPT4gYXNzZXJ0TGVhZlR5cGUsXG4gIGFzc2VydExpc3RUeXBlOiAoKSA9PiBhc3NlcnRMaXN0VHlwZSxcbiAgYXNzZXJ0TmFtZTogKCkgPT4gYXNzZXJ0TmFtZSxcbiAgYXNzZXJ0TmFtZWRUeXBlOiAoKSA9PiBhc3NlcnROYW1lZFR5cGUsXG4gIGFzc2VydE5vbk51bGxUeXBlOiAoKSA9PiBhc3NlcnROb25OdWxsVHlwZSxcbiAgYXNzZXJ0TnVsbGFibGVUeXBlOiAoKSA9PiBhc3NlcnROdWxsYWJsZVR5cGUsXG4gIGFzc2VydE9iamVjdFR5cGU6ICgpID0+IGFzc2VydE9iamVjdFR5cGUsXG4gIGFzc2VydE91dHB1dFR5cGU6ICgpID0+IGFzc2VydE91dHB1dFR5cGUsXG4gIGFzc2VydFNjYWxhclR5cGU6ICgpID0+IGFzc2VydFNjYWxhclR5cGUsXG4gIGFzc2VydFNjaGVtYTogKCkgPT4gYXNzZXJ0U2NoZW1hLFxuICBhc3NlcnRUeXBlOiAoKSA9PiBhc3NlcnRUeXBlLFxuICBhc3NlcnRVbmlvblR5cGU6ICgpID0+IGFzc2VydFVuaW9uVHlwZSxcbiAgYXNzZXJ0VmFsaWROYW1lOiAoKSA9PiBhc3NlcnRWYWxpZE5hbWUsXG4gIGFzc2VydFZhbGlkU2NoZW1hOiAoKSA9PiBhc3NlcnRWYWxpZFNjaGVtYSxcbiAgYXNzZXJ0V3JhcHBpbmdUeXBlOiAoKSA9PiBhc3NlcnRXcmFwcGluZ1R5cGUsXG4gIGFzdEZyb21WYWx1ZTogKCkgPT4gYXN0RnJvbVZhbHVlLFxuICBidWlsZEFTVFNjaGVtYTogKCkgPT4gYnVpbGRBU1RTY2hlbWEsXG4gIGJ1aWxkQ2xpZW50U2NoZW1hOiAoKSA9PiBidWlsZENsaWVudFNjaGVtYSxcbiAgYnVpbGRTY2hlbWE6ICgpID0+IGJ1aWxkU2NoZW1hLFxuICBjb2VyY2VJbnB1dFZhbHVlOiAoKSA9PiBjb2VyY2VJbnB1dFZhbHVlLFxuICBjb25jYXRBU1Q6ICgpID0+IGNvbmNhdEFTVCxcbiAgY3JlYXRlU291cmNlRXZlbnRTdHJlYW06ICgpID0+IGNyZWF0ZVNvdXJjZUV2ZW50U3RyZWFtLFxuICBkZWZhdWx0RmllbGRSZXNvbHZlcjogKCkgPT4gZGVmYXVsdEZpZWxkUmVzb2x2ZXIsXG4gIGRlZmF1bHRUeXBlUmVzb2x2ZXI6ICgpID0+IGRlZmF1bHRUeXBlUmVzb2x2ZXIsXG4gIGRvVHlwZXNPdmVybGFwOiAoKSA9PiBkb1R5cGVzT3ZlcmxhcCxcbiAgZXhlY3V0ZTogKCkgPT4gZXhlY3V0ZSxcbiAgZXhlY3V0ZVN5bmM6ICgpID0+IGV4ZWN1dGVTeW5jLFxuICBleHRlbmRTY2hlbWE6ICgpID0+IGV4dGVuZFNjaGVtYSxcbiAgZmluZEJyZWFraW5nQ2hhbmdlczogKCkgPT4gZmluZEJyZWFraW5nQ2hhbmdlcyxcbiAgZmluZERhbmdlcm91c0NoYW5nZXM6ICgpID0+IGZpbmREYW5nZXJvdXNDaGFuZ2VzLFxuICBmb3JtYXRFcnJvcjogKCkgPT4gZm9ybWF0RXJyb3IsXG4gIGdldEFyZ3VtZW50VmFsdWVzOiAoKSA9PiBnZXRBcmd1bWVudFZhbHVlcyxcbiAgZ2V0RGlyZWN0aXZlVmFsdWVzOiAoKSA9PiBnZXREaXJlY3RpdmVWYWx1ZXMsXG4gIGdldEVudGVyTGVhdmVGb3JLaW5kOiAoKSA9PiBnZXRFbnRlckxlYXZlRm9yS2luZCxcbiAgZ2V0SW50cm9zcGVjdGlvblF1ZXJ5OiAoKSA9PiBnZXRJbnRyb3NwZWN0aW9uUXVlcnksXG4gIGdldExvY2F0aW9uOiAoKSA9PiBnZXRMb2NhdGlvbixcbiAgZ2V0TmFtZWRUeXBlOiAoKSA9PiBnZXROYW1lZFR5cGUsXG4gIGdldE51bGxhYmxlVHlwZTogKCkgPT4gZ2V0TnVsbGFibGVUeXBlLFxuICBnZXRPcGVyYXRpb25BU1Q6ICgpID0+IGdldE9wZXJhdGlvbkFTVCxcbiAgZ2V0T3BlcmF0aW9uUm9vdFR5cGU6ICgpID0+IGdldE9wZXJhdGlvblJvb3RUeXBlLFxuICBnZXRWYXJpYWJsZVZhbHVlczogKCkgPT4gZ2V0VmFyaWFibGVWYWx1ZXMsXG4gIGdldFZpc2l0Rm46ICgpID0+IGdldFZpc2l0Rm4sXG4gIGdyYXBocWw6ICgpID0+IGdyYXBocWwsXG4gIGdyYXBocWxTeW5jOiAoKSA9PiBncmFwaHFsU3luYyxcbiAgaW50cm9zcGVjdGlvbkZyb21TY2hlbWE6ICgpID0+IGludHJvc3BlY3Rpb25Gcm9tU2NoZW1hLFxuICBpbnRyb3NwZWN0aW9uVHlwZXM6ICgpID0+IGludHJvc3BlY3Rpb25UeXBlcyxcbiAgaXNBYnN0cmFjdFR5cGU6ICgpID0+IGlzQWJzdHJhY3RUeXBlLFxuICBpc0NvbXBvc2l0ZVR5cGU6ICgpID0+IGlzQ29tcG9zaXRlVHlwZSxcbiAgaXNDb25zdFZhbHVlTm9kZTogKCkgPT4gaXNDb25zdFZhbHVlTm9kZSxcbiAgaXNEZWZpbml0aW9uTm9kZTogKCkgPT4gaXNEZWZpbml0aW9uTm9kZSxcbiAgaXNEaXJlY3RpdmU6ICgpID0+IGlzRGlyZWN0aXZlLFxuICBpc0VudW1UeXBlOiAoKSA9PiBpc0VudW1UeXBlLFxuICBpc0VxdWFsVHlwZTogKCkgPT4gaXNFcXVhbFR5cGUsXG4gIGlzRXhlY3V0YWJsZURlZmluaXRpb25Ob2RlOiAoKSA9PiBpc0V4ZWN1dGFibGVEZWZpbml0aW9uTm9kZSxcbiAgaXNJbnB1dE9iamVjdFR5cGU6ICgpID0+IGlzSW5wdXRPYmplY3RUeXBlLFxuICBpc0lucHV0VHlwZTogKCkgPT4gaXNJbnB1dFR5cGUsXG4gIGlzSW50ZXJmYWNlVHlwZTogKCkgPT4gaXNJbnRlcmZhY2VUeXBlLFxuICBpc0ludHJvc3BlY3Rpb25UeXBlOiAoKSA9PiBpc0ludHJvc3BlY3Rpb25UeXBlLFxuICBpc0xlYWZUeXBlOiAoKSA9PiBpc0xlYWZUeXBlLFxuICBpc0xpc3RUeXBlOiAoKSA9PiBpc0xpc3RUeXBlLFxuICBpc05hbWVkVHlwZTogKCkgPT4gaXNOYW1lZFR5cGUsXG4gIGlzTm9uTnVsbFR5cGU6ICgpID0+IGlzTm9uTnVsbFR5cGUsXG4gIGlzTnVsbGFibGVUeXBlOiAoKSA9PiBpc051bGxhYmxlVHlwZSxcbiAgaXNPYmplY3RUeXBlOiAoKSA9PiBpc09iamVjdFR5cGUsXG4gIGlzT3V0cHV0VHlwZTogKCkgPT4gaXNPdXRwdXRUeXBlLFxuICBpc1JlcXVpcmVkQXJndW1lbnQ6ICgpID0+IGlzUmVxdWlyZWRBcmd1bWVudCxcbiAgaXNSZXF1aXJlZElucHV0RmllbGQ6ICgpID0+IGlzUmVxdWlyZWRJbnB1dEZpZWxkLFxuICBpc1NjYWxhclR5cGU6ICgpID0+IGlzU2NhbGFyVHlwZSxcbiAgaXNTY2hlbWE6ICgpID0+IGlzU2NoZW1hLFxuICBpc1NlbGVjdGlvbk5vZGU6ICgpID0+IGlzU2VsZWN0aW9uTm9kZSxcbiAgaXNTcGVjaWZpZWREaXJlY3RpdmU6ICgpID0+IGlzU3BlY2lmaWVkRGlyZWN0aXZlLFxuICBpc1NwZWNpZmllZFNjYWxhclR5cGU6ICgpID0+IGlzU3BlY2lmaWVkU2NhbGFyVHlwZSxcbiAgaXNUeXBlOiAoKSA9PiBpc1R5cGUsXG4gIGlzVHlwZURlZmluaXRpb25Ob2RlOiAoKSA9PiBpc1R5cGVEZWZpbml0aW9uTm9kZSxcbiAgaXNUeXBlRXh0ZW5zaW9uTm9kZTogKCkgPT4gaXNUeXBlRXh0ZW5zaW9uTm9kZSxcbiAgaXNUeXBlTm9kZTogKCkgPT4gaXNUeXBlTm9kZSxcbiAgaXNUeXBlU3ViVHlwZU9mOiAoKSA9PiBpc1R5cGVTdWJUeXBlT2YsXG4gIGlzVHlwZVN5c3RlbURlZmluaXRpb25Ob2RlOiAoKSA9PiBpc1R5cGVTeXN0ZW1EZWZpbml0aW9uTm9kZSxcbiAgaXNUeXBlU3lzdGVtRXh0ZW5zaW9uTm9kZTogKCkgPT4gaXNUeXBlU3lzdGVtRXh0ZW5zaW9uTm9kZSxcbiAgaXNVbmlvblR5cGU6ICgpID0+IGlzVW5pb25UeXBlLFxuICBpc1ZhbGlkTmFtZUVycm9yOiAoKSA9PiBpc1ZhbGlkTmFtZUVycm9yLFxuICBpc1ZhbHVlTm9kZTogKCkgPT4gaXNWYWx1ZU5vZGUsXG4gIGlzV3JhcHBpbmdUeXBlOiAoKSA9PiBpc1dyYXBwaW5nVHlwZSxcbiAgbGV4aWNvZ3JhcGhpY1NvcnRTY2hlbWE6ICgpID0+IGxleGljb2dyYXBoaWNTb3J0U2NoZW1hLFxuICBsb2NhdGVkRXJyb3I6ICgpID0+IGxvY2F0ZWRFcnJvcixcbiAgcGFyc2U6ICgpID0+IHBhcnNlLFxuICBwYXJzZUNvbnN0VmFsdWU6ICgpID0+IHBhcnNlQ29uc3RWYWx1ZSxcbiAgcGFyc2VUeXBlOiAoKSA9PiBwYXJzZVR5cGUsXG4gIHBhcnNlVmFsdWU6ICgpID0+IHBhcnNlVmFsdWUsXG4gIHByaW50OiAoKSA9PiBwcmludCxcbiAgcHJpbnRFcnJvcjogKCkgPT4gcHJpbnRFcnJvcixcbiAgcHJpbnRJbnRyb3NwZWN0aW9uU2NoZW1hOiAoKSA9PiBwcmludEludHJvc3BlY3Rpb25TY2hlbWEsXG4gIHByaW50TG9jYXRpb246ICgpID0+IHByaW50TG9jYXRpb24sXG4gIHByaW50U2NoZW1hOiAoKSA9PiBwcmludFNjaGVtYSxcbiAgcHJpbnRTb3VyY2VMb2NhdGlvbjogKCkgPT4gcHJpbnRTb3VyY2VMb2NhdGlvbixcbiAgcHJpbnRUeXBlOiAoKSA9PiBwcmludFR5cGUsXG4gIHJlc29sdmVPYmpNYXBUaHVuazogKCkgPT4gcmVzb2x2ZU9iak1hcFRodW5rLFxuICByZXNvbHZlUmVhZG9ubHlBcnJheVRodW5rOiAoKSA9PiByZXNvbHZlUmVhZG9ubHlBcnJheVRodW5rLFxuICByZXNwb25zZVBhdGhBc0FycmF5OiAoKSA9PiBwYXRoVG9BcnJheSxcbiAgc2VwYXJhdGVPcGVyYXRpb25zOiAoKSA9PiBzZXBhcmF0ZU9wZXJhdGlvbnMsXG4gIHNwZWNpZmllZERpcmVjdGl2ZXM6ICgpID0+IHNwZWNpZmllZERpcmVjdGl2ZXMsXG4gIHNwZWNpZmllZFJ1bGVzOiAoKSA9PiBzcGVjaWZpZWRSdWxlcyxcbiAgc3BlY2lmaWVkU2NhbGFyVHlwZXM6ICgpID0+IHNwZWNpZmllZFNjYWxhclR5cGVzLFxuICBzdHJpcElnbm9yZWRDaGFyYWN0ZXJzOiAoKSA9PiBzdHJpcElnbm9yZWRDaGFyYWN0ZXJzLFxuICBzdWJzY3JpYmU6ICgpID0+IHN1YnNjcmliZSxcbiAgc3ludGF4RXJyb3I6ICgpID0+IHN5bnRheEVycm9yLFxuICB0eXBlRnJvbUFTVDogKCkgPT4gdHlwZUZyb21BU1QsXG4gIHZhbGlkYXRlOiAoKSA9PiB2YWxpZGF0ZSxcbiAgdmFsaWRhdGVTY2hlbWE6ICgpID0+IHZhbGlkYXRlU2NoZW1hLFxuICB2YWx1ZUZyb21BU1Q6ICgpID0+IHZhbHVlRnJvbUFTVCxcbiAgdmFsdWVGcm9tQVNUVW50eXBlZDogKCkgPT4gdmFsdWVGcm9tQVNUVW50eXBlZCxcbiAgdmVyc2lvbjogKCkgPT4gdmVyc2lvbixcbiAgdmVyc2lvbkluZm86ICgpID0+IHZlcnNpb25JbmZvLFxuICB2aXNpdDogKCkgPT4gdmlzaXQsXG4gIHZpc2l0SW5QYXJhbGxlbDogKCkgPT4gdmlzaXRJblBhcmFsbGVsLFxuICB2aXNpdFdpdGhUeXBlSW5mbzogKCkgPT4gdmlzaXRXaXRoVHlwZUluZm9cbn0pO1xudmFyIGluaXRfZ3JhcGhxbDIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL2dyYXBocWwvaW5kZXgubWpzXCIoKSB7XG4gICAgaW5pdF92ZXJzaW9uKCk7XG4gICAgaW5pdF9ncmFwaHFsKCk7XG4gICAgaW5pdF90eXBlKCk7XG4gICAgaW5pdF9sYW5ndWFnZSgpO1xuICAgIGluaXRfZXhlY3V0aW9uKCk7XG4gICAgaW5pdF92YWxpZGF0aW9uKCk7XG4gICAgaW5pdF9lcnJvcigpO1xuICAgIGluaXRfdXRpbGl0aWVzKCk7XG4gIH1cbn0pO1xuXG5leHBvcnQge1xuICBHcmFwaFFMRXJyb3IsXG4gIERpcmVjdGl2ZUxvY2F0aW9uLFxuICBLaW5kLFxuICBwYXJzZSxcbiAgQlJFQUssXG4gIHZpc2l0LFxuICBwcmludCxcbiAgaXNUeXBlLFxuICBpc1NjYWxhclR5cGUsXG4gIGlzT2JqZWN0VHlwZSxcbiAgaXNJbnRlcmZhY2VUeXBlLFxuICBpc1VuaW9uVHlwZSxcbiAgaXNFbnVtVHlwZSxcbiAgaXNJbnB1dE9iamVjdFR5cGUsXG4gIGlzTGlzdFR5cGUsXG4gIGlzTm9uTnVsbFR5cGUsXG4gIGlzSW5wdXRUeXBlLFxuICBpc091dHB1dFR5cGUsXG4gIGlzTGVhZlR5cGUsXG4gIGlzQ29tcG9zaXRlVHlwZSxcbiAgaXNBYnN0cmFjdFR5cGUsXG4gIGFzc2VydEFic3RyYWN0VHlwZSxcbiAgR3JhcGhRTExpc3QsXG4gIEdyYXBoUUxOb25OdWxsLFxuICBnZXROdWxsYWJsZVR5cGUsXG4gIGlzTmFtZWRUeXBlLFxuICBnZXROYW1lZFR5cGUsXG4gIEdyYXBoUUxTY2FsYXJUeXBlLFxuICBHcmFwaFFMT2JqZWN0VHlwZSxcbiAgR3JhcGhRTEludGVyZmFjZVR5cGUsXG4gIEdyYXBoUUxFbnVtVHlwZSxcbiAgR3JhcGhRTElucHV0T2JqZWN0VHlwZSxcbiAgZG9UeXBlc092ZXJsYXAsXG4gIEdyYXBoUUxGbG9hdCxcbiAgR3JhcGhRTEJvb2xlYW4sXG4gIGFzdEZyb21WYWx1ZSxcbiAgU2NoZW1hTWV0YUZpZWxkRGVmLFxuICBUeXBlTWV0YUZpZWxkRGVmLFxuICBUeXBlTmFtZU1ldGFGaWVsZERlZixcbiAgaXNTY2hlbWEsXG4gIHZhbGlkYXRlU2NoZW1hLFxuICB0eXBlRnJvbUFTVCxcbiAgVHlwZUluZm8sXG4gIHZpc2l0V2l0aFR5cGVJbmZvLFxuICBpc1NlbGVjdGlvbk5vZGUsXG4gIEV4ZWN1dGFibGVEZWZpbml0aW9uc1J1bGUsXG4gIEZyYWdtZW50c09uQ29tcG9zaXRlVHlwZXNSdWxlLFxuICBLbm93bkRpcmVjdGl2ZXNSdWxlLFxuICBLbm93bkZyYWdtZW50TmFtZXNSdWxlLFxuICBLbm93blR5cGVOYW1lc1J1bGUsXG4gIExvbmVTY2hlbWFEZWZpbml0aW9uUnVsZSxcbiAgTm9VbnVzZWRGcmFnbWVudHNSdWxlLFxuICBQb3NzaWJsZVR5cGVFeHRlbnNpb25zUnVsZSxcbiAgUHJvdmlkZWRSZXF1aXJlZEFyZ3VtZW50c1J1bGUsXG4gIFVuaXF1ZUFyZ3VtZW50TmFtZXNSdWxlLFxuICBVbmlxdWVEaXJlY3RpdmVOYW1lc1J1bGUsXG4gIFVuaXF1ZURpcmVjdGl2ZXNQZXJMb2NhdGlvblJ1bGUsXG4gIFVuaXF1ZUVudW1WYWx1ZU5hbWVzUnVsZSxcbiAgVW5pcXVlRmllbGREZWZpbml0aW9uTmFtZXNSdWxlLFxuICBVbmlxdWVJbnB1dEZpZWxkTmFtZXNSdWxlLFxuICBVbmlxdWVPcGVyYXRpb25UeXBlc1J1bGUsXG4gIFVuaXF1ZVR5cGVOYW1lc1J1bGUsXG4gIFVuaXF1ZVZhcmlhYmxlTmFtZXNSdWxlLFxuICBzcGVjaWZpZWRSdWxlcyxcbiAgdmFsaWRhdGUsXG4gIE5vRGVwcmVjYXRlZEN1c3RvbVJ1bGUsXG4gIGdldEludHJvc3BlY3Rpb25RdWVyeSxcbiAgYnVpbGRDbGllbnRTY2hlbWEsXG4gIGdyYXBocWxfZXhwb3J0cyxcbiAgaW5pdF9ncmFwaHFsMiBhcyBpbml0X2dyYXBocWxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1GSUVJQUtQQy5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQSxFQUNFO0FBQUEsRUFDQTtBQUFBLE9BQ0s7QUFHUCxTQUFTLGFBQWEsT0FBTztBQUMzQixTQUFPLE9BQU8sU0FBUyxZQUFZLFVBQVU7QUFDL0M7QUFDQSxJQUFJLG9CQUFvQixNQUFNO0FBQUEsRUFDNUIsa0RBQWtEO0FBQUEsRUFDbEQ7QUFDRixDQUFDO0FBR0QsU0FBUyxVQUFVLFdBQVcsU0FBUztBQUNyQyxRQUFNLG1CQUFtQixRQUFRLFNBQVM7QUFDMUMsTUFBSSxDQUFDLGtCQUFrQjtBQUNyQixVQUFNLElBQUk7QUFBQSxNQUNSLFdBQVcsT0FBTyxVQUFVO0FBQUEsSUFDOUI7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxJQUFJLGlCQUFpQixNQUFNO0FBQUEsRUFDekIsK0NBQStDO0FBQUEsRUFDL0M7QUFDRixDQUFDO0FBR0QsU0FBUyxZQUFZLFFBQVEs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O0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUVBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUVBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUVBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFB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