import {
  es_default
} from "/@fs/D:/twenty-table-o/node_modules/.vite/packages/twenty-front/deps/chunk-Z2TSRKUH.js?v=226f7286";
import "/@fs/D:/twenty-table-o/node_modules/.vite/packages/twenty-front/deps/chunk-G7PUMFDC.js?v=226f7286";
import "/@fs/D:/twenty-table-o/node_modules/.vite/packages/twenty-front/deps/chunk-FWN6Y45K.js?v=226f7286";
import {
  require_react
} from "/@fs/D:/twenty-table-o/node_modules/.vite/packages/twenty-front/deps/chunk-LABDTKBP.js?v=226f7286";
import {
  __commonJS,
  __toESM
} from "/@fs/D:/twenty-table-o/node_modules/.vite/packages/twenty-front/deps/chunk-XPZLJQLW.js?v=226f7286";

// node_modules/transit-js/transit.js
var require_transit = __commonJS({
  "node_modules/transit-js/transit.js"(exports, module) {
    "use strict";
    var COMPILED = true;
    var goog = goog || {};
    goog.global = exports || self;
    goog.exportPath_ = function(a2, b2, c2, d2) {
      a2 = a2.split(".");
      d2 = d2 || goog.global;
      a2[0] in d2 || "undefined" == typeof d2.execScript || d2.execScript("var " + a2[0]);
      for (var e2; a2.length && (e2 = a2.shift()); ) {
        if (a2.length || void 0 === b2) {
          d2 = d2[e2] && d2[e2] !== Object.prototype[e2] ? d2[e2] : d2[e2] = {};
        } else {
          if (!c2 && goog.isObject(b2) && goog.isObject(d2[e2])) {
            for (var f2 in b2) {
              b2.hasOwnProperty(f2) && (d2[e2][f2] = b2[f2]);
            }
          } else {
            d2[e2] = b2;
          }
        }
      }
    };
    goog.define = function(a2, b2) {
      if (!COMPILED) {
        var c2 = goog.global.CLOSURE_UNCOMPILED_DEFINES, d2 = goog.global.CLOSURE_DEFINES;
        c2 && void 0 === c2.nodeType && Object.prototype.hasOwnProperty.call(c2, a2) ? b2 = c2[a2] : d2 && void 0 === d2.nodeType && Object.prototype.hasOwnProperty.call(d2, a2) && (b2 = d2[a2]);
      }
      return b2;
    };
    goog.FEATURESET_YEAR = 2012;
    goog.DEBUG = true;
    goog.LOCALE = "en";
    goog.TRUSTED_SITE = true;
    goog.DISALLOW_TEST_ONLY_CODE = COMPILED && !goog.DEBUG;
    goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = false;
    goog.provide = function(a2) {
      if (goog.isInModuleLoader_()) {
        throw Error("goog.provide cannot be used within a module.");
      }
      if (!COMPILED && goog.isProvided_(a2)) {
        throw Error('Namespace "' + a2 + '" already declared.');
      }
      goog.constructNamespace_(a2);
    };
    goog.constructNamespace_ = function(a2, b2, c2) {
      if (!COMPILED) {
        delete goog.implicitNamespaces_[a2];
        for (var d2 = a2; (d2 = d2.substring(0, d2.lastIndexOf("."))) && !goog.getObjectByName(d2); ) {
          goog.implicitNamespaces_[d2] = true;
        }
      }
      goog.exportPath_(a2, b2, c2);
    };
    goog.getScriptNonce = function(a2) {
      if (a2 && a2 != goog.global) {
        return goog.getScriptNonce_(a2.document);
      }
      null === goog.cspNonce_ && (goog.cspNonce_ = goog.getScriptNonce_(goog.global.document));
      return goog.cspNonce_;
    };
    goog.NONCE_PATTERN_ = /^[\w+/_-]+[=]{0,2}$/;
    goog.cspNonce_ = null;
    goog.getScriptNonce_ = function(a2) {
      return (a2 = a2.querySelector && a2.querySelector("script[nonce]")) && (a2 = a2.nonce || a2.getAttribute("nonce")) && goog.NONCE_PATTERN_.test(a2) ? a2 : "";
    };
    goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
    goog.module = function(a2) {
      if ("string" !== typeof a2 || !a2 || -1 == a2.search(goog.VALID_MODULE_RE_)) {
        throw Error("Invalid module identifier");
      }
      if (!goog.isInGoogModuleLoader_()) {
        throw Error("Module " + a2 + " has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
      }
      if (goog.moduleLoaderState_.moduleName) {
        throw Error("goog.module may only be called once per module.");
      }
      goog.moduleLoaderState_.moduleName = a2;
      if (!COMPILED) {
        if (goog.isProvided_(a2)) {
          throw Error('Namespace "' + a2 + '" already declared.');
        }
        delete goog.implicitNamespaces_[a2];
      }
    };
    goog.module.get = function(a2) {
      return goog.module.getInternal_(a2);
    };
    goog.module.getInternal_ = function(a2) {
      if (!COMPILED) {
        if (a2 in goog.loadedModules_) {
          return goog.loadedModules_[a2].exports;
        }
        if (!goog.implicitNamespaces_[a2]) {
          return a2 = goog.getObjectByName(a2), null != a2 ? a2 : null;
        }
      }
      return null;
    };
    goog.ModuleType = { ES6: "es6", GOOG: "goog" };
    goog.moduleLoaderState_ = null;
    goog.isInModuleLoader_ = function() {
      return goog.isInGoogModuleLoader_() || goog.isInEs6ModuleLoader_();
    };
    goog.isInGoogModuleLoader_ = function() {
      return !!goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.GOOG;
    };
    goog.isInEs6ModuleLoader_ = function() {
      if (goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.ES6) {
        return true;
      }
      var a2 = goog.global.$jscomp;
      return a2 ? "function" != typeof a2.getCurrentModulePath ? false : !!a2.getCurrentModulePath() : false;
    };
    goog.module.declareLegacyNamespace = function() {
      if (!COMPILED && !goog.isInGoogModuleLoader_()) {
        throw Error("goog.module.declareLegacyNamespace must be called from within a goog.module");
      }
      if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
        throw Error("goog.module must be called prior to goog.module.declareLegacyNamespace.");
      }
      goog.moduleLoaderState_.declareLegacyNamespace = true;
    };
    goog.declareModuleId = function(a2) {
      if (!COMPILED) {
        if (!goog.isInEs6ModuleLoader_()) {
          throw Error("goog.declareModuleId may only be called from within an ES6 module");
        }
        if (goog.moduleLoaderState_ && goog.moduleLoaderState_.moduleName) {
          throw Error("goog.declareModuleId may only be called once per module.");
        }
        if (a2 in goog.loadedModules_) {
          throw Error('Module with namespace "' + a2 + '" already exists.');
        }
      }
      if (goog.moduleLoaderState_) {
        goog.moduleLoaderState_.moduleName = a2;
      } else {
        var b2 = goog.global.$jscomp;
        if (!b2 || "function" != typeof b2.getCurrentModulePath) {
          throw Error('Module with namespace "' + a2 + '" has been loaded incorrectly.');
        }
        b2 = b2.require(b2.getCurrentModulePath());
        goog.loadedModules_[a2] = { exports: b2, type: goog.ModuleType.ES6, moduleId: a2 };
      }
    };
    goog.setTestOnly = function(a2) {
      if (goog.DISALLOW_TEST_ONLY_CODE) {
        throw a2 = a2 || "", Error("Importing test-only code into non-debug environment" + (a2 ? ": " + a2 : "."));
      }
    };
    goog.forwardDeclare = function(a2) {
    };
    COMPILED || (goog.isProvided_ = function(a2) {
      return a2 in goog.loadedModules_ || !goog.implicitNamespaces_[a2] && null != goog.getObjectByName(a2);
    }, goog.implicitNamespaces_ = { "goog.module": true });
    goog.getObjectByName = function(a2, b2) {
      a2 = a2.split(".");
      b2 = b2 || goog.global;
      for (var c2 = 0; c2 < a2.length; c2++) {
        if (b2 = b2[a2[c2]], null == b2) {
          return null;
        }
      }
      return b2;
    };
    goog.addDependency = function(a2, b2, c2, d2) {
      !COMPILED && goog.DEPENDENCIES_ENABLED && goog.debugLoader_.addDependency(a2, b2, c2, d2);
    };
    goog.ENABLE_DEBUG_LOADER = true;
    goog.logToConsole_ = function(a2) {
      goog.global.console && goog.global.console.error(a2);
    };
    goog.require = function(a2) {
      if (!COMPILED) {
        goog.ENABLE_DEBUG_LOADER && goog.debugLoader_.requested(a2);
        if (goog.isProvided_(a2)) {
          if (goog.isInModuleLoader_()) {
            return goog.module.getInternal_(a2);
          }
        } else {
          if (goog.ENABLE_DEBUG_LOADER) {
            var b2 = goog.moduleLoaderState_;
            goog.moduleLoaderState_ = null;
            try {
              goog.debugLoader_.load_(a2);
            } finally {
              goog.moduleLoaderState_ = b2;
            }
          }
        }
        return null;
      }
    };
    goog.requireType = function(a2) {
      return {};
    };
    goog.basePath = "";
    goog.nullFunction = function() {
    };
    goog.abstractMethod = function() {
      throw Error("unimplemented abstract method");
    };
    goog.addSingletonGetter = function(a2) {
      a2.instance_ = void 0;
      a2.getInstance = function() {
        if (a2.instance_) {
          return a2.instance_;
        }
        goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a2);
        return a2.instance_ = new a2();
      };
    };
    goog.instantiatedSingletons_ = [];
    goog.LOAD_MODULE_USING_EVAL = true;
    goog.SEAL_MODULE_EXPORTS = goog.DEBUG;
    goog.loadedModules_ = {};
    goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
    goog.TRANSPILE = "detect";
    goog.ASSUME_ES_MODULES_TRANSPILED = false;
    goog.TRANSPILE_TO_LANGUAGE = "";
    goog.TRANSPILER = "transpile.js";
    goog.TRUSTED_TYPES_POLICY_NAME = "goog";
    goog.hasBadLetScoping = null;
    goog.loadModule = function(a2) {
      var b2 = goog.moduleLoaderState_;
      try {
        goog.moduleLoaderState_ = { moduleName: "", declareLegacyNamespace: false, type: goog.ModuleType.GOOG };
        var c2 = {}, d2 = c2;
        if ("function" === typeof a2) {
          d2 = a2.call(void 0, d2);
        } else {
          if ("string" === typeof a2) {
            d2 = goog.loadModuleFromSource_.call(void 0, d2, a2);
          } else {
            throw Error("Invalid module definition");
          }
        }
        var e2 = goog.moduleLoaderState_.moduleName;
        if ("string" === typeof e2 && e2) {
          goog.moduleLoaderState_.declareLegacyNamespace ? goog.constructNamespace_(e2, d2, c2 !== d2) : goog.SEAL_MODULE_EXPORTS && Object.seal && "object" == typeof d2 && null != d2 && Object.seal(d2), goog.loadedModules_[e2] = { exports: d2, type: goog.ModuleType.GOOG, moduleId: goog.moduleLoaderState_.moduleName };
        } else {
          throw Error('Invalid module name "' + e2 + '"');
        }
      } finally {
        goog.moduleLoaderState_ = b2;
      }
    };
    goog.loadModuleFromSource_ = function(a, b) {
      eval(goog.CLOSURE_EVAL_PREFILTER_.createScript(b));
      return a;
    };
    goog.normalizePath_ = function(a2) {
      a2 = a2.split("/");
      for (var b2 = 0; b2 < a2.length; ) {
        "." == a2[b2] ? a2.splice(b2, 1) : b2 && ".." == a2[b2] && a2[b2 - 1] && ".." != a2[b2 - 1] ? a2.splice(--b2, 2) : b2++;
      }
      return a2.join("/");
    };
    goog.loadFileSync_ = function(a2) {
      if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
        return goog.global.CLOSURE_LOAD_FILE_SYNC(a2);
      }
      try {
        var b2 = new goog.global.XMLHttpRequest();
        b2.open("get", a2, false);
        b2.send();
        return 0 == b2.status || 200 == b2.status ? b2.responseText : null;
      } catch (c2) {
        return null;
      }
    };
    goog.transpile_ = function(a2, b2, c2) {
      var d2 = goog.global.$jscomp;
      d2 || (goog.global.$jscomp = d2 = {});
      var e2 = d2.transpile;
      if (!e2) {
        var f2 = goog.basePath + goog.TRANSPILER, g = goog.loadFileSync_(f2);
        if (g) {
          (function() {
            (0, eval)(g + "\n//# sourceURL=" + f2);
          }).call(goog.global);
          if (goog.global.$gwtExport && goog.global.$gwtExport.$jscomp && !goog.global.$gwtExport.$jscomp.transpile) {
            throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: ' + JSON.stringify(goog.global.$gwtExport));
          }
          goog.global.$jscomp.transpile = goog.global.$gwtExport.$jscomp.transpile;
          d2 = goog.global.$jscomp;
          e2 = d2.transpile;
        }
      }
      e2 || (e2 = d2.transpile = function(h, k) {
        goog.logToConsole_(k + " requires transpilation but no transpiler was found.");
        return h;
      });
      return e2(a2, b2, c2);
    };
    goog.typeOf = function(a2) {
      var b2 = typeof a2;
      return "object" != b2 ? b2 : a2 ? Array.isArray(a2) ? "array" : b2 : "null";
    };
    goog.isArrayLike = function(a2) {
      var b2 = goog.typeOf(a2);
      return "array" == b2 || "object" == b2 && "number" == typeof a2.length;
    };
    goog.isDateLike = function(a2) {
      return goog.isObject(a2) && "function" == typeof a2.getFullYear;
    };
    goog.isObject = function(a2) {
      var b2 = typeof a2;
      return "object" == b2 && null != a2 || "function" == b2;
    };
    goog.getUid = function(a2) {
      return Object.prototype.hasOwnProperty.call(a2, goog.UID_PROPERTY_) && a2[goog.UID_PROPERTY_] || (a2[goog.UID_PROPERTY_] = ++goog.uidCounter_);
    };
    goog.hasUid = function(a2) {
      return !!a2[goog.UID_PROPERTY_];
    };
    goog.removeUid = function(a2) {
      null !== a2 && "removeAttribute" in a2 && a2.removeAttribute(goog.UID_PROPERTY_);
      try {
        delete a2[goog.UID_PROPERTY_];
      } catch (b2) {
      }
    };
    goog.UID_PROPERTY_ = "closure_uid_" + (1e9 * Math.random() >>> 0);
    goog.uidCounter_ = 0;
    goog.cloneObject = function(a2) {
      var b2 = goog.typeOf(a2);
      if ("object" == b2 || "array" == b2) {
        if ("function" === typeof a2.clone) {
          return a2.clone();
        }
        b2 = "array" == b2 ? [] : {};
        for (var c2 in a2) {
          b2[c2] = goog.cloneObject(a2[c2]);
        }
        return b2;
      }
      return a2;
    };
    goog.bindNative_ = function(a2, b2, c2) {
      return a2.call.apply(a2.bind, arguments);
    };
    goog.bindJs_ = function(a2, b2, c2) {
      if (!a2) {
        throw Error();
      }
      if (2 < arguments.length) {
        var d2 = Array.prototype.slice.call(arguments, 2);
        return function() {
          var e2 = Array.prototype.slice.call(arguments);
          Array.prototype.unshift.apply(e2, d2);
          return a2.apply(b2, e2);
        };
      }
      return function() {
        return a2.apply(b2, arguments);
      };
    };
    goog.bind = function(a2, b2, c2) {
      Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
      return goog.bind.apply(null, arguments);
    };
    goog.partial = function(a2, b2) {
      var c2 = Array.prototype.slice.call(arguments, 1);
      return function() {
        var d2 = c2.slice();
        d2.push.apply(d2, arguments);
        return a2.apply(this, d2);
      };
    };
    goog.mixin = function(a2, b2) {
      for (var c2 in b2) {
        a2[c2] = b2[c2];
      }
    };
    goog.now = function() {
      return Date.now();
    };
    goog.globalEval = function(a2) {
      (0, eval)(a2);
    };
    goog.getCssName = function(a2, b2) {
      if ("." == String(a2).charAt(0)) {
        throw Error('className passed in goog.getCssName must not start with ".". You passed: ' + a2);
      }
      var c2 = function(e2) {
        return goog.cssNameMapping_[e2] || e2;
      }, d2 = function(e2) {
        e2 = e2.split("-");
        for (var f2 = [], g = 0; g < e2.length; g++) {
          f2.push(c2(e2[g]));
        }
        return f2.join("-");
      };
      d2 = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? c2 : d2 : function(e2) {
        return e2;
      };
      a2 = b2 ? a2 + "-" + d2(b2) : d2(a2);
      return goog.global.CLOSURE_CSS_NAME_MAP_FN ? goog.global.CLOSURE_CSS_NAME_MAP_FN(a2) : a2;
    };
    goog.setCssNameMapping = function(a2, b2) {
      goog.cssNameMapping_ = a2;
      goog.cssNameMappingStyle_ = b2;
    };
    !COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
    goog.getMsg = function(a2, b2, c2) {
      c2 && c2.html && (a2 = a2.replace(/</g, "&lt;"));
      c2 && c2.unescapeHtmlEntities && (a2 = a2.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&apos;/g, "'").replace(/&quot;/g, '"').replace(/&amp;/g, "&"));
      b2 && (a2 = a2.replace(/\{\$([^}]+)}/g, function(d2, e2) {
        return null != b2 && e2 in b2 ? b2[e2] : d2;
      }));
      return a2;
    };
    goog.getMsgWithFallback = function(a2, b2) {
      return a2;
    };
    goog.exportSymbol = function(a2, b2, c2) {
      goog.exportPath_(a2, b2, true, c2);
    };
    goog.exportProperty = function(a2, b2, c2) {
      a2[b2] = c2;
    };
    goog.inherits = function(a2, b2) {
      function c2() {
      }
      c2.prototype = b2.prototype;
      a2.superClass_ = b2.prototype;
      a2.prototype = new c2();
      a2.prototype.constructor = a2;
      a2.base = function(d2, e2, f2) {
        for (var g = Array(arguments.length - 2), h = 2; h < arguments.length; h++) {
          g[h - 2] = arguments[h];
        }
        return b2.prototype[e2].apply(d2, g);
      };
    };
    goog.scope = function(a2) {
      if (goog.isInModuleLoader_()) {
        throw Error("goog.scope is not supported within a module.");
      }
      a2.call(goog.global);
    };
    COMPILED || (goog.global.COMPILED = COMPILED);
    goog.defineClass = function(a2, b2) {
      var c2 = b2.constructor, d2 = b2.statics;
      c2 && c2 != Object.prototype.constructor || (c2 = function() {
        throw Error("cannot instantiate an interface (no constructor defined).");
      });
      c2 = goog.defineClass.createSealingConstructor_(c2, a2);
      a2 && goog.inherits(c2, a2);
      delete b2.constructor;
      delete b2.statics;
      goog.defineClass.applyProperties_(c2.prototype, b2);
      null != d2 && (d2 instanceof Function ? d2(c2) : goog.defineClass.applyProperties_(c2, d2));
      return c2;
    };
    goog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG;
    goog.defineClass.createSealingConstructor_ = function(a2, b2) {
      return goog.defineClass.SEAL_CLASS_INSTANCES ? function() {
        var c2 = a2.apply(this, arguments) || this;
        c2[goog.UID_PROPERTY_] = c2[goog.UID_PROPERTY_];
        return c2;
      } : a2;
    };
    goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
    goog.defineClass.applyProperties_ = function(a2, b2) {
      for (var c2 in b2) {
        Object.prototype.hasOwnProperty.call(b2, c2) && (a2[c2] = b2[c2]);
      }
      for (var d2 = 0; d2 < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; d2++) {
        c2 = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d2], Object.prototype.hasOwnProperty.call(b2, c2) && (a2[c2] = b2[c2]);
      }
    };
    goog.identity_ = function(a2) {
      return a2;
    };
    goog.createTrustedTypesPolicy = function(a2) {
      var b2 = null, c2 = goog.global.trustedTypes;
      if (!c2 || !c2.createPolicy) {
        return b2;
      }
      try {
        b2 = c2.createPolicy(a2, { createHTML: goog.identity_, createScript: goog.identity_, createScriptURL: goog.identity_ });
      } catch (d2) {
        goog.logToConsole_(d2.message);
      }
      return b2;
    };
    !COMPILED && goog.DEPENDENCIES_ENABLED && (goog.isEdge_ = function() {
      return !!(goog.global.navigator && goog.global.navigator.userAgent ? goog.global.navigator.userAgent : "").match(/Edge\/(\d+)(\.\d)*/i);
    }, goog.inHtmlDocument_ = function() {
      var a2 = goog.global.document;
      return null != a2 && "write" in a2;
    }, goog.isDocumentLoading_ = function() {
      var a2 = goog.global.document;
      return a2.attachEvent ? "complete" != a2.readyState : "loading" == a2.readyState;
    }, goog.findBasePath_ = function() {
      if (void 0 != goog.global.CLOSURE_BASE_PATH && "string" === typeof goog.global.CLOSURE_BASE_PATH) {
        goog.basePath = goog.global.CLOSURE_BASE_PATH;
      } else {
        if (goog.inHtmlDocument_()) {
          var a2 = goog.global.document, b2 = a2.currentScript;
          a2 = b2 ? [b2] : a2.getElementsByTagName("SCRIPT");
          for (b2 = a2.length - 1; 0 <= b2; --b2) {
            var c2 = a2[b2].src, d2 = c2.lastIndexOf("?");
            d2 = -1 == d2 ? c2.length : d2;
            if ("base.js" == c2.substr(d2 - 7, 7)) {
              goog.basePath = c2.substr(0, d2 - 7);
              break;
            }
          }
        }
      }
    }, goog.findBasePath_(), goog.Transpiler = function() {
      this.requiresTranspilation_ = null;
      this.transpilationTarget_ = goog.TRANSPILE_TO_LANGUAGE;
    }, goog.Transpiler.prototype.createRequiresTranspilation_ = function() {
      function a(f2, g) {
        e ? d[f2] = true : g() ? (c = f2, d[f2] = false) : e = d[f2] = true;
      }
      function b(f) {
        try {
          return !!eval(goog.CLOSURE_EVAL_PREFILTER_.createScript(f));
        } catch (g) {
          return false;
        }
      }
      var c = "es3", d = { es3: false }, e = false;
      a("es5", function() {
        return b("[1,].length==1");
      });
      a("es6", function() {
        return goog.isEdge_() ? false : b('(()=>{"use strict";class X{constructor(){if(new.target!=String)throw 1;this.x=42}}let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof String))throw 1;for(const a of[2,3]){if(a==2)continue;function f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()==3}})()');
      });
      a("es7", function() {
        return b("2**3==8");
      });
      a("es8", function() {
        return b("async()=>1,1");
      });
      a("es9", function() {
        return b("({...rest}={}),1");
      });
      a("es_2019", function() {
        return b('let r;try{throw 0}catch{r="\u2029"};r');
      });
      a("es_2020", function() {
        return b("null?.x??1");
      });
      a("es_next", function() {
        return false;
      });
      return { target: c, map: d };
    }, goog.Transpiler.prototype.needsTranspile = function(a2, b2) {
      if ("always" == goog.TRANSPILE) {
        return true;
      }
      if ("never" == goog.TRANSPILE) {
        return false;
      }
      if (!this.requiresTranspilation_) {
        var c2 = this.createRequiresTranspilation_();
        this.requiresTranspilation_ = c2.map;
        this.transpilationTarget_ = this.transpilationTarget_ || c2.target;
      }
      if (a2 in this.requiresTranspilation_) {
        return this.requiresTranspilation_[a2] ? true : !goog.inHtmlDocument_() || "es6" != b2 || "noModule" in goog.global.document.createElement("script") ? false : true;
      }
      throw Error("Unknown language mode: " + a2);
    }, goog.Transpiler.prototype.transpile = function(a2, b2) {
      return goog.transpile_(a2, b2, this.transpilationTarget_);
    }, goog.transpiler_ = new goog.Transpiler(), goog.protectScriptTag_ = function(a2) {
      return a2.replace(/<\/(SCRIPT)/ig, "\\x3c/$1");
    }, goog.DebugLoader_ = function() {
      this.dependencies_ = {};
      this.idToPath_ = {};
      this.written_ = {};
      this.loadingDeps_ = [];
      this.depsToLoad_ = [];
      this.paused_ = false;
      this.factory_ = new goog.DependencyFactory(goog.transpiler_);
      this.deferredCallbacks_ = {};
      this.deferredQueue_ = [];
    }, goog.DebugLoader_.prototype.bootstrap = function(a2, b2) {
      function c2() {
        d2 && (goog.global.setTimeout(d2, 0), d2 = null);
      }
      var d2 = b2;
      if (a2.length) {
        b2 = [];
        for (var e2 = 0; e2 < a2.length; e2++) {
          var f2 = this.getPathFromDeps_(a2[e2]);
          if (!f2) {
            throw Error("Unregonized namespace: " + a2[e2]);
          }
          b2.push(this.dependencies_[f2]);
        }
        f2 = goog.require;
        var g = 0;
        for (e2 = 0; e2 < a2.length; e2++) {
          f2(a2[e2]), b2[e2].onLoad(function() {
            ++g == a2.length && c2();
          });
        }
      } else {
        c2();
      }
    }, goog.DebugLoader_.prototype.loadClosureDeps = function() {
      this.depsToLoad_.push(this.factory_.createDependency(goog.normalizePath_(goog.basePath + "deps.js"), "deps.js", [], [], {}, false));
      this.loadDeps_();
    }, goog.DebugLoader_.prototype.requested = function(a2, b2) {
      (a2 = this.getPathFromDeps_(a2)) && (b2 || this.areDepsLoaded_(this.dependencies_[a2].requires)) && (b2 = this.deferredCallbacks_[a2]) && (delete this.deferredCallbacks_[a2], b2());
    }, goog.DebugLoader_.prototype.setDependencyFactory = function(a2) {
      this.factory_ = a2;
    }, goog.DebugLoader_.prototype.load_ = function(a2) {
      if (this.getPathFromDeps_(a2)) {
        var b2 = this, c2 = [], d2 = function(e2) {
          var f2 = b2.getPathFromDeps_(e2);
          if (!f2) {
            throw Error("Bad dependency path or symbol: " + e2);
          }
          if (!b2.written_[f2]) {
            b2.written_[f2] = true;
            e2 = b2.dependencies_[f2];
            for (f2 = 0; f2 < e2.requires.length; f2++) {
              goog.isProvided_(e2.requires[f2]) || d2(e2.requires[f2]);
            }
            c2.push(e2);
          }
        };
        d2(a2);
        a2 = !!this.depsToLoad_.length;
        this.depsToLoad_ = this.depsToLoad_.concat(c2);
        this.paused_ || a2 || this.loadDeps_();
      } else {
        goog.logToConsole_("goog.require could not find: " + a2);
      }
    }, goog.DebugLoader_.prototype.loadDeps_ = function() {
      for (var a2 = this, b2 = this.paused_; this.depsToLoad_.length && !b2; ) {
        (function() {
          var c2 = false, d2 = a2.depsToLoad_.shift(), e2 = false;
          a2.loading_(d2);
          var f2 = { pause: function() {
            if (c2) {
              throw Error("Cannot call pause after the call to load.");
            }
            b2 = true;
          }, resume: function() {
            c2 ? a2.resume_() : b2 = false;
          }, loaded: function() {
            if (e2) {
              throw Error("Double call to loaded.");
            }
            e2 = true;
            a2.loaded_(d2);
          }, pending: function() {
            for (var g = [], h = 0; h < a2.loadingDeps_.length; h++) {
              g.push(a2.loadingDeps_[h]);
            }
            return g;
          }, setModuleState: function(g) {
            goog.moduleLoaderState_ = { type: g, moduleName: "", declareLegacyNamespace: false };
          }, registerEs6ModuleExports: function(g, h, k) {
            k && (goog.loadedModules_[k] = { exports: h, type: goog.ModuleType.ES6, moduleId: k || "" });
          }, registerGoogModuleExports: function(g, h) {
            goog.loadedModules_[g] = { exports: h, type: goog.ModuleType.GOOG, moduleId: g };
          }, clearModuleState: function() {
            goog.moduleLoaderState_ = null;
          }, defer: function(g) {
            if (c2) {
              throw Error("Cannot register with defer after the call to load.");
            }
            a2.defer_(d2, g);
          }, areDepsLoaded: function() {
            return a2.areDepsLoaded_(d2.requires);
          } };
          try {
            d2.load(f2);
          } finally {
            c2 = true;
          }
        })();
      }
      b2 && this.pause_();
    }, goog.DebugLoader_.prototype.pause_ = function() {
      this.paused_ = true;
    }, goog.DebugLoader_.prototype.resume_ = function() {
      this.paused_ && (this.paused_ = false, this.loadDeps_());
    }, goog.DebugLoader_.prototype.loading_ = function(a2) {
      this.loadingDeps_.push(a2);
    }, goog.DebugLoader_.prototype.loaded_ = function(a2) {
      for (var b2 = 0; b2 < this.loadingDeps_.length; b2++) {
        if (this.loadingDeps_[b2] == a2) {
          this.loadingDeps_.splice(b2, 1);
          break;
        }
      }
      for (b2 = 0; b2 < this.deferredQueue_.length; b2++) {
        if (this.deferredQueue_[b2] == a2.path) {
          this.deferredQueue_.splice(b2, 1);
          break;
        }
      }
      if (this.loadingDeps_.length == this.deferredQueue_.length && !this.depsToLoad_.length) {
        for (; this.deferredQueue_.length; ) {
          this.requested(this.deferredQueue_.shift(), true);
        }
      }
      a2.loaded();
    }, goog.DebugLoader_.prototype.areDepsLoaded_ = function(a2) {
      for (var b2 = 0; b2 < a2.length; b2++) {
        var c2 = this.getPathFromDeps_(a2[b2]);
        if (!c2 || !(c2 in this.deferredCallbacks_ || goog.isProvided_(a2[b2]))) {
          return false;
        }
      }
      return true;
    }, goog.DebugLoader_.prototype.getPathFromDeps_ = function(a2) {
      return a2 in this.idToPath_ ? this.idToPath_[a2] : a2 in this.dependencies_ ? a2 : null;
    }, goog.DebugLoader_.prototype.defer_ = function(a2, b2) {
      this.deferredCallbacks_[a2.path] = b2;
      this.deferredQueue_.push(a2.path);
    }, goog.LoadController = function() {
    }, goog.LoadController.prototype.pause = function() {
    }, goog.LoadController.prototype.resume = function() {
    }, goog.LoadController.prototype.loaded = function() {
    }, goog.LoadController.prototype.pending = function() {
    }, goog.LoadController.prototype.registerEs6ModuleExports = function(a2, b2, c2) {
    }, goog.LoadController.prototype.setModuleState = function(a2) {
    }, goog.LoadController.prototype.clearModuleState = function() {
    }, goog.LoadController.prototype.defer = function(a2) {
    }, goog.LoadController.prototype.areDepsLoaded = function() {
    }, goog.Dependency = function(a2, b2, c2, d2, e2) {
      this.path = a2;
      this.relativePath = b2;
      this.provides = c2;
      this.requires = d2;
      this.loadFlags = e2;
      this.loaded_ = false;
      this.loadCallbacks_ = [];
    }, goog.Dependency.prototype.getPathName = function() {
      var a2 = this.path, b2 = a2.indexOf("://");
      0 <= b2 && (a2 = a2.substring(b2 + 3), b2 = a2.indexOf("/"), 0 <= b2 && (a2 = a2.substring(b2 + 1)));
      return a2;
    }, goog.Dependency.prototype.onLoad = function(a2) {
      this.loaded_ ? a2() : this.loadCallbacks_.push(a2);
    }, goog.Dependency.prototype.loaded = function() {
      this.loaded_ = true;
      var a2 = this.loadCallbacks_;
      this.loadCallbacks_ = [];
      for (var b2 = 0; b2 < a2.length; b2++) {
        a2[b2]();
      }
    }, goog.Dependency.defer_ = false, goog.Dependency.callbackMap_ = {}, goog.Dependency.registerCallback_ = function(a2) {
      var b2 = Math.random().toString(32);
      goog.Dependency.callbackMap_[b2] = a2;
      return b2;
    }, goog.Dependency.unregisterCallback_ = function(a2) {
      delete goog.Dependency.callbackMap_[a2];
    }, goog.Dependency.callback_ = function(a2, b2) {
      if (a2 in goog.Dependency.callbackMap_) {
        for (var c2 = goog.Dependency.callbackMap_[a2], d2 = [], e2 = 1; e2 < arguments.length; e2++) {
          d2.push(arguments[e2]);
        }
        c2.apply(void 0, d2);
      } else {
        throw Error("Callback key " + a2 + " does not exist (was base.js loaded more than once?).");
      }
    }, goog.Dependency.prototype.load = function(a2) {
      if (goog.global.CLOSURE_IMPORT_SCRIPT) {
        goog.global.CLOSURE_IMPORT_SCRIPT(this.path) ? a2.loaded() : a2.pause();
      } else {
        if (goog.inHtmlDocument_()) {
          var b2 = goog.global.document;
          if ("complete" == b2.readyState && !goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {
            if (/\bdeps.js$/.test(this.path)) {
              a2.loaded();
              return;
            }
            throw Error('Cannot write "' + this.path + '" after document load');
          }
          var c2 = goog.getScriptNonce();
          if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && goog.isDocumentLoading_()) {
            var d2 = function(h) {
              h.readyState && "complete" != h.readyState ? h.onload = d2 : (goog.Dependency.unregisterCallback_(e2), a2.loaded());
            };
            var e2 = goog.Dependency.registerCallback_(d2);
            c2 = c2 ? ' nonce="' + c2 + '"' : "";
            var f2 = '<script src="' + this.path + '"' + c2 + (goog.Dependency.defer_ ? " defer" : "") + ' id="script-' + e2 + '"><\/script>';
            f2 += "<script" + c2 + ">";
            f2 = goog.Dependency.defer_ ? f2 + ("document.getElementById('script-" + e2 + "').onload = function() {\n  goog.Dependency.callback_('" + e2 + "', this);\n};\n") : f2 + ("goog.Dependency.callback_('" + e2 + "', document.getElementById('script-" + e2 + "'));");
            f2 += "<\/script>";
            b2.write(goog.TRUSTED_TYPES_POLICY_ ? goog.TRUSTED_TYPES_POLICY_.createHTML(f2) : f2);
          } else {
            var g = b2.createElement("script");
            g.defer = goog.Dependency.defer_;
            g.async = false;
            c2 && (g.nonce = c2);
            goog.DebugLoader_.IS_OLD_IE_ ? (a2.pause(), g.onreadystatechange = function() {
              if ("loaded" == g.readyState || "complete" == g.readyState) {
                a2.loaded(), a2.resume();
              }
            }) : g.onload = function() {
              g.onload = null;
              a2.loaded();
            };
            g.src = goog.TRUSTED_TYPES_POLICY_ ? goog.TRUSTED_TYPES_POLICY_.createScriptURL(this.path) : this.path;
            b2.head.appendChild(g);
          }
        } else {
          goog.logToConsole_("Cannot use default debug loader outside of HTML documents."), "deps.js" == this.relativePath ? (goog.logToConsole_("Consider setting CLOSURE_IMPORT_SCRIPT before loading base.js, or setting CLOSURE_NO_DEPS to true."), a2.loaded()) : a2.pause();
        }
      }
    }, goog.Es6ModuleDependency = function(a2, b2, c2, d2, e2) {
      goog.Dependency.call(this, a2, b2, c2, d2, e2);
    }, goog.inherits(goog.Es6ModuleDependency, goog.Dependency), goog.Es6ModuleDependency.prototype.load = function(a2) {
      function b2(l, n) {
        var m = "", p = goog.getScriptNonce();
        p && (m = ' nonce="' + p + '"');
        l = n ? '<script type="module" crossorigin' + m + ">" + n + "<\/script>" : '<script type="module" crossorigin src="' + l + '"' + m + "><\/script>";
        d2.write(goog.TRUSTED_TYPES_POLICY_ ? goog.TRUSTED_TYPES_POLICY_.createHTML(l) : l);
      }
      function c2(l, n) {
        var m = d2.createElement("script");
        m.defer = true;
        m.async = false;
        m.type = "module";
        m.setAttribute("crossorigin", true);
        var p = goog.getScriptNonce();
        p && (m.nonce = p);
        n ? m.text = goog.TRUSTED_TYPES_POLICY_ ? goog.TRUSTED_TYPES_POLICY_.createScript(n) : n : m.src = goog.TRUSTED_TYPES_POLICY_ ? goog.TRUSTED_TYPES_POLICY_.createScriptURL(l) : l;
        d2.head.appendChild(m);
      }
      if (goog.global.CLOSURE_IMPORT_SCRIPT) {
        goog.global.CLOSURE_IMPORT_SCRIPT(this.path) ? a2.loaded() : a2.pause();
      } else {
        if (goog.inHtmlDocument_()) {
          var d2 = goog.global.document, e2 = this;
          if (goog.isDocumentLoading_()) {
            var f2 = b2;
            goog.Dependency.defer_ = true;
          } else {
            f2 = c2;
          }
          var g = goog.Dependency.registerCallback_(function() {
            goog.Dependency.unregisterCallback_(g);
            a2.setModuleState(goog.ModuleType.ES6);
          });
          f2(void 0, 'goog.Dependency.callback_("' + g + '")');
          f2(this.path, void 0);
          var h = goog.Dependency.registerCallback_(function(l) {
            goog.Dependency.unregisterCallback_(h);
            a2.registerEs6ModuleExports(e2.path, l, goog.moduleLoaderState_.moduleName);
          });
          f2(void 0, 'import * as m from "' + this.path + '"; goog.Dependency.callback_("' + h + '", m)');
          var k = goog.Dependency.registerCallback_(function() {
            goog.Dependency.unregisterCallback_(k);
            a2.clearModuleState();
            a2.loaded();
          });
          f2(void 0, 'goog.Dependency.callback_("' + k + '")');
        } else {
          goog.logToConsole_("Cannot use default debug loader outside of HTML documents."), a2.pause();
        }
      }
    }, goog.TransformedDependency = function(a2, b2, c2, d2, e2) {
      goog.Dependency.call(this, a2, b2, c2, d2, e2);
      this.contents_ = null;
      this.lazyFetch_ = !goog.inHtmlDocument_() || !("noModule" in goog.global.document.createElement("script"));
    }, goog.inherits(goog.TransformedDependency, goog.Dependency), goog.TransformedDependency.prototype.load = function(a2) {
      function b2() {
        e2.contents_ = goog.loadFileSync_(e2.path);
        e2.contents_ && (e2.contents_ = e2.transform(e2.contents_), e2.contents_ && (e2.contents_ += "\n//# sourceURL=" + e2.path));
      }
      function c2() {
        e2.lazyFetch_ && b2();
        if (e2.contents_) {
          f2 && a2.setModuleState(goog.ModuleType.ES6);
          try {
            var n = e2.contents_;
            e2.contents_ = null;
            goog.globalEval(goog.CLOSURE_EVAL_PREFILTER_.createScript(n));
            if (f2) {
              var m = goog.moduleLoaderState_.moduleName;
            }
          } finally {
            f2 && a2.clearModuleState();
          }
          f2 && goog.global.$jscomp.require.ensure([e2.getPathName()], function() {
            a2.registerEs6ModuleExports(e2.path, goog.global.$jscomp.require(e2.getPathName()), m);
          });
          a2.loaded();
        }
      }
      function d2() {
        var n = goog.global.document, m = goog.Dependency.registerCallback_(function() {
          goog.Dependency.unregisterCallback_(m);
          c2();
        }), p = goog.getScriptNonce();
        p = "<script" + (p ? ' nonce="' + p + '"' : "") + ">" + goog.protectScriptTag_('goog.Dependency.callback_("' + m + '");') + "<\/script>";
        n.write(goog.TRUSTED_TYPES_POLICY_ ? goog.TRUSTED_TYPES_POLICY_.createHTML(p) : p);
      }
      var e2 = this;
      if (goog.global.CLOSURE_IMPORT_SCRIPT) {
        b2(), this.contents_ && goog.global.CLOSURE_IMPORT_SCRIPT("", this.contents_) ? (this.contents_ = null, a2.loaded()) : a2.pause();
      } else {
        var f2 = this.loadFlags.module == goog.ModuleType.ES6;
        this.lazyFetch_ || b2();
        var g = 1 < a2.pending().length, h = g && goog.DebugLoader_.IS_OLD_IE_;
        g = goog.Dependency.defer_ && (g || goog.isDocumentLoading_());
        if (h || g) {
          a2.defer(function() {
            c2();
          });
        } else {
          var k = goog.global.document;
          h = goog.inHtmlDocument_() && ("ActiveXObject" in goog.global || goog.isEdge_());
          if (f2 && goog.inHtmlDocument_() && goog.isDocumentLoading_() && !h) {
            goog.Dependency.defer_ = true;
            a2.pause();
            var l = k.onreadystatechange;
            k.onreadystatechange = function() {
              "interactive" == k.readyState && (k.onreadystatechange = l, c2(), a2.resume());
              "function" === typeof l && l.apply(void 0, arguments);
            };
          } else {
            !goog.DebugLoader_.IS_OLD_IE_ && goog.inHtmlDocument_() && goog.isDocumentLoading_() ? d2() : c2();
          }
        }
      }
    }, goog.TransformedDependency.prototype.transform = function(a2) {
    }, goog.TranspiledDependency = function(a2, b2, c2, d2, e2, f2) {
      goog.TransformedDependency.call(this, a2, b2, c2, d2, e2);
      this.transpiler = f2;
    }, goog.inherits(goog.TranspiledDependency, goog.TransformedDependency), goog.TranspiledDependency.prototype.transform = function(a2) {
      return this.transpiler.transpile(a2, this.getPathName());
    }, goog.PreTranspiledEs6ModuleDependency = function(a2, b2, c2, d2, e2) {
      goog.TransformedDependency.call(this, a2, b2, c2, d2, e2);
    }, goog.inherits(goog.PreTranspiledEs6ModuleDependency, goog.TransformedDependency), goog.PreTranspiledEs6ModuleDependency.prototype.transform = function(a2) {
      return a2;
    }, goog.GoogModuleDependency = function(a2, b2, c2, d2, e2, f2, g) {
      goog.TransformedDependency.call(this, a2, b2, c2, d2, e2);
      this.needsTranspile_ = f2;
      this.transpiler_ = g;
    }, goog.inherits(goog.GoogModuleDependency, goog.TransformedDependency), goog.GoogModuleDependency.prototype.transform = function(a2) {
      this.needsTranspile_ && (a2 = this.transpiler_.transpile(a2, this.getPathName()));
      return goog.LOAD_MODULE_USING_EVAL && void 0 !== goog.global.JSON ? "goog.loadModule(" + goog.global.JSON.stringify(a2 + "\n//# sourceURL=" + this.path + "\n") + ");" : 'goog.loadModule(function(exports) {"use strict";' + a2 + "\n;return exports});\n//# sourceURL=" + this.path + "\n";
    }, goog.DebugLoader_.IS_OLD_IE_ = !(goog.global.atob || !goog.global.document || !goog.global.document.all), goog.DebugLoader_.prototype.addDependency = function(a2, b2, c2, d2) {
      b2 = b2 || [];
      a2 = a2.replace(/\\/g, "/");
      var e2 = goog.normalizePath_(goog.basePath + a2);
      d2 && "boolean" !== typeof d2 || (d2 = d2 ? { module: goog.ModuleType.GOOG } : {});
      c2 = this.factory_.createDependency(e2, a2, b2, c2, d2, goog.transpiler_.needsTranspile(d2.lang || "es3", d2.module));
      this.dependencies_[e2] = c2;
      for (c2 = 0; c2 < b2.length; c2++) {
        this.idToPath_[b2[c2]] = e2;
      }
      this.idToPath_[a2] = e2;
    }, goog.DependencyFactory = function(a2) {
      this.transpiler = a2;
    }, goog.DependencyFactory.prototype.createDependency = function(a2, b2, c2, d2, e2, f2) {
      return e2.module == goog.ModuleType.GOOG ? new goog.GoogModuleDependency(a2, b2, c2, d2, e2, f2, this.transpiler) : f2 ? new goog.TranspiledDependency(a2, b2, c2, d2, e2, this.transpiler) : e2.module == goog.ModuleType.ES6 ? "never" == goog.TRANSPILE && goog.ASSUME_ES_MODULES_TRANSPILED ? new goog.PreTranspiledEs6ModuleDependency(a2, b2, c2, d2, e2) : new goog.Es6ModuleDependency(a2, b2, c2, d2, e2) : new goog.Dependency(a2, b2, c2, d2, e2);
    }, goog.debugLoader_ = new goog.DebugLoader_(), goog.loadClosureDeps = function() {
      goog.debugLoader_.loadClosureDeps();
    }, goog.setDependencyFactory = function(a2) {
      goog.debugLoader_.setDependencyFactory(a2);
    }, goog.TRUSTED_TYPES_POLICY_ = goog.TRUSTED_TYPES_POLICY_NAME ? goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + "#base") : null, goog.global.CLOSURE_NO_DEPS || goog.debugLoader_.loadClosureDeps(), goog.bootstrap = function(a2, b2) {
      goog.debugLoader_.bootstrap(a2, b2);
    });
    if (!COMPILED) {
      isChrome87 = false;
      try {
        isChrome87 = eval(goog.global.trustedTypes.emptyScript) !== goog.global.trustedTypes.emptyScript;
      } catch (a2) {
      }
      goog.CLOSURE_EVAL_PREFILTER_ = goog.global.trustedTypes && isChrome87 && goog.createTrustedTypesPolicy("goog#base#devonly#eval") || { createScript: goog.identity_ };
    }
    var isChrome87;
    goog.object = {};
    goog.object.forEach = function(a2, b2, c2) {
      for (const d2 in a2) {
        b2.call(c2, a2[d2], d2, a2);
      }
    };
    goog.object.filter = function(a2, b2, c2) {
      const d2 = {};
      for (const e2 in a2) {
        b2.call(c2, a2[e2], e2, a2) && (d2[e2] = a2[e2]);
      }
      return d2;
    };
    goog.object.map = function(a2, b2, c2) {
      const d2 = {};
      for (const e2 in a2) {
        d2[e2] = b2.call(c2, a2[e2], e2, a2);
      }
      return d2;
    };
    goog.object.some = function(a2, b2, c2) {
      for (const d2 in a2) {
        if (b2.call(c2, a2[d2], d2, a2)) {
          return true;
        }
      }
      return false;
    };
    goog.object.every = function(a2, b2, c2) {
      for (const d2 in a2) {
        if (!b2.call(c2, a2[d2], d2, a2)) {
          return false;
        }
      }
      return true;
    };
    goog.object.getCount = function(a2) {
      let b2 = 0;
      for (const c2 in a2) {
        b2++;
      }
      return b2;
    };
    goog.object.getAnyKey = function(a2) {
      for (const b2 in a2) {
        return b2;
      }
    };
    goog.object.getAnyValue = function(a2) {
      for (const b2 in a2) {
        return a2[b2];
      }
    };
    goog.object.contains = function(a2, b2) {
      return goog.object.containsValue(a2, b2);
    };
    goog.object.getValues = function(a2) {
      const b2 = [];
      let c2 = 0;
      for (const d2 in a2) {
        b2[c2++] = a2[d2];
      }
      return b2;
    };
    goog.object.getKeys = function(a2) {
      const b2 = [];
      let c2 = 0;
      for (const d2 in a2) {
        b2[c2++] = d2;
      }
      return b2;
    };
    goog.object.getValueByKeys = function(a2, b2) {
      var c2 = goog.isArrayLike(b2);
      const d2 = c2 ? b2 : arguments;
      for (c2 = c2 ? 0 : 1; c2 < d2.length; c2++) {
        if (null == a2) {
          return;
        }
        a2 = a2[d2[c2]];
      }
      return a2;
    };
    goog.object.containsKey = function(a2, b2) {
      return null !== a2 && b2 in a2;
    };
    goog.object.containsValue = function(a2, b2) {
      for (const c2 in a2) {
        if (a2[c2] == b2) {
          return true;
        }
      }
      return false;
    };
    goog.object.findKey = function(a2, b2, c2) {
      for (const d2 in a2) {
        if (b2.call(c2, a2[d2], d2, a2)) {
          return d2;
        }
      }
    };
    goog.object.findValue = function(a2, b2, c2) {
      return (b2 = goog.object.findKey(a2, b2, c2)) && a2[b2];
    };
    goog.object.isEmpty = function(a2) {
      for (const b2 in a2) {
        return false;
      }
      return true;
    };
    goog.object.clear = function(a2) {
      for (const b2 in a2) {
        delete a2[b2];
      }
    };
    goog.object.remove = function(a2, b2) {
      let c2;
      (c2 = b2 in a2) && delete a2[b2];
      return c2;
    };
    goog.object.add = function(a2, b2, c2) {
      if (null !== a2 && b2 in a2) {
        throw Error('The object already contains the key "' + b2 + '"');
      }
      goog.object.set(a2, b2, c2);
    };
    goog.object.get = function(a2, b2, c2) {
      return null !== a2 && b2 in a2 ? a2[b2] : c2;
    };
    goog.object.set = function(a2, b2, c2) {
      a2[b2] = c2;
    };
    goog.object.setIfUndefined = function(a2, b2, c2) {
      return b2 in a2 ? a2[b2] : a2[b2] = c2;
    };
    goog.object.setWithReturnValueIfNotSet = function(a2, b2, c2) {
      if (b2 in a2) {
        return a2[b2];
      }
      c2 = c2();
      return a2[b2] = c2;
    };
    goog.object.equals = function(a2, b2) {
      for (const c2 in a2) {
        if (!(c2 in b2) || a2[c2] !== b2[c2]) {
          return false;
        }
      }
      for (const c2 in b2) {
        if (!(c2 in a2)) {
          return false;
        }
      }
      return true;
    };
    goog.object.clone = function(a2) {
      const b2 = {};
      for (const c2 in a2) {
        b2[c2] = a2[c2];
      }
      return b2;
    };
    goog.object.unsafeClone = function(a2) {
      if (!a2 || "object" !== typeof a2) {
        return a2;
      }
      if ("function" === typeof a2.clone) {
        return a2.clone();
      }
      const b2 = Array.isArray(a2) ? [] : "function" !== typeof ArrayBuffer || "function" !== typeof ArrayBuffer.isView || !ArrayBuffer.isView(a2) || a2 instanceof DataView ? {} : new a2.constructor(a2.length);
      for (const c2 in a2) {
        b2[c2] = goog.object.unsafeClone(a2[c2]);
      }
      return b2;
    };
    goog.object.transpose = function(a2) {
      const b2 = {};
      for (const c2 in a2) {
        b2[a2[c2]] = c2;
      }
      return b2;
    };
    goog.object.PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
    goog.object.extend = function(a2, b2) {
      let c2, d2;
      for (let e2 = 1; e2 < arguments.length; e2++) {
        d2 = arguments[e2];
        for (c2 in d2) {
          a2[c2] = d2[c2];
        }
        for (let f2 = 0; f2 < goog.object.PROTOTYPE_FIELDS_.length; f2++) {
          c2 = goog.object.PROTOTYPE_FIELDS_[f2], Object.prototype.hasOwnProperty.call(d2, c2) && (a2[c2] = d2[c2]);
        }
      }
    };
    goog.object.create = function(a2) {
      const b2 = arguments.length;
      if (1 == b2 && Array.isArray(arguments[0])) {
        return goog.object.create.apply(null, arguments[0]);
      }
      if (b2 % 2) {
        throw Error("Uneven number of arguments");
      }
      const c2 = {};
      for (let d2 = 0; d2 < b2; d2 += 2) {
        c2[arguments[d2]] = arguments[d2 + 1];
      }
      return c2;
    };
    goog.object.createSet = function(a2) {
      const b2 = arguments.length;
      if (1 == b2 && Array.isArray(arguments[0])) {
        return goog.object.createSet.apply(null, arguments[0]);
      }
      const c2 = {};
      for (let d2 = 0; d2 < b2; d2++) {
        c2[arguments[d2]] = true;
      }
      return c2;
    };
    goog.object.createImmutableView = function(a2) {
      let b2 = a2;
      Object.isFrozen && !Object.isFrozen(a2) && (b2 = Object.create(a2), Object.freeze(b2));
      return b2;
    };
    goog.object.isImmutableView = function(a2) {
      return !!Object.isFrozen && Object.isFrozen(a2);
    };
    goog.object.getAllPropertyNames = function(a2, b2, c2) {
      if (!a2) {
        return [];
      }
      if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {
        return goog.object.getKeys(a2);
      }
      const d2 = {};
      for (; a2 && (a2 !== Object.prototype || b2) && (a2 !== Function.prototype || c2); ) {
        const e2 = Object.getOwnPropertyNames(a2);
        for (let f2 = 0; f2 < e2.length; f2++) {
          d2[e2[f2]] = true;
        }
        a2 = Object.getPrototypeOf(a2);
      }
      return goog.object.getKeys(d2);
    };
    goog.object.getSuperClass = function(a2) {
      return (a2 = Object.getPrototypeOf(a2.prototype)) && a2.constructor;
    };
    var com = { cognitect: {} };
    com.cognitect.transit = {};
    com.cognitect.transit.util = {};
    com.cognitect.transit.util.objectKeys = "undefined" != typeof Object.keys ? function(a2) {
      return Object.keys(a2);
    } : function(a2) {
      return goog.object.getKeys(a2);
    };
    com.cognitect.transit.util.isArray = "undefined" != typeof Array.isArray ? function(a2) {
      return Array.isArray(a2);
    } : function(a2) {
      return "array" === goog.typeOf(a2);
    };
    com.cognitect.transit.util.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    com.cognitect.transit.util.randInt = function(a2) {
      return Math.round(Math.random() * a2);
    };
    com.cognitect.transit.util.randHex = function() {
      return com.cognitect.transit.util.randInt(15).toString(16);
    };
    com.cognitect.transit.util.randomUUID = function() {
      var a2 = (8 | 3 & com.cognitect.transit.util.randInt(14)).toString(16);
      return com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-4" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + a2 + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex();
    };
    com.cognitect.transit.util.btoa = function(a2) {
      if ("undefined" != typeof btoa) {
        return btoa(a2);
      }
      a2 = String(a2);
      for (var b2, c2, d2 = 0, e2 = com.cognitect.transit.util.chars, f2 = ""; a2.charAt(d2 | 0) || (e2 = "=", d2 % 1); f2 += e2.charAt(63 & b2 >> 8 - d2 % 1 * 8)) {
        c2 = a2.charCodeAt(d2 += 0.75);
        if (255 < c2) {
          throw Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
        }
        b2 = b2 << 8 | c2;
      }
      return f2;
    };
    com.cognitect.transit.util.atob = function(a2) {
      if ("undefined" != typeof atob) {
        return atob(a2);
      }
      a2 = String(a2).replace(/=+$/, "");
      if (1 == a2.length % 4) {
        throw Error("'atob' failed: The string to be decoded is not correctly encoded.");
      }
      for (var b2 = 0, c2, d2, e2 = 0, f2 = ""; d2 = a2.charAt(e2++); ~d2 && (c2 = b2 % 4 ? 64 * c2 + d2 : d2, b2++ % 4) ? f2 += String.fromCharCode(255 & c2 >> (-2 * b2 & 6)) : 0) {
        d2 = com.cognitect.transit.util.chars.indexOf(d2);
      }
      return f2;
    };
    com.cognitect.transit.util.Uint8ToBase64 = function(a2) {
      for (var b2 = 0, c2 = a2.length, d2 = "", e2; b2 < c2; ) {
        e2 = a2.subarray(b2, Math.min(b2 + 32768, c2)), d2 += String.fromCharCode.apply(null, e2), b2 += 32768;
      }
      return com.cognitect.transit.util.btoa(d2);
    };
    com.cognitect.transit.util.Base64ToUint8 = function(a2) {
      a2 = com.cognitect.transit.util.atob(a2);
      for (var b2 = a2.length, c2 = new Uint8Array(b2), d2 = 0; d2 < b2; d2++) {
        var e2 = a2.charCodeAt(d2);
        c2[d2] = e2;
      }
      return c2;
    };
    com.cognitect.transit.delimiters = {};
    com.cognitect.transit.delimiters.ESC = "~";
    com.cognitect.transit.delimiters.TAG = "#";
    com.cognitect.transit.delimiters.SUB = "^";
    com.cognitect.transit.delimiters.RES = "`";
    com.cognitect.transit.delimiters.ESC_TAG = "~#";
    com.cognitect.transit.caching = {};
    com.cognitect.transit.caching.MIN_SIZE_CACHEABLE = 3;
    com.cognitect.transit.caching.BASE_CHAR_IDX = 48;
    com.cognitect.transit.caching.CACHE_CODE_DIGITS = 44;
    com.cognitect.transit.caching.MAX_CACHE_ENTRIES = com.cognitect.transit.caching.CACHE_CODE_DIGITS * com.cognitect.transit.caching.CACHE_CODE_DIGITS;
    com.cognitect.transit.caching.MAX_CACHE_SIZE = 4096;
    com.cognitect.transit.caching.isCacheable = function(a2, b2) {
      if (a2.length > com.cognitect.transit.caching.MIN_SIZE_CACHEABLE) {
        if (b2) {
          return true;
        }
        b2 = a2.charAt(0);
        a2 = a2.charAt(1);
        return b2 === com.cognitect.transit.delimiters.ESC ? ":" === a2 || "$" === a2 || "#" === a2 : false;
      }
      return false;
    };
    com.cognitect.transit.caching.idxToCode = function(a2) {
      var b2 = Math.floor(a2 / com.cognitect.transit.caching.CACHE_CODE_DIGITS);
      a2 = String.fromCharCode(a2 % com.cognitect.transit.caching.CACHE_CODE_DIGITS + com.cognitect.transit.caching.BASE_CHAR_IDX);
      return 0 === b2 ? com.cognitect.transit.delimiters.SUB + a2 : com.cognitect.transit.delimiters.SUB + String.fromCharCode(b2 + com.cognitect.transit.caching.BASE_CHAR_IDX) + a2;
    };
    com.cognitect.transit.caching.WriteCache = function() {
      this.cacheSize = this.gen = this.idx = 0;
      this.cache = {};
    };
    com.cognitect.transit.caching.WriteCache.prototype.write = function(a2, b2) {
      return com.cognitect.transit.caching.isCacheable(a2, b2) ? (this.cacheSize === com.cognitect.transit.caching.MAX_CACHE_SIZE ? (this.clear(), this.gen = 0, this.cache = {}) : this.idx === com.cognitect.transit.caching.MAX_CACHE_ENTRIES && this.clear(), b2 = this.cache[a2], null == b2 ? (this.cache[a2] = [com.cognitect.transit.caching.idxToCode(this.idx), this.gen], this.idx++, a2) : b2[1] != this.gen ? (b2[1] = this.gen, b2[0] = com.cognitect.transit.caching.idxToCode(this.idx), this.idx++, a2) : b2[0]) : a2;
    };
    com.cognitect.transit.caching.WriteCache.prototype.clear = function() {
      this.idx = 0;
      this.gen++;
    };
    com.cognitect.transit.caching.writeCache = function() {
      return new com.cognitect.transit.caching.WriteCache();
    };
    com.cognitect.transit.caching.isCacheCode = function(a2) {
      return a2.charAt(0) === com.cognitect.transit.delimiters.SUB && " " !== a2.charAt(1);
    };
    com.cognitect.transit.caching.codeToIdx = function(a2) {
      if (2 === a2.length) {
        return a2.charCodeAt(1) - com.cognitect.transit.caching.BASE_CHAR_IDX;
      }
      var b2 = (a2.charCodeAt(1) - com.cognitect.transit.caching.BASE_CHAR_IDX) * com.cognitect.transit.caching.CACHE_CODE_DIGITS;
      a2 = a2.charCodeAt(2) - com.cognitect.transit.caching.BASE_CHAR_IDX;
      return b2 + a2;
    };
    com.cognitect.transit.caching.ReadCache = function() {
      this.idx = 0;
      this.cache = [];
    };
    com.cognitect.transit.caching.ReadCache.prototype.write = function(a2, b2) {
      this.idx == com.cognitect.transit.caching.MAX_CACHE_ENTRIES && (this.idx = 0);
      this.cache[this.idx] = a2;
      this.idx++;
      return a2;
    };
    com.cognitect.transit.caching.ReadCache.prototype.read = function(a2, b2) {
      return this.cache[com.cognitect.transit.caching.codeToIdx(a2)];
    };
    com.cognitect.transit.caching.ReadCache.prototype.clear = function() {
      this.idx = 0;
    };
    com.cognitect.transit.caching.readCache = function() {
      return new com.cognitect.transit.caching.ReadCache();
    };
    com.cognitect.transit.eq = {};
    com.cognitect.transit.eq.hashCodeProperty = "transit$hashCode$";
    com.cognitect.transit.eq.hashCodeCounter = 1;
    com.cognitect.transit.eq.equals = function(a2, b2) {
      if (null == a2) {
        return null == b2;
      }
      if (a2 === b2) {
        return true;
      }
      if ("object" === typeof a2) {
        if (com.cognitect.transit.util.isArray(a2)) {
          if (com.cognitect.transit.util.isArray(b2) && a2.length === b2.length) {
            for (var c2 = 0; c2 < a2.length; c2++) {
              if (!com.cognitect.transit.eq.equals(a2[c2], b2[c2])) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        if (a2.com$cognitect$transit$equals) {
          return a2.com$cognitect$transit$equals(b2);
        }
        if (null != b2 && "object" === typeof b2) {
          if (b2.com$cognitect$transit$equals) {
            return b2.com$cognitect$transit$equals(a2);
          }
          c2 = 0;
          var d2 = com.cognitect.transit.util.objectKeys(b2).length, e2;
          for (e2 in a2) {
            if (a2.hasOwnProperty(e2) && (c2++, !b2.hasOwnProperty(e2) || !com.cognitect.transit.eq.equals(a2[e2], b2[e2]))) {
              return false;
            }
          }
          return c2 === d2;
        }
      }
      return false;
    };
    com.cognitect.transit.eq.hashCombine = function(a2, b2) {
      return a2 ^ b2 + 2654435769 + (a2 << 6) + (a2 >> 2);
    };
    com.cognitect.transit.eq.stringCodeCache = {};
    com.cognitect.transit.eq.stringCodeCacheSize = 0;
    com.cognitect.transit.eq.STR_CACHE_MAX = 256;
    com.cognitect.transit.eq.hashString = function(a2) {
      var b2 = com.cognitect.transit.eq.stringCodeCache[a2];
      if (null != b2) {
        return b2;
      }
      for (var c2 = b2 = 0; c2 < a2.length; ++c2) {
        b2 = 31 * b2 + a2.charCodeAt(c2), b2 %= 4294967296;
      }
      com.cognitect.transit.eq.stringCodeCacheSize++;
      com.cognitect.transit.eq.stringCodeCacheSize >= com.cognitect.transit.eq.STR_CACHE_MAX && (com.cognitect.transit.eq.stringCodeCache = {}, com.cognitect.transit.eq.stringCodeCacheSize = 1);
      return com.cognitect.transit.eq.stringCodeCache[a2] = b2;
    };
    com.cognitect.transit.eq.hashMapLike = function(a2) {
      var b2 = 0;
      if (null != a2.forEach) {
        a2.forEach(function(g, h, k) {
          b2 = (b2 + (com.cognitect.transit.eq.hashCode(h) ^ com.cognitect.transit.eq.hashCode(g))) % 4503599627370496;
        });
      } else {
        for (var c2 = com.cognitect.transit.util.objectKeys(a2), d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = a2[e2];
          b2 = (b2 + (com.cognitect.transit.eq.hashCode(e2) ^ com.cognitect.transit.eq.hashCode(f2))) % 4503599627370496;
        }
      }
      return b2;
    };
    com.cognitect.transit.eq.hashArrayLike = function(a2) {
      var b2 = 0;
      if (com.cognitect.transit.util.isArray(a2)) {
        for (var c2 = 0; c2 < a2.length; c2++) {
          b2 = com.cognitect.transit.eq.hashCombine(b2, com.cognitect.transit.eq.hashCode(a2[c2]));
        }
      } else {
        a2.forEach && a2.forEach(function(d2, e2) {
          b2 = com.cognitect.transit.eq.hashCombine(b2, com.cognitect.transit.eq.hashCode(d2));
        });
      }
      return b2;
    };
    com.cognitect.transit.eq.hashCode = function(a2) {
      if (null == a2) {
        return 0;
      }
      switch (typeof a2) {
        case "number":
          return a2;
        case "boolean":
          return true === a2 ? 1 : 0;
        case "string":
          return com.cognitect.transit.eq.hashString(a2);
        case "function":
          var b2 = a2[com.cognitect.transit.eq.hashCodeProperty];
          b2 || (b2 = com.cognitect.transit.eq.hashCodeCounter, "undefined" != typeof Object.defineProperty ? Object.defineProperty(a2, com.cognitect.transit.eq.hashCodeProperty, { value: b2, enumerable: false }) : a2[com.cognitect.transit.eq.hashCodeProperty] = b2, com.cognitect.transit.eq.hashCodeCounter++);
          return b2;
        default:
          return a2 instanceof Date ? a2.valueOf() : com.cognitect.transit.util.isArray(a2) ? com.cognitect.transit.eq.hashArrayLike(a2) : a2.com$cognitect$transit$hashCode ? a2.com$cognitect$transit$hashCode() : com.cognitect.transit.eq.hashMapLike(a2);
      }
    };
    com.cognitect.transit.eq.extendToEQ = function(a2, b2) {
      a2.com$cognitect$transit$hashCode = b2.hashCode;
      a2.com$cognitect$transit$equals = b2.equals;
      return a2;
    };
    goog.debug = {};
    function module$contents$goog$debug$Error_DebugError(a2, b2) {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, module$contents$goog$debug$Error_DebugError);
      } else {
        const c2 = Error().stack;
        c2 && (this.stack = c2);
      }
      a2 && (this.message = String(a2));
      b2 && (this.cause = b2);
      this.reportErrorToServer = true;
    }
    goog.inherits(module$contents$goog$debug$Error_DebugError, Error);
    module$contents$goog$debug$Error_DebugError.prototype.name = "CustomError";
    goog.debug.Error = module$contents$goog$debug$Error_DebugError;
    goog.dom = {};
    goog.dom.NodeType = { ELEMENT: 1, ATTRIBUTE: 2, TEXT: 3, CDATA_SECTION: 4, ENTITY_REFERENCE: 5, ENTITY: 6, PROCESSING_INSTRUCTION: 7, COMMENT: 8, DOCUMENT: 9, DOCUMENT_TYPE: 10, DOCUMENT_FRAGMENT: 11, NOTATION: 12 };
    goog.asserts = {};
    goog.asserts.ENABLE_ASSERTS = goog.DEBUG;
    goog.asserts.AssertionError = function(a2, b2) {
      module$contents$goog$debug$Error_DebugError.call(this, goog.asserts.subs_(a2, b2));
      this.messagePattern = a2;
    };
    goog.inherits(goog.asserts.AssertionError, module$contents$goog$debug$Error_DebugError);
    goog.asserts.AssertionError.prototype.name = "AssertionError";
    goog.asserts.DEFAULT_ERROR_HANDLER = function(a2) {
      throw a2;
    };
    goog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER;
    goog.asserts.subs_ = function(a2, b2) {
      a2 = a2.split("%s");
      for (var c2 = "", d2 = a2.length - 1, e2 = 0; e2 < d2; e2++) {
        c2 += a2[e2] + (e2 < b2.length ? b2[e2] : "%s");
      }
      return c2 + a2[d2];
    };
    goog.asserts.doAssertFailure_ = function(a2, b2, c2, d2) {
      var e2 = "Assertion failed";
      if (c2) {
        e2 += ": " + c2;
        var f2 = d2;
      } else {
        a2 && (e2 += ": " + a2, f2 = b2);
      }
      a2 = new goog.asserts.AssertionError("" + e2, f2 || []);
      goog.asserts.errorHandler_(a2);
    };
    goog.asserts.setErrorHandler = function(a2) {
      goog.asserts.ENABLE_ASSERTS && (goog.asserts.errorHandler_ = a2);
    };
    goog.asserts.assert = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && !a2 && goog.asserts.doAssertFailure_("", null, b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertExists = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && null == a2 && goog.asserts.doAssertFailure_("Expected to exist: %s.", [a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.fail = function(a2, b2) {
      goog.asserts.ENABLE_ASSERTS && goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure" + (a2 ? ": " + a2 : ""), Array.prototype.slice.call(arguments, 1)));
    };
    goog.asserts.assertNumber = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && "number" !== typeof a2 && goog.asserts.doAssertFailure_("Expected number but got %s: %s.", [goog.typeOf(a2), a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertString = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && "string" !== typeof a2 && goog.asserts.doAssertFailure_("Expected string but got %s: %s.", [goog.typeOf(a2), a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertFunction = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && "function" !== typeof a2 && goog.asserts.doAssertFailure_("Expected function but got %s: %s.", [goog.typeOf(a2), a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertObject = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && !goog.isObject(a2) && goog.asserts.doAssertFailure_("Expected object but got %s: %s.", [goog.typeOf(a2), a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertArray = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && !Array.isArray(a2) && goog.asserts.doAssertFailure_("Expected array but got %s: %s.", [goog.typeOf(a2), a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertBoolean = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && "boolean" !== typeof a2 && goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.", [goog.typeOf(a2), a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertElement = function(a2, b2, c2) {
      !goog.asserts.ENABLE_ASSERTS || goog.isObject(a2) && a2.nodeType == goog.dom.NodeType.ELEMENT || goog.asserts.doAssertFailure_("Expected Element but got %s: %s.", [goog.typeOf(a2), a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertInstanceof = function(a2, b2, c2, d2) {
      !goog.asserts.ENABLE_ASSERTS || a2 instanceof b2 || goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.", [goog.asserts.getType_(b2), goog.asserts.getType_(a2)], c2, Array.prototype.slice.call(arguments, 3));
      return a2;
    };
    goog.asserts.assertFinite = function(a2, b2, c2) {
      !goog.asserts.ENABLE_ASSERTS || "number" == typeof a2 && isFinite(a2) || goog.asserts.doAssertFailure_("Expected %s to be a finite number but it is not.", [a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.getType_ = function(a2) {
      return a2 instanceof Function ? a2.displayName || a2.name || "unknown type name" : a2 instanceof Object ? a2.constructor.displayName || a2.constructor.name || Object.prototype.toString.call(a2) : null === a2 ? "null" : typeof a2;
    };
    goog.reflect = {};
    goog.reflect.object = function(a2, b2) {
      return b2;
    };
    goog.reflect.objectProperty = function(a2, b2) {
      return a2;
    };
    goog.reflect.sinkValue = function(a2) {
      goog.reflect.sinkValue[" "](a2);
      return a2;
    };
    goog.reflect.sinkValue[" "] = goog.nullFunction;
    goog.reflect.canAccessProperty = function(a2, b2) {
      try {
        return goog.reflect.sinkValue(a2[b2]), true;
      } catch (c2) {
      }
      return false;
    };
    goog.reflect.cache = function(a2, b2, c2, d2) {
      d2 = d2 ? d2(b2) : b2;
      return Object.prototype.hasOwnProperty.call(a2, d2) ? a2[d2] : a2[d2] = c2(b2);
    };
    goog.math = {};
    var module$contents$goog$math$Long_Long = class _module$contents$goog$math$Long_Long {
      constructor(a2, b2) {
        this.low_ = a2 | 0;
        this.high_ = b2 | 0;
      }
      toInt() {
        return this.low_;
      }
      toNumber() {
        return this.high_ * module$contents$goog$math$Long_TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
      }
      isSafeInteger() {
        var a2 = this.high_ >> 21;
        return 0 == a2 || -1 == a2 && !(0 == this.low_ && -2097152 == this.high_);
      }
      toString(a2) {
        a2 = a2 || 10;
        if (2 > a2 || 36 < a2) {
          throw Error("radix out of range: " + a2);
        }
        if (this.isSafeInteger()) {
          var b2 = this.toNumber();
          return 10 == a2 ? "" + b2 : b2.toString(a2);
        }
        b2 = 14 - (a2 >> 2);
        var c2 = Math.pow(a2, b2), d2 = _module$contents$goog$math$Long_Long.fromBits(c2, c2 / module$contents$goog$math$Long_TWO_PWR_32_DBL_);
        c2 = this.div(d2);
        d2 = Math.abs(this.subtract(c2.multiply(d2)).toNumber());
        var e2 = 10 == a2 ? "" + d2 : d2.toString(a2);
        e2.length < b2 && (e2 = "0000000000000".substr(e2.length - b2) + e2);
        d2 = c2.toNumber();
        return (10 == a2 ? d2 : d2.toString(a2)) + e2;
      }
      getHighBits() {
        return this.high_;
      }
      getLowBits() {
        return this.low_;
      }
      getLowBitsUnsigned() {
        return this.low_ >>> 0;
      }
      getNumBitsAbs() {
        if (this.isNegative()) {
          return this.equals(_module$contents$goog$math$Long_Long.getMinValue()) ? 64 : this.negate().getNumBitsAbs();
        }
        for (var a2 = 0 != this.high_ ? this.high_ : this.low_, b2 = 31; 0 < b2 && 0 == (a2 & 1 << b2); b2--) {
        }
        return 0 != this.high_ ? b2 + 33 : b2 + 1;
      }
      isZero() {
        return 0 == this.low_ && 0 == this.high_;
      }
      isNegative() {
        return 0 > this.high_;
      }
      isOdd() {
        return 1 == (this.low_ & 1);
      }
      equals(a2) {
        return this.low_ == a2.low_ && this.high_ == a2.high_;
      }
      notEquals(a2) {
        return !this.equals(a2);
      }
      lessThan(a2) {
        return 0 > this.compare(a2);
      }
      lessThanOrEqual(a2) {
        return 0 >= this.compare(a2);
      }
      greaterThan(a2) {
        return 0 < this.compare(a2);
      }
      greaterThanOrEqual(a2) {
        return 0 <= this.compare(a2);
      }
      compare(a2) {
        return this.high_ == a2.high_ ? this.low_ == a2.low_ ? 0 : this.getLowBitsUnsigned() > a2.getLowBitsUnsigned() ? 1 : -1 : this.high_ > a2.high_ ? 1 : -1;
      }
      negate() {
        var a2 = ~this.low_ + 1 | 0;
        return _module$contents$goog$math$Long_Long.fromBits(a2, ~this.high_ + !a2 | 0);
      }
      add(a2) {
        var b2 = this.high_ >>> 16, c2 = this.high_ & 65535, d2 = this.low_ >>> 16, e2 = a2.high_ >>> 16, f2 = a2.high_ & 65535, g = a2.low_ >>> 16;
        a2 = (this.low_ & 65535) + (a2.low_ & 65535);
        g = (a2 >>> 16) + (d2 + g);
        d2 = g >>> 16;
        d2 += c2 + f2;
        b2 = (d2 >>> 16) + (b2 + e2) & 65535;
        return _module$contents$goog$math$Long_Long.fromBits((g & 65535) << 16 | a2 & 65535, b2 << 16 | d2 & 65535);
      }
      subtract(a2) {
        return this.add(a2.negate());
      }
      multiply(a2) {
        if (this.isZero()) {
          return this;
        }
        if (a2.isZero()) {
          return a2;
        }
        var b2 = this.high_ >>> 16, c2 = this.high_ & 65535, d2 = this.low_ >>> 16, e2 = this.low_ & 65535, f2 = a2.high_ >>> 16, g = a2.high_ & 65535, h = a2.low_ >>> 16;
        a2 = a2.low_ & 65535;
        var k = e2 * a2;
        var l = (k >>> 16) + d2 * a2;
        var n = l >>> 16;
        l = (l & 65535) + e2 * h;
        n += l >>> 16;
        n += c2 * a2;
        var m = n >>> 16;
        n = (n & 65535) + d2 * h;
        m += n >>> 16;
        n = (n & 65535) + e2 * g;
        m = m + (n >>> 16) + (b2 * a2 + c2 * h + d2 * g + e2 * f2) & 65535;
        return _module$contents$goog$math$Long_Long.fromBits((l & 65535) << 16 | k & 65535, m << 16 | n & 65535);
      }
      div(a2) {
        if (a2.isZero()) {
          throw Error("division by zero");
        }
        if (this.isNegative()) {
          if (this.equals(_module$contents$goog$math$Long_Long.getMinValue())) {
            if (a2.equals(_module$contents$goog$math$Long_Long.getOne()) || a2.equals(_module$contents$goog$math$Long_Long.getNegOne())) {
              return _module$contents$goog$math$Long_Long.getMinValue();
            }
            if (a2.equals(_module$contents$goog$math$Long_Long.getMinValue())) {
              return _module$contents$goog$math$Long_Long.getOne();
            }
            var b2 = this.shiftRight(1).div(a2).shiftLeft(1);
            if (b2.equals(_module$contents$goog$math$Long_Long.getZero())) {
              return a2.isNegative() ? _module$contents$goog$math$Long_Long.getOne() : _module$contents$goog$math$Long_Long.getNegOne();
            }
            var c2 = this.subtract(a2.multiply(b2));
            return b2.add(c2.div(a2));
          }
          return a2.isNegative() ? this.negate().div(a2.negate()) : this.negate().div(a2).negate();
        }
        if (this.isZero()) {
          return _module$contents$goog$math$Long_Long.getZero();
        }
        if (a2.isNegative()) {
          return a2.equals(_module$contents$goog$math$Long_Long.getMinValue()) ? _module$contents$goog$math$Long_Long.getZero() : this.div(a2.negate()).negate();
        }
        var d2 = _module$contents$goog$math$Long_Long.getZero();
        for (c2 = this; c2.greaterThanOrEqual(a2); ) {
          b2 = Math.max(1, Math.floor(c2.toNumber() / a2.toNumber()));
          var e2 = Math.ceil(Math.log(b2) / Math.LN2);
          e2 = 48 >= e2 ? 1 : Math.pow(2, e2 - 48);
          for (var f2 = _module$contents$goog$math$Long_Long.fromNumber(b2), g = f2.multiply(a2); g.isNegative() || g.greaterThan(c2); ) {
            b2 -= e2, f2 = _module$contents$goog$math$Long_Long.fromNumber(b2), g = f2.multiply(a2);
          }
          f2.isZero() && (f2 = _module$contents$goog$math$Long_Long.getOne());
          d2 = d2.add(f2);
          c2 = c2.subtract(g);
        }
        return d2;
      }
      modulo(a2) {
        return this.subtract(this.div(a2).multiply(a2));
      }
      not() {
        return _module$contents$goog$math$Long_Long.fromBits(~this.low_, ~this.high_);
      }
      and(a2) {
        return _module$contents$goog$math$Long_Long.fromBits(this.low_ & a2.low_, this.high_ & a2.high_);
      }
      or(a2) {
        return _module$contents$goog$math$Long_Long.fromBits(this.low_ | a2.low_, this.high_ | a2.high_);
      }
      xor(a2) {
        return _module$contents$goog$math$Long_Long.fromBits(this.low_ ^ a2.low_, this.high_ ^ a2.high_);
      }
      shiftLeft(a2) {
        a2 &= 63;
        if (0 == a2) {
          return this;
        }
        var b2 = this.low_;
        return 32 > a2 ? _module$contents$goog$math$Long_Long.fromBits(b2 << a2, this.high_ << a2 | b2 >>> 32 - a2) : _module$contents$goog$math$Long_Long.fromBits(0, b2 << a2 - 32);
      }
      shiftRight(a2) {
        a2 &= 63;
        if (0 == a2) {
          return this;
        }
        var b2 = this.high_;
        return 32 > a2 ? _module$contents$goog$math$Long_Long.fromBits(this.low_ >>> a2 | b2 << 32 - a2, b2 >> a2) : _module$contents$goog$math$Long_Long.fromBits(b2 >> a2 - 32, 0 <= b2 ? 0 : -1);
      }
      shiftRightUnsigned(a2) {
        a2 &= 63;
        if (0 == a2) {
          return this;
        }
        var b2 = this.high_;
        return 32 > a2 ? _module$contents$goog$math$Long_Long.fromBits(this.low_ >>> a2 | b2 << 32 - a2, b2 >>> a2) : 32 == a2 ? _module$contents$goog$math$Long_Long.fromBits(b2, 0) : _module$contents$goog$math$Long_Long.fromBits(b2 >>> a2 - 32, 0);
      }
      static fromInt(a2) {
        var b2 = a2 | 0;
        goog.asserts.assert(a2 === b2, "value should be a 32-bit integer");
        return -128 <= b2 && 128 > b2 ? module$contents$goog$math$Long_getCachedIntValue_(b2) : new _module$contents$goog$math$Long_Long(b2, 0 > b2 ? -1 : 0);
      }
      static fromNumber(a2) {
        return 0 < a2 ? a2 >= module$contents$goog$math$Long_TWO_PWR_63_DBL_ ? _module$contents$goog$math$Long_Long.getMaxValue() : new _module$contents$goog$math$Long_Long(a2, a2 / module$contents$goog$math$Long_TWO_PWR_32_DBL_) : 0 > a2 ? a2 <= -module$contents$goog$math$Long_TWO_PWR_63_DBL_ ? _module$contents$goog$math$Long_Long.getMinValue() : new _module$contents$goog$math$Long_Long(-a2, -a2 / module$contents$goog$math$Long_TWO_PWR_32_DBL_).negate() : _module$contents$goog$math$Long_Long.getZero();
      }
      static fromBits(a2, b2) {
        return new _module$contents$goog$math$Long_Long(a2, b2);
      }
      static fromString(a2, b2) {
        if ("-" == a2.charAt(0)) {
          return _module$contents$goog$math$Long_Long.fromString(a2.substring(1), b2).negate();
        }
        var c2 = parseInt(a2, b2 || 10);
        if (c2 <= module$contents$goog$math$Long_MAX_SAFE_INTEGER_) {
          return new _module$contents$goog$math$Long_Long(c2 % module$contents$goog$math$Long_TWO_PWR_32_DBL_ | 0, c2 / module$contents$goog$math$Long_TWO_PWR_32_DBL_ | 0);
        }
        if (0 == a2.length) {
          throw Error("number format error: empty string");
        }
        if (0 <= a2.indexOf("-")) {
          throw Error('number format error: interior "-" character: ' + a2);
        }
        b2 = b2 || 10;
        if (2 > b2 || 36 < b2) {
          throw Error("radix out of range: " + b2);
        }
        c2 = _module$contents$goog$math$Long_Long.fromNumber(Math.pow(b2, 8));
        for (var d2 = _module$contents$goog$math$Long_Long.getZero(), e2 = 0; e2 < a2.length; e2 += 8) {
          var f2 = Math.min(8, a2.length - e2), g = parseInt(a2.substring(e2, e2 + f2), b2);
          8 > f2 ? (f2 = _module$contents$goog$math$Long_Long.fromNumber(Math.pow(b2, f2)), d2 = d2.multiply(f2).add(_module$contents$goog$math$Long_Long.fromNumber(g))) : (d2 = d2.multiply(c2), d2 = d2.add(_module$contents$goog$math$Long_Long.fromNumber(g)));
        }
        return d2;
      }
      static isStringInRange(a2, b2) {
        b2 = b2 || 10;
        if (2 > b2 || 36 < b2) {
          throw Error("radix out of range: " + b2);
        }
        b2 = "-" == a2.charAt(0) ? module$contents$goog$math$Long_MIN_VALUE_FOR_RADIX_[b2] : module$contents$goog$math$Long_MAX_VALUE_FOR_RADIX_[b2];
        return a2.length < b2.length ? true : a2.length == b2.length && a2 <= b2 ? true : false;
      }
      static getZero() {
        return module$contents$goog$math$Long_ZERO_;
      }
      static getOne() {
        return module$contents$goog$math$Long_ONE_;
      }
      static getNegOne() {
        return module$contents$goog$math$Long_NEG_ONE_;
      }
      static getMaxValue() {
        return module$contents$goog$math$Long_MAX_VALUE_;
      }
      static getMinValue() {
        return module$contents$goog$math$Long_MIN_VALUE_;
      }
      static getTwoPwr24() {
        return module$contents$goog$math$Long_TWO_PWR_24_;
      }
    };
    goog.math.Long = module$contents$goog$math$Long_Long;
    var module$contents$goog$math$Long_IntCache_ = {};
    function module$contents$goog$math$Long_getCachedIntValue_(a2) {
      return goog.reflect.cache(module$contents$goog$math$Long_IntCache_, a2, function(b2) {
        return new module$contents$goog$math$Long_Long(b2, 0 > b2 ? -1 : 0);
      });
    }
    var module$contents$goog$math$Long_MAX_VALUE_FOR_RADIX_ = "  111111111111111111111111111111111111111111111111111111111111111 2021110011022210012102010021220101220221 13333333333333333333333333333333 1104332401304422434310311212 1540241003031030222122211 22341010611245052052300 777777777777777777777 67404283172107811827 9223372036854775807 1728002635214590697 41a792678515120367 10b269549075433c37 4340724c6c71dc7a7 160e2ad3246366807 7fffffffffffffff 33d3d8307b214008 16agh595df825fa7 ba643dci0ffeehh 5cbfjia3fh26ja7 2heiciiie82dh97 1adaibb21dckfa7 i6k448cf4192c2 acd772jnc9l0l7 64ie1focnn5g77 3igoecjbmca687 27c48l5b37oaop 1bk39f3ah3dmq7 q1se8f0m04isb hajppbc1fc207 bm03i95hia437 7vvvvvvvvvvvv 5hg4ck9jd4u37 3tdtk1v8j6tpp 2pijmikexrxp7 1y2p0ij32e8e7".split(" ");
    var module$contents$goog$math$Long_MIN_VALUE_FOR_RADIX_ = "  -1000000000000000000000000000000000000000000000000000000000000000 -2021110011022210012102010021220101220222 -20000000000000000000000000000000 -1104332401304422434310311213 -1540241003031030222122212 -22341010611245052052301 -1000000000000000000000 -67404283172107811828 -9223372036854775808 -1728002635214590698 -41a792678515120368 -10b269549075433c38 -4340724c6c71dc7a8 -160e2ad3246366808 -8000000000000000 -33d3d8307b214009 -16agh595df825fa8 -ba643dci0ffeehi -5cbfjia3fh26ja8 -2heiciiie82dh98 -1adaibb21dckfa8 -i6k448cf4192c3 -acd772jnc9l0l8 -64ie1focnn5g78 -3igoecjbmca688 -27c48l5b37oaoq -1bk39f3ah3dmq8 -q1se8f0m04isc -hajppbc1fc208 -bm03i95hia438 -8000000000000 -5hg4ck9jd4u38 -3tdtk1v8j6tpq -2pijmikexrxp8 -1y2p0ij32e8e8".split(" ");
    var module$contents$goog$math$Long_MAX_SAFE_INTEGER_ = 9007199254740991;
    var module$contents$goog$math$Long_TWO_PWR_32_DBL_ = 4294967296;
    var module$contents$goog$math$Long_TWO_PWR_63_DBL_ = 9223372036854776e3;
    var module$contents$goog$math$Long_ZERO_ = module$contents$goog$math$Long_Long.fromBits(0, 0);
    var module$contents$goog$math$Long_ONE_ = module$contents$goog$math$Long_Long.fromBits(1, 0);
    var module$contents$goog$math$Long_NEG_ONE_ = module$contents$goog$math$Long_Long.fromBits(-1, -1);
    var module$contents$goog$math$Long_MAX_VALUE_ = module$contents$goog$math$Long_Long.fromBits(4294967295, 2147483647);
    var module$contents$goog$math$Long_MIN_VALUE_ = module$contents$goog$math$Long_Long.fromBits(0, 2147483648);
    var module$contents$goog$math$Long_TWO_PWR_24_ = module$contents$goog$math$Long_Long.fromBits(16777216, 0);
    com.cognitect.transit.types = {};
    com.cognitect.transit.types.ITERATOR = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator";
    com.cognitect.transit.types.TaggedValue = function(a2, b2) {
      this.tag = a2;
      this.rep = b2;
      this.hashCode = -1;
    };
    com.cognitect.transit.types.TaggedValue.prototype.toString = function() {
      return "[TaggedValue: " + this.tag + ", " + this.rep + "]";
    };
    com.cognitect.transit.types.TaggedValue.prototype.equiv = function(a2) {
      return com.cognitect.transit.eq.equals(this, a2);
    };
    com.cognitect.transit.types.TaggedValue.prototype.equiv = com.cognitect.transit.types.TaggedValue.prototype.equiv;
    com.cognitect.transit.types.TaggedValue.prototype.com$cognitect$transit$equals = function(a2) {
      return a2 instanceof com.cognitect.transit.types.TaggedValue ? this.tag === a2.tag && com.cognitect.transit.eq.equals(this.rep, a2.rep) : false;
    };
    com.cognitect.transit.types.TaggedValue.prototype.com$cognitect$transit$hashCode = function() {
      -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCombine(com.cognitect.transit.eq.hashCode(this.tag), com.cognitect.transit.eq.hashCode(this.rep)));
      return this.hashCode;
    };
    com.cognitect.transit.types.taggedValue = function(a2, b2) {
      return new com.cognitect.transit.types.TaggedValue(a2, b2);
    };
    com.cognitect.transit.types.isTaggedValue = function(a2) {
      return a2 instanceof com.cognitect.transit.types.TaggedValue;
    };
    com.cognitect.transit.types.nullValue = function() {
      return null;
    };
    com.cognitect.transit.types.boolValue = function(a2) {
      return "t" === a2;
    };
    com.cognitect.transit.types.MAX_INT = module$contents$goog$math$Long_Long.fromString("9007199254740991");
    com.cognitect.transit.types.MIN_INT = module$contents$goog$math$Long_Long.fromString("-9007199254740991");
    com.cognitect.transit.types.intValue = function(a2) {
      if ("number" === typeof a2 || a2 instanceof module$contents$goog$math$Long_Long) {
        return a2;
      }
      a2 = module$contents$goog$math$Long_Long.fromString(a2, 10);
      return a2.greaterThan(com.cognitect.transit.types.MAX_INT) || a2.lessThan(com.cognitect.transit.types.MIN_INT) ? a2 : a2.toNumber();
    };
    module$contents$goog$math$Long_Long.prototype.equiv = function(a2) {
      return com.cognitect.transit.eq.equals(this, a2);
    };
    module$contents$goog$math$Long_Long.prototype.equiv = module$contents$goog$math$Long_Long.prototype.equiv;
    module$contents$goog$math$Long_Long.prototype.com$cognitect$transit$equals = function(a2) {
      return a2 instanceof module$contents$goog$math$Long_Long && this.equals(a2);
    };
    module$contents$goog$math$Long_Long.prototype.com$cognitect$transit$hashCode = function() {
      return this.toInt();
    };
    com.cognitect.transit.types.isInteger = function(a2) {
      return a2 instanceof module$contents$goog$math$Long_Long ? true : "number" === typeof a2 && !isNaN(a2) && Infinity !== a2 && parseFloat(a2) === parseInt(a2, 10);
    };
    com.cognitect.transit.types.floatValue = function(a2) {
      return parseFloat(a2);
    };
    com.cognitect.transit.types.bigInteger = function(a2) {
      return com.cognitect.transit.types.taggedValue("n", a2);
    };
    com.cognitect.transit.types.isBigInteger = function(a2) {
      return a2 instanceof com.cognitect.transit.types.TaggedValue && "n" === a2.tag;
    };
    com.cognitect.transit.types.bigDecimalValue = function(a2) {
      return com.cognitect.transit.types.taggedValue("f", a2);
    };
    com.cognitect.transit.types.isBigDecimal = function(a2) {
      return a2 instanceof com.cognitect.transit.types.TaggedValue && "f" === a2.tag;
    };
    com.cognitect.transit.types.charValue = function(a2) {
      return a2;
    };
    com.cognitect.transit.types.Keyword = function(a2) {
      this._name = a2;
      this.hashCode = -1;
    };
    com.cognitect.transit.types.Keyword.prototype.toString = function() {
      return ":" + this._name;
    };
    com.cognitect.transit.types.Keyword.prototype.namespace = function() {
      var a2 = this._name.indexOf("/");
      return -1 != a2 ? this._name.substring(0, a2) : null;
    };
    com.cognitect.transit.types.Keyword.prototype.name = function() {
      var a2 = this._name.indexOf("/");
      return -1 != a2 ? this._name.substring(a2 + 1, this._name.length) : this._name;
    };
    com.cognitect.transit.types.Keyword.prototype.equiv = function(a2) {
      return com.cognitect.transit.eq.equals(this, a2);
    };
    com.cognitect.transit.types.Keyword.prototype.equiv = com.cognitect.transit.types.Keyword.prototype.equiv;
    com.cognitect.transit.types.Keyword.prototype.com$cognitect$transit$equals = function(a2) {
      return a2 instanceof com.cognitect.transit.types.Keyword && this._name == a2._name;
    };
    com.cognitect.transit.types.Keyword.prototype.com$cognitect$transit$hashCode = function() {
      -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this._name));
      return this.hashCode;
    };
    com.cognitect.transit.types.keyword = function(a2) {
      return new com.cognitect.transit.types.Keyword(a2);
    };
    com.cognitect.transit.types.isKeyword = function(a2) {
      return a2 instanceof com.cognitect.transit.types.Keyword;
    };
    com.cognitect.transit.types.Symbol = function(a2) {
      this._name = a2;
      this.hashCode = -1;
    };
    com.cognitect.transit.types.Symbol.prototype.namespace = function() {
      var a2 = this._name.indexOf("/");
      return -1 != a2 ? this._name.substring(0, a2) : null;
    };
    com.cognitect.transit.types.Symbol.prototype.name = function() {
      var a2 = this._name.indexOf("/");
      return -1 != a2 ? this._name.substring(a2 + 1, this._name.length) : this._name;
    };
    com.cognitect.transit.types.Symbol.prototype.toString = function() {
      return this._name;
    };
    com.cognitect.transit.types.Symbol.prototype.equiv = function(a2) {
      return com.cognitect.transit.eq.equals(this, a2);
    };
    com.cognitect.transit.types.Symbol.prototype.equiv = com.cognitect.transit.types.Symbol.prototype.equiv;
    com.cognitect.transit.types.Symbol.prototype.com$cognitect$transit$equals = function(a2) {
      return a2 instanceof com.cognitect.transit.types.Symbol && this._name == a2._name;
    };
    com.cognitect.transit.types.Symbol.prototype.com$cognitect$transit$hashCode = function() {
      -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this._name));
      return this.hashCode;
    };
    com.cognitect.transit.types.symbol = function(a2) {
      return new com.cognitect.transit.types.Symbol(a2);
    };
    com.cognitect.transit.types.isSymbol = function(a2) {
      return a2 instanceof com.cognitect.transit.types.Symbol;
    };
    com.cognitect.transit.types.hexFor = function(a2, b2, c2) {
      var d2 = "";
      c2 = c2 || b2 + 1;
      for (var e2 = 8 * (7 - b2), f2 = module$contents$goog$math$Long_Long.fromInt(255).shiftLeft(e2); b2 < c2; b2++, e2 -= 8, f2 = f2.shiftRightUnsigned(8)) {
        var g = a2.and(f2).shiftRightUnsigned(e2).toString(16);
        1 == g.length && (g = "0" + g);
        d2 += g;
      }
      return d2;
    };
    com.cognitect.transit.types.UUID = function(a2, b2) {
      this.high = a2;
      this.low = b2;
      this.hashCode = -1;
    };
    com.cognitect.transit.types.UUID.prototype.getLeastSignificantBits = function() {
      return this.low;
    };
    com.cognitect.transit.types.UUID.prototype.getMostSignificantBits = function() {
      return this.high;
    };
    com.cognitect.transit.types.UUID.prototype.toString = function() {
      var a2 = this.high, b2 = this.low;
      var c2 = com.cognitect.transit.types.hexFor(a2, 0, 4) + "-";
      c2 += com.cognitect.transit.types.hexFor(a2, 4, 6) + "-";
      c2 += com.cognitect.transit.types.hexFor(a2, 6, 8) + "-";
      c2 += com.cognitect.transit.types.hexFor(b2, 0, 2) + "-";
      return c2 += com.cognitect.transit.types.hexFor(b2, 2, 8);
    };
    com.cognitect.transit.types.UUID.prototype.equiv = function(a2) {
      return com.cognitect.transit.eq.equals(this, a2);
    };
    com.cognitect.transit.types.UUID.prototype.equiv = com.cognitect.transit.types.UUID.prototype.equiv;
    com.cognitect.transit.types.UUID.prototype.com$cognitect$transit$equals = function(a2) {
      return a2 instanceof com.cognitect.transit.types.UUID && this.high.equals(a2.high) && this.low.equals(a2.low);
    };
    com.cognitect.transit.types.UUID.prototype.com$cognitect$transit$hashCode = function() {
      -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this.toString()));
      return this.hashCode;
    };
    com.cognitect.transit.types.UUIDfromString = function(a2) {
      a2 = a2.replace(/-/g, "");
      var b2, c2;
      var d2 = b2 = 0;
      for (c2 = 24; 8 > d2; d2 += 2, c2 -= 8) {
        b2 |= parseInt(a2.substring(d2, d2 + 2), 16) << c2;
      }
      var e2 = 0;
      d2 = 8;
      for (c2 = 24; 16 > d2; d2 += 2, c2 -= 8) {
        e2 |= parseInt(a2.substring(d2, d2 + 2), 16) << c2;
      }
      var f2 = module$contents$goog$math$Long_Long.fromBits(e2, b2);
      b2 = 0;
      d2 = 16;
      for (c2 = 24; 24 > d2; d2 += 2, c2 -= 8) {
        b2 |= parseInt(a2.substring(d2, d2 + 2), 16) << c2;
      }
      e2 = 0;
      for (c2 = d2 = 24; 32 > d2; d2 += 2, c2 -= 8) {
        e2 |= parseInt(a2.substring(d2, d2 + 2), 16) << c2;
      }
      a2 = module$contents$goog$math$Long_Long.fromBits(e2, b2);
      return new com.cognitect.transit.types.UUID(f2, a2);
    };
    com.cognitect.transit.types.uuid = function(a2) {
      return com.cognitect.transit.types.UUIDfromString(a2);
    };
    com.cognitect.transit.types.isUUID = function(a2) {
      return a2 instanceof com.cognitect.transit.types.UUID;
    };
    com.cognitect.transit.types.date = function(a2) {
      a2 = "number" === typeof a2 ? a2 : parseInt(a2, 10);
      return new Date(a2);
    };
    com.cognitect.transit.types.verboseDate = function(a2) {
      return new Date(a2);
    };
    Date.prototype.com$cognitect$transit$equals = function(a2) {
      return a2 instanceof Date ? this.valueOf() === a2.valueOf() : false;
    };
    Date.prototype.com$cognitect$transit$hashCode = function() {
      return this.valueOf();
    };
    com.cognitect.transit.types.binary = function(a2, b2) {
      return b2 && false === b2.preferBuffers || "undefined" == typeof goog.global.Buffer ? "undefined" != typeof Uint8Array ? com.cognitect.transit.util.Base64ToUint8(a2) : com.cognitect.transit.types.taggedValue("b", a2) : new goog.global.Buffer(a2, "base64");
    };
    com.cognitect.transit.types.isBinary = function(a2) {
      return "undefined" != typeof goog.global.Buffer && a2 instanceof goog.global.Buffer ? true : "undefined" != typeof Uint8Array && a2 instanceof Uint8Array ? true : a2 instanceof com.cognitect.transit.types.TaggedValue && "b" === a2.tag;
    };
    com.cognitect.transit.types.uri = function(a2) {
      return com.cognitect.transit.types.taggedValue("r", a2);
    };
    com.cognitect.transit.types.isURI = function(a2) {
      return a2 instanceof com.cognitect.transit.types.TaggedValue && "r" === a2.tag;
    };
    com.cognitect.transit.types.KEYS = 0;
    com.cognitect.transit.types.VALUES = 1;
    com.cognitect.transit.types.ENTRIES = 2;
    com.cognitect.transit.types.TransitArrayMapIterator = function(a2, b2) {
      this.entries = a2;
      this.type = b2 || com.cognitect.transit.types.KEYS;
      this.idx = 0;
    };
    com.cognitect.transit.types.TransitArrayMapIterator.prototype.next = function() {
      if (this.idx < this.entries.length) {
        var a2 = { value: this.type === com.cognitect.transit.types.KEYS ? this.entries[this.idx] : this.type === com.cognitect.transit.types.VALUES ? this.entries[this.idx + 1] : [this.entries[this.idx], this.entries[this.idx + 1]], done: false };
        this.idx += 2;
        return a2;
      }
      return { value: null, done: true };
    };
    com.cognitect.transit.types.TransitArrayMapIterator.prototype.next = com.cognitect.transit.types.TransitArrayMapIterator.prototype.next;
    com.cognitect.transit.types.TransitArrayMapIterator.prototype[com.cognitect.transit.types.ITERATOR] = function() {
      return this;
    };
    com.cognitect.transit.types.TransitMapIterator = function(a2, b2) {
      this.map = a2;
      this.type = b2 || com.cognitect.transit.types.KEYS;
      this.keys = this.map.getKeys();
      this.idx = 0;
      this.bucket = null;
      this.bucketIdx = 0;
    };
    com.cognitect.transit.types.TransitMapIterator.prototype.next = function() {
      if (this.idx < this.map.size) {
        null != this.bucket && this.bucketIdx < this.bucket.length || (this.bucket = this.map.map[this.keys[this.idx]], this.bucketIdx = 0);
        var a2 = { value: this.type === com.cognitect.transit.types.KEYS ? this.bucket[this.bucketIdx] : this.type === com.cognitect.transit.types.VALUES ? this.bucket[this.bucketIdx + 1] : [this.bucket[this.bucketIdx], this.bucket[this.bucketIdx + 1]], done: false };
        this.idx++;
        this.bucketIdx += 2;
        return a2;
      }
      return { value: null, done: true };
    };
    com.cognitect.transit.types.TransitMapIterator.prototype.next = com.cognitect.transit.types.TransitMapIterator.prototype.next;
    com.cognitect.transit.types.TransitMapIterator.prototype[com.cognitect.transit.types.ITERATOR] = function() {
      return this;
    };
    com.cognitect.transit.types.mapEquals = function(a2, b2) {
      if (a2 instanceof com.cognitect.transit.types.TransitMap && com.cognitect.transit.types.isMap(b2)) {
        if (a2.size !== b2.size) {
          return false;
        }
        for (var c2 in a2.map) {
          for (var d2 = a2.map[c2], e2 = 0; e2 < d2.length; e2 += 2) {
            if (!com.cognitect.transit.eq.equals(d2[e2 + 1], b2.get(d2[e2]))) {
              return false;
            }
          }
        }
        return true;
      }
      if (a2 instanceof com.cognitect.transit.types.TransitArrayMap && com.cognitect.transit.types.isMap(b2)) {
        if (a2.size !== b2.size) {
          return false;
        }
        a2 = a2._entries;
        for (e2 = 0; e2 < a2.length; e2 += 2) {
          if (!com.cognitect.transit.eq.equals(a2[e2 + 1], b2.get(a2[e2]))) {
            return false;
          }
        }
        return true;
      }
      if (null != b2 && "object" === typeof b2 && (e2 = com.cognitect.transit.util.objectKeys(b2), c2 = e2.length, a2.size === c2)) {
        for (d2 = 0; d2 < c2; d2++) {
          var f2 = e2[d2];
          if (!a2.has(f2) || !com.cognitect.transit.eq.equals(b2[f2], a2.get(f2))) {
            return false;
          }
        }
        return true;
      }
      return false;
    };
    com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD = 8;
    com.cognitect.transit.types.ARRAY_MAP_THRESHOLD = 32;
    com.cognitect.transit.types.ARRAY_MAP_ACCESS_THRESHOLD = 32;
    com.cognitect.transit.types.print = function(a2) {
      return null == a2 ? "null" : "array" === goog.typeOf(a2) ? "[" + a2.toString() + "]" : "string" === goog.typeOf(a2) ? '"' + a2 + '"' : a2.toString();
    };
    com.cognitect.transit.types.printMap = function(a2) {
      var b2 = 0, c2 = "TransitMap {";
      a2.forEach(function(d2, e2) {
        c2 += com.cognitect.transit.types.print(e2) + " => " + com.cognitect.transit.types.print(d2);
        b2 < a2.size - 1 && (c2 += ", ");
        b2++;
      });
      return c2 + "}";
    };
    com.cognitect.transit.types.printSet = function(a2) {
      var b2 = 0, c2 = "TransitSet {";
      a2.forEach(function(d2) {
        c2 += com.cognitect.transit.types.print(d2);
        b2 < a2.size - 1 && (c2 += ", ");
        b2++;
      });
      return c2 + "}";
    };
    com.cognitect.transit.types.TransitArrayMap = function(a2) {
      this._entries = a2;
      this.backingMap = null;
      this.hashCode = -1;
      this.size = a2.length / 2;
      this.accesses = 0;
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.toString = function() {
      return com.cognitect.transit.types.printMap(this);
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.inspect = function() {
      return this.toString();
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.convert = function() {
      if (this.backingMap) {
        throw Error("Invalid operation, already converted");
      }
      if (this.size < com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD) {
        return false;
      }
      this.accesses++;
      return this.accesses > com.cognitect.transit.types.ARRAY_MAP_ACCESS_THRESHOLD ? (this.backingMap = com.cognitect.transit.types.map(this._entries, false, true), this._entries = [], true) : false;
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.clear = function() {
      this.hashCode = -1;
      this.backingMap ? this.backingMap.clear() : this._entries = [];
      this.size = 0;
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.clear = com.cognitect.transit.types.TransitArrayMap.prototype.clear;
    com.cognitect.transit.types.TransitArrayMap.prototype.keys = function() {
      return this.backingMap ? this.backingMap.keys() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.KEYS);
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.keys = com.cognitect.transit.types.TransitArrayMap.prototype.keys;
    com.cognitect.transit.types.TransitArrayMap.prototype.keySet = function() {
      if (this.backingMap) {
        return this.backingMap.keySet();
      }
      for (var a2 = [], b2 = 0, c2 = 0; c2 < this._entries.length; b2++, c2 += 2) {
        a2[b2] = this._entries[c2];
      }
      return a2;
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.keySet = com.cognitect.transit.types.TransitArrayMap.prototype.keySet;
    com.cognitect.transit.types.TransitArrayMap.prototype.entries = function() {
      return this.backingMap ? this.backingMap.entries() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.ENTRIES);
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.entries = com.cognitect.transit.types.TransitArrayMap.prototype.entries;
    com.cognitect.transit.types.TransitArrayMap.prototype.values = function() {
      return this.backingMap ? this.backingMap.values() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.VALUES);
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.values = com.cognitect.transit.types.TransitArrayMap.prototype.values;
    com.cognitect.transit.types.TransitArrayMap.prototype.forEach = function(a2) {
      if (this.backingMap) {
        this.backingMap.forEach(a2);
      } else {
        for (var b2 = 0; b2 < this._entries.length; b2 += 2) {
          a2(this._entries[b2 + 1], this._entries[b2]);
        }
      }
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.forEach = com.cognitect.transit.types.TransitArrayMap.prototype.forEach;
    com.cognitect.transit.types.TransitArrayMap.prototype.get = function(a2, b2) {
      if (this.backingMap) {
        return this.backingMap.get(a2);
      }
      if (this.convert()) {
        return this.get(a2);
      }
      for (var c2 = 0; c2 < this._entries.length; c2 += 2) {
        if (com.cognitect.transit.eq.equals(this._entries[c2], a2)) {
          return this._entries[c2 + 1];
        }
      }
      return b2;
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.get = com.cognitect.transit.types.TransitArrayMap.prototype.get;
    com.cognitect.transit.types.TransitArrayMap.prototype.has = function(a2) {
      if (this.backingMap) {
        return this.backingMap.has(a2);
      }
      if (this.convert()) {
        return this.has(a2);
      }
      for (var b2 = 0; b2 < this._entries.length; b2 += 2) {
        if (com.cognitect.transit.eq.equals(this._entries[b2], a2)) {
          return true;
        }
      }
      return false;
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.has = com.cognitect.transit.types.TransitArrayMap.prototype.has;
    com.cognitect.transit.types.TransitArrayMap.prototype.set = function(a2, b2) {
      this.hashCode = -1;
      if (this.backingMap) {
        this.backingMap.set(a2, b2), this.size = this.backingMap.size;
      } else {
        for (var c2 = 0; c2 < this._entries.length; c2 += 2) {
          if (com.cognitect.transit.eq.equals(this._entries[c2], a2)) {
            this._entries[c2 + 1] = b2;
            return;
          }
        }
        this._entries.push(a2);
        this._entries.push(b2);
        this.size++;
        this.size > com.cognitect.transit.types.ARRAY_MAP_THRESHOLD && (this.backingMap = com.cognitect.transit.types.map(this._entries, false, true), this._entries = null);
      }
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.set = com.cognitect.transit.types.TransitArrayMap.prototype.set;
    com.cognitect.transit.types.TransitArrayMap.prototype["delete"] = function(a2) {
      this.hashCode = -1;
      if (this.backingMap) {
        return a2 = this.backingMap.delete(a2), this.size = this.backingMap.size, a2;
      }
      for (var b2 = 0; b2 < this._entries.length; b2 += 2) {
        if (com.cognitect.transit.eq.equals(this._entries[b2], a2)) {
          return a2 = this._entries[b2 + 1], this._entries.splice(b2, 2), this.size--, a2;
        }
      }
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.clone = function() {
      var a2 = com.cognitect.transit.types.map();
      this.forEach(function(b2, c2) {
        a2.set(c2, b2);
      });
      return a2;
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.clone = com.cognitect.transit.types.TransitArrayMap.prototype.clone;
    com.cognitect.transit.types.TransitArrayMap.prototype[com.cognitect.transit.types.ITERATOR] = function() {
      return this.entries();
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.com$cognitect$transit$hashCode = function() {
      if (this.backingMap) {
        return this.backingMap.com$cognitect$transit$hashCode();
      }
      -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashMapLike(this));
      return this.hashCode;
    };
    com.cognitect.transit.types.TransitArrayMap.prototype.com$cognitect$transit$equals = function(a2) {
      return this.backingMap ? com.cognitect.transit.types.mapEquals(this.backingMap, a2) : com.cognitect.transit.types.mapEquals(this, a2);
    };
    com.cognitect.transit.types.TransitMap = function(a2, b2, c2) {
      this.map = b2 || {};
      this._keys = a2 || [];
      this.size = c2 || 0;
      this.hashCode = -1;
    };
    com.cognitect.transit.types.TransitMap.prototype.toString = function() {
      return com.cognitect.transit.types.printMap(this);
    };
    com.cognitect.transit.types.TransitMap.prototype.inspect = function() {
      return this.toString();
    };
    com.cognitect.transit.types.TransitMap.prototype.clear = function() {
      this.hashCode = -1;
      this.map = {};
      this._keys = [];
      this.size = 0;
    };
    com.cognitect.transit.types.TransitMap.prototype.clear = com.cognitect.transit.types.TransitMap.prototype.clear;
    com.cognitect.transit.types.TransitMap.prototype.getKeys = function() {
      return null != this._keys ? this._keys : com.cognitect.transit.util.objectKeys(this.map);
    };
    com.cognitect.transit.types.TransitMap.prototype["delete"] = function(a2) {
      this.hashCode = -1;
      this._keys = null;
      for (var b2 = com.cognitect.transit.eq.hashCode(a2), c2 = this.map[b2], d2 = 0; d2 < c2.length; d2 += 2) {
        if (com.cognitect.transit.eq.equals(a2, c2[d2])) {
          return a2 = c2[d2 + 1], c2.splice(d2, 2), 0 === c2.length && delete this.map[b2], this.size--, a2;
        }
      }
    };
    com.cognitect.transit.types.TransitMap.prototype.entries = function() {
      return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.ENTRIES);
    };
    com.cognitect.transit.types.TransitMap.prototype.entries = com.cognitect.transit.types.TransitMap.prototype.entries;
    com.cognitect.transit.types.TransitMap.prototype.forEach = function(a2) {
      for (var b2 = this.getKeys(), c2 = 0; c2 < b2.length; c2++) {
        for (var d2 = this.map[b2[c2]], e2 = 0; e2 < d2.length; e2 += 2) {
          a2(d2[e2 + 1], d2[e2], this);
        }
      }
    };
    com.cognitect.transit.types.TransitMap.prototype.forEach = com.cognitect.transit.types.TransitMap.prototype.forEach;
    com.cognitect.transit.types.TransitMap.prototype.get = function(a2, b2) {
      var c2 = com.cognitect.transit.eq.hashCode(a2);
      c2 = this.map[c2];
      if (null != c2) {
        for (b2 = 0; b2 < c2.length; b2 += 2) {
          if (com.cognitect.transit.eq.equals(a2, c2[b2])) {
            return c2[b2 + 1];
          }
        }
      } else {
        return b2;
      }
    };
    com.cognitect.transit.types.TransitMap.prototype.get = com.cognitect.transit.types.TransitMap.prototype.get;
    com.cognitect.transit.types.TransitMap.prototype.has = function(a2) {
      var b2 = com.cognitect.transit.eq.hashCode(a2);
      b2 = this.map[b2];
      if (null != b2) {
        for (var c2 = 0; c2 < b2.length; c2 += 2) {
          if (com.cognitect.transit.eq.equals(a2, b2[c2])) {
            return true;
          }
        }
      }
      return false;
    };
    com.cognitect.transit.types.TransitMap.prototype.has = com.cognitect.transit.types.TransitMap.prototype.has;
    com.cognitect.transit.types.TransitMap.prototype.keys = function() {
      return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.KEYS);
    };
    com.cognitect.transit.types.TransitMap.prototype.keys = com.cognitect.transit.types.TransitMap.prototype.keys;
    com.cognitect.transit.types.TransitMap.prototype.keySet = function() {
      for (var a2 = this.getKeys(), b2 = [], c2 = 0; c2 < a2.length; c2++) {
        for (var d2 = this.map[a2[c2]], e2 = 0; e2 < d2.length; e2 += 2) {
          b2.push(d2[e2]);
        }
      }
      return b2;
    };
    com.cognitect.transit.types.TransitMap.prototype.keySet = com.cognitect.transit.types.TransitMap.prototype.keySet;
    com.cognitect.transit.types.TransitMap.prototype.set = function(a2, b2) {
      this.hashCode = -1;
      var c2 = com.cognitect.transit.eq.hashCode(a2), d2 = this.map[c2];
      if (null == d2) {
        this._keys && this._keys.push(c2), this.map[c2] = [a2, b2], this.size++;
      } else {
        c2 = true;
        for (var e2 = 0; e2 < d2.length; e2 += 2) {
          if (com.cognitect.transit.eq.equals(b2, d2[e2])) {
            c2 = false;
            d2[e2] = b2;
            break;
          }
        }
        c2 && (d2.push(a2), d2.push(b2), this.size++);
      }
    };
    com.cognitect.transit.types.TransitMap.prototype.set = com.cognitect.transit.types.TransitMap.prototype.set;
    com.cognitect.transit.types.TransitMap.prototype.values = function() {
      return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.VALUES);
    };
    com.cognitect.transit.types.TransitMap.prototype.values = com.cognitect.transit.types.TransitMap.prototype.values;
    com.cognitect.transit.types.TransitMap.prototype.clone = function() {
      var a2 = com.cognitect.transit.types.map();
      this.forEach(function(b2, c2) {
        a2.set(c2, b2);
      });
      return a2;
    };
    com.cognitect.transit.types.TransitMap.prototype.clone = com.cognitect.transit.types.TransitMap.prototype.clone;
    com.cognitect.transit.types.TransitMap.prototype[com.cognitect.transit.types.ITERATOR] = function() {
      return this.entries();
    };
    com.cognitect.transit.types.TransitMap.prototype.com$cognitect$transit$hashCode = function() {
      -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashMapLike(this));
      return this.hashCode;
    };
    com.cognitect.transit.types.TransitMap.prototype.com$cognitect$transit$equals = function(a2) {
      return com.cognitect.transit.types.mapEquals(this, a2);
    };
    com.cognitect.transit.types.map = function(a2, b2, c2) {
      a2 = a2 || [];
      b2 = false === b2 ? b2 : true;
      if ((true !== c2 || !c2) && a2.length <= 2 * com.cognitect.transit.types.ARRAY_MAP_THRESHOLD) {
        if (b2) {
          var d2 = a2;
          a2 = [];
          for (b2 = 0; b2 < d2.length; b2 += 2) {
            var e2 = false;
            for (c2 = 0; c2 < a2.length; c2 += 2) {
              if (com.cognitect.transit.eq.equals(a2[c2], d2[b2])) {
                a2[c2 + 1] = d2[b2 + 1];
                e2 = true;
                break;
              }
            }
            e2 || (a2.push(d2[b2]), a2.push(d2[b2 + 1]));
          }
        }
        return new com.cognitect.transit.types.TransitArrayMap(a2);
      }
      d2 = {};
      e2 = [];
      var f2 = 0;
      for (b2 = 0; b2 < a2.length; b2 += 2) {
        c2 = com.cognitect.transit.eq.hashCode(a2[b2]);
        var g = d2[c2];
        if (null == g) {
          e2.push(c2), d2[c2] = [a2[b2], a2[b2 + 1]], f2++;
        } else {
          var h = true;
          for (c2 = 0; c2 < g.length; c2 += 2) {
            if (com.cognitect.transit.eq.equals(g[c2], a2[b2])) {
              g[c2 + 1] = a2[b2 + 1];
              h = false;
              break;
            }
          }
          h && (g.push(a2[b2]), g.push(a2[b2 + 1]), f2++);
        }
      }
      return new com.cognitect.transit.types.TransitMap(e2, d2, f2);
    };
    com.cognitect.transit.types.isArrayMap = function(a2) {
      return a2 instanceof com.cognitect.transit.types.TransitArrayMap;
    };
    com.cognitect.transit.types.isMap = function(a2) {
      return a2 instanceof com.cognitect.transit.types.TransitArrayMap || a2 instanceof com.cognitect.transit.types.TransitMap;
    };
    com.cognitect.transit.types.TransitSet = function(a2) {
      this.map = a2;
      this.size = a2.size;
    };
    com.cognitect.transit.types.TransitSet.prototype.toString = function() {
      return com.cognitect.transit.types.printSet(this);
    };
    com.cognitect.transit.types.TransitSet.prototype.inspect = function() {
      return this.toString();
    };
    com.cognitect.transit.types.TransitSet.prototype.add = function(a2) {
      this.map.set(a2, a2);
      this.size = this.map.size;
    };
    com.cognitect.transit.types.TransitSet.prototype.add = com.cognitect.transit.types.TransitSet.prototype.add;
    com.cognitect.transit.types.TransitSet.prototype.clear = function() {
      this.map = new com.cognitect.transit.types.TransitMap();
      this.size = 0;
    };
    com.cognitect.transit.types.TransitSet.prototype.clear = com.cognitect.transit.types.TransitSet.prototype.clear;
    com.cognitect.transit.types.TransitSet.prototype["delete"] = function(a2) {
      a2 = this.map.delete(a2);
      this.size = this.map.size;
      return a2;
    };
    com.cognitect.transit.types.TransitSet.prototype.entries = function() {
      return this.map.entries();
    };
    com.cognitect.transit.types.TransitSet.prototype.entries = com.cognitect.transit.types.TransitSet.prototype.entries;
    com.cognitect.transit.types.TransitSet.prototype.forEach = function(a2, b2) {
      var c2 = this;
      this.map.forEach(function(d2, e2, f2) {
        a2(e2, c2);
      });
    };
    com.cognitect.transit.types.TransitSet.prototype.forEach = com.cognitect.transit.types.TransitSet.prototype.forEach;
    com.cognitect.transit.types.TransitSet.prototype.has = function(a2) {
      return this.map.has(a2);
    };
    com.cognitect.transit.types.TransitSet.prototype.has = com.cognitect.transit.types.TransitSet.prototype.has;
    com.cognitect.transit.types.TransitSet.prototype.keys = function() {
      return this.map.keys();
    };
    com.cognitect.transit.types.TransitSet.prototype.keys = com.cognitect.transit.types.TransitSet.prototype.keys;
    com.cognitect.transit.types.TransitSet.prototype.keySet = function() {
      return this.map.keySet();
    };
    com.cognitect.transit.types.TransitSet.prototype.keySet = com.cognitect.transit.types.TransitSet.prototype.keySet;
    com.cognitect.transit.types.TransitSet.prototype.values = function() {
      return this.map.values();
    };
    com.cognitect.transit.types.TransitSet.prototype.values = com.cognitect.transit.types.TransitSet.prototype.values;
    com.cognitect.transit.types.TransitSet.prototype.clone = function() {
      var a2 = com.cognitect.transit.types.set();
      this.forEach(function(b2) {
        a2.add(b2);
      });
      return a2;
    };
    com.cognitect.transit.types.TransitSet.prototype.clone = com.cognitect.transit.types.TransitSet.prototype.clone;
    com.cognitect.transit.types.TransitSet.prototype[com.cognitect.transit.types.ITERATOR] = function() {
      return this.values();
    };
    com.cognitect.transit.types.TransitSet.prototype.com$cognitect$transit$equals = function(a2) {
      if (a2 instanceof com.cognitect.transit.types.TransitSet) {
        if (this.size === a2.size) {
          return com.cognitect.transit.eq.equals(this.map, a2.map);
        }
      } else {
        return false;
      }
    };
    com.cognitect.transit.types.TransitSet.prototype.com$cognitect$transit$hashCode = function(a2) {
      return com.cognitect.transit.eq.hashCode(this.map);
    };
    com.cognitect.transit.types.set = function(a2) {
      a2 = a2 || [];
      for (var b2 = {}, c2 = [], d2 = 0, e2 = 0; e2 < a2.length; e2++) {
        var f2 = com.cognitect.transit.eq.hashCode(a2[e2]), g = b2[f2];
        if (null == g) {
          c2.push(f2), b2[f2] = [a2[e2], a2[e2]], d2++;
        } else {
          f2 = true;
          for (var h = 0; h < g.length; h += 2) {
            if (com.cognitect.transit.eq.equals(g[h], a2[e2])) {
              f2 = false;
              break;
            }
          }
          f2 && (g.push(a2[e2]), g.push(a2[e2]), d2++);
        }
      }
      return new com.cognitect.transit.types.TransitSet(new com.cognitect.transit.types.TransitMap(c2, b2, d2));
    };
    com.cognitect.transit.types.isSet = function(a2) {
      return a2 instanceof com.cognitect.transit.types.TransitSet;
    };
    com.cognitect.transit.types.quoted = function(a2) {
      return com.cognitect.transit.types.taggedValue("'", a2);
    };
    com.cognitect.transit.types.isQuoted = function(a2) {
      return a2 instanceof com.cognitect.transit.types.TaggedValue && "'" === a2.tag;
    };
    com.cognitect.transit.types.list = function(a2) {
      return com.cognitect.transit.types.taggedValue("list", a2);
    };
    com.cognitect.transit.types.isList = function(a2) {
      return a2 instanceof com.cognitect.transit.types.TaggedValue && "list" === a2.tag;
    };
    com.cognitect.transit.types.link = function(a2) {
      return com.cognitect.transit.types.taggedValue("link", a2);
    };
    com.cognitect.transit.types.isLink = function(a2) {
      return a2 instanceof com.cognitect.transit.types.TaggedValue && "link" === a2.tag;
    };
    com.cognitect.transit.types.specialDouble = function(a2) {
      switch (a2) {
        case "-INF":
          return -Infinity;
        case "INF":
          return Infinity;
        case "NaN":
          return NaN;
        default:
          throw Error("Invalid special double value " + a2);
      }
    };
    com.cognitect.transit.impl = {};
    com.cognitect.transit.impl.decoder = {};
    com.cognitect.transit.impl.decoder.Tag = function(a2) {
      this.str = a2;
    };
    com.cognitect.transit.impl.decoder.tag = function(a2) {
      return new com.cognitect.transit.impl.decoder.Tag(a2);
    };
    com.cognitect.transit.impl.decoder.isTag = function(a2) {
      return a2 && a2 instanceof com.cognitect.transit.impl.decoder.Tag;
    };
    com.cognitect.transit.impl.decoder.isGroundHandler = function(a2) {
      switch (a2) {
        case "_":
        case "s":
        case "?":
        case "i":
        case "d":
        case "b":
        case "'":
        case "array":
        case "map":
          return true;
      }
      return false;
    };
    com.cognitect.transit.impl.decoder.Decoder = function(a2) {
      this.options = a2 || {};
      this.handlers = {};
      for (var b2 in this.defaults.handlers) {
        this.handlers[b2] = this.defaults.handlers[b2];
      }
      for (b2 in this.options.handlers) {
        if (com.cognitect.transit.impl.decoder.isGroundHandler(b2)) {
          throw Error('Cannot override handler for ground type "' + b2 + '"');
        }
        this.handlers[b2] = this.options.handlers[b2];
      }
      this.preferStrings = null != this.options.preferStrings ? this.options.preferStrings : this.defaults.preferStrings;
      this.preferBuffers = null != this.options.preferBuffers ? this.options.preferBuffers : this.defaults.preferBuffers;
      this.defaultHandler = this.options.defaultHandler || this.defaults.defaultHandler;
      this.mapBuilder = this.options.mapBuilder;
      this.arrayBuilder = this.options.arrayBuilder;
    };
    com.cognitect.transit.impl.decoder.Decoder.prototype.defaults = { handlers: { _: function(a2, b2) {
      return com.cognitect.transit.types.nullValue();
    }, "?": function(a2, b2) {
      return com.cognitect.transit.types.boolValue(a2);
    }, b: function(a2, b2) {
      return com.cognitect.transit.types.binary(a2, b2);
    }, i: function(a2, b2) {
      return com.cognitect.transit.types.intValue(a2);
    }, n: function(a2, b2) {
      return com.cognitect.transit.types.bigInteger(a2);
    }, d: function(a2, b2) {
      return com.cognitect.transit.types.floatValue(a2);
    }, f: function(a2, b2) {
      return com.cognitect.transit.types.bigDecimalValue(a2);
    }, c: function(a2, b2) {
      return com.cognitect.transit.types.charValue(a2);
    }, ":": function(a2, b2) {
      return com.cognitect.transit.types.keyword(a2);
    }, $: function(a2, b2) {
      return com.cognitect.transit.types.symbol(a2);
    }, r: function(a2, b2) {
      return com.cognitect.transit.types.uri(a2);
    }, z: function(a2, b2) {
      return com.cognitect.transit.types.specialDouble(a2);
    }, "'": function(a2, b2) {
      return a2;
    }, m: function(a2, b2) {
      return com.cognitect.transit.types.date(a2);
    }, t: function(a2, b2) {
      return com.cognitect.transit.types.verboseDate(a2);
    }, u: function(a2, b2) {
      return com.cognitect.transit.types.uuid(a2);
    }, set: function(a2, b2) {
      return com.cognitect.transit.types.set(a2);
    }, list: function(a2, b2) {
      return com.cognitect.transit.types.list(a2);
    }, link: function(a2, b2) {
      return com.cognitect.transit.types.link(a2);
    }, cmap: function(a2, b2) {
      return com.cognitect.transit.types.map(a2, false);
    } }, defaultHandler: function(a2, b2) {
      return com.cognitect.transit.types.taggedValue(a2, b2);
    }, preferStrings: true, preferBuffers: true };
    com.cognitect.transit.impl.decoder.Decoder.prototype.decode = function(a2, b2, c2, d2) {
      if (null == a2) {
        return null;
      }
      switch (typeof a2) {
        case "string":
          return this.decodeString(a2, b2, c2, d2);
        case "object":
          return com.cognitect.transit.util.isArray(a2) ? "^ " === a2[0] ? this.decodeArrayHash(a2, b2, c2, d2) : this.decodeArray(a2, b2, c2, d2) : this.decodeHash(a2, b2, c2, d2);
      }
      return a2;
    };
    com.cognitect.transit.impl.decoder.Decoder.prototype.decode = com.cognitect.transit.impl.decoder.Decoder.prototype.decode;
    com.cognitect.transit.impl.decoder.Decoder.prototype.decodeString = function(a2, b2, c2, d2) {
      return com.cognitect.transit.caching.isCacheable(a2, c2) ? (a2 = this.parseString(a2, b2, false), b2 && b2.write(a2, c2), a2) : com.cognitect.transit.caching.isCacheCode(a2) ? b2.read(a2, c2) : this.parseString(a2, b2, c2);
    };
    com.cognitect.transit.impl.decoder.Decoder.prototype.decodeHash = function(a2, b2, c2, d2) {
      c2 = com.cognitect.transit.util.objectKeys(a2);
      var e2 = c2[0];
      d2 = 1 == c2.length ? this.decode(e2, b2, false, false) : null;
      if (com.cognitect.transit.impl.decoder.isTag(d2)) {
        return a2 = a2[e2], c2 = this.handlers[d2.str], null != c2 ? c2(this.decode(a2, b2, false, true), this) : com.cognitect.transit.types.taggedValue(d2.str, this.decode(a2, b2, false, false));
      }
      if (this.mapBuilder) {
        if (c2.length < 2 * com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD && this.mapBuilder.fromArray) {
          var f2 = [];
          for (d2 = 0; d2 < c2.length; d2++) {
            e2 = c2[d2], f2.push(this.decode(e2, b2, true, false)), f2.push(this.decode(a2[e2], b2, false, false));
          }
          return this.mapBuilder.fromArray(f2, a2);
        }
        f2 = this.mapBuilder.init(a2);
        for (d2 = 0; d2 < c2.length; d2++) {
          e2 = c2[d2], f2 = this.mapBuilder.add(f2, this.decode(e2, b2, true, false), this.decode(a2[e2], b2, false, false), a2);
        }
        return this.mapBuilder.finalize(f2, a2);
      }
      f2 = [];
      for (d2 = 0; d2 < c2.length; d2++) {
        e2 = c2[d2], f2.push(this.decode(e2, b2, true, false)), f2.push(this.decode(a2[e2], b2, false, false));
      }
      return com.cognitect.transit.types.map(f2, false);
    };
    com.cognitect.transit.impl.decoder.Decoder.prototype.decodeArrayHash = function(a2, b2, c2, d2) {
      if (this.mapBuilder) {
        if (a2.length < 2 * com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD + 1 && this.mapBuilder.fromArray) {
          d2 = [];
          for (c2 = 1; c2 < a2.length; c2 += 2) {
            d2.push(this.decode(a2[c2], b2, true, false)), d2.push(this.decode(a2[c2 + 1], b2, false, false));
          }
          return this.mapBuilder.fromArray(d2, a2);
        }
        d2 = this.mapBuilder.init(a2);
        for (c2 = 1; c2 < a2.length; c2 += 2) {
          d2 = this.mapBuilder.add(d2, this.decode(a2[c2], b2, true, false), this.decode(a2[c2 + 1], b2, false, false), a2);
        }
        return this.mapBuilder.finalize(d2, a2);
      }
      d2 = [];
      for (c2 = 1; c2 < a2.length; c2 += 2) {
        d2.push(this.decode(a2[c2], b2, true, false)), d2.push(this.decode(a2[c2 + 1], b2, false, false));
      }
      return com.cognitect.transit.types.map(d2, false);
    };
    com.cognitect.transit.impl.decoder.Decoder.prototype.decodeArray = function(a2, b2, c2, d2) {
      if (d2) {
        var e2 = [];
        for (d2 = 0; d2 < a2.length; d2++) {
          e2.push(this.decode(a2[d2], b2, c2, false));
        }
        return e2;
      }
      e2 = b2 && b2.idx;
      if (2 === a2.length && "string" === typeof a2[0] && (d2 = this.decode(a2[0], b2, false, false), com.cognitect.transit.impl.decoder.isTag(d2))) {
        return a2 = a2[1], e2 = this.handlers[d2.str], null != e2 ? e2 = e2(this.decode(a2, b2, c2, true), this) : com.cognitect.transit.types.taggedValue(d2.str, this.decode(a2, b2, c2, false));
      }
      b2 && e2 != b2.idx && (b2.idx = e2);
      if (this.arrayBuilder) {
        if (32 >= a2.length && this.arrayBuilder.fromArray) {
          e2 = [];
          for (d2 = 0; d2 < a2.length; d2++) {
            e2.push(this.decode(a2[d2], b2, c2, false));
          }
          return this.arrayBuilder.fromArray(e2, a2);
        }
        e2 = this.arrayBuilder.init(a2);
        for (d2 = 0; d2 < a2.length; d2++) {
          e2 = this.arrayBuilder.add(e2, this.decode(a2[d2], b2, c2, false), a2);
        }
        return this.arrayBuilder.finalize(e2, a2);
      }
      e2 = [];
      for (d2 = 0; d2 < a2.length; d2++) {
        e2.push(this.decode(a2[d2], b2, c2, false));
      }
      return e2;
    };
    com.cognitect.transit.impl.decoder.Decoder.prototype.parseString = function(a2, b2, c2) {
      if (a2.charAt(0) === com.cognitect.transit.delimiters.ESC) {
        b2 = a2.charAt(1);
        if (b2 === com.cognitect.transit.delimiters.ESC || b2 === com.cognitect.transit.delimiters.SUB || b2 === com.cognitect.transit.delimiters.RES) {
          return a2.substring(1);
        }
        if (b2 === com.cognitect.transit.delimiters.TAG) {
          return com.cognitect.transit.impl.decoder.tag(a2.substring(2));
        }
        c2 = this.handlers[b2];
        return null == c2 ? this.defaultHandler(b2, a2.substring(2)) : c2(a2.substring(2), this);
      }
      return a2;
    };
    com.cognitect.transit.impl.decoder.decoder = function(a2) {
      return new com.cognitect.transit.impl.decoder.Decoder(a2);
    };
    com.cognitect.transit.impl.reader = {};
    com.cognitect.transit.impl.reader.JSONUnmarshaller = function(a2) {
      this.decoder = new com.cognitect.transit.impl.decoder.Decoder(a2);
    };
    com.cognitect.transit.impl.reader.JSONUnmarshaller.prototype.unmarshal = function(a2, b2) {
      return this.decoder.decode(JSON.parse(a2), b2);
    };
    com.cognitect.transit.impl.reader.Reader = function(a2, b2) {
      this.unmarshaller = a2;
      this.options = b2 || {};
      this.cache = this.options.cache ? this.options.cache : new com.cognitect.transit.caching.ReadCache();
    };
    com.cognitect.transit.impl.reader.Reader.prototype.read = function(a2) {
      a2 = this.unmarshaller.unmarshal(a2, this.cache);
      this.cache.clear();
      return a2;
    };
    com.cognitect.transit.impl.reader.Reader.prototype.read = com.cognitect.transit.impl.reader.Reader.prototype.read;
    com.cognitect.transit.handlers = {};
    com.cognitect.transit.handlers.ctorGuid = 0;
    com.cognitect.transit.handlers.ctorGuidProperty = "transit$guid$" + com.cognitect.transit.util.randomUUID();
    com.cognitect.transit.handlers.typeTag = function(a2) {
      if (null == a2) {
        return "null";
      }
      if (a2 === String) {
        return "string";
      }
      if (a2 === Boolean) {
        return "boolean";
      }
      if (a2 === Number) {
        return "number";
      }
      if (a2 === Array) {
        return "array";
      }
      if (a2 === Object) {
        return "map";
      }
      var b2 = a2[com.cognitect.transit.handlers.ctorGuidProperty];
      null == b2 && ("undefined" != typeof Object.defineProperty ? (b2 = ++com.cognitect.transit.handlers.ctorGuid, Object.defineProperty(a2, com.cognitect.transit.handlers.ctorGuidProperty, { value: b2, enumerable: false })) : a2[com.cognitect.transit.handlers.ctorGuidProperty] = b2 = ++com.cognitect.transit.handlers.ctorGuid);
      return b2;
    };
    com.cognitect.transit.handlers.constructor = function(a2) {
      return null == a2 ? null : a2.constructor;
    };
    com.cognitect.transit.handlers.padZeros = function(a2, b2) {
      a2 = a2.toString();
      for (var c2 = a2.length; c2 < b2; c2++) {
        a2 = "0" + a2;
      }
      return a2;
    };
    com.cognitect.transit.handlers.stringableKeys = function(a2) {
      a2 = com.cognitect.transit.util.objectKeys(a2);
      for (var b2 = 0; b2 < a2.length; b2++) {
      }
      return true;
    };
    com.cognitect.transit.handlers.NilHandler = function() {
    };
    com.cognitect.transit.handlers.NilHandler.prototype.tag = function(a2) {
      return "_";
    };
    com.cognitect.transit.handlers.NilHandler.prototype.rep = function(a2) {
      return null;
    };
    com.cognitect.transit.handlers.NilHandler.prototype.stringRep = function(a2) {
      return "null";
    };
    com.cognitect.transit.handlers.StringHandler = function() {
    };
    com.cognitect.transit.handlers.StringHandler.prototype.tag = function(a2) {
      return "s";
    };
    com.cognitect.transit.handlers.StringHandler.prototype.rep = function(a2) {
      return a2;
    };
    com.cognitect.transit.handlers.StringHandler.prototype.stringRep = function(a2) {
      return a2;
    };
    com.cognitect.transit.handlers.NumberHandler = function() {
    };
    com.cognitect.transit.handlers.NumberHandler.prototype.tag = function(a2) {
      return "i";
    };
    com.cognitect.transit.handlers.NumberHandler.prototype.rep = function(a2) {
      return a2;
    };
    com.cognitect.transit.handlers.NumberHandler.prototype.stringRep = function(a2) {
      return a2.toString();
    };
    com.cognitect.transit.handlers.IntegerHandler = function() {
    };
    com.cognitect.transit.handlers.IntegerHandler.prototype.tag = function(a2) {
      return "i";
    };
    com.cognitect.transit.handlers.IntegerHandler.prototype.rep = function(a2) {
      return a2.toString();
    };
    com.cognitect.transit.handlers.IntegerHandler.prototype.stringRep = function(a2) {
      return a2.toString();
    };
    com.cognitect.transit.handlers.BooleanHandler = function() {
    };
    com.cognitect.transit.handlers.BooleanHandler.prototype.tag = function(a2) {
      return "?";
    };
    com.cognitect.transit.handlers.BooleanHandler.prototype.rep = function(a2) {
      return a2;
    };
    com.cognitect.transit.handlers.BooleanHandler.prototype.stringRep = function(a2) {
      return a2.toString();
    };
    com.cognitect.transit.handlers.ArrayHandler = function() {
    };
    com.cognitect.transit.handlers.ArrayHandler.prototype.tag = function(a2) {
      return "array";
    };
    com.cognitect.transit.handlers.ArrayHandler.prototype.rep = function(a2) {
      return a2;
    };
    com.cognitect.transit.handlers.ArrayHandler.prototype.stringRep = function(a2) {
      return null;
    };
    com.cognitect.transit.handlers.MapHandler = function() {
    };
    com.cognitect.transit.handlers.MapHandler.prototype.tag = function(a2) {
      return "map";
    };
    com.cognitect.transit.handlers.MapHandler.prototype.rep = function(a2) {
      return a2;
    };
    com.cognitect.transit.handlers.MapHandler.prototype.stringRep = function(a2) {
      return null;
    };
    com.cognitect.transit.handlers.VerboseDateHandler = function() {
    };
    com.cognitect.transit.handlers.VerboseDateHandler.prototype.tag = function(a2) {
      return "t";
    };
    com.cognitect.transit.handlers.VerboseDateHandler.prototype.rep = function(a2) {
      return a2.getUTCFullYear() + "-" + com.cognitect.transit.handlers.padZeros(a2.getUTCMonth() + 1, 2) + "-" + com.cognitect.transit.handlers.padZeros(a2.getUTCDate(), 2) + "T" + com.cognitect.transit.handlers.padZeros(a2.getUTCHours(), 2) + ":" + com.cognitect.transit.handlers.padZeros(a2.getUTCMinutes(), 2) + ":" + com.cognitect.transit.handlers.padZeros(a2.getUTCSeconds(), 2) + "." + com.cognitect.transit.handlers.padZeros(a2.getUTCMilliseconds(), 3) + "Z";
    };
    com.cognitect.transit.handlers.VerboseDateHandler.prototype.stringRep = function(a2, b2) {
      return b2.rep(a2);
    };
    com.cognitect.transit.handlers.DateHandler = function() {
    };
    com.cognitect.transit.handlers.DateHandler.prototype.tag = function(a2) {
      return "m";
    };
    com.cognitect.transit.handlers.DateHandler.prototype.rep = function(a2) {
      return a2.valueOf();
    };
    com.cognitect.transit.handlers.DateHandler.prototype.stringRep = function(a2) {
      return a2.valueOf().toString();
    };
    com.cognitect.transit.handlers.DateHandler.prototype.getVerboseHandler = function(a2) {
      return new com.cognitect.transit.handlers.VerboseDateHandler();
    };
    com.cognitect.transit.handlers.UUIDHandler = function() {
    };
    com.cognitect.transit.handlers.UUIDHandler.prototype.tag = function(a2) {
      return "u";
    };
    com.cognitect.transit.handlers.UUIDHandler.prototype.rep = function(a2) {
      return a2.toString();
    };
    com.cognitect.transit.handlers.UUIDHandler.prototype.stringRep = function(a2) {
      return a2.toString();
    };
    com.cognitect.transit.handlers.KeywordHandler = function() {
    };
    com.cognitect.transit.handlers.KeywordHandler.prototype.tag = function(a2) {
      return ":";
    };
    com.cognitect.transit.handlers.KeywordHandler.prototype.rep = function(a2) {
      return a2._name;
    };
    com.cognitect.transit.handlers.KeywordHandler.prototype.stringRep = function(a2, b2) {
      return b2.rep(a2);
    };
    com.cognitect.transit.handlers.SymbolHandler = function() {
    };
    com.cognitect.transit.handlers.SymbolHandler.prototype.tag = function(a2) {
      return "$";
    };
    com.cognitect.transit.handlers.SymbolHandler.prototype.rep = function(a2) {
      return a2._name;
    };
    com.cognitect.transit.handlers.SymbolHandler.prototype.stringRep = function(a2, b2) {
      return b2.rep(a2);
    };
    com.cognitect.transit.handlers.TaggedHandler = function() {
    };
    com.cognitect.transit.handlers.TaggedHandler.prototype.tag = function(a2) {
      return a2.tag;
    };
    com.cognitect.transit.handlers.TaggedHandler.prototype.rep = function(a2) {
      return a2.rep;
    };
    com.cognitect.transit.handlers.TaggedHandler.prototype.stringRep = function(a2, b2) {
      return null;
    };
    com.cognitect.transit.handlers.TransitSetHandler = function() {
    };
    com.cognitect.transit.handlers.TransitSetHandler.prototype.tag = function(a2) {
      return "set";
    };
    com.cognitect.transit.handlers.TransitSetHandler.prototype.rep = function(a2) {
      var b2 = [];
      a2.forEach(function(c2, d2) {
        b2.push(c2);
      });
      return com.cognitect.transit.types.taggedValue("array", b2);
    };
    com.cognitect.transit.handlers.TransitSetHandler.prototype.stringRep = function(a2, b2) {
      return null;
    };
    com.cognitect.transit.handlers.TransitArrayMapHandler = function() {
    };
    com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.tag = function(a2) {
      return "map";
    };
    com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.rep = function(a2) {
      return a2;
    };
    com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.stringRep = function(a2, b2) {
      return null;
    };
    com.cognitect.transit.handlers.TransitMapHandler = function() {
    };
    com.cognitect.transit.handlers.TransitMapHandler.prototype.tag = function(a2) {
      return "map";
    };
    com.cognitect.transit.handlers.TransitMapHandler.prototype.rep = function(a2) {
      return a2;
    };
    com.cognitect.transit.handlers.TransitMapHandler.prototype.stringRep = function(a2, b2) {
      return null;
    };
    com.cognitect.transit.handlers.BufferHandler = function() {
    };
    com.cognitect.transit.handlers.BufferHandler.prototype.tag = function(a2) {
      return "b";
    };
    com.cognitect.transit.handlers.BufferHandler.prototype.rep = function(a2) {
      return a2.toString("base64");
    };
    com.cognitect.transit.handlers.BufferHandler.prototype.stringRep = function(a2, b2) {
      return null;
    };
    com.cognitect.transit.handlers.Uint8ArrayHandler = function() {
    };
    com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.tag = function(a2) {
      return "b";
    };
    com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.rep = function(a2) {
      return com.cognitect.transit.util.Uint8ToBase64(a2);
    };
    com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.stringRep = function(a2, b2) {
      return null;
    };
    com.cognitect.transit.handlers.defaultHandlers = function(a2) {
      a2.set(null, new com.cognitect.transit.handlers.NilHandler());
      a2.set(String, new com.cognitect.transit.handlers.StringHandler());
      a2.set(Number, new com.cognitect.transit.handlers.NumberHandler());
      a2.set(module$contents$goog$math$Long_Long, new com.cognitect.transit.handlers.IntegerHandler());
      a2.set(Boolean, new com.cognitect.transit.handlers.BooleanHandler());
      a2.set(Array, new com.cognitect.transit.handlers.ArrayHandler());
      a2.set(Object, new com.cognitect.transit.handlers.MapHandler());
      a2.set(Date, new com.cognitect.transit.handlers.DateHandler());
      a2.set(com.cognitect.transit.types.UUID, new com.cognitect.transit.handlers.UUIDHandler());
      a2.set(com.cognitect.transit.types.Keyword, new com.cognitect.transit.handlers.KeywordHandler());
      a2.set(com.cognitect.transit.types.Symbol, new com.cognitect.transit.handlers.SymbolHandler());
      a2.set(com.cognitect.transit.types.TaggedValue, new com.cognitect.transit.handlers.TaggedHandler());
      a2.set(com.cognitect.transit.types.TransitSet, new com.cognitect.transit.handlers.TransitSetHandler());
      a2.set(com.cognitect.transit.types.TransitArrayMap, new com.cognitect.transit.handlers.TransitArrayMapHandler());
      a2.set(com.cognitect.transit.types.TransitMap, new com.cognitect.transit.handlers.TransitMapHandler());
      "undefined" != typeof goog.global.Buffer && a2.set(goog.global.Buffer, new com.cognitect.transit.handlers.BufferHandler());
      "undefined" != typeof Uint8Array && a2.set(Uint8Array, new com.cognitect.transit.handlers.Uint8ArrayHandler());
      return a2;
    };
    com.cognitect.transit.handlers.Handlers = function() {
      this.handlers = {};
      com.cognitect.transit.handlers.defaultHandlers(this);
    };
    com.cognitect.transit.handlers.Handlers.prototype.get = function(a2) {
      a2 = "string" === typeof a2 ? this.handlers[a2] : this.handlers[com.cognitect.transit.handlers.typeTag(a2)];
      return null != a2 ? a2 : this.handlers["default"];
    };
    com.cognitect.transit.handlers.Handlers.prototype.get = com.cognitect.transit.handlers.Handlers.prototype.get;
    com.cognitect.transit.handlers.validTag = function(a2) {
      switch (a2) {
        case "null":
        case "string":
        case "boolean":
        case "number":
        case "array":
        case "map":
          return false;
      }
      return true;
    };
    com.cognitect.transit.handlers.Handlers.prototype.set = function(a2, b2) {
      "string" === typeof a2 && com.cognitect.transit.handlers.validTag(a2) ? this.handlers[a2] = b2 : this.handlers[com.cognitect.transit.handlers.typeTag(a2)] = b2;
    };
    com.cognitect.transit.impl.writer = {};
    com.cognitect.transit.impl.writer.escape = function(a2) {
      if (0 < a2.length) {
        var b2 = a2.charAt(0);
        return b2 === com.cognitect.transit.delimiters.ESC || b2 === com.cognitect.transit.delimiters.SUB || b2 === com.cognitect.transit.delimiters.RES ? com.cognitect.transit.delimiters.ESC + a2 : a2;
      }
      return a2;
    };
    com.cognitect.transit.impl.writer.JSONMarshaller = function(a2) {
      this.opts = a2 || {};
      this.preferStrings = null != this.opts.preferStrings ? this.opts.preferStrings : true;
      this.objectBuilder = this.opts.objectBuilder || null;
      this.transform = this.opts.transform || null;
      this.handlers = new com.cognitect.transit.handlers.Handlers();
      if (a2 = this.opts.handlers) {
        if (com.cognitect.transit.util.isArray(a2) || !a2.forEach) {
          throw Error('transit writer "handlers" option must be a map');
        }
        var b2 = this;
        a2.forEach(function(c2, d2) {
          if (void 0 !== d2) {
            b2.handlers.set(d2, c2);
          } else {
            throw Error("Cannot create handler for JavaScript undefined");
          }
        });
      }
      this.handlerForForeign = this.opts.handlerForForeign;
      this.unpack = this.opts.unpack || function(c2) {
        return com.cognitect.transit.types.isArrayMap(c2) && null === c2.backingMap ? c2._entries : false;
      };
      this.verbose = this.opts && this.opts.verbose || false;
    };
    com.cognitect.transit.impl.writer.JSONMarshaller.prototype.handler = function(a2) {
      var b2 = this.handlers.get(com.cognitect.transit.handlers.constructor(a2));
      return null != b2 ? b2 : (a2 = a2 && a2.transitTag) ? this.handlers.get(a2) : null;
    };
    com.cognitect.transit.impl.writer.JSONMarshaller.prototype.registerHandler = function(a2, b2) {
      this.handlers.set(a2, b2);
    };
    com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitNil = function(a2, b2) {
      return a2 ? this.emitString(com.cognitect.transit.delimiters.ESC, "_", "", a2, b2) : null;
    };
    com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitString = function(a2, b2, c2, d2, e2) {
      a2 = a2 + b2 + c2;
      return e2 ? e2.write(a2, d2) : a2;
    };
    com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitBoolean = function(a2, b2, c2) {
      return b2 ? this.emitString(com.cognitect.transit.delimiters.ESC, "?", a2.toString()[0], b2, c2) : a2;
    };
    com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitInteger = function(a2, b2, c2) {
      return Infinity === a2 ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "INF", b2, c2) : -Infinity === a2 ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "-INF", b2, c2) : isNaN(a2) ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "NaN", b2, c2) : b2 || "string" === typeof a2 || a2 instanceof module$contents$goog$math$Long_Long ? this.emitString(com.cognitect.transit.delimiters.ESC, "i", a2.toString(), b2, c2) : a2;
    };
    com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitDouble = function(a2, b2, c2) {
      return b2 ? this.emitString(a2.ESC, "d", a2, b2, c2) : a2;
    };
    com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitBinary = function(a2, b2, c2) {
      return this.emitString(com.cognitect.transit.delimiters.ESC, "b", a2, b2, c2);
    };
    com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitQuoted = function(a2, b2, c2) {
      if (a2.verbose) {
        a2 = {};
        var d2 = this.emitString(com.cognitect.transit.delimiters.ESC_TAG, "'", "", true, c2);
        a2[d2] = com.cognitect.transit.impl.writer.marshal(this, b2, false, c2);
        return a2;
      }
      return [this.emitString(com.cognitect.transit.delimiters.ESC_TAG, "'", "", true, c2), com.cognitect.transit.impl.writer.marshal(this, b2, false, c2)];
    };
    com.cognitect.transit.impl.writer.emitObjects = function(a2, b2, c2) {
      var d2 = [];
      if (com.cognitect.transit.util.isArray(b2)) {
        for (var e2 = 0; e2 < b2.length; e2++) {
          d2.push(com.cognitect.transit.impl.writer.marshal(a2, b2[e2], false, c2));
        }
      } else {
        b2.forEach(function(f2, g) {
          d2.push(com.cognitect.transit.impl.writer.marshal(a2, f2, false, c2));
        });
      }
      return d2;
    };
    com.cognitect.transit.impl.writer.emitArray = function(a2, b2, c2, d2) {
      return com.cognitect.transit.impl.writer.emitObjects(a2, b2, d2);
    };
    com.cognitect.transit.impl.writer.isStringableKey = function(a2, b2) {
      return "string" !== typeof b2 ? (a2 = a2.handler(b2)) && 1 === a2.tag(b2).length : true;
    };
    com.cognitect.transit.impl.writer.stringableKeys = function(a2, b2) {
      var c2 = a2.unpack(b2), d2 = true;
      if (c2) {
        for (b2 = 0; b2 < c2.length && (d2 = com.cognitect.transit.impl.writer.isStringableKey(a2, c2[b2]), d2); b2 += 2) {
        }
        return d2;
      }
      if (b2.keys) {
        c2 = b2.keys();
        var e2 = null;
        if (c2.next) {
          for (e2 = c2.next(); !e2.done; ) {
            d2 = com.cognitect.transit.impl.writer.isStringableKey(a2, e2.value);
            if (!d2) {
              break;
            }
            e2 = c2.next();
          }
          return d2;
        }
      }
      if (b2.forEach) {
        return b2.forEach(function(f2, g) {
          d2 = d2 && com.cognitect.transit.impl.writer.isStringableKey(a2, g);
        }), d2;
      }
      throw Error("Cannot walk keys of object type " + com.cognitect.transit.handlers.constructor(b2).name);
    };
    com.cognitect.transit.impl.writer.isForeignObject = function(a2) {
      if (a2.constructor.transit$isObject) {
        return true;
      }
      var b2 = a2.constructor.toString();
      b2 = b2.substr(9);
      b2 = b2.substr(0, b2.indexOf("("));
      b2 = "Object" == b2;
      "undefined" != typeof Object.defineProperty ? Object.defineProperty(a2.constructor, "transit$isObject", { value: b2, enumerable: false }) : a2.constructor.transit$isObject = b2;
      return b2;
    };
    com.cognitect.transit.impl.writer.emitMap = function(a2, b2, c2, d2) {
      var e2 = null, f2 = null, g = null;
      e2 = null;
      c2 = 0;
      if (b2.constructor === Object || null != b2.forEach || a2.handlerForForeign && com.cognitect.transit.impl.writer.isForeignObject(b2)) {
        if (a2.verbose) {
          if (null != b2.forEach) {
            if (com.cognitect.transit.impl.writer.stringableKeys(a2, b2)) {
              var h = {};
              b2.forEach(function(k, l) {
                h[com.cognitect.transit.impl.writer.marshal(a2, l, true, false)] = com.cognitect.transit.impl.writer.marshal(a2, k, false, d2);
              });
            } else {
              e2 = a2.unpack(b2);
              f2 = [];
              g = a2.emitString(com.cognitect.transit.delimiters.ESC_TAG, "cmap", "", true, d2);
              if (e2) {
                for (; c2 < e2.length; c2 += 2) {
                  f2.push(com.cognitect.transit.impl.writer.marshal(a2, e2[c2], false, false)), f2.push(com.cognitect.transit.impl.writer.marshal(a2, e2[c2 + 1], false, d2));
                }
              } else {
                b2.forEach(function(k, l) {
                  f2.push(com.cognitect.transit.impl.writer.marshal(a2, l, false, false));
                  f2.push(com.cognitect.transit.impl.writer.marshal(a2, k, false, d2));
                });
              }
              h = {};
              h[g] = f2;
            }
          } else {
            for (e2 = com.cognitect.transit.util.objectKeys(b2), h = {}; c2 < e2.length; c2++) {
              h[com.cognitect.transit.impl.writer.marshal(a2, e2[c2], true, false)] = com.cognitect.transit.impl.writer.marshal(a2, b2[e2[c2]], false, d2);
            }
          }
          return h;
        }
        if (null != b2.forEach) {
          if (com.cognitect.transit.impl.writer.stringableKeys(a2, b2)) {
            e2 = a2.unpack(b2);
            h = ["^ "];
            if (e2) {
              for (; c2 < e2.length; c2 += 2) {
                h.push(com.cognitect.transit.impl.writer.marshal(a2, e2[c2], true, d2)), h.push(com.cognitect.transit.impl.writer.marshal(a2, e2[c2 + 1], false, d2));
              }
            } else {
              b2.forEach(function(k, l) {
                h.push(com.cognitect.transit.impl.writer.marshal(a2, l, true, d2));
                h.push(com.cognitect.transit.impl.writer.marshal(a2, k, false, d2));
              });
            }
            return h;
          }
          e2 = a2.unpack(b2);
          f2 = [];
          g = a2.emitString(com.cognitect.transit.delimiters.ESC_TAG, "cmap", "", true, d2);
          if (e2) {
            for (; c2 < e2.length; c2 += 2) {
              f2.push(com.cognitect.transit.impl.writer.marshal(a2, e2[c2], false, d2)), f2.push(com.cognitect.transit.impl.writer.marshal(a2, e2[c2 + 1], false, d2));
            }
          } else {
            b2.forEach(function(k, l) {
              f2.push(com.cognitect.transit.impl.writer.marshal(a2, l, false, d2));
              f2.push(com.cognitect.transit.impl.writer.marshal(a2, k, false, d2));
            });
          }
          return [g, f2];
        }
        h = ["^ "];
        for (e2 = com.cognitect.transit.util.objectKeys(b2); c2 < e2.length; c2++) {
          h.push(com.cognitect.transit.impl.writer.marshal(a2, e2[c2], true, d2)), h.push(com.cognitect.transit.impl.writer.marshal(a2, b2[e2[c2]], false, d2));
        }
        return h;
      }
      if (null != a2.objectBuilder) {
        return a2.objectBuilder(b2, function(k) {
          return com.cognitect.transit.impl.writer.marshal(a2, k, true, d2);
        }, function(k) {
          return com.cognitect.transit.impl.writer.marshal(a2, k, false, d2);
        });
      }
      c2 = com.cognitect.transit.handlers.constructor(b2).name;
      e2 = Error("Cannot write " + c2);
      e2.data = { obj: b2, type: c2 };
      throw e2;
    };
    com.cognitect.transit.impl.writer.emitTaggedMap = function(a2, b2, c2, d2, e2) {
      return a2.verbose ? (d2 = {}, d2[a2.emitString(com.cognitect.transit.delimiters.ESC_TAG, b2, "", true, e2)] = com.cognitect.transit.impl.writer.marshal(a2, c2, false, e2), d2) : [a2.emitString(com.cognitect.transit.delimiters.ESC_TAG, b2, "", true, e2), com.cognitect.transit.impl.writer.marshal(a2, c2, false, e2)];
    };
    com.cognitect.transit.impl.writer.emitEncoded = function(a2, b2, c2, d2, e2, f2, g) {
      if (1 === c2.length) {
        if ("string" === typeof d2) {
          return a2.emitString(com.cognitect.transit.delimiters.ESC, c2, d2, f2, g);
        }
        if (f2 || a2.preferStrings) {
          (d2 = a2.verbose && b2.getVerboseHandler()) ? (c2 = d2.tag(e2), d2 = d2.stringRep(e2, d2)) : d2 = b2.stringRep(e2, b2);
          if (null !== d2) {
            return a2.emitString(com.cognitect.transit.delimiters.ESC, c2, d2, f2, g);
          }
          a2 = Error('Tag "' + c2 + '" cannot be encoded as string');
          a2.data = { tag: c2, rep: d2, obj: e2 };
          throw a2;
        }
      }
      return com.cognitect.transit.impl.writer.emitTaggedMap(a2, c2, d2, f2, g);
    };
    com.cognitect.transit.impl.writer.marshal = function(a2, b2, c2, d2) {
      null !== a2.transform && (b2 = a2.transform(b2));
      var e2 = a2.handler(b2) || (a2.handlerForForeign ? a2.handlerForForeign(b2, a2.handlers) : null), f2 = e2 ? e2.tag(b2) : null, g = e2 ? e2.rep(b2) : null;
      if (null != e2 && null != f2) {
        switch (f2) {
          case "_":
            return a2.emitNil(c2, d2);
          case "s":
            return a2.emitString("", "", com.cognitect.transit.impl.writer.escape(g), c2, d2);
          case "?":
            return a2.emitBoolean(g, c2, d2);
          case "i":
            return a2.emitInteger(g, c2, d2);
          case "d":
            return a2.emitDouble(g, c2, d2);
          case "b":
            return a2.emitBinary(g, c2, d2);
          case "'":
            return a2.emitQuoted(a2, g, d2);
          case "array":
            return com.cognitect.transit.impl.writer.emitArray(a2, g, c2, d2);
          case "map":
            return com.cognitect.transit.impl.writer.emitMap(a2, g, c2, d2);
          default:
            return com.cognitect.transit.impl.writer.emitEncoded(a2, e2, f2, g, b2, c2, d2);
        }
      } else {
        throw a2 = com.cognitect.transit.handlers.constructor(b2).name, c2 = Error("Cannot write " + a2), c2.data = { obj: b2, type: a2 }, c2;
      }
    };
    com.cognitect.transit.impl.writer.maybeQuoted = function(a2, b2) {
      a2 = a2.handler(b2) || (a2.handlerForForeign ? a2.handlerForForeign(b2, a2.handlers) : null);
      if (null != a2) {
        return 1 === a2.tag(b2).length ? com.cognitect.transit.types.quoted(b2) : b2;
      }
      a2 = com.cognitect.transit.handlers.constructor(b2).name;
      var c2 = Error("Cannot write " + a2);
      c2.data = { obj: b2, type: a2 };
      throw c2;
    };
    com.cognitect.transit.impl.writer.marshalTop = function(a2, b2, c2, d2) {
      return JSON.stringify(com.cognitect.transit.impl.writer.marshal(a2, com.cognitect.transit.impl.writer.maybeQuoted(a2, b2), c2, d2));
    };
    com.cognitect.transit.impl.writer.Writer = function(a2, b2) {
      this._marshaller = a2;
      this.options = b2 || {};
      this.cache = false === this.options.cache ? null : this.options.cache ? this.options.cache : new com.cognitect.transit.caching.WriteCache();
    };
    com.cognitect.transit.impl.writer.Writer.prototype.marshaller = function() {
      return this._marshaller;
    };
    com.cognitect.transit.impl.writer.Writer.prototype.marshaller = com.cognitect.transit.impl.writer.Writer.prototype.marshaller;
    com.cognitect.transit.impl.writer.Writer.prototype.write = function(a2, b2) {
      b2 = b2 || {};
      var c2 = b2.asMapKey || false, d2 = this._marshaller.verbose ? false : this.cache;
      a2 = false === b2.marshalTop ? com.cognitect.transit.impl.writer.marshal(this._marshaller, a2, c2, d2) : com.cognitect.transit.impl.writer.marshalTop(this._marshaller, a2, c2, d2);
      null != this.cache && this.cache.clear();
      return a2;
    };
    com.cognitect.transit.impl.writer.Writer.prototype.write = com.cognitect.transit.impl.writer.Writer.prototype.write;
    com.cognitect.transit.impl.writer.Writer.prototype.register = function(a2, b2) {
      this._marshaller.registerHandler(a2, b2);
    };
    com.cognitect.transit.impl.writer.Writer.prototype.register = com.cognitect.transit.impl.writer.Writer.prototype.register;
    var TRANSIT_DEV = true;
    var TRANSIT_NODE_TARGET = true;
    var TRANSIT_BROWSER_TARGET = false;
    var TRANSIT_BROWSER_AMD_TARGET = false;
    com.cognitect.transit.reader = function(a2, b2) {
      if ("json" === a2 || "json-verbose" === a2 || null == a2) {
        return a2 = new com.cognitect.transit.impl.reader.JSONUnmarshaller(b2), new com.cognitect.transit.impl.reader.Reader(a2, b2);
      }
      throw Error("Cannot create reader of type " + a2);
    };
    com.cognitect.transit.writer = function(a2, b2) {
      if ("json" === a2 || "json-verbose" === a2 || null == a2) {
        return "json-verbose" === a2 && (null == b2 && (b2 = {}), b2.verbose = true), a2 = new com.cognitect.transit.impl.writer.JSONMarshaller(b2), new com.cognitect.transit.impl.writer.Writer(a2, b2);
      }
      b2 = Error('Type must be "json"');
      b2.data = { type: a2 };
      throw b2;
    };
    com.cognitect.transit.makeWriteHandler = function(a2) {
      var b2 = function() {
      };
      b2.prototype.tag = a2.tag;
      b2.prototype.rep = a2.rep;
      b2.prototype.stringRep = a2.stringRep;
      b2.prototype.getVerboseHandler = a2.getVerboseHandler;
      return new b2();
    };
    com.cognitect.transit.makeBuilder = function(a2) {
      var b2 = function() {
      };
      b2.prototype.init = a2.init;
      b2.prototype.add = a2.add;
      b2.prototype.finalize = a2.finalize;
      b2.prototype.fromArray = a2.fromArray;
      return new b2();
    };
    com.cognitect.transit.date = com.cognitect.transit.types.date;
    com.cognitect.transit.integer = com.cognitect.transit.types.intValue;
    com.cognitect.transit.isInteger = com.cognitect.transit.types.isInteger;
    com.cognitect.transit.uuid = com.cognitect.transit.types.uuid;
    com.cognitect.transit.isUUID = com.cognitect.transit.types.isUUID;
    com.cognitect.transit.bigInt = com.cognitect.transit.types.bigInteger;
    com.cognitect.transit.isBigInt = com.cognitect.transit.types.isBigInteger;
    com.cognitect.transit.bigDec = com.cognitect.transit.types.bigDecimalValue;
    com.cognitect.transit.isBigDec = com.cognitect.transit.types.isBigDecimal;
    com.cognitect.transit.keyword = com.cognitect.transit.types.keyword;
    com.cognitect.transit.isKeyword = com.cognitect.transit.types.isKeyword;
    com.cognitect.transit.symbol = com.cognitect.transit.types.symbol;
    com.cognitect.transit.isSymbol = com.cognitect.transit.types.isSymbol;
    com.cognitect.transit.binary = com.cognitect.transit.types.binary;
    com.cognitect.transit.isBinary = com.cognitect.transit.types.isBinary;
    com.cognitect.transit.uri = com.cognitect.transit.types.uri;
    com.cognitect.transit.isURI = com.cognitect.transit.types.isURI;
    com.cognitect.transit.map = com.cognitect.transit.types.map;
    com.cognitect.transit.isMap = com.cognitect.transit.types.isMap;
    com.cognitect.transit.set = com.cognitect.transit.types.set;
    com.cognitect.transit.isSet = com.cognitect.transit.types.isSet;
    com.cognitect.transit.list = com.cognitect.transit.types.list;
    com.cognitect.transit.isList = com.cognitect.transit.types.isList;
    com.cognitect.transit.quoted = com.cognitect.transit.types.quoted;
    com.cognitect.transit.isQuoted = com.cognitect.transit.types.isQuoted;
    com.cognitect.transit.tagged = com.cognitect.transit.types.taggedValue;
    com.cognitect.transit.isTaggedValue = com.cognitect.transit.types.isTaggedValue;
    com.cognitect.transit.link = com.cognitect.transit.types.link;
    com.cognitect.transit.isLink = com.cognitect.transit.types.isLink;
    com.cognitect.transit.hash = com.cognitect.transit.eq.hashCode;
    com.cognitect.transit.hashMapLike = com.cognitect.transit.eq.hashMapLike;
    com.cognitect.transit.hashArrayLike = com.cognitect.transit.eq.hashArrayLike;
    com.cognitect.transit.equals = com.cognitect.transit.eq.equals;
    com.cognitect.transit.extendToEQ = com.cognitect.transit.eq.extendToEQ;
    com.cognitect.transit.mapToObject = function(a2) {
      var b2 = {};
      a2.forEach(function(c2, d2) {
        if ("string" !== typeof d2) {
          throw Error("Cannot convert map with non-string keys");
        }
        b2[d2] = c2;
      });
      return b2;
    };
    com.cognitect.transit.objectToMap = function(a2) {
      var b2 = com.cognitect.transit.map(), c2;
      for (c2 in a2) {
        a2.hasOwnProperty(c2) && b2.set(c2, a2[c2]);
      }
      return b2;
    };
    com.cognitect.transit.decoder = com.cognitect.transit.impl.decoder.decoder;
    com.cognitect.transit.readCache = com.cognitect.transit.caching.readCache;
    com.cognitect.transit.writeCache = com.cognitect.transit.caching.writeCache;
    com.cognitect.transit.UUIDfromString = com.cognitect.transit.types.UUIDfromString;
    com.cognitect.transit.randomUUID = com.cognitect.transit.util.randomUUID;
    com.cognitect.transit.stringableKeys = com.cognitect.transit.impl.writer.stringableKeys;
    TRANSIT_BROWSER_TARGET && (goog.exportSymbol("transit.reader", com.cognitect.transit.reader), goog.exportSymbol("transit.writer", com.cognitect.transit.writer), goog.exportSymbol("transit.makeBuilder", com.cognitect.transit.makeBuilder), goog.exportSymbol("transit.makeWriteHandler", com.cognitect.transit.makeWriteHandler), goog.exportSymbol("transit.date", com.cognitect.transit.types.date), goog.exportSymbol("transit.integer", com.cognitect.transit.types.intValue), goog.exportSymbol(
      "transit.isInteger",
      com.cognitect.transit.types.isInteger
    ), goog.exportSymbol("transit.uuid", com.cognitect.transit.types.uuid), goog.exportSymbol("transit.isUUID", com.cognitect.transit.types.isUUID), goog.exportSymbol("transit.bigInt", com.cognitect.transit.types.bigInteger), goog.exportSymbol("transit.isBigInt", com.cognitect.transit.types.isBigInteger), goog.exportSymbol("transit.bigDec", com.cognitect.transit.types.bigDecimalValue), goog.exportSymbol("transit.isBigDec", com.cognitect.transit.types.isBigDecimal), goog.exportSymbol("transit.keyword", com.cognitect.transit.types.keyword), goog.exportSymbol("transit.isKeyword", com.cognitect.transit.types.isKeyword), goog.exportSymbol("transit.symbol", com.cognitect.transit.types.symbol), goog.exportSymbol("transit.isSymbol", com.cognitect.transit.types.isSymbol), goog.exportSymbol("transit.binary", com.cognitect.transit.types.binary), goog.exportSymbol("transit.isBinary", com.cognitect.transit.types.isBinary), goog.exportSymbol("transit.uri", com.cognitect.transit.types.uri), goog.exportSymbol("transit.isURI", com.cognitect.transit.types.isURI), goog.exportSymbol("transit.map", com.cognitect.transit.types.map), goog.exportSymbol("transit.isMap", com.cognitect.transit.types.isMap), goog.exportSymbol("transit.set", com.cognitect.transit.types.set), goog.exportSymbol("transit.isSet", com.cognitect.transit.types.isSet), goog.exportSymbol("transit.list", com.cognitect.transit.types.list), goog.exportSymbol("transit.isList", com.cognitect.transit.types.isList), goog.exportSymbol(
      "transit.quoted",
      com.cognitect.transit.types.quoted
    ), goog.exportSymbol("transit.isQuoted", com.cognitect.transit.types.isQuoted), goog.exportSymbol("transit.tagged", com.cognitect.transit.types.taggedValue), goog.exportSymbol("transit.isTaggedValue", com.cognitect.transit.types.isTaggedValue), goog.exportSymbol("transit.link", com.cognitect.transit.types.link), goog.exportSymbol("transit.isLink", com.cognitect.transit.types.isLink), goog.exportSymbol("transit.hash", com.cognitect.transit.eq.hashCode), goog.exportSymbol(
      "transit.hashMapLike",
      com.cognitect.transit.eq.hashMapLike
    ), goog.exportSymbol("transit.hashArrayLike", com.cognitect.transit.eq.hashArrayLike), goog.exportSymbol("transit.equals", com.cognitect.transit.eq.equals), goog.exportSymbol("transit.extendToEQ", com.cognitect.transit.eq.extendToEQ), goog.exportSymbol("transit.mapToObject", com.cognitect.transit.mapToObject), goog.exportSymbol("transit.objectToMap", com.cognitect.transit.objectToMap), goog.exportSymbol("transit.decoder", com.cognitect.transit.impl.decoder.decoder), goog.exportSymbol("transit.UUIDfromString", com.cognitect.transit.types.UUIDfromString), goog.exportSymbol("transit.randomUUID", com.cognitect.transit.util.randomUUID), goog.exportSymbol("transit.stringableKeys", com.cognitect.transit.impl.writer.stringableKeys), goog.exportSymbol("transit.readCache", com.cognitect.transit.caching.readCache), goog.exportSymbol("transit.writeCache", com.cognitect.transit.caching.writeCache));
    TRANSIT_NODE_TARGET && (module.exports = {
      reader: com.cognitect.transit.reader,
      writer: com.cognitect.transit.writer,
      makeBuilder: com.cognitect.transit.makeBuilder,
      makeWriteHandler: com.cognitect.transit.makeWriteHandler,
      date: com.cognitect.transit.types.date,
      integer: com.cognitect.transit.types.intValue,
      isInteger: com.cognitect.transit.types.isInteger,
      uuid: com.cognitect.transit.types.uuid,
      isUUID: com.cognitect.transit.types.isUUID,
      bigInt: com.cognitect.transit.types.bigInteger,
      isBigInt: com.cognitect.transit.types.isBigInteger,
      bigDec: com.cognitect.transit.types.bigDecimalValue,
      isBigDec: com.cognitect.transit.types.isBigDecimal,
      keyword: com.cognitect.transit.types.keyword,
      isKeyword: com.cognitect.transit.types.isKeyword,
      symbol: com.cognitect.transit.types.symbol,
      isSymbol: com.cognitect.transit.types.isSymbol,
      binary: com.cognitect.transit.types.binary,
      isBinary: com.cognitect.transit.types.isBinary,
      uri: com.cognitect.transit.types.uri,
      isURI: com.cognitect.transit.types.isURI,
      map: com.cognitect.transit.types.map,
      isMap: com.cognitect.transit.types.isMap,
      set: com.cognitect.transit.types.set,
      isSet: com.cognitect.transit.types.isSet,
      list: com.cognitect.transit.types.list,
      isList: com.cognitect.transit.types.isList,
      quoted: com.cognitect.transit.types.quoted,
      isQuoted: com.cognitect.transit.types.isQuoted,
      tagged: com.cognitect.transit.types.taggedValue,
      isTaggedValue: com.cognitect.transit.types.isTaggedValue,
      link: com.cognitect.transit.types.link,
      isLink: com.cognitect.transit.types.isLink,
      hash: com.cognitect.transit.eq.hashCode,
      hashArrayLike: com.cognitect.transit.eq.hashArrayLike,
      hashMapLike: com.cognitect.transit.eq.hashMapLike,
      equals: com.cognitect.transit.eq.equals,
      extendToEQ: com.cognitect.transit.eq.extendToEQ,
      mapToObject: com.cognitect.transit.mapToObject,
      objectToMap: com.cognitect.transit.objectToMap,
      decoder: com.cognitect.transit.impl.decoder.decoder,
      UUIDfromString: com.cognitect.transit.types.UUIDfromString,
      randomUUID: com.cognitect.transit.util.randomUUID,
      stringableKeys: com.cognitect.transit.impl.writer.stringableKeys,
      readCache: com.cognitect.transit.caching.readCache,
      writeCache: com.cognitect.transit.caching.writeCache
    });
  }
});

// node_modules/recoil-sync/es/index.js
var import_react = __toESM(require_react());
var import_transit_js = __toESM(require_transit());
function err(message) {
  const error = new Error(message);
  if (error.stack === void 0) {
    try {
      throw error;
    } catch (_) {
    }
  }
  return error;
}
var err_1 = err;
var Recoil_err = err_1;
function lazyProxy(base, factories) {
  const proxy = new Proxy(base, {
    // Compute and cache lazy property if not already done.
    get: (target, prop) => {
      if (!(prop in target) && prop in factories) {
        target[prop] = factories[prop]();
      }
      return target[prop];
    },
    // This method allows user to iterate keys as normal
    ownKeys: (target) => {
      return Object.keys(target);
    }
  });
  return proxy;
}
var Recoil_lazyProxy = lazyProxy;
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var {
  DefaultValue,
  RecoilLoadable,
  useRecoilSnapshot,
  useRecoilStoreID,
  useRecoilTransaction_UNSTABLE
} = es_default;
var {
  useCallback,
  useEffect,
  useRef
} = import_react.default;
var DEFAULT_VALUE = new DefaultValue();
function setIntersectsMap(a2, b2) {
  if (a2.size <= b2.size) {
    for (const x of a2) {
      if (b2.has(x)) {
        return true;
      }
    }
  } else {
    for (const x of b2.keys()) {
      if (a2.has(x)) {
        return true;
      }
    }
  }
  return false;
}
var Registries = class {
  constructor() {
    _defineProperty(this, "atomRegistries", /* @__PURE__ */ new Map());
    _defineProperty(this, "nextEffectKey", 0);
    _defineProperty(this, "storageRegistries", /* @__PURE__ */ new Map());
  }
  getAtomRegistry(recoilStoreID, externalStoreKey) {
    if (!this.atomRegistries.has(recoilStoreID)) {
      this.atomRegistries.set(recoilStoreID, /* @__PURE__ */ new Map());
    }
    const storeRegistries = this.atomRegistries.get(recoilStoreID);
    const registry = storeRegistries === null || storeRegistries === void 0 ? void 0 : storeRegistries.get(externalStoreKey);
    if (registry != null) {
      return registry;
    }
    const newRegistry = /* @__PURE__ */ new Map();
    storeRegistries === null || storeRegistries === void 0 ? void 0 : storeRegistries.set(externalStoreKey, newRegistry);
    return newRegistry;
  }
  setAtomEffect(recoilStoreID, externalStoreKey, node, options) {
    var _atomRegistry$get;
    const atomRegistry = this.getAtomRegistry(recoilStoreID, externalStoreKey);
    if (!atomRegistry.has(node.key)) {
      atomRegistry.set(node.key, {
        atom: node,
        effects: /* @__PURE__ */ new Map()
      });
    }
    const effectKey = this.nextEffectKey++;
    const effectRegistration = {
      options,
      subscribedItemKeys: /* @__PURE__ */ new Set([options.itemKey])
    };
    (_atomRegistry$get = atomRegistry.get(node.key)) === null || _atomRegistry$get === void 0 ? void 0 : _atomRegistry$get.effects.set(effectKey, effectRegistration);
    return {
      effectRegistration,
      unregisterEffect: () => {
        var _atomRegistry$get2;
        return void ((_atomRegistry$get2 = atomRegistry.get(node.key)) === null || _atomRegistry$get2 === void 0 ? void 0 : _atomRegistry$get2.effects.delete(effectKey));
      }
    };
  }
  getStorage(recoilStoreID, externalStoreKey) {
    var _this$storageRegistri;
    return (_this$storageRegistri = this.storageRegistries.get(recoilStoreID)) === null || _this$storageRegistri === void 0 ? void 0 : _this$storageRegistri.get(externalStoreKey);
  }
  setStorage(recoilStoreID, externalStoreKey, storage) {
    var _this$storageRegistri2;
    if (!this.storageRegistries.has(recoilStoreID)) {
      this.storageRegistries.set(recoilStoreID, /* @__PURE__ */ new Map());
    }
    (_this$storageRegistri2 = this.storageRegistries.get(recoilStoreID)) === null || _this$storageRegistri2 === void 0 ? void 0 : _this$storageRegistri2.set(externalStoreKey, storage);
    return () => {
      var _this$storageRegistri3;
      return void ((_this$storageRegistri3 = this.storageRegistries.get(recoilStoreID)) === null || _this$storageRegistri3 === void 0 ? void 0 : _this$storageRegistri3.delete(externalStoreKey));
    };
  }
};
var registries = new Registries();
function validateLoadable(input, {
  refine,
  actionOnFailure_UNSTABLE
}) {
  return RecoilLoadable.of(input).map((x) => {
    if (x instanceof DefaultValue) {
      return x;
    }
    const result = refine(x);
    if (result.type === "success") {
      return result.value;
    }
    if (actionOnFailure_UNSTABLE === "defaultValue") {
      return new DefaultValue();
    }
    throw Recoil_err(`[${result.path.toString()}]: ${result.message}`);
  });
}
function readAtomItems(effectRegistration, readFromStorage, diff) {
  const {
    options
  } = effectRegistration;
  const readFromStorageRequired = readFromStorage !== null && readFromStorage !== void 0 ? readFromStorage : (itemKey) => RecoilLoadable.error(`Read functionality not provided for ${options.storeKey != null ? `"${options.storeKey}" ` : ""}store in useRecoilSync() hook while updating item "${itemKey}".`);
  effectRegistration.subscribedItemKeys = /* @__PURE__ */ new Set();
  const read = (itemKey) => {
    effectRegistration.subscribedItemKeys.add(itemKey);
    const value2 = diff !== null && diff !== void 0 && diff.has(itemKey) ? diff === null || diff === void 0 ? void 0 : diff.get(itemKey) : readFromStorageRequired(itemKey);
    if (RecoilLoadable.isLoadable(value2)) {
      const loadable = value2;
      if (loadable.state === "hasError") {
        throw loadable.contents;
      }
    }
    return value2;
  };
  let value;
  try {
    value = options.read({
      read
    });
  } catch (error) {
    return RecoilLoadable.error(error);
  }
  return value instanceof DefaultValue ? null : validateLoadable(value, options);
}
function writeAtomItemsToDiff(diff, options, readFromStorage, loadable) {
  if (loadable != null && (loadable === null || loadable === void 0 ? void 0 : loadable.state) !== "hasValue") {
    return diff;
  }
  const readFromStorageRequired = readFromStorage !== null && readFromStorage !== void 0 ? readFromStorage : (_) => {
    throw Recoil_err(`Read functionality not provided for ${options.storeKey != null ? `"${options.storeKey}" ` : ""}store in useRecoilSync() hook while writing item "${options.itemKey}".`);
  };
  const read = (itemKey) => diff.has(itemKey) ? diff.get(itemKey) : readFromStorageRequired(itemKey);
  const write = (k, l) => void diff.set(k, l);
  const reset = (k) => void diff.set(k, DEFAULT_VALUE);
  options.write({
    write,
    reset,
    read
  }, loadable == null ? DEFAULT_VALUE : loadable.contents);
  return diff;
}
var itemsFromSnapshot = (recoilStoreID, storeKey, getInfo) => {
  const items = /* @__PURE__ */ new Map();
  for (const [, {
    atom,
    effects
  }] of registries.getAtomRegistry(recoilStoreID, storeKey)) {
    for (const [, {
      options
    }] of effects) {
      var _registries$getStorag;
      const atomInfo = getInfo(atom);
      writeAtomItemsToDiff(items, options, (_registries$getStorag = registries.getStorage(recoilStoreID, storeKey)) === null || _registries$getStorag === void 0 ? void 0 : _registries$getStorag.read, atomInfo.isSet || options.syncDefault === true ? atomInfo.loadable : null);
    }
  }
  return items;
};
function getWriteInterface(recoilStoreID, storeKey, diff, getInfo) {
  return Recoil_lazyProxy({
    diff
  }, {
    allItems: () => itemsFromSnapshot(recoilStoreID, storeKey, getInfo)
  });
}
function useRecoilSync({
  storeKey,
  write,
  read,
  listen
}) {
  const recoilStoreID = useRecoilStoreID();
  const snapshot = useRecoilSnapshot();
  const previousSnapshotRef = useRef(snapshot);
  useEffect(() => {
    if (write != null && snapshot !== previousSnapshotRef.current) {
      previousSnapshotRef.current = snapshot;
      const diff = /* @__PURE__ */ new Map();
      const atomRegistry = registries.getAtomRegistry(recoilStoreID, storeKey);
      const modifiedAtoms = snapshot.getNodes_UNSTABLE({
        isModified: true
      });
      for (const atom of modifiedAtoms) {
        const registration = atomRegistry.get(atom.key);
        if (registration != null) {
          var _atomInfo$loadable, _registration$pending, _registration$pending2;
          const atomInfo = snapshot.getInfo_UNSTABLE(registration.atom);
          if (atomInfo.isSet && ((_atomInfo$loadable = atomInfo.loadable) === null || _atomInfo$loadable === void 0 ? void 0 : _atomInfo$loadable.contents) !== ((_registration$pending = registration.pendingUpdate) === null || _registration$pending === void 0 ? void 0 : _registration$pending.value) || !atomInfo.isSet && !(((_registration$pending2 = registration.pendingUpdate) === null || _registration$pending2 === void 0 ? void 0 : _registration$pending2.value) instanceof DefaultValue)) {
            for (const [, {
              options
            }] of registration.effects) {
              writeAtomItemsToDiff(diff, options, read, atomInfo.isSet || options.syncDefault === true ? atomInfo.loadable : null);
            }
          }
          delete registration.pendingUpdate;
        }
      }
      if (diff.size) {
        write(getWriteInterface(recoilStoreID, storeKey, diff, snapshot.getInfo_UNSTABLE));
      }
    }
  }, [read, recoilStoreID, snapshot, storeKey, write]);
  const updateItems = useRecoilTransaction_UNSTABLE(({
    set: set2,
    reset
  }) => (diff) => {
    const atomRegistry = registries.getAtomRegistry(recoilStoreID, storeKey);
    for (const [, atomRegistration] of atomRegistry) {
      for (const [, effectRegistration] of Array.from(atomRegistration.effects).reverse()) {
        const {
          options,
          subscribedItemKeys
        } = effectRegistration;
        if (setIntersectsMap(subscribedItemKeys, diff)) {
          const loadable = readAtomItems(effectRegistration, read, diff);
          if (loadable != null) {
            switch (loadable.state) {
              case "hasValue":
                if (loadable.contents instanceof DefaultValue) {
                  atomRegistration.pendingUpdate = {
                    value: DEFAULT_VALUE
                  };
                  reset(atomRegistration.atom);
                } else {
                  atomRegistration.pendingUpdate = {
                    value: loadable.contents
                  };
                  set2(atomRegistration.atom, loadable.contents);
                }
                break;
              case "hasError":
                if (options.actionOnFailure_UNSTABLE === "errorState") {
                  atomRegistration.pendingUpdate = {
                    value: DEFAULT_VALUE
                  };
                  reset(atomRegistration.atom);
                }
                break;
              case "loading":
                throw Recoil_err("Recoil does not yet support setting atoms to an asynchronous state");
            }
            break;
          } else {
            atomRegistration.pendingUpdate = {
              value: DEFAULT_VALUE
            };
            reset(atomRegistration.atom);
          }
        }
      }
    }
  }, [recoilStoreID, storeKey, read]);
  const updateItem = useCallback((itemKey, newValue) => {
    updateItems(/* @__PURE__ */ new Map([[itemKey, newValue]]));
  }, [updateItems]);
  const updateAllKnownItems = useCallback((itemSnapshot) => {
    const atomRegistry = registries.getAtomRegistry(recoilStoreID, storeKey);
    for (const [, registration] of atomRegistry) {
      for (const [, {
        subscribedItemKeys
      }] of registration.effects) {
        for (const itemKey of subscribedItemKeys) {
          if (!itemSnapshot.has(itemKey)) {
            itemSnapshot.set(itemKey, DEFAULT_VALUE);
          }
        }
      }
    }
    updateItems(itemSnapshot);
  }, [recoilStoreID, storeKey, updateItems]);
  useEffect(() => (
    // TODO try/catch errors and set atom to error state if actionOnFailure is errorState
    listen === null || listen === void 0 ? void 0 : listen({
      updateItem,
      updateItems,
      updateAllKnownItems
    })
  ), [updateItem, updateItems, updateAllKnownItems, listen]);
  registries.setStorage(recoilStoreID, storeKey, {
    write,
    read
  });
  useEffect(() => registries.setStorage(recoilStoreID, storeKey, {
    write,
    read
  }), [recoilStoreID, storeKey, read, write]);
}
function RecoilSync({
  children,
  ...props
}) {
  useRecoilSync(props);
  return children;
}
function syncEffect(opt) {
  return ({
    node,
    trigger,
    storeID,
    setSelf,
    getLoadable,
    getInfo_UNSTABLE
  }) => {
    var _opt$itemKey;
    const itemKey = (_opt$itemKey = opt.itemKey) !== null && _opt$itemKey !== void 0 ? _opt$itemKey : node.key;
    const options = {
      itemKey,
      read: ({
        read
      }) => read(itemKey),
      write: ({
        write
      }, loadable) => write(itemKey, loadable),
      syncDefault: false,
      actionOnFailure_UNSTABLE: "errorState",
      ...opt
    };
    const {
      storeKey
    } = options;
    const storage = registries.getStorage(storeID, storeKey);
    const {
      effectRegistration,
      unregisterEffect
    } = registries.setAtomEffect(storeID, storeKey, node, options);
    if (trigger === "get") {
      const readFromStorage = storage === null || storage === void 0 ? void 0 : storage.read;
      if (readFromStorage != null) {
        try {
          const loadable = readAtomItems(effectRegistration, readFromStorage);
          if (loadable != null) {
            switch (loadable.state) {
              case "hasValue":
                if (!(loadable.contents instanceof DefaultValue)) {
                  setSelf(loadable.contents);
                }
                break;
              case "hasError":
                if (options.actionOnFailure_UNSTABLE === "errorState") {
                  throw loadable.contents;
                }
                break;
              case "loading":
                setSelf(loadable.toPromise());
                break;
            }
          }
        } catch (error) {
          if (options.actionOnFailure_UNSTABLE === "errorState") {
            throw error;
          }
        }
      }
      const writeToStorage = storage === null || storage === void 0 ? void 0 : storage.write;
      if (options.syncDefault === true && writeToStorage != null) {
        window.setTimeout(() => {
          const loadable = getLoadable(node);
          if (loadable.state === "hasValue") {
            const diff = writeAtomItemsToDiff(/* @__PURE__ */ new Map(), options, storage === null || storage === void 0 ? void 0 : storage.read, loadable);
            writeToStorage(getWriteInterface(storeID, storeKey, diff, getInfo_UNSTABLE));
          }
        }, 0);
      }
    }
    return unregisterEffect;
  };
}
var RecoilSync_1 = {
  useRecoilSync,
  RecoilSync,
  syncEffect,
  registries_FOR_TESTING: registries
};
var RecoilSync_2 = RecoilSync_1.useRecoilSync;
var RecoilSync_3 = RecoilSync_1.RecoilSync;
var RecoilSync_4 = RecoilSync_1.syncEffect;
var RecoilSync_5 = RecoilSync_1.registries_FOR_TESTING;
var RecoilSync$1 = Object.freeze({
  __proto__: null,
  useRecoilSync: RecoilSync_2,
  RecoilSync: RecoilSync_3,
  syncEffect: RecoilSync_4,
  registries_FOR_TESTING: RecoilSync_5
});
function raiseError(suffix, resultFailure) {
  if (resultFailure != null) {
    const path = resultFailure.path.toString();
    const message = resultFailure.message;
    throw Recoil_err(`[refine.js (path=${path}, message=${message})]: ${suffix}`);
  }
  throw Recoil_err(`[refine.js (null result)]: ${suffix}`);
}
function assertion(checker, errorMessage = "assertion error") {
  return (value) => {
    const result = checker(value);
    return result.type === "success" ? result.value : raiseError(errorMessage, result);
  };
}
function coercion(checker, onResult) {
  return (value) => {
    const result = checker(value);
    if (onResult != null) {
      onResult(result);
    }
    return result.type === "success" ? result.value : null;
  };
}
var Refine_API = {
  assertion,
  coercion
};
var Path = class _Path {
  constructor(parent = null, field = "<root>") {
    _defineProperty(this, "parent", void 0);
    _defineProperty(this, "field", void 0);
    this.parent = parent;
    this.field = field;
  }
  // Method to extend path by a field while traversing a container
  extend(field) {
    return new _Path(this, field);
  }
  toString() {
    const pieces = [];
    let current = this;
    while (current != null) {
      const {
        field,
        parent
      } = current;
      pieces.push(field);
      current = parent;
    }
    return pieces.reverse().join("");
  }
};
function success(value, warnings) {
  return {
    type: "success",
    value,
    warnings
  };
}
function failure(message, path) {
  return {
    type: "failure",
    message,
    path
  };
}
function compose(checker, next) {
  return (value, path = new Path()) => {
    const result = checker(value, path);
    return result.type === "failure" ? result : next(result, path);
  };
}
var Refine_Checkers = {
  Path,
  success,
  failure,
  compose
};
var Refine_Checkers_1 = Refine_Checkers.Path;
var Refine_Checkers_2 = Refine_Checkers.success;
var Refine_Checkers_3 = Refine_Checkers.failure;
var Refine_Checkers_4 = Refine_Checkers.compose;
var Refine_Checkers$1 = Object.freeze({
  __proto__: null,
  Path: Refine_Checkers_1,
  success: Refine_Checkers_2,
  failure: Refine_Checkers_3,
  compose: Refine_Checkers_4
});
var {
  Path: Path$1,
  compose: compose$1,
  failure: failure$1,
  success: success$1
} = Refine_Checkers$1;
function isPlainObject(value) {
  if (Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
}
function array(valueChecker) {
  return (value, path = new Path$1()) => {
    if (!Array.isArray(value)) {
      return failure$1("value is not an array", path);
    }
    const len = value.length;
    const out = new Array(len);
    const warnings = [];
    for (let i = 0; i < len; i++) {
      const element = value[i];
      const result = valueChecker(element, path.extend(`[${i}]`));
      if (result.type === "failure") {
        return failure$1(result.message, result.path);
      }
      out[i] = result.value;
      if (result.warnings.length !== 0) {
        warnings.push(...result.warnings);
      }
    }
    return success$1(out, warnings);
  };
}
function tuple(...checkers) {
  return (value, path = new Path$1()) => {
    if (!Array.isArray(value)) {
      return failure$1("value is not an array", path);
    }
    const out = new Array(checkers.length);
    const warnings = [];
    for (const [i, checker] of checkers.entries()) {
      const result = checker(value[i], path.extend(`[${i}]`));
      if (result.type === "failure") {
        return failure$1(result.message, result.path);
      }
      out[i] = result.value;
      if (result.warnings.length !== 0) {
        warnings.push(...result.warnings);
      }
    }
    return success$1(out, warnings);
  };
}
function dict(valueChecker) {
  return (value, path = new Path$1()) => {
    if (typeof value !== "object" || value === null || !isPlainObject(value)) {
      return failure$1("value is not an object", path);
    }
    const out = {};
    const warnings = [];
    for (const [key, element] of Object.entries(value)) {
      const result = valueChecker(element, path.extend(`.${key}`));
      if (result.type === "failure") {
        return failure$1(result.message, result.path);
      }
      out[key] = result.value;
      if (result.warnings.length !== 0) {
        warnings.push(...result.warnings);
      }
    }
    return success$1(out, warnings);
  };
}
var OptionalProperty = class {
  constructor(checker) {
    _defineProperty(this, "checker", void 0);
    this.checker = checker;
  }
};
function optional(checker) {
  return new OptionalProperty((value, path = new Path$1()) => {
    const result = checker(value, path);
    if (result.type === "failure") {
      return {
        ...result,
        message: "(optional property) " + result.message
      };
    } else {
      return result;
    }
  });
}
function object(checkers) {
  const checkerProperties = Object.keys(checkers);
  return (value, path = new Path$1()) => {
    if (typeof value !== "object" || value === null || !isPlainObject(value)) {
      return failure$1("value is not an object", path);
    }
    const out = {};
    const warnings = [];
    for (const key of checkerProperties) {
      const provided = checkers[key];
      let check;
      let element;
      if (provided instanceof OptionalProperty) {
        check = provided.checker;
        if (!value.hasOwnProperty(key)) {
          continue;
        }
        element = value[key];
      } else {
        check = provided;
        element = value.hasOwnProperty(key) ? value[key] : void 0;
      }
      const result = check(element, path.extend(`.${key}`));
      if (result.type === "failure") {
        return failure$1(result.message, result.path);
      }
      out[key] = result.value;
      if (result.warnings.length !== 0) {
        warnings.push(...result.warnings);
      }
    }
    return success$1(out, warnings);
  };
}
function set(checker) {
  return (value, path = new Path$1()) => {
    if (!(value instanceof Set)) {
      return failure$1("value is not a Set", path);
    }
    const out = /* @__PURE__ */ new Set();
    const warnings = [];
    for (const item of value) {
      const result = checker(item, path.extend("[]"));
      if (result.type === "failure") {
        return failure$1(result.message, result.path);
      }
      out.add(result.value);
      if (result.warnings.length) {
        warnings.push(...result.warnings);
      }
    }
    return success$1(out, warnings);
  };
}
function map(keyChecker, valueChecker) {
  return (value, path = new Path$1()) => {
    if (!(value instanceof Map)) {
      return failure$1("value is not a Map", path);
    }
    const out = /* @__PURE__ */ new Map();
    const warnings = [];
    for (const [k, v] of value.entries()) {
      const keyResult = keyChecker(k, path.extend(`[${k}] key`));
      if (keyResult.type === "failure") {
        return failure$1(keyResult.message, keyResult.path);
      }
      const valueResult = valueChecker(v, path.extend(`[${k}]`));
      if (valueResult.type === "failure") {
        return failure$1(valueResult.message, valueResult.path);
      }
      out.set(k, v);
      warnings.push(...keyResult.warnings, ...valueResult.warnings);
    }
    return success$1(out, warnings);
  };
}
function writableArray(valueChecker) {
  return compose$1(array(valueChecker), ({
    value,
    warnings
  }) => success$1([...value], warnings));
}
function writableDict(valueChecker) {
  return compose$1(dict(valueChecker), ({
    value,
    warnings
  }) => success$1({
    ...value
  }, warnings));
}
function writableObject(checkers) {
  return compose$1(object(checkers), ({
    value,
    warnings
  }) => success$1({
    ...value
  }, warnings));
}
var Refine_ContainerCheckers = {
  array,
  tuple,
  object,
  optional,
  dict,
  set,
  map,
  writableArray,
  writableDict,
  writableObject
};
var Refine_ContainerCheckers_1 = Refine_ContainerCheckers.array;
var Refine_ContainerCheckers_2 = Refine_ContainerCheckers.tuple;
var Refine_ContainerCheckers_3 = Refine_ContainerCheckers.object;
var Refine_ContainerCheckers_4 = Refine_ContainerCheckers.optional;
var Refine_ContainerCheckers_5 = Refine_ContainerCheckers.dict;
var Refine_ContainerCheckers_6 = Refine_ContainerCheckers.set;
var Refine_ContainerCheckers_7 = Refine_ContainerCheckers.map;
var Refine_ContainerCheckers_8 = Refine_ContainerCheckers.writableArray;
var Refine_ContainerCheckers_9 = Refine_ContainerCheckers.writableDict;
var Refine_ContainerCheckers_10 = Refine_ContainerCheckers.writableObject;
var Refine_ContainerCheckers$1 = Object.freeze({
  __proto__: null,
  array: Refine_ContainerCheckers_1,
  tuple: Refine_ContainerCheckers_2,
  object: Refine_ContainerCheckers_3,
  optional: Refine_ContainerCheckers_4,
  dict: Refine_ContainerCheckers_5,
  set: Refine_ContainerCheckers_6,
  map: Refine_ContainerCheckers_7,
  writableArray: Refine_ContainerCheckers_8,
  writableDict: Refine_ContainerCheckers_9,
  writableObject: Refine_ContainerCheckers_10
});
var {
  assertion: assertion$1
} = Refine_API;
function tryParseJSONMixed(text, reviver) {
  if (text == null) {
    return null;
  }
  try {
    return JSON.parse(text, reviver);
  } catch {
    return null;
  }
}
function jsonParserEnforced(checker, suffix) {
  const assertedChecker = assertion$1(checker, suffix !== null && suffix !== void 0 ? suffix : "value is invalid");
  return (rawJSON) => {
    return assertedChecker(tryParseJSONMixed(rawJSON !== null && rawJSON !== void 0 ? rawJSON : ""));
  };
}
function jsonParser(checker) {
  return (rawJSON) => {
    const result = checker(tryParseJSONMixed(rawJSON));
    return result.type === "success" ? result.value : null;
  };
}
var Refine_JSON = {
  jsonParserEnforced,
  jsonParser
};
var {
  Path: Path$2,
  compose: compose$2,
  failure: failure$2,
  success: success$2
} = Refine_Checkers$1;
function mixed() {
  return MIXED_CHECKER;
}
var MIXED_CHECKER = (value) => success$2(value, []);
function literal(literalValue) {
  const str = (value) => JSON.stringify(value);
  return (value, path = new Path$2()) => {
    var _str;
    return value === literalValue ? success$2(literalValue, []) : failure$2(`value is not literal ${(_str = str(literalValue)) !== null && _str !== void 0 ? _str : "void"}`, path);
  };
}
function bool() {
  return (value, path = new Path$2()) => typeof value === "boolean" ? success$2(value, []) : failure$2("value is not a boolean", path);
}
function number() {
  return (value, path = new Path$2()) => typeof value === "number" ? success$2(value, []) : failure$2("value is not a number", path);
}
function string(regex) {
  return (value, path = new Path$2()) => {
    if (typeof value !== "string") {
      return failure$2("value is not a string", path);
    }
    if (regex != null && !regex.test(value)) {
      return failure$2(`value does not match regex: ${regex.toString()}`, path);
    }
    return success$2(value, []);
  };
}
function stringLiterals(enumValues) {
  return (value, path = new Path$2()) => {
    if (typeof value !== "string") {
      return failure$2("value must be a string", path);
    }
    const out = enumValues[value];
    if (out == null) {
      return failure$2(`value is not one of ${Object.keys(enumValues).join(", ")}`, path);
    }
    return success$2(out, []);
  };
}
function enumObject(enumObj) {
  const enumValues = Object.keys(enumObj).reduce((res, key) => Object.assign(res, {
    [enumObj[key]]: enumObj[key]
  }), {});
  const stringLiteralsChecker = stringLiterals(enumValues);
  return (rawValue, path = new Path$2()) => {
    const value = typeof rawValue === "number" ? rawValue.toString() : rawValue;
    const result = stringLiteralsChecker(value, path);
    if (result.type === "success" && typeof result.value !== typeof rawValue) {
      return failure$2("input must be the same type as the enum values", path);
    }
    return result;
  };
}
function date() {
  return (value, path = new Path$2()) => {
    if (!(value instanceof Date)) {
      return failure$2("value is not a date", path);
    }
    if (isNaN(value)) {
      return failure$2("invalid date", path);
    }
    return success$2(value, []);
  };
}
function jsonDate() {
  return compose$2(string(), ({
    value,
    warnings
  }, path) => {
    const parsedDate = new Date(value);
    return Number.isNaN(parsedDate) ? failure$2("value is not valid date string", path) : success$2(parsedDate, warnings);
  });
}
var Refine_PrimitiveCheckers = {
  mixed,
  literal,
  bool,
  number,
  string,
  stringLiterals,
  date,
  jsonDate,
  enumObject
};
var {
  Path: Path$3,
  compose: compose$3,
  failure: failure$3,
  success: success$3
} = Refine_Checkers$1;
function asType(checker, cast) {
  return compose$3(checker, ({
    value,
    warnings
  }) => success$3(cast(value), warnings));
}
function unionFailure(message, path, failures) {
  return failure$3(`${message}: ${failures.map((f2) => f2.message).join(", ")}`, path);
}
function or(aChecker, bChecker) {
  return (value, path = new Path$3()) => {
    const a2 = aChecker(value, path);
    if (a2.type === "success") {
      return success$3(a2.value, a2.warnings);
    }
    const b2 = bChecker(value, path);
    if (b2.type === "success") {
      return success$3(b2.value, b2.warnings);
    }
    return unionFailure("value did not match any types in or()", path, [a2, b2]);
  };
}
function union(...checkers) {
  return (value, path = new Path$3()) => {
    const failures = [];
    for (const checker of checkers) {
      const result = checker(value, path);
      if (result.type === "success") {
        return success$3(result.value, result.warnings);
      }
      failures.push(result);
    }
    return unionFailure("value did not match any types in union", path, failures);
  };
}
function match(...checkers) {
  return union(...checkers);
}
function nullable(checker, options) {
  const {
    nullWithWarningWhenInvalid = false
  } = options !== null && options !== void 0 ? options : {};
  return (value, parentPath = new Path$3()) => {
    if (value == null) {
      return success$3(value, []);
    }
    const result = checker(value, parentPath);
    if (result.type === "success") {
      return success$3(result.value, result.warnings);
    }
    if (nullWithWarningWhenInvalid) {
      return success$3(null, [result]);
    }
    const {
      message,
      path
    } = result;
    return failure$3(message, path);
  };
}
function voidable(checker, options) {
  const {
    undefinedWithWarningWhenInvalid = false
  } = options !== null && options !== void 0 ? options : {};
  return (value, parentPath = new Path$3()) => {
    if (value === void 0) {
      return success$3(void 0, []);
    }
    const result = checker(value, parentPath);
    if (result.type === "success") {
      return success$3(result.value, result.warnings);
    }
    if (undefinedWithWarningWhenInvalid) {
      return success$3(void 0, [result]);
    }
    const {
      message,
      path
    } = result;
    return failure$3(message, path);
  };
}
function withDefault(checker, fallback) {
  return (value, path = new Path$3()) => {
    if (value == null) {
      return success$3(fallback, []);
    }
    const result = checker(value, path);
    return result.type === "failure" || result.value != null ? result : success$3(fallback, []);
  };
}
function constraint(checker, predicate) {
  return compose$3(checker, ({
    value,
    warnings
  }, path) => {
    const result = predicate(value);
    const [passed, message] = typeof result === "boolean" ? [result, "value failed constraint check"] : result;
    return passed ? success$3(value, warnings) : failure$3(message, path);
  });
}
function lazy(getChecker) {
  return (value, path = new Path$3()) => {
    const checker = getChecker();
    return checker(value, path);
  };
}
function custom(checkValue, failureMessage = `failed to return non-null from custom checker.`) {
  return (value, path = new Path$3()) => {
    try {
      const checked = checkValue(value);
      return checked != null ? success$3(checked, []) : failure$3(failureMessage, path);
    } catch (error) {
      return failure$3(error.message, path);
    }
  };
}
var Refine_UtilityCheckers = {
  or,
  union,
  match,
  nullable,
  voidable,
  withDefault,
  constraint,
  asType,
  lazy,
  custom
};
var {
  assertion: assertion$2,
  coercion: coercion$1
} = Refine_API;
var {
  Path: Path$4
} = Refine_Checkers$1;
var {
  array: array$1,
  dict: dict$1,
  map: map$1,
  object: object$1,
  optional: optional$1,
  set: set$1,
  tuple: tuple$1,
  writableArray: writableArray$1,
  writableDict: writableDict$1,
  writableObject: writableObject$1
} = Refine_ContainerCheckers$1;
var {
  jsonParser: jsonParser$1,
  jsonParserEnforced: jsonParserEnforced$1
} = Refine_JSON;
var {
  bool: bool$1,
  date: date$1,
  enumObject: enumObject$1,
  jsonDate: jsonDate$1,
  literal: literal$1,
  mixed: mixed$1,
  number: number$1,
  string: string$1,
  stringLiterals: stringLiterals$1
} = Refine_PrimitiveCheckers;
var {
  asType: asType$1,
  constraint: constraint$1,
  custom: custom$1,
  lazy: lazy$1,
  match: match$1,
  nullable: nullable$1,
  or: or$1,
  union: union$1,
  voidable: voidable$1,
  withDefault: withDefault$1
} = Refine_UtilityCheckers;
var Refine_index = {
  // API
  assertion: assertion$2,
  coercion: coercion$1,
  jsonParser: jsonParser$1,
  jsonParserEnforced: jsonParserEnforced$1,
  Path: Path$4,
  // Checkers - Primitives
  mixed: mixed$1,
  literal: literal$1,
  bool: bool$1,
  number: number$1,
  string: string$1,
  stringLiterals: stringLiterals$1,
  enumObject: enumObject$1,
  date: date$1,
  jsonDate: jsonDate$1,
  // Checkers - Utility
  asType: asType$1,
  or: or$1,
  union: union$1,
  match: match$1,
  nullable: nullable$1,
  voidable: voidable$1,
  withDefault: withDefault$1,
  constraint: constraint$1,
  lazy: lazy$1,
  custom: custom$1,
  // Checkers - Containers
  array: array$1,
  tuple: tuple$1,
  dict: dict$1,
  object: object$1,
  optional: optional$1,
  set: set$1,
  map: map$1,
  writableArray: writableArray$1,
  writableDict: writableDict$1,
  writableObject: writableObject$1
};
var {
  DefaultValue: DefaultValue$1,
  RecoilLoadable: RecoilLoadable$1
} = es_default;
var {
  syncEffect: syncEffect$1,
  useRecoilSync: useRecoilSync$1
} = RecoilSync$1;
var {
  useCallback: useCallback$1,
  useEffect: useEffect$1,
  useMemo,
  useRef: useRef$1
} = import_react.default;
var {
  assertion: assertion$3,
  mixed: mixed$2,
  writableDict: writableDict$2
} = Refine_index;
var registries$1 = /* @__PURE__ */ new Map();
var itemStateChecker = writableDict$2(mixed$2());
var refineState = assertion$3(itemStateChecker);
var wrapState = (x) => {
  return new Map(Array.from(Object.entries(refineState(x))));
};
var unwrapState = (state) => Object.fromEntries(Array.from(state.entries()).filter(([, value]) => !(value instanceof DefaultValue$1)));
function parseURL(href, loc, deserialize) {
  const url = new URL(href);
  switch (loc.part) {
    case "href":
      return wrapState(deserialize(`${url.pathname}${url.search}${url.hash}`));
    case "hash":
      return url.hash ? wrapState(deserialize(decodeURIComponent(url.hash.substr(1)))) : null;
    case "search":
      return url.search ? wrapState(deserialize(decodeURIComponent(url.search.substr(1)))) : null;
    case "queryParams": {
      const searchParams = new URLSearchParams(url.search);
      const {
        param
      } = loc;
      if (param != null) {
        const stateStr = searchParams.get(param);
        return stateStr != null ? wrapState(deserialize(stateStr)) : /* @__PURE__ */ new Map();
      }
      return new Map(Array.from(searchParams.entries()).map(([key, value]) => {
        try {
          return [key, deserialize(value)];
        } catch (error) {
          return [key, RecoilLoadable$1.error(error)];
        }
      }));
    }
  }
  throw Recoil_err(`Unknown URL location part: "${loc.part}"`);
}
function encodeURL(href, loc, items, serialize) {
  const url = new URL(href);
  switch (loc.part) {
    case "href":
      return serialize(unwrapState(items));
    case "hash":
      url.hash = encodeURIComponent(serialize(unwrapState(items)));
      break;
    case "search":
      url.search = encodeURIComponent(serialize(unwrapState(items)));
      break;
    case "queryParams": {
      const {
        param
      } = loc;
      const searchParams = new URLSearchParams(url.search);
      if (param != null) {
        searchParams.set(param, serialize(unwrapState(items)));
      } else {
        for (const [itemKey, value] of items.entries()) {
          value instanceof DefaultValue$1 ? searchParams.delete(itemKey) : searchParams.set(itemKey, serialize(value));
        }
      }
      url.search = searchParams.toString();
      break;
    }
    default:
      throw Recoil_err(`Unknown URL location part: "${loc.part}"`);
  }
  return url.href;
}
var DEFAULT_BROWSER_INTERFACE = {
  replaceURL: (url) => history.replaceState(null, "", url),
  pushURL: (url) => history.pushState(null, "", url),
  getURL: () => window.document.location,
  listenChangeURL: (handleUpdate) => {
    window.addEventListener("popstate", handleUpdate);
    return () => window.removeEventListener("popstate", handleUpdate);
  }
};
function RecoilURLSync({
  storeKey,
  location: loc,
  serialize,
  deserialize,
  browserInterface,
  children
}) {
  const {
    getURL,
    replaceURL,
    pushURL,
    listenChangeURL
  } = {
    ...DEFAULT_BROWSER_INTERFACE,
    ...browserInterface !== null && browserInterface !== void 0 ? browserInterface : {}
  };
  const memoizedLoc = useMemo(
    () => loc,
    // Complications with disjoint uniont
    // $FlowIssue[prop-missing]
    [loc.part, loc.queryParam]
    // eslint-disable-line fb-www/react-hooks-deps
  );
  const updateCachedState = useCallback$1(() => {
    cachedState.current = parseURL(getURL(), memoizedLoc, deserialize);
  }, [getURL, memoizedLoc, deserialize]);
  const cachedState = useRef$1(null);
  const firstRender = useRef$1(true);
  firstRender.current && updateCachedState();
  firstRender.current = false;
  useEffect$1(updateCachedState, [updateCachedState]);
  const write = useCallback$1(({
    diff,
    allItems
  }) => {
    updateCachedState();
    const atomRegistry = registries$1.get(storeKey);
    const itemsToPush = atomRegistry != null ? new Set(Array.from(atomRegistry).filter(([, {
      history: history2,
      itemKeys
    }]) => history2 === "push" && Array.from(itemKeys).some((key) => diff.has(key))).map(([, {
      itemKeys
    }]) => itemKeys).reduce((itemKeys, keys) => itemKeys.concat(Array.from(keys)), [])) : null;
    if (itemsToPush !== null && itemsToPush !== void 0 && itemsToPush.size && cachedState.current != null) {
      const replaceItems = cachedState.current;
      for (const [key, value] of allItems) {
        if (!itemsToPush.has(key)) {
          replaceItems.set(key, value);
        }
      }
      replaceURL(encodeURL(getURL(), loc, replaceItems, serialize));
      pushURL(encodeURL(getURL(), loc, allItems, serialize));
    } else {
      replaceURL(encodeURL(getURL(), loc, allItems, serialize));
    }
    cachedState.current = allItems;
  }, [getURL, loc, pushURL, replaceURL, serialize, storeKey, updateCachedState]);
  const read = useCallback$1((itemKey) => {
    var _cachedState$current, _cachedState$current2;
    return (_cachedState$current = cachedState.current) !== null && _cachedState$current !== void 0 && _cachedState$current.has(itemKey) ? (_cachedState$current2 = cachedState.current) === null || _cachedState$current2 === void 0 ? void 0 : _cachedState$current2.get(itemKey) : new DefaultValue$1();
  }, []);
  const listen = useCallback$1(({
    updateAllKnownItems
  }) => {
    function handleUpdate() {
      updateCachedState();
      if (cachedState.current != null) {
        updateAllKnownItems(cachedState.current);
      }
    }
    return listenChangeURL(handleUpdate);
  }, [listenChangeURL, updateCachedState]);
  useRecoilSync$1({
    storeKey,
    read,
    write,
    listen
  });
  return children;
}
function urlSyncEffect({
  history: history2 = "replace",
  ...options
}) {
  const atomEffect = syncEffect$1(options);
  return (effectArgs) => {
    var _options$itemKey;
    if (!registries$1.has(options.storeKey)) {
      registries$1.set(options.storeKey, /* @__PURE__ */ new Map());
    }
    const atomRegistry = registries$1.get(options.storeKey);
    if (atomRegistry == null) {
      throw Recoil_err("Error with atom registration");
    }
    atomRegistry.set(effectArgs.node.key, {
      history: history2,
      itemKeys: /* @__PURE__ */ new Set([(_options$itemKey = options.itemKey) !== null && _options$itemKey !== void 0 ? _options$itemKey : effectArgs.node.key])
    });
    const cleanup = atomEffect(effectArgs);
    return () => {
      atomRegistry.delete(effectArgs.node.key);
      cleanup === null || cleanup === void 0 ? void 0 : cleanup();
    };
  };
}
var RecoilSync_URL = {
  RecoilURLSync,
  urlSyncEffect
};
function nullthrows(x, message) {
  if (x != null) {
    return x;
  }
  throw Recoil_err(message !== null && message !== void 0 ? message : "Got unexpected null or undefined");
}
var Recoil_nullthrows = nullthrows;
var {
  RecoilURLSync: RecoilURLSync$1
} = RecoilSync_URL;
var {
  useCallback: useCallback$2
} = import_react.default;
function RecoilURLSyncJSON(options) {
  if (options.location.part === "href") {
    throw Recoil_err('"href" location is not supported for JSON encoding');
  }
  const serialize = useCallback$2((x) => x === void 0 ? "" : Recoil_nullthrows(JSON.stringify(x), "Unable to serialize state with JSON"), []);
  const deserialize = useCallback$2((x) => JSON.parse(x), []);
  return import_react.default.createElement(RecoilURLSync$1, _extends({}, options, {
    serialize,
    deserialize
  }));
}
var RecoilSync_URLJSON = {
  RecoilURLSyncJSON
};
var RecoilSync_URLJSON_1 = RecoilSync_URLJSON.RecoilURLSyncJSON;
var RecoilSync_URLJSON$1 = Object.freeze({
  __proto__: null,
  RecoilURLSyncJSON: RecoilSync_URLJSON_1
});
function sprintf(format, ...args) {
  let index = 0;
  return format.replace(/%s/g, () => String(args[index++]));
}
var sprintf_1 = sprintf;
function expectationViolation(format, ...args) {
  if (true) {
    const message = sprintf_1.call(null, format, ...args);
    const error = new Error(message);
    error.name = "Expectation Violation";
    console.error(error);
  }
}
var expectationViolation_1 = expectationViolation;
var Recoil_expectationViolation = expectationViolation_1;
var {
  useEffect: useEffect$2,
  useRef: useRef$2
} = import_react.default;
function usePrevious(value) {
  const ref = useRef$2();
  useEffect$2(() => {
    ref.current = value;
  });
  return ref.current;
}
var Recoil_usePrevious = usePrevious;
var {
  DefaultValue: DefaultValue$2
} = es_default;
var {
  RecoilURLSync: RecoilURLSync$2
} = RecoilSync_URL;
var {
  useCallback: useCallback$3,
  useEffect: useEffect$3,
  useMemo: useMemo$1
} = import_react.default;
var BUILTIN_HANDLERS = [{
  tag: "Date",
  class: Date,
  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by
   * Flow's LTI update could not be added via codemod */
  write: (x) => x.toISOString(),
  read: (str) => new Date(str)
}, {
  tag: "Set",
  class: Set,
  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by
   * Flow's LTI update could not be added via codemod */
  write: (x) => Array.from(x),
  read: (arr) => new Set(arr)
}, {
  tag: "Map",
  class: Map,
  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by
   * Flow's LTI update could not be added via codemod */
  write: (x) => Array.from(x.entries()),
  read: (arr) => new Map(arr)
}, {
  tag: "__DV",
  class: DefaultValue$2,
  write: () => 0,
  // number encodes the smallest in URL
  read: () => new DefaultValue$2()
}];
function RecoilURLSyncTransit({
  handlers: handlersProp,
  ...options
}) {
  if (options.location.part === "href") {
    throw Recoil_err('"href" location is not supported for Transit encoding');
  }
  const previousHandlers = Recoil_usePrevious(handlersProp);
  useEffect$3(() => {
    if (true) {
      if (previousHandlers != null && previousHandlers !== handlersProp) {
        const message = `<RecoilURLSyncTransit> 'handlers' prop was detected to be unstable.
          It is important that this is a stable or memoized array instance.
          Otherwise you may miss URL changes as the listener is re-subscribed.
        `;
        Recoil_expectationViolation(message);
      }
    }
  }, [previousHandlers, handlersProp]);
  const handlers = useMemo$1(() => [...BUILTIN_HANDLERS, ...handlersProp !== null && handlersProp !== void 0 ? handlersProp : []], [handlersProp]);
  const writer = useMemo$1(() => import_transit_js.default.writer("json", {
    handlers: import_transit_js.default.map(handlers.map((handler) => [handler.class, import_transit_js.default.makeWriteHandler({
      tag: () => handler.tag,
      rep: handler.write
    })]).flat(1))
  }), [handlers]);
  const serialize = useCallback$3((x) => writer.write(x), [writer]);
  const reader = useMemo$1(() => import_transit_js.default.reader("json", {
    handlers: handlers.reduce((c2, {
      tag,
      read
    }) => {
      c2[tag] = read;
      return c2;
    }, {}),
    mapBuilder: {
      init: () => ({}),
      add: (ret, key, val) => {
        ret[key] = val;
        return ret;
      },
      finalize: (ret) => ret
    }
  }), [handlers]);
  const deserialize = useCallback$3((x) => reader.read(x), [reader]);
  return import_react.default.createElement(RecoilURLSync$2, _extends({}, options, {
    serialize,
    deserialize
  }));
}
var RecoilSync_URLTransit = {
  RecoilURLSyncTransit
};
var RecoilSync_URLTransit_1 = RecoilSync_URLTransit.RecoilURLSyncTransit;
var RecoilSync_URLTransit$1 = Object.freeze({
  __proto__: null,
  RecoilURLSyncTransit: RecoilSync_URLTransit_1
});
var {
  RecoilSync: RecoilSync$2,
  syncEffect: syncEffect$2
} = RecoilSync$1;
var {
  RecoilURLSync: RecoilURLSync$3,
  urlSyncEffect: urlSyncEffect$1
} = RecoilSync_URL;
var {
  RecoilURLSyncJSON: RecoilURLSyncJSON$1
} = RecoilSync_URLJSON$1;
var {
  RecoilURLSyncTransit: RecoilURLSyncTransit$1
} = RecoilSync_URLTransit$1;
var RecoilSync_index = {
  // Core Recoil Sync
  RecoilSync: RecoilSync$2,
  syncEffect: syncEffect$2,
  // Recoil Sync URL
  RecoilURLSync: RecoilURLSync$3,
  RecoilURLSyncJSON: RecoilURLSyncJSON$1,
  RecoilURLSyncTransit: RecoilURLSyncTransit$1,
  urlSyncEffect: urlSyncEffect$1
};
var RecoilSync_index_1 = RecoilSync_index.RecoilSync;
var RecoilSync_index_2 = RecoilSync_index.syncEffect;
var RecoilSync_index_3 = RecoilSync_index.RecoilURLSync;
var RecoilSync_index_4 = RecoilSync_index.RecoilURLSyncJSON;
var RecoilSync_index_5 = RecoilSync_index.RecoilURLSyncTransit;
var RecoilSync_index_6 = RecoilSync_index.urlSyncEffect;
var es_default2 = RecoilSync_index;
export {
  RecoilSync_index_1 as RecoilSync,
  RecoilSync_index_3 as RecoilURLSync,
  RecoilSync_index_4 as RecoilURLSyncJSON,
  RecoilSync_index_5 as RecoilURLSyncTransit,
  es_default2 as default,
  RecoilSync_index_2 as syncEffect,
  RecoilSync_index_6 as urlSyncEffect
};
//# sourceMappingURL=recoil-sync.js.map
